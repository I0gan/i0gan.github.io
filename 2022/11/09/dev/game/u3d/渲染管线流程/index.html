<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>渲染管线流程 | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>渲染管线流程</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-11-09T07:30:02.000Z" id="date"> 2022-11-09</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-11-11T04:09:57.763Z" id="updated"> 2022-11-11</time></div></span><br><span>Word Count: <div class="control">2.7k</div></span><br><span>Read Time: <div class="control">10 min</div></span></div></div><hr><div id="post-content"><h1 id="渲染管线流程"><a href="#渲染管线流程" class="headerlink" title="渲染管线流程"></a>渲染管线流程</h1><p>在游戏引擎中，我们会将一些美术素材，无论是2D的还是3D的，显示在屏幕上，这一流程我们称之为渲染管线。渲染管线分为几个步骤：<strong>应用阶段</strong>-<strong>几何阶段</strong>-<strong>光栅化阶段</strong>-<strong>像素处理</strong>-<strong>合并阶段</strong></p>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><h3 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h3><p>应用阶段的主要任务是把 顶点数据、shader、贴图、材质球、灯光以及一些设置等等传入GPU的过程，这个过程叫做 <strong>DrawCall</strong></p>
<p>Unity <strong>DrawCall</strong> 内部分为 SetPassCall 和 Batch，SetPassCall的作用是设置渲染管线的上下文，一般每一种Unity里的Material就是一个SetPassCall，</p>
<p>Batch就是每一次CPU向GPU打包发送顶点数据的批次，当我们优化性能的时候经常会用到（动态）合批，合批就是将拥有两个相同的材质（材质实例也要相同）的物体同时传入GPU进行处理。</p>
<blockquote>
<p>合批处理在UGUI中会有一些不同<br>先获得一个按Hierarchy的顺序的列表<br>计算每个物体的深度。<br>2.1 深度从0开始递增。如果世界包围盒Z轴不为0（或isCanvasInjectionIndex），则需独占一个批次，同时独占一个深度。即等于之前所有物体最大深度+1，后一个物体深度需要+1。<br>2.2 对一般物体的深度。会判断是否可跟之前的物件共享深度，走接下来的流程。<br>2.2.1 先按格子（默认大小是120，根据包围盒再计算）划分出多个格子。（只是为了加速求交）。<br>2.2.2 计算物体包围相交哪些格子，再跟格子中已有的物体进行包围盒相交判断。如果不相交则使用当前深度；如果相交且可合批，则使用相交物体中最大的深度；如果相交且不可合批，则使用相交物体中最大的深度+1。合批条件：无独占批次+材质相同+贴图相同+裁剪开关和裁剪矩形相同+贴图A8格式一致（kTexFormatAlpha8） 2.2.3 将该物体加入所有相交的格子中。若遇到独占深度的物体，则格子数据清空。即后续物件不跟之前的物件共享深度。<br>排序：按照深度-&gt;材质-&gt;贴图-&gt;层级顺序优先级排序。<br>合批：对排序后的列表，从头开始一个一个检测是否能与前面的物体合批。合批条件：无独占批次（只判断isCanvasInjectionIndex）+材质相同+贴图相同+裁剪开关和裁剪矩形相同+贴图A8格式一致（kTexFormatAlpha8），非SubBatch只判断前两个条件，一般情况下UI的材质都一样。</p>
</blockquote>
<hr>
<p>UGUI批处理原文链接：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/hankangwen/article/details/122667647">https://blog.csdn.net/hankangwen/article/details/122667647</a></p>
<p>在Unity中的shader中会将这些数据存到一些通道里： POSITION、NORMAL、COLOR、 TANGENT、TEXCOOR</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">a2v</span> <span class="hljs-comment">//application to vertex shader</span><br>&#123;<br>    float4 vertex : POSITION;<br>    float3 normal : NORMAL;<br>    float4 color : COLOR;<br>    float4 tangent : TANGENT;<br>    float4 texcoord : TEXCOORD0;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h3><p><strong>顶点着色器</strong></p>
<p>MVP变换</p>
<p>Model - View - Projection 对应 Model Space→World Space→ View Space</p>
<p><strong>Model</strong> 期间对应的是一个Model矩阵，Model矩阵的作用是实现模型的Transform仿射变换，包括了Translation，Rotation，Scaling(变换的顺序不能变)</p>
<p>矩阵的乘法是右结合的，以TRS的顺序求结果那么逻辑上就是先缩放再旋转最后平移，因为一旦先进行了平移再缩放就会将平移的距离一并缩放，得到错误结果，旋转同理，先平移再旋转得到的就不是绕原点的旋转结果了。在这个TRS过程中，R和S都是线性变换，但是T不是，意味着T是一种特殊的变换，为了化简这种特殊性，我们引入齐次坐标，将二维的点用三个坐标表示，三维的点用四个坐标表示（下式是一个二维的齐次坐标平移变换过程，详细解释可以参考Games101） [x′y′w′]&#x3D;[10tx01ty001][xy1]&#x3D;[x+txy+ty1]</p>
<p>最后对应的Model Matrix</p>
<p>Model&#x3D;T×R× S&#x3D;[100tx010ty001tz0001][10000cosθ−sinθ00sinθcosθ00001][cosθ0sinθ00100−sinθ0cosθ00001][cosθ−sinθ00sinθcosθ0000100001][x0000y0000z00001]</p>
<p><strong>View</strong>变换是将世界空间中的坐标变换到摄像机空间，至于为什么会存在一个摄像机空间，是因为与其变换摄像头位置的操作，直接变换世界空间的坐标收益更大，所以我们优先将世界空间的坐标对齐到以摄像机为原点构建的坐标系上</p>
<p>View变换的原理和Mode矩阵差不多，也是旋转加平移，由于是一个逆变换，所以这里采用的是先平移再旋转，矩阵的表示就为 R×T</p>
<p>将一个物体旋转到指定的基向量上也许并不好算，但是将基向量旋转到指定的位置就变得很简单，我们通过写出这个旋转矩阵的逆矩阵，再对这个正交的逆矩阵求逆（正交矩阵的特性：正交矩阵的逆就是原矩阵关于主对角线对称）</p>
<p>Rview−1&#x3D;[xg^×t^xtx−g0yg^×t^yty−g0zg^×t^ztz−g00001]</p>
<p>Rview&#x3D;[xg^×t^yg^×t^zg^×t^0xtytzt0x−gy−gz−g00001]</p>
<p><strong>Projection</strong>的过程就有些复杂了</p>
<p>先从简单的 <strong>正交投影</strong>(Orthographic projection)讲，正交投影的过程很简单，讲模型平移到原点为中心，然后挤压入一个正则立方体中（ (−1,1)3NDC 空间） Mortho&#x3D;[2r−l00002l−b00002n−f00001][100−r+l2010−l+b2001−n+f20001]</p>
<p>由于-1到1的距离是2，所以缩放过后的物体长宽高也为2，只需要将 $物体的坐标 &#x2F; 物体的长宽高 * 2$ 就能得到缩放矩阵，平移很简单，移到中心即可</p>
<p><img src="https://pic3.zhimg.com/80/v2-b47e63b428ac83431556283ad3e2042a_720w.webp" alt="img"></p>
<p>再来看 <strong>透视投影</strong>(Perspective projection)</p>
<p>透视投影这里直接采用将正交矩阵挤压成投影矩阵</p>
<p>Mpersp→ortho&#x3D;[n0000n0000n+f−nf0010]</p>
<p>所以最后投影矩阵的结果为 Mpersp&#x3D;Mperp→ortho×Mortho</p>
<p><strong>曲面细分着色器</strong></p>
<p>（可选着色器）实现LOD</p>
<p><strong>图元装配</strong></p>
<p>View Space→Clip Space→Screen Space</p>
<p>图元装配会将顶点装配成指定的图形，与此同时，会进行裁剪、背面剔除等操作，以减少不必要的计算，加速渲染过程。(图元可以理解为三角形)</p>
<p><strong>裁剪</strong></p>
<p>进行完MVP变换后，就要针对屏幕大小进行裁剪,还有背面剔除等操作</p>
<p><strong>屏幕映射</strong></p>
<p>将NDC空间内的顶点映射到屏幕空间</p>
<h3 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h3><p>此过程将组成的三角形映射到片元上，每个片元的信息都是由三个顶点的信息插值得到</p>
<p>此过程也包括纹理映射和实现光照模型</p>
<h3 id="合并阶段-Blend"><a href="#合并阶段-Blend" class="headerlink" title="合并阶段(Blend)"></a>合并阶段(Blend)</h3><p>合并处理阶段属于屏幕后期处理范围，一般包括Alpha测试，深度测试，模板测试和混合，通过这个阶段可以决定每个片元的可见性</p>
<h4 id="ALPHA测试"><a href="#ALPHA测试" class="headerlink" title="ALPHA测试"></a>ALPHA测试</h4><p>通过片元数据，可以获取该片元的alpha值，如果alpha值小于某个数的话，则直接将该片元丢弃，不进行渲染，这是非常“粗暴”的（即只渲染透明度在某一范围内的片元），可以用来做一些树叶镂空的效果。</p>
<h4 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h4><p>近处的物体会遮挡远处的物体，这种效果我们可以通过深度测试来模拟实现。它通过将深度缓存中的值和当前片元的深度进行比较，计算是否需要更新深度缓存和颜色缓存，如果不需要则将该片元丢弃，这与模板测试比较类似。我们在渲染半透明物体时， 需要开启深度测试而关闭深度写入功能。</p>
<h4 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h4><p>模板测试默认是不开启的，如果开启了模板测试，GPU会首先读取模板缓冲区中该片元位置的模板值，然后将该值和读取到的参考值进行比较，这个比较函数可以是由开发者指定的，例如小于时舍弃该片元，或者大于等于时舍弃该片元。如果这个片元没有通过这个测试，该片元就会被舍弃</p>
<h3 id="混合阶段"><a href="#混合阶段" class="headerlink" title="混合阶段"></a>混合阶段</h3><p>对于不透明的物体，可以直接关闭混合操作，片元着色器的值会直接覆盖颜色缓冲区的像素值，对于半透明的物体，会采用混合计算得出新的像素值</p>
<blockquote>
<p>透明渲染:<br>这种直接读取深度值，从后往前blend的透明渲染模式称为over操作，一般的渲染引擎都是这么处理透明物体的混合的<br>除此之外还有一些其他的透明渲染模式，如(OIT,order-independent transparency)，OIT主要解决当两个透明的物体有重叠部分时，由于原本是基于物体深度的排序，所以交叠部分会出现渲染错误<br>一种常见的OIT方式为<strong>depth peeling</strong></p>
<p>首先先将所有的不透明物体和透明物体的深度写入到第一个z-buffer;</p>
<p>渲染所有的不透明物体, 将得到的深度值和第一个z-buffer中的值比较, 如果两个值相等, 我们就认为这个表面是距离我们最近的透明面, 这时将得到的RGBA值存入到color buffer中. 同时我们在第二个z-buffer中写入距离我们第二近的深度值, 实现peeling的效果.</p>
<p>将第二个z-buffer作为输入, 第一个z-buffer作为输出, 得到的RGBA颜色用<strong>under</strong>的方式和之前的颜色混合.</p>
<p>重复前面的步骤, 渲染所有的透明物体后, 将最终的颜色和不透明表面的颜色混合.</p>
<p>（原帖:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149982810%EF%BC%89">https://zhuanlan.zhihu.com/p/149982810）</a><br>此外还有一些简单高效的渲染模式，如 Screen-Door Transparency，附上shader</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-3879c7dc147999ec54995a88d08d1c70_720w.webp" alt="img"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Ocias/Diffuse (Stipple Transparency)&quot; &#123;<br>Properties &#123;<br>    _MainTex (&quot;Base (RGB)&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>    _Transparency (&quot;Transparency&quot;, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">1.0</span> &#125;<br>SubShader &#123;<br>    Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br>    LOD <span class="hljs-number">150</span><br>CGPROGRAM<br>pragma surface surf Lambert noforwardadd<br><span class="hljs-type">sampler2D</span> _MainTex;<br>struct Input &#123;<br>    float2 uv_MainTex;<br>    float4 screenPos;<br>&#125;;<br>half _Transparency;<br><span class="hljs-type">void</span> surf (Input IN, <span class="hljs-keyword">inout</span> SurfaceOutput o) &#123;<br>    fixed4 c = tex2D(_MainTex, IN.uv_MainTex);<br>    o.Albedo = c.rgb;<br>    o.Alpha = c.a;<br><span class="hljs-comment">// Screen-door transparency: Discard pixel if below threshold.</span><br>float4x4 thresholdMatrix = &#123;  <span class="hljs-number">1.0</span> / <span class="hljs-number">17.0</span>,  <span class="hljs-number">2.0</span> / <span class="hljs-number">17.0</span>,  <span class="hljs-number">3.0</span> / <span class="hljs-number">17.0</span>, <span class="hljs-number">4.0</span> / <span class="hljs-number">17.0</span>,<br>  <span class="hljs-number">8.0</span> / <span class="hljs-number">17.0</span>,  <span class="hljs-number">7.0</span> / <span class="hljs-number">15.0</span>, <span class="hljs-number">6.0</span> / <span class="hljs-number">17.0</span>,  <span class="hljs-number">5.0</span> / <span class="hljs-number">17.0</span>,<br>  <span class="hljs-number">9.0</span> / <span class="hljs-number">17.0</span>, <span class="hljs-number">10.0</span> / <span class="hljs-number">15.0</span>,  <span class="hljs-number">11.0</span> / <span class="hljs-number">17.0</span>, <span class="hljs-number">12.0</span> / <span class="hljs-number">17.0</span>,<br>  <span class="hljs-number">16.0</span> / <span class="hljs-number">17.0</span>,  <span class="hljs-number">15.0</span> / <span class="hljs-number">13.0</span>, <span class="hljs-number">14.0</span> / <span class="hljs-number">17.0</span>,  <span class="hljs-number">13.0</span> / <span class="hljs-number">17.0</span> &#125;;<br>float4x4 _RowAccess = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;;<br>float2 pos = IN.screenPos.xy / IN.screenPos.w; pos *= _ScreenParams.xy;<br><span class="hljs-comment">// pixel position</span><br>clip(_Transparency - thresholdMatrix[fmod(pos.x, <span class="hljs-number">4</span>)] * _RowAccess[fmod(pos.y, <span class="hljs-number">4</span>)]); <br>&#125;<br>ENDCG<br>&#125;<br>Fallback &quot;Mobile/VertexLit&quot;<br>&#125; <br></code></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/11/14/dev/db/mysql/%E9%AB%98%E5%BA%A6%E4%B8%BA3%E7%9A%84B+%E6%A0%91/">← Next 一颗高度为3的B+树到底能存多少数据</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/11/08/dev/language/csharp/csharp_container/">C#容器 Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-text">渲染管线流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-text">渲染管线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5"><span class="toc-text">应用阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5"><span class="toc-text">几何阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-text">光栅化阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%98%B6%E6%AE%B5-Blend"><span class="toc-text">合并阶段(Blend)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ALPHA%E6%B5%8B%E8%AF%95"><span class="toc-text">ALPHA测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-text">深度测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="toc-text">模板测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E9%98%B6%E6%AE%B5"><span class="toc-text">混合阶段</span></a></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>