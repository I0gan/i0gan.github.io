<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Unity面试整理 | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Unity面试整理</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-11-07T04:29:38.000Z" id="date"> 2022-11-07</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-06-04T03:00:48.512Z" id="updated"> 2023-06-04</time></div></span><br><span>Word Count: <div class="control">9.1k</div></span><br><span>Read Time: <div class="control">32 min</div></span></div></div><hr><div id="post-content"><h1 id="Unity面试整理"><a href="#Unity面试整理" class="headerlink" title="Unity面试整理"></a>Unity面试整理</h1><p>C#：Unity游戏开发客户端面经： <a target="_blank" rel="noopener" href="https://blog.csdn.net/Sea3752/article/details/127354146?spm=1001.2014.3001.5501">https://blog.csdn.net/Sea3752/article/details/127354146?spm=1001.2014.3001.5501</a></p>
<p>数据结构：Unity游戏开发客户端面经：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Sea3752/article/details/127520720?spm=1001.2014.3001.5501">https://blog.csdn.net/Sea3752/article/details/127520720?spm=1001.2014.3001.5501</a></p>
<p>lua：Unity游戏开发客户端面经——lua（初级）_正在奋斗中的小志的博客-CSDN博客 </p>
<p>算法：Unity游戏开发客户端面经——算法（初级）_正在奋斗中的小志的博客-CSDN博客_拉绳算法</p>
<p>设计模式：Unity游戏开发客户端面经——设计模式（初级）_正在奋斗中的小志的博客-CSDN博客</p>
<p>Unity：Unity游戏开发客户端面经——Unity（初级）_正在奋斗中的小志的博客-CSDN博客 </p>
<p>性能优化：Unity游戏开发客户端面经——性能优化（初级）_正在奋斗中的小志的博客-CSDN博客</p>
<p>热更新：Unity游戏开发客户端面经——热更新（初级）_正在奋斗中的小志的博客-CSDN博客</p>
<p>网络 ：Unity游戏开发客户端面经——网络（初级）_正在奋斗中的小志的博客-CSDN博客</p>
<p>数学：Unity游戏开发客户端面经——数学（初级）_正在奋斗中的小志的博客-CSDN博客</p>
<p>操作系统：Unity游戏开发客户端面经——操作系统（初级）_正在奋斗中的小志的博客-CSDN博客<br>ref ：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Sea3752/article/details/127718757">https://blog.csdn.net/Sea3752/article/details/127718757</a></p>
<h2 id="UGUI优化"><a href="#UGUI优化" class="headerlink" title="UGUI优化"></a>UGUI优化</h2><p>1.UI动静分离<br>动”指的是元素移动，或者放大&#x2F;缩小频率比较高的UI。“静”则是静止不动的UI，准确来说，是界面上不会移动、旋转、缩放、更换贴图和颜色的UI。UGUI系统是以Canvas为节点拆分动与静，把会动的UI元素放入专门为它们准备的合并用的画板上，再将静止不动的UI元素留在原来的画板上。这样一来，当会动的UI元素来回移动、旋转、缩放、改变贴图和颜色的时候，就不会再去重构那些静止部分的UI元素了。 动静分离后，CPU在重绘和合并时的消耗就大大降低了。</p>
<p>2.拆分过重的UI<br>有时一个Prefab里装着2～3个界面 ，它们在展示一个界面时隐藏了其他界面，这样的操作会导致一个UI里的东西过多，在实例化和初始化时，消耗的CPU也会很大，因此我们要想办法拆分这些过重的UI界面。所以我们需要把隐藏的UI拆分出来，使其成为独立运作的界面，只在需要展示时才调用实例化。</p>
<ol start="3">
<li>打SpriteAtlas图集<br>每个UI界面打一个私有的SpriteAtlas图集，多个UI公用的图片打一个公有的图集，这样可以合批处理，降低DrawCall，同时打ab包时不会产生资源冗余。</li>
</ol>
<p>4.遮罩尽量使用RectMask<br>  由于底层实现的不同，使用Mask比RectMask产生的DrawCall多，所以建议尽量使用RectMask 作为遮罩。</p>
<p>5.其它优化<br>（1）不需要进行事件接受的组件，取消勾选Raycast Target。</p>
<p>（2）不适用富文本的Text，取消勾选Rich Text。</p>
<p>（3）尽量不用Best Fit。</p>
<p>ref：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46712616/article/details/123001829">https://blog.csdn.net/m0_46712616/article/details/123001829</a></p>
<p>面经：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sea3752/category_12057629.html">https://blog.csdn.net/sea3752/category_12057629.html</a></p>
<h2 id="网易雷火"><a href="#网易雷火" class="headerlink" title="网易雷火"></a>网易雷火</h2><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="Unity回调方法执行顺序"><a href="#Unity回调方法执行顺序" class="headerlink" title="Unity回调方法执行顺序:"></a>Unity回调方法执行顺序:</h3><p>Awake –&gt;OnEable–&gt; Start –&gt; FixedUpdate –&gt; Update –&gt; LateUpdate –&gt;OnGUI –&gt;Reset –&gt; OnDisable –&gt;OnDestroy</p>
<p>ref:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38803654/article/details/115250287">https://blog.csdn.net/qq_38803654/article/details/115250287</a></p>
<h3 id="Animator和Animation区别"><a href="#Animator和Animation区别" class="headerlink" title="Animator和Animation区别"></a>Animator和Animation区别</h3><p>两者都是控制动画播放的</p>
<p>Animation控制一个动画播放的各类方法和数据（当然你可以通过修改目标动画进行动画切换）</p>
<p>Animator则可以实现控制多个动画的播放，切换，叠加等一级对骨骼动画控制等更复杂的效果，是一个动画状态机</p>
<p>除却必要的动画文件，还会生成一个.controller结尾的文件，也因此占内存比Animation更大<br>ref：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39979037/article/details/91958858">https://blog.csdn.net/qq_39979037/article/details/91958858</a></p>
<h3 id="说说对象池"><a href="#说说对象池" class="headerlink" title="说说对象池"></a>说说对象池</h3><p>unity各种回调方法特征</p>
<h3 id="C-GC"><a href="#C-GC" class="headerlink" title="C# GC"></a>C# GC</h3><p>什么是GC<br>GC的全称是garbage collection，中文名称垃圾回收，是.net中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。</p>
<p>在进行垃圾回收时，垃圾回收器回首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起。这就是GC的四个步骤。</p>
<p>GC的作用<br>提高软件系统的内聚。<br>降低编程复杂度，使程序员不必分散精力去处理析构。<br>不妨碍设计师进行系统抽象。<br>减少由于内存运用不当产生的Bug。<br>成功的将内存管理工作从程序的编写时，脱离至运行时，使不可预估的管理漏洞变为可预估的。<br>回收对象(什么是垃圾)<br>上一篇文章有介绍.Net类型分为两大类，一个就是值类型，另一个就是引用类型。前者是分配在栈上，并不需要GC回收；后者是分配在堆上，因此它的内存释放和回收需要通过GC来完成。</p>
<p>只要判定一个引用类型对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。</p>
<p>对象代龄<br>CLR初始化后的第一批被创建的对象被列为0代对象。CLR会为0代对象设定一个容量限制，当创建的对象大小超过这个设定的容量上限时，GC就会开始工作，工作的范围是0代对象所处的内存区域，然后开始搜寻垃圾对象，并释放内存。当GC工作结束后，幸存的对象将被列为第1代对象而保留在第1代对象的区域内。此后新创建的对象将被列为新的一批0代对象，直到0代的内存区域再次被填满，然后会针对0代对象区域进行新一轮的垃圾收集，之后这些0代对象又会列为第1代对象，并入第1代区域内。第1代区域起初也会被设上一个容量限制值，等到第1代对象大小超过了这个限制之后，GC就会扩大战场，对第1代区域也做一次垃圾收集，之后，又一次幸存下来的对象将会提升一个代龄，成为第2代对象。</p>
<p>回收方式<br>Finalizer：</p>
<p>Finalizer是对象被GC回收之前调用的终结器，初衷是在这里释放非托管资源，由于Finalize是由GC负责调用，所以可以说是一种自动的释放方式。但是这里面要注意两个问题：第一，由于无法确定GC何时会运作，因此可能很长的一段时间里对象的资源都没有得到释放，这对于一些关键资源而言是非常要命的。第二，由于负责调用Finalize的线程并不保证各个对象的Finalize的调用顺序，这可能会带来微妙的依赖性问题。如果你在对象a的Finalize中引用了对象b，而a和b两者都实现了Finalize，那么如果b的Finalize先被调用的话，随后在调用a的Finalize时就会出现问题，因为它引用了一个已经被释放的资源。因此，在Finalize方法中应该尽量避免引用其他实现了Finalize方法的对象。<br>Dispose：C#提供using关键字支持Dispose Pattern进行资源释放。这样能通过确定的方式释放非托管资源，而且using结构提供了异常安全性。所以，一般建议采用Dispose Pattern，并在Finalizer中辅以检查，如果忘记显式Dispose对象则在Finalizer中释放资源。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42254223/article/details/108910619">https://blog.csdn.net/weixin_42254223/article/details/108910619</a></p>
<h3 id="非托管资源回收"><a href="#非托管资源回收" class="headerlink" title="非托管资源回收"></a>非托管资源回收</h3><p>: <a target="_blank" rel="noopener" href="https://www.xp.cn/b.php/62852.html">https://www.xp.cn/b.php/62852.html</a><br>Tcp和Udp特征以及区别<br>操作系统原语 : <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43896318/article/details/105418357">https://blog.csdn.net/weixin_43896318/article/details/105418357</a><br>进程通信方式<br>补码求解<br>子掩码计算<br>死锁问题<br>Lamada表达式<br>委托和事件的区别</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhudaokuan/article/details/113032690">https://blog.csdn.net/zhudaokuan/article/details/113032690</a></p>
<h3 id="排序树遍历"><a href="#排序树遍历" class="headerlink" title="排序树遍历"></a>排序树遍历</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43915790/article/details/118163540">https://blog.csdn.net/weixin_43915790/article/details/118163540</a></p>
<h3 id="B-树原理优点"><a href="#B-树原理优点" class="headerlink" title="B+树原理优点"></a>B+树原理优点</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/summer_fish/article/details/109780915">https://blog.csdn.net/summer_fish/article/details/109780915</a></p>
<h3 id="从1亿个玩家中找出战斗力排行第100的玩家"><a href="#从1亿个玩家中找出战斗力排行第100的玩家" class="headerlink" title="从1亿个玩家中找出战斗力排行第100的玩家"></a>从1亿个玩家中找出战斗力排行第100的玩家</h3><p>前两天面试3面学长问我的这个问题（想说TEG的3个面试学长都是好和蔼，希望能完成最后一面，各方面原因造成我无比想去鹅场的心已经按捺不住了），这个问题还是建立最小堆比较好一些。</p>
<pre><code>    先拿10000个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。
</code></pre>
<h4 id="这个算法还可以优化吗"><a href="#这个算法还可以优化吗" class="headerlink" title="这个算法还可以优化吗"></a>这个算法还可以优化吗</h4><p>优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。</p>
<p>ref：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Fly_as_tadpole/article/details/88378410">https://blog.csdn.net/Fly_as_tadpole/article/details/88378410</a></p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>如何处理抖动<br>游戏同步如何保证准确性<br>如何做断线重连<br>说说你用过的网络同步框架<br>你所知道的异步通信框架<br>安卓图片压缩<br>自动寻路算法<br>如何处理寻路中的传送门<br>有没有读过NGUI源码<br>你认为NGUI该怎么做优化<br>如何解决UI遮挡物体的问题<br>有没有用过tolua<br>Xlua源码有没有看过<br>Xlua底层如何实现热更新<br>说一下c#的GC吧<br>Delegate和Event的区别<br>图形渲染管道<br>Shader广告牌效果<br>高斯模糊？<br>边缘检测算法？<br>光照模型？<br>有没有了解过pbs光照？<br>简单说下你写的opengl程序<br>有没有看过开源引擎框架<br>游戏引擎模型动画系统的实现</p>
<h2 id="三面-总裁面"><a href="#三面-总裁面" class="headerlink" title="三面(总裁面)"></a>三面(总裁面)</h2><p>知不知道mipmap<br>知不知道怎么减少lua GC<br>知不知道反射<br>知不知道mono怎么优化<br>知不知道四元数和欧拉角的区别<br>知不知道怎么做内存优化<br>知不知道什么是JPS算法<br>知不知道JPS-BitPre<br>知不知道怎么做视野裁剪<br>知不知道怎么合包<br>知不知道如何减少Drawcall<br>项目用的TCP还是UDP<br>是什么使得你们做出这个决策<br>你们还做过那些重要决策，原因？<br>会用SVN吗？<br>除了这上面的你还有哪些技能？<br>开源框架了解几个，简单介绍下CNN<br>学过数据库吗<br>Sql数据库用的什么算法<br>有没有了解过红黑树<br>红黑树怎么插入数据<br>知不知道负载均衡和分布式<br>会用Linux吗<br>什么时候可以入职</p>
<h2 id="四面-HR"><a href="#四面-HR" class="headerlink" title="四面(HR)"></a>四面(HR)</h2><p>对我们雷火有了解吗<br>玩过网易的哪些游戏<br>你了解过雷火出品过哪些游戏吗<br>有没有玩过逆水寒<br>你是如何看待逆水寒和天刀这两款游戏<br>如何看待版号问题<br>大学做过哪些自己觉得很有意义的事<br>接受加班吗<br>等等等<br>五面(交叉面，后来得知面我的是逆水寒那边的老大)<br>Lua的GC了解过吗？c#的呢？<br>为什么会有解释型语言？<br>.net底层工作原理？<br>了解过lua虚拟机吗？<br>Lua虚拟机工作流程<br>Lua中table的底层实现<br>什么是GDB调试<br>什么是chunkspy<br>Lua的闭包<br>Lua底层模块加载原理<br>Lua调试器如何工作<br>Lua协程，对称和非对称协程<br>C++智能指针<br>有没有读过STL源码<br>Vector的实现<br>虚析构<br>dynamic_cast和static_cast<br>拥塞控制<br>Upd如何实现可靠传输<br>平面上三个点，任给一个点如何判断是否在三角形内<br>还是三个点，任给一条线段判断线段是否和三角形相交<br>垃圾邮件如何识别<br>这个算法还能优化吗<br>机器学习实现垃圾过滤<br>从数据上出发有没有优化方案<br>网络同步上你做过哪些探索<br>还有什么想问的</p>
<p>ref：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34204419/article/details/85148138">https://blog.csdn.net/qq_34204419/article/details/85148138</a></p>
<h1 id="Csharp"><a href="#Csharp" class="headerlink" title="Csharp"></a>Csharp</h1><p>1.C#中堆和栈的区别？<br>栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。 堆：一般由程序员分配释放。用 new、 malloc 等分配内存函数分配得到的就是在堆上。 存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维护；<br>堆：是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC) 来回收。<br>栈内存无需我们管理，也不受 GC 管理。当栈顶元素使用完毕，立马释放。而堆则需要 GC 清理。<br>使用引用类型的时候，一般是对指针进行的操作而非引用类型对象本身。但是值类型则操作其本身<br>2.C#中的委托是什么？事件是不是一种委托？<br>委托的本质是一个类，委托是将一种方法作为参数代入到另一种方法。 事件是委托的实例，事件是一种 特殊的委托。 &#x2F;&#x2F; 比如： onclick 事件中的参数就是一种方法。<br>3.C#静态构造函数特点是什么？<br>最先被执行的构造函数，且在一个类里只允许有一个无参的静态构造函数<br>执行顺序：静态变量 &gt; 静态构造函数 &gt; 实例变量 &gt; 实例构造函数<br>4.CTS、CLS、CLR分别作何解释<br>CTS ：通用语言系统。 CLS ：通用语言规范。 CLR ：公共语言运行库。<br>CTS ： Common Type System 通用类型系统。 Int32 、 Int16 → int 、 String → string 、 Boolean → bool 。<br>每种语言都定义了自己的类型， .NET 通过 CTS 提供了公共的类型，然后翻译生成对应的 .NET 类型。<br>CLS ： Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语法，.NET 通过 CLS 提供了公共的语法，然后不同语言翻译生成对应的 .NET 语法。<br>CLR ： Common Language Runtime 公共语言运行时，就是 GC 、 JIT 等这些。有不同的 CLR ，比如服务器<br>CLR 、 Linux CLR （ Mono ）、 Silverlight CLR(CoreCLR) 。相当于一个发动机，负责执行 IL 。<br>5.C#中什么是值类型与引用类型？<br>值类型： struct 、 enum 、 int 、 float 、 char 、 bool 、 decimal<br>引用类型： class 、 delegate 、 interface 、 array 、 object 、 string<br>6.请详述在C#中类(class)与结构(struct)的异同？<br>class 可以被实例化 , 属于引用类型 ,<br>class 可以实现接口和单继承其他类 , 还可以作为基类型 , 是分配在内存的堆上的<br>struct 属于值类型 , 不能作为基类型 , 但是可以实现接口 , 是分配在内存的栈上的 .<br>7.new关键字的作用<br>运算符：创建对象实例<br>修饰符：在派生类定义一个重名的方法，隐藏掉基类方法<br>约束：泛型约束定义，约束可使用的泛型类型<br>8.int?和int有什么区别<br>int ？为可空类型，默认值可以是 null<br>int 默认值是 0<br>int? 是通过 int 装箱为引用类型实现<br>9.C#中值传递与引用传递的区别是什么？<br>值传递时，系统首先为被调用方法的形参分配内存空间，并将实参的值按位置一一对应地复制给形参，<br>此后，被调用方法中形参值得任何改变都不会影响到相应的实参；<br>引用传递时，系统不是将实参本身的值复制后传递给形参，而是将其引用值（即地址值）传递给形参，<br>因此，形参所引用的该地址上的变量与传递的实参相同，方法体内相应形参值得任何改变都将影响到作<br>为引用传递的实参。<br>简而言之，按值传递不是值参数是值类型，而是指形参变量会复制实参变量，也就是会在栈上多创建一<br>个相同的变量。而按引用传递则不会。可以通过 ref 和 out 来决定参数是否按照引用传递。<br>10.C#中参数传递 ref 与 out 的区别？<br>（ 1 ） ref 指定的参数在函数调用时必须先初始化，而 out 不用<br>（ 2 ） out 指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而 ref 不用<br>总结： ref 可以把值传到方法里，也可以把值传到方法外； out 只可以把值传到方法外<br>注意： string 作为特殊的引用类型，其操作是与值类型看齐的，若要将方法内对形参赋值后的结果传递出来，需要加上ref 或 out 关键字。<br>11.C#中什么是装箱和拆箱？<br>装箱：把值类型转换成引用类型<br>拆箱：把引用类型转换成值类型<br>装箱：对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。<br>（ 1 ）第一步：新分配托管堆内存 ( 大小为值类型实例大小加上一个方法表指针。<br>（ 2 ）第二步：将值类型的实例字段拷贝到新分配的内存中。<br>（ 3 ）第三步：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。<br>拆箱：检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。<br>在装箱时是不需要显式的类型转换的，不过拆箱需要显式的类型转换。<br>int i&#x3D;0;<br>System.Object obj&#x3D;i; &#x2F;&#x2F; 这个过程就是装箱！就是将 i 装箱！<br>int j&#x3D;(int)obj;&#x2F;&#x2F; 这个过程 obj 拆箱！<br>12.C#实现多态的过程中 overload 重载 与override 重写的区别？<br>override 重写与 overload 重载的区别。<br>重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要<br>override 是进行基类中函数的重写。实现多态。<br>重载：是方法的名称相同，参数或参数类型不同；重载是面向过程的概念。<br>重写：是对基类中的虚方法进行重写。重写是面向对象的概念。 13.C# 中 static 关键字的作用？<br>对类有意义的字段和方法使用 static 关键字修饰，称为静态成员，通过类名加访问操作符 “.” 进行访问 ; 对<br>类的实例有意义的字段和方法不加 static 关键字，称为非静态成员或实例成员。<br>注 : 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否<br>为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。<br>14.C# 成员变量和成员函数前加static的作用？<br>它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。<br>分别用来反映类的状态。<br>比如类成员变量可以用来统计类实例的数量，类成员函数<br>负责这种统计的动作。不用 new<br>15.C#中索引器的实现过程，是否只能根据数字进行索引，请描述一 下<br>C# 通过提供索引器，可以象处理数组一样处理对象。特别是属性，每一个元素都以一个 get 或 set 方法暴<br>露。索引器不单能索引数字（数组下标），还能索引一些 HASHMAP 的字符串，所以，通常来说， C# 中<br>类的索引器通常只有一个，就是 THIS ，但也可以有无数个，只要你的参数列表不同就可以了索引器和返<br>回值无关 , 索引器最大的好处是使代码看上去更自然，更符合实际的思考模式。<br>微软官方一个示例：<br>索引器允许类或结构的实例按照与数组相同的方式进行索引。 索引器类似于属性，不同之处在于它们的<br>访问器采用参数。 在下面的示例中，定义了一个泛型类（ class SampleCollection ），并为其提供了简<br>单的 get 和 set 访问器 方法（作为分配和检索值的方法）。 Program 类为存储字符串创建了此类的一个<br>实例。<br>16.C#中 abstract class和interface有什么区别?<br>abstract class abstract 声明抽象类抽象方法，一个类中有抽象方法，那么这个类就是抽象类了。所谓的 抽象方法，就是不含主体（不提供实现方法），必须由继承者重写。因此，抽象类不可实例化，只能通 过继承被子类重写。<br>interface 声明接口，只提供一些方法规约，在 C#8 之前的版本中不提供任何实现，在 C#9 版本也可以支 持接口的实现；不能用public 、 abstract 等修饰，无字段、常量，无构造函数<br>两者区别：<br>1.interface 中不能有字段，而 abstract class 可以有 ; 2.interface 中不能有 public 等修饰符，而 abstract<br>class 可以有。 3.interface 可以实现多继承 。<br>17.C#中用sealed修饰的类有什么特点？<br>密封，不能继承。<br>18.字符串中string str&#x3D;null和string str&#x3D;””和string str&#x3D;string.Empty的区别<br>string.Empty 相当于 “”,Empty 是一个静态只读的字段。 string str&#x3D;”” , 初始化对象，并分配一个空字符串 的内存空间 string str&#x3D;null, 初始化对象，不会分配内存空间<br>19.byte b &#x3D; ‘a’; byte c &#x3D; 1; byte d &#x3D; ‘ab’; byte e &#x3D; ‘啊’; byte g &#x3D; 256; 这些变量有些错误是错在哪里?<br>本题考查的是数据类型能承载数据的大小。<br>1byte &#x3D;8bit ， 1 个汉字 &#x3D;2 个 byte ， 1 个英文 &#x3D;1 个 byte&#x3D;8bit<br>所以 bc 是对的， deg 是错的。 ‘a’ 是 char 类型， a 错误<br>java byte 取值范围是 -128<del>127, 而 C# 里一个 byte 是 0</del>255<br>20.string和StringBuilder的区别,两者性能的比较<br>都是引用类型，分配再堆上 StringBuilder默认容量是 16 ，可以允许扩充它所封装的字符串中字符的数量 . 每个 StringBuffer 对象都有 一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会 自动增加容量。<br>对于简单的字符串连接操作，在性能上 stringbuilder 不一定总是优于 strin 因为 stringbulider 对象的创建 也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder 会导致性能的浪费而非节约，只有大量无法预知次数的字符串操作才考虑stringbuilder 的使用。从最后分析可以看出如果是相对 较少的字符串拼接根本看不出太大差别。<br>Stringbulider 的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分<br>21.什么是扩展方法？<br>一句话解释，扩展方法使你能够向现有类型 “ 添加 ” 方法，无需修改类型<br>条件：按扩展方法必须满足的条件， 1. 必须要静态类中的静态方法 2. 第一个参数的类型是要扩展的类型，并且需要添加this 关键字以标识其为扩展方法<br>建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现<br>使用：不能通过类名调用，直接使用类型来调用</p>
<ol start="22">
<li><p>特性是什么？如何使用？<br>特性与属性是完全不相同的两个概念，只是在名称上比较相近。 Attribute 特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll 内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息<br>23.什么叫应用程序域(AppDomain)<br>一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立（即，从应用程序入口点开始，沿着对象激活的序列的任何位置）。<br>应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行 为可以预知。<br>在一个单独的进程中可以存在多个应用程序域。应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。<br>24.byte a &#x3D;255;a+&#x3D;5;a的值是多少？<br>byte 的取值范围是 -2 的 8 次方至 2 的 8 次方 -1 ， -256 至 258 ， a+&#x3D;1 时， a 的值时 0 ， a+&#x3D;5 时， a 的值是 0 ，所 以a+&#x3D;5 时，值是 4<br>25.const和readonly有什么区别？<br>都可以标识一个常量。主要有以下区别：<br>1 、初始化位置不同。 const 必须在声明的同时赋值； readonly 即可以在声明处赋值 ;<br>2 、修饰对象不同。 const 即可以修饰类的字段，也可以修饰局部变量； readonly 只能修饰类的字段<br>3 、 const 是编译时常量，在编译时确定该值； readonly 是运行时常量，在运行时确定该值。<br>4 、 const 默认是静态的；而 readonly 如果设置成静态需要显示声明<br>5 、修饰引用类型时不同， const 只能修饰 string 或值为 null 的其他引用类型； readonly 可以是任何类型。<br>26.分析下面代码，a、b的值是多少？<br>分析：一个字母、数字占一个 byte ，一个中文占占两个 byte ，所以 a&#x3D;8,b&#x3D;5<br>27.Strings &#x3D; new String(“xyz”);创建了几个String Object?<br>两个对象，一个是 “xyz”, 一个是指向 “xyz” 的引用对象 s 。<br>28.c#可否对内存直接操作<br>C# 在 unsafe 模式下可以使用指针对内存进行操作 , 但在托管模式下不可以使用指针， C#NET 默认不运行带指针的，需要设置下，选择项目右键-&gt; 属性 -&gt; 选择生成 -&gt;“ 允许不安全代码 ” 打勾 -&gt; 保存<br>29.什么是强类型，什么是弱类型？哪种更好些？为什么?<br>强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类 型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译 型编程语言，如c++,java,c#,pascal等 , 弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活， 多用于解释型编程语言，如javascript 等<br>30.Math.Round(11.5)等於多少? Math.Round(-11.5)等於多少?<br>Math.Round(11.5)&#x3D;12<br>Math.Round(-11.5)&#x3D;-12<br>31.&amp;和&amp;&amp;的区别<br>相同点 &amp;和 &amp;&amp; 都可作逻辑与的运算符，表示逻辑与（ and ），当运算符两边的表达式的结果都为 true 时，其结 果才为true ，否则，只要有一方为 false ，则结果为 false 。（ ps ：当要用到逻辑与的时候 &amp; 是毫无意义， &amp;本身就不是干这个的）<br>string strTmp &#x3D; “a1某某某 “;<br>int a &#x3D; System.Text.Encoding.Default.GetBytes(strTmp).Length;<br>int b &#x3D; strTmp.Length; 不同点<br>if(loginUser!&#x3D;null&amp;&amp;string.IsnullOrEmpty(loginUser.UserName))<br>&amp;&amp; 具有短路的功能，即如果第一个表达式为 false ，则不再计算第二个表达式，对于上面的表达式，当loginUser为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将 &amp;&amp; 改为 &amp; ，则 会抛出NullPointerException 异常。（ ps ：所以说当要用到逻辑与的时候 &amp; 是毫无意义的） &amp; 是用作位运算的。 总结 &amp;是位运算，返回结果是 int 类型 &amp;&amp; 是逻辑运算，返回结果是 bool 类型<br>32.i++和++i有什么区别？<br>1.i++ 是先赋值，然后再自增； ++i 是先自增，后赋值。<br>2.i&#x3D;0 ， i++&#x3D;0 ， ++i&#x3D;1 ； Console.WriteLine(++i&#x3D;&#x3D;i++); 结果位 true<br>33.as和is的区别<br>as 在转换的同时判断兼容性，如果无法进行转换，返回位 null （没有产生新的对象）， as 转换是否成功<br>判断的依据是是否位 null is 只是做类型兼容性判断，并不执行真正的类型转换，返回 true 或 false ，对象<br>为 null 也会返回 false 。<br>as 比 is 效率更高， as 只需要做一次类型兼容检查<br>34.谈谈final、finally的区别。<br>final ：不能作为父类被继承。一个类不能声明是 final ，又声明为 abstract 。<br>finally ：用于 try{}catch{}finally{} 结构，用于异常处理时执行任何清除操作。<br>35.简述C#成员修饰符<br>abstract: 指示该方法或属性没有实现。<br>const: 指定域或局部变量的值不能被改动。<br>event: 声明一个事件。<br>extern: 指示方法在外部实现。<br>override: 对由基类继承成员的新实现。<br>readonly: 指示一个域只能在声明时以及相同类的内部被赋值。<br>static: 指示一个成员属于类型本身 , 而不是属于特定的对象。<br>virtual: 指示一个方法或存取器的实现可以在继承类中被覆盖。<br>36.什么是匿名类，有什么好处？<br>不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。<br>37.说说什么是逐字字符串<br>38.列举你知道的数字格式化转换<br>39.说说字符串拼接、字符串内插法<br>40.什么是虚函数？什么是抽象函数？<br>虚函数：没有实现的，可以由子类继承并重写的函数。<br>抽象函数：规定其非虚子类必须实现的函数，必须被重写。<br>41.什么是WebService?<br>答： Web Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service 能与其他兼容的组件进行互操作。<br>42.ADO.NET常用对象有哪些？<br>Connection ： 主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据 库中取得数据的。Close 和 Dispose 的区别， Close 以后还可以 Open ， Dispose 以后则不能再用。<br>Command ： 主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数<br>据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在 Connection 对象上，也就是<br>Command ： 对象是通过在 Connection 对象连接到数据源。<br>DataAdapter ： 主要是在数据源以及 DataSet 之间执行数据传输的工作，它可以透过 Command 对象下 达命令后，并将取得的数据放入DataSet 对象中。这个对象是架构在 Command 对象上，并提供了许多 配合DataSet 使用的功能。<br>DataSet ： 这个对象可以视为一个暂存区（ Cache ），可以把从数据库中所查询到的数据保留起来甚至可以将整个数据库显示出来，DataSet 是放在内存中的。 DataSet 的能力不只是可以储存多个 Table 而已，还可以透过DataAdapter 对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。 DataSet 对象可以说是 ADO.NET 中重量级的对象，这个对象架构在 DataAdapter 对象上，本身不具备和 数据源沟通的能力；也就是说我们是将DataAdapter 对象当做 DataSet 对象以及数据源间传输数据的桥 梁。DataSet 包含若干 DataTable 、 DataTableTable 包含若干 DataRow 。<br>DataReader ： 当我们只需要循序的读取数据而不需要其它操作时，可以使用 DataReader 对象。<br>DataReader 对象只是一次一次向下循序的读取数据源中的数据，这些数据是存在数据库服务器中的，而 不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据，而且这些数据是只读的，并不允许作其它的操作。因为DataReader 在读取数据的时候限制了每次只读取一条，而且只能只读，所以使用起来不但节省资源而且效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全 部传回，故可以降低网络的负载。<br>43.在ASP.NET中所有的自定义用户控件都必须继承自？<br>Control 类<br>44.在.NET托管代码总我们不必担心内存泄漏，这是因为有了？<br>GC 垃圾收集器。<br>45.什么是MVC模式<br>MVC(Model View Controller) 模型－视图－控制器<br>aspx 就是 View ，视图； Model ： DataSet 、 Reader 、对象； Controller ： cs 代码。<br>MVC 是典型的平行关系，没有说谁在上谁在下的关系，模型负责业务领域的事情，视图负责显示的事<br>情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证什么的应该是在模型里处理<br>了。它强制性的使应用程序的输入、处理和输出分开。 MVC 最大的好处是将逻辑和页面分离。 46. 能用 foreach 遍历访问的对象的要求<br>需要实现 IEnumerable 接口或声明 GetEnumerator 方法的类型。<br>47.什么是反射?<br>程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能<br>够动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类<br>型的字段属性。它是在运行时创建和使用类型实例。<br>48.ORM中的延迟加载与直接加载有什么异同？<br>延迟加载（ Lazy Loading ）只在真正需要进行数据操作的时候再进行加载数据，可以减少不必要的开销。<br>49.简述Func与Action的区别？<br>Func 是有返回值的委托， Action 是没有返回值的委托。<br>50.23种设计模式分别叫什么名称，如何分类？<br>分三类：<br>创建型，行为型，结构型；<br>创建型包含：</p>
</li>
<li><p>单例模式</p>
</li>
<li><p>工厂模式</p>
</li>
<li><p>建造者模式</p>
</li>
<li><p>原型模式</p>
</li>
<li><p>工厂方法模式<br>  行为型包含：</p>
</li>
<li><p>策略模式</p>
</li>
<li><p>模板方法模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>迭代子模式</p>
</li>
<li><p>责任链模式</p>
</li>
<li><p>命令模式</p>
</li>
<li><p>备忘录模式</p>
</li>
<li><p>状态模式</p>
</li>
<li><p>访问者模式</p>
</li>
<li><p>中介者模式</p>
</li>
<li><p>解释器模式<br>结构型设计模式包含：</p>
</li>
<li><p>适配器模式</p>
</li>
<li><p>装饰器模式</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>外观模式</p>
</li>
<li><p>桥接模式</p>
</li>
<li><p>组合模式</p>
</li>
<li><p>享元模式</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/bt5190/article/details/118144811">https://blog.csdn.net/bt5190/article/details/118144811</a> </p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/11/07/dev/language/csharp/dotnet%E9%9D%9E%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90%E7%9A%84%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95/">← Next dotnet非托管资源的回收方法</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/11/03/dev/code/dfs_bfs/">BFS and DFS Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86"><span class="toc-text">Unity面试整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UGUI%E4%BC%98%E5%8C%96"><span class="toc-text">UGUI优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB"><span class="toc-text">网易雷火</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2"><span class="toc-text">一面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">Unity回调方法执行顺序:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animator%E5%92%8CAnimation%E5%8C%BA%E5%88%AB"><span class="toc-text">Animator和Animation区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-text">说说对象池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-GC"><span class="toc-text">C# GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-text">非托管资源回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-text">排序树遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E5%8E%9F%E7%90%86%E4%BC%98%E7%82%B9"><span class="toc-text">B+树原理优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E1%E4%BA%BF%E4%B8%AA%E7%8E%A9%E5%AE%B6%E4%B8%AD%E6%89%BE%E5%87%BA%E6%88%98%E6%96%97%E5%8A%9B%E6%8E%92%E8%A1%8C%E7%AC%AC100%E7%9A%84%E7%8E%A9%E5%AE%B6"><span class="toc-text">从1亿个玩家中找出战斗力排行第100的玩家</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E7%AE%97%E6%B3%95%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E5%90%97"><span class="toc-text">这个算法还可以优化吗</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E9%9D%A2"><span class="toc-text">二面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%9D%A2-%E6%80%BB%E8%A3%81%E9%9D%A2"><span class="toc-text">三面(总裁面)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E9%9D%A2-HR"><span class="toc-text">四面(HR)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Csharp"><span class="toc-text">Csharp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>