<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>ProtoBuf | Hexo</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":""}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/demo/"><span class="navItemTitle">独立页面</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>ProtoBuf</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-09-17T02:05:08.000Z" id="date"> 2022-09-17</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-09-16T20:08:50.546Z" id="updated"> 2022-09-17</time></div></span><br><span>Word Count: <div class="control">3.1k</div></span><br><span>Read Time: <div class="control">13 min</div></span></div></div><hr><div id="post-content"><h1 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>protobuffer是google开发的一种数据描述语言，它能够将结构化的数据序列化，并切可以将序列化的数据进行反序列化恢复原有的数据结构。一般用于数据存储以及通信协议方面。</p>
<p>如果是第一次使用protobuffer,我们可以将其与json或者xml进行类比，其实它与json或xml类似都可以作为数据的存储方式，不同的是json和xml是文本格式，而protobuffer是二进制格式。二进制格式不利于使用者直观的阅读，但是与json以及xml相比它有更多的优点。</p>
<p>protoBuffer相比于xml的优点<br>更加简介<br>体积小：消息大小只需要xml的1&#x2F;10<del>1&#x2F;3<br>解析速度快：解析速度比xml快20</del>100倍<br>使用proto Buffer的编译器，可以生成方便在编程中使用的数据访问代码.<br>具有更好的兼容性，很好的支持向上或向下兼容的特性<br>提供多种序列化的出口和入口,如文件流，string流,array流等等</p>
<p>proto文件来预先定义的消息格式。数据包是按照proto文件所定义的消息格式完成二进制码流的编码和解码。proto文件，它是一个消息的协议文件，这个协议文件的后缀文件名为“.proto”。</p>
<h3 id="protobuffer语法"><a href="#protobuffer语法" class="headerlink" title="protobuffer语法"></a>protobuffer语法</h3><p>消息类型实例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">Package example;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">required</span> <span class="hljs-type">int32</span> id = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> email = <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">PhoneType</span>&#123;<br>    mobile = <span class="hljs-number">1</span>;<br>    home = <span class="hljs-number">2</span>;<br>    work = <span class="hljs-number">3</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">message </span><span class="hljs-title class_">PhoneNumber</span>&#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> number = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">optional</span> PhoneType type = <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">repeated</span> PhoneNumber phone = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h3><p>protobuffer中字段规则包括一下三种：</p>
<p>required：实例中必须包含的字段<br>optional：实例中可以选择性包含的字段，若实例没有指定，则为默认值，若没有设置该字段的默认值，其值是该类型的默认值。如string默认值为””，bool默认值为false,整数默认值为0。<br>repeated: 可以有多个值的字段，这类变量类似于vector，可以存储此类型的多个值。<br>由于一些历史原因，基本数值类型的repeated的字段并没有被尽可能地高效编码。在新的代码中，用户应该使用特殊选项[packed&#x3D;true]来保证更高效的编码。<br>一般情况下慎重使用required字段，当此字段一定是必要的时候才使用。</p>
<p>repeated使用实例：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span> &#123;  <br>  <span class="hljs-keyword">required</span> <span class="hljs-type">int32</span> age = <span class="hljs-number">1</span>;  <br>  <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;  <br>&#125;  <br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Family</span> &#123;  <br>  <span class="hljs-keyword">repeated</span> Person person = <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>


<p>c代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>  <br>&#123;  <br>	GOOGLE_PROTOBUF_VERIFY_VERSION;  <br><br>	Family family;  <br>	Person* person;  <br><br>	<span class="hljs-comment">// 添加一个家庭成员，John  </span><br>	person = family.add_person();  <br>	person-&gt;set_age(<span class="hljs-number">25</span>);  <br>	person-&gt;set_name(<span class="hljs-string">&quot;John&quot;</span>);  <br><br>	<span class="hljs-comment">// 添加一个家庭成员，Lucy  </span><br>	person = family.add_person();  <br>	person-&gt;set_age(<span class="hljs-number">23</span>);  <br>	person-&gt;set_name(<span class="hljs-string">&quot;Lucy&quot;</span>);  <br><br>	<span class="hljs-comment">// 添加一个家庭成员，Tony  </span><br>	person = family.add_person();  <br>	person-&gt;set_age(<span class="hljs-number">2</span>);  <br>	person-&gt;set_name(<span class="hljs-string">&quot;Tony&quot;</span>);  <br><br>	<span class="hljs-comment">// 显示所有家庭成员  </span><br>	<span class="hljs-type">int</span> size = family.person_size();  <br>	<br>	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这个家庭有 &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot; 个成员，如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)  <br>	&#123;  <br>	    Person psn = family.person(i);  <br>	    <span class="hljs-built_in">cout</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;. &quot;</span> &lt;&lt; psn.name() &lt;&lt; <span class="hljs-string">&quot;, 年龄 &quot;</span> &lt;&lt; psn.age() &lt;&lt; <span class="hljs-built_in">endl</span>;  <br>	&#125;  <br><br>	getchar();  <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>protobuffer中的数据类型与C++数据类型之间的关联如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">protobuffer类型	C++类型<br>double	double<br>float	float<br>int32	int32<br>int64	int64<br>uint32	uint32<br>uint64	uint64<br>sint32	int32<br>sint64	int64<br>fixed32	uint32<br>fixed64	uint64<br>sfixed32	uint32<br>sfixed64	uint64<br>bool	bool<br>string	string<br>bytes	string<br></code></pre></td></tr></table></figure>


<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>当需要定义一个消息类型的时候，我们可能想为某一个字段指定预定义列表中的值。这个时候就需要用到枚举</p>
<p>如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">optional</span> <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span> [default = <span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Corpus</span> &#123;<br>    UNIVERSAL = <span class="hljs-number">0</span>;<br>    WEB = <span class="hljs-number">1</span>;<br>    IMAGES = <span class="hljs-number">2</span>;<br>    LOCAL = <span class="hljs-number">3</span>;<br>    NEWS = <span class="hljs-number">4</span>;<br>    PRODUCTS = <span class="hljs-number">5</span>;<br>    VIDEO = <span class="hljs-number">6</span>;<br>  &#125;<br>  <span class="hljs-keyword">optional</span> Corpus corpus = <span class="hljs-number">4</span> [default = UNIVERSAL];<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="变量标识号"><a href="#变量标识号" class="headerlink" title="变量标识号"></a>变量标识号</h4><p>在proto数据结构中，每一个变量都有唯一的数字标识。这些标识符的作用是在二进制格式中识别各个字段的，一旦开始使用就不可再改变。</p>
<p>此处需要注意的是1-15之内的标号在存储的时候只占一个字节，而大于15到162047之间的需要占两个字符，所以我们尽量为频繁使用的字段分配1-15内的标识号<br>。另外19000-19999之内的标识号已经被预留，不可用。最大标识号为2^29-1。</p>
<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>protobuffer中的消息可以嵌套消息，也就是在一个message中定义另一个message。如上面实例可以看出。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>我们可以通过扩展对proto文件进行扩展，而不需要直接区编辑原文件。</p>
<p>例如有原文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">message Foo&#123;<br>  //...<br>  extensions 100 to 199;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>上述extensions 100 to 199表示此范围内的标识号被保留为扩展用。我们在扩展文件中就可以使用这些标识号了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">extend Foo&#123;<br>  optional int32 bar = 126;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>述为扩展。当用户的Foo消息被编码的时候，数据的传输格式与用户在Foo里定义新字段的效果是完全一样的。然而，要在程序代码中访问扩展字段的方法与访问普通的字段稍有不同——生成的数据访问代码为扩展准备了特殊的访问函数来访问它。例如，下面是如何在C++中设置bar的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Foo foo;<br>foo.SetExtentions(bar, 15);<br></code></pre></td></tr></table></figure>


<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>与c++注释风格相同。双斜杠</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>向上且向下兼容更新消息<br>当在需求不断增加的过程中，数据结构也会不断变化，这个时候就需要我们去更新消息。怎么才能做到更新消息不会影响之前的数据和代码。这个时候我们更新消息需要遵循以下几个原则：</p>
<p>不要更改任何已有的字段的数值标识<br>所添加的字段必须是optional或者repeated。<br>包名称解析<br>为了防止消息明明冲突，我们往往会在文件的开始出生命包，包的作用相当于命名空间。在编译成C++代码时也是namespace。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">package foo.bar;<br>message open&#123;<br>  ///...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在C++对open进行访问的时候的访问方式为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">foo::bar::open test;<br></code></pre></td></tr></table></figure>

<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>C++程序使用protobuffer<br>按照上面的规则我们可以设计出合理的protobuffer类型。然后下一步就是将proto文件生成C++头文件和实现文件,将.proto文件编译成C接口的方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc -I=SOURCE_DIR --cpp_out=DIST_DIR test.proto<br></code></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>使用proto生成的头文件进行编译时需要链接protobuffer库。具体为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">g++ main.cpp test.pb.cc -lprotobuf<br></code></pre></td></tr></table></figure>

<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>protobuffer编译为C++代码的常用接口<br>对于C++来说，编译器会为每个.proto文件生成一个.h文件和.cc文件。.proto文件中的每一个消息对应一个类。<br>protobuffer中常用的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">has_name() :判断是否有当前成员<br>clear_name() :清空该成员变量值<br>name() :获取成员的变量值<br>set_name(string) :设置变量值<br>set_name(const char*):设置变量值<br>set_name(int) :设置变量值<br>clear() :清空所有元素为空状态<br>void CopyFrom(person):从给定的对象复制。<br>mutable_name() :获取变量name的指针<br>add_name() :为repeated变量增加值<br>ByteSize() :获取变量所占的字节数<br>若有元素data属性为repeated，其行为类似于vector,则此时则可用下列函数：<br>add_data() : 添加data元素，返回值为Date*类型。<br>data_size() : 获取repeated元素size，即元素的个数。<br>data(i) : 获取data中地i个元素。<br>ByteSize() : 获取序列化之后的protobuff对象的长度。<br>CopyFrom(const ProtoType&amp;): 从一个protobuf对象拷贝到另一个<br></code></pre></td></tr></table></figure>

<h3 id="常用的序列化方法"><a href="#常用的序列化方法" class="headerlink" title="常用的序列化方法"></a>常用的序列化方法</h3><h4 id="C数组的序列化与反序列化的API"><a href="#C数组的序列化与反序列化的API" class="headerlink" title="C数组的序列化与反序列化的API"></a>C数组的序列化与反序列化的API</h4><p>如果想将其序列为char*并通过socket进行传输，这是使用SerializeToArray来达到目的。<br>除了下述的SerializeToArray方法之外，还有方法SerializePartialToArray，两者用法相同，其中唯一的区别在于SerializePartialToArray允许忽略required字段，而前者不允许</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span>* parray = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">256</span>);<br><span class="hljs-comment">//API</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParseFromArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, <span class="hljs-type">int</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SerializeToArray</span><span class="hljs-params">(<span class="hljs-type">void</span>* data. <span class="hljs-type">int</span> size)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_people</span><span class="hljs-params">()</span>               </span><br><span class="hljs-function"></span>&#123;  <br>    wp.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;sealyao&quot;</span>);     <br>    wp.<span class="hljs-built_in">set_id</span>(<span class="hljs-number">123456</span>);          <br>    wp.<span class="hljs-built_in">set_email</span>(<span class="hljs-string">&quot;sealyaog@gmail.com&quot;</span>);  <br>    wp.<span class="hljs-built_in">SerializeToArray</span>(parray,<span class="hljs-number">256</span>);  <br>&#125;  <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_people</span><span class="hljs-params">()</span>               </span><br><span class="hljs-function"></span>&#123;  <br>    rap.<span class="hljs-built_in">ParseFromArray</span>(parray,<span class="hljs-number">256</span>);  <br>    cout &lt;&lt; <span class="hljs-string">&quot;Get People from Array:&quot;</span> &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\t Name : &quot;</span> &lt;&lt;rap.<span class="hljs-built_in">name</span>() &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\t Id : &quot;</span> &lt;&lt; rap.<span class="hljs-built_in">id</span>() &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\t email : &quot;</span> &lt;&lt; rap.<span class="hljs-built_in">email</span>() &lt;&lt; endl;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="C-String的序列化与反序列化API"><a href="#C-String的序列化与反序列化API" class="headerlink" title="C++ String的序列化与反序列化API"></a>C++ String的序列化与反序列化API</h4><p>除了下述的SerializeToString方法之外，还有方法SerializePartialToString，两者用法相同，其中唯一的区别在于SerializePartialToString允许忽略required字段，而前者不允许</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++string序列化和序列化API</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SerializeToString</span><span class="hljs-params">(string* output)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParseFromString</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; data)</span></span>; <br><span class="hljs-comment">//使用：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_people</span><span class="hljs-params">()</span>               </span><br><span class="hljs-function"></span>&#123;  <br>    wp.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;sealyao&quot;</span>);     <br>    wp.<span class="hljs-built_in">set_id</span>(<span class="hljs-number">123456</span>);          <br>    wp.<span class="hljs-built_in">set_email</span>(<span class="hljs-string">&quot;sealyaog@gmail.com&quot;</span>);  <br>    wp.<span class="hljs-built_in">SerializeToString</span>(&amp;pstring);  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_people</span><span class="hljs-params">()</span>               </span><br><span class="hljs-function"></span>&#123;  <br>    rsp.<span class="hljs-built_in">ParseFromString</span>(pstring);    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Get People from String:&quot;</span> &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\t Name : &quot;</span> &lt;&lt;rsp.<span class="hljs-built_in">name</span>() &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\t Id : &quot;</span> &lt;&lt; rsp.<span class="hljs-built_in">id</span>() &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\t email : &quot;</span> &lt;&lt; rsp.<span class="hljs-built_in">email</span>() &lt;&lt; endl;  <br>&#125;  <br></code></pre></td></tr></table></figure>



<h4 id="文件描述符序列化与反序列化API"><a href="#文件描述符序列化与反序列化API" class="headerlink" title="文件描述符序列化与反序列化API"></a>文件描述符序列化与反序列化API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//文件描述符的序列化和序列化API </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SerializeToFileDescriptor</span><span class="hljs-params">(<span class="hljs-type">int</span> file_descriptor)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParseFromFileDescriptor</span><span class="hljs-params">(<span class="hljs-type">int</span> file_descriptor)</span></span>;  <br></code></pre></td></tr></table></figure>

<p>使用: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_people</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;  <br>   fd = <span class="hljs-built_in">open</span>(path,O_CREAT|O_TRUNC|O_RDWR,<span class="hljs-number">0644</span>); <br>   <span class="hljs-keyword">if</span>(fd &lt;= <span class="hljs-number">0</span>)&#123; <br>       <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>       <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>   &#125;     <br>   wp.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;i0gan&quot;</span>);<br>   wp.<span class="hljs-built_in">set_id</span>(<span class="hljs-number">123456</span>);  <br>   wp.<span class="hljs-built_in">set_email</span>(<span class="hljs-string">&quot;i0gan@pwnsky.com&quot;</span>);<br>   wp.<span class="hljs-built_in">SerializeToFileDescriptor</span>(fd);<br>   <span class="hljs-built_in">close</span>(fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_people</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   fd = <span class="hljs-built_in">open</span>(path,O_RDONLY);<br>   <span class="hljs-keyword">if</span>(fd &lt;= <span class="hljs-number">0</span>)&#123;<br>       <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>       <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>   &#125;<br>   rp.<span class="hljs-built_in">ParseFromFileDescriptor</span>(fd);<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;Get People from FD:&quot;</span> &lt;&lt; endl;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;\t Name : &quot;</span> &lt;&lt;rp.<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;\t Id : &quot;</span> &lt;&lt; rp.<span class="hljs-built_in">id</span>() &lt;&lt; endl;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;\t email : &quot;</span> &lt;&lt; rp.<span class="hljs-built_in">email</span>() &lt;&lt; endl;<br>   <span class="hljs-built_in">close</span>(fd);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="C-stream-序列化和反序列化API"><a href="#C-stream-序列化和反序列化API" class="headerlink" title="C++ stream 序列化和反序列化API"></a>C++ stream 序列化和反序列化API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++ stream 序列化/反序列化API </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SerializeToOstream</span><span class="hljs-params">(ostream* output)</span> <span class="hljs-type">const</span></span>; <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParseFromIstream</span><span class="hljs-params">(istream* input)</span></span>;  <br></code></pre></td></tr></table></figure>

<p>使用： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_people</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-function">fstream <span class="hljs-title">fs</span><span class="hljs-params">(path,ios::out|ios::trunc|ios::binary)</span></span>; <br>    wp.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;i0gan&quot;</span>); <br>    wp.<span class="hljs-built_in">set_id</span>(<span class="hljs-number">123456</span>); <br>    wp.<span class="hljs-built_in">set_email</span>(<span class="hljs-string">&quot;i0gan@pwnsky.com&quot;</span>); <br>    wp.<span class="hljs-built_in">SerializeToOstream</span>(&amp;fs); <br>    fs.<span class="hljs-built_in">close</span>(); <br>    fs.<span class="hljs-built_in">clear</span>(); <br>&#125;  <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_people</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-function">fstream <span class="hljs-title">fs</span><span class="hljs-params">(path,ios::in|ios::binary)</span></span>; <br>    rp.<span class="hljs-built_in">ParseFromIstream</span>(&amp;fs); <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\t Name : &quot;</span> &lt;&lt;rp.<span class="hljs-built_in">name</span>() &lt;&lt; endl; <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\t Id : &quot;</span> &lt;&lt; rp.<span class="hljs-built_in">id</span>() &lt;&lt; endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\t email : &quot;</span> &lt;&lt; rp.<span class="hljs-built_in">email</span>() &lt;&lt; endl; <br>    fs.<span class="hljs-built_in">close</span>(); <br>    fs.<span class="hljs-built_in">clear</span>(); <br>&#125; <br></code></pre></td></tr></table></figure>



<h2 id="string和bytes类型的区别"><a href="#string和bytes类型的区别" class="headerlink" title="string和bytes类型的区别"></a>string和bytes类型的区别</h2><p>string与bytes区别<br>按照经验我们知道bytes一般适用于存储二进制数据的，但在C++中,string既可以存储ASCII文本字符串，也能存储任意多个\0的二进制序列，那两者的区别在哪里呢？</p>
<p>string类型（protobuffer中的string，与C++区别开）不能存储非法的UTF-8字符，如果遇到该字符，序列化的时候将会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[libprotobuf ERROR google/protobuf/wire_format.cc:1091] String field ‘str’ contains invalid UTF-8 data when serializing a protocol buffer. Use the ‘bytes’ type if you intend to send raw bytes.<br></code></pre></td></tr></table></figure>

<p>出现上述错误的原因<br>这里从ProtoBuf的源码进行分析。protoBuf在序列化的过程中，都会调用SerializeFieldWithCachedSizes这个函数。我们看一下序列化string和bytes在序列化过程中的区别。</p>
<p>对于string类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">case</span> FieldDescriptor::TYPE_STRING: &#123;<br>  string scratch;<br>  <span class="hljs-type">const</span> string&amp; value = field-&gt;<span class="hljs-built_in">is_repeated</span>() ?<br>    message_reflection-&gt;<span class="hljs-built_in">GetRepeatedStringReference</span>(<br>      message, field, j, &amp;scratch) :<br>    message_reflection-&gt;<span class="hljs-built_in">GetStringReference</span>(message, field, &amp;scratch);<br>  <span class="hljs-built_in">VerifyUTF8StringNamedField</span>(value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">length</span>(), SERIALIZE,<br>                             field-&gt;<span class="hljs-built_in">name</span>().<span class="hljs-built_in">c_str</span>());<br>  WireFormatLite::<span class="hljs-built_in">WriteString</span>(field-&gt;<span class="hljs-built_in">number</span>(), value, output);<br>  <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于bytes类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">case</span> FieldDescriptor::TYPE_BYTES: &#123;<br>        string scratch;<br>        <span class="hljs-type">const</span> string&amp; value = field-&gt;<span class="hljs-built_in">is_repeated</span>() ?<br>          message_reflection-&gt;<span class="hljs-built_in">GetRepeatedStringReference</span>(<br>            message, field, j, &amp;scratch) :<br>          message_reflection-&gt;<span class="hljs-built_in">GetStringReference</span>(message, field, &amp;scratch);<br>        WireFormatLite::<span class="hljs-built_in">WriteBytes</span>(field-&gt;<span class="hljs-built_in">number</span>(), value, output);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面可以看到，序列化string和bytes的区别主要在于:string类型序列化调用了VerifyUTF8StringNamedField函数检验string中是否有非法的UTF-8字符。其中VerifyUTF8StringNamedField实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WireFormat::VerifyUTF8StringFallback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">int</span> size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          Operation op,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">const</span> <span class="hljs-type">char</span>* field_name)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsStructurallyValidUTF8</span>(data, size)) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* operation_str = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>      <span class="hljs-keyword">case</span> PARSE:<br>        operation_str = <span class="hljs-string">&quot;parsing&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> SERIALIZE:<br>        operation_str = <span class="hljs-string">&quot;serializing&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-comment">// no default case: have the compiler warn if a case is not covered.</span><br>    &#125;<br>    string quoted_field_name = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (field_name != <span class="hljs-literal">NULL</span>) &#123;<br>      quoted_field_name = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot; &#x27;%s&#x27;&quot;</span>, field_name);<br>    &#125;<br>    <span class="hljs-comment">// no space below to avoid double space when the field name is missing.</span><br>    <span class="hljs-built_in">GOOGLE_LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;String field&quot;</span> &lt;&lt; quoted_field_name &lt;&lt; <span class="hljs-string">&quot; contains invalid &quot;</span><br>               &lt;&lt; <span class="hljs-string">&quot;UTF-8 data when &quot;</span> &lt;&lt; operation_str &lt;&lt; <span class="hljs-string">&quot; a protocol &quot;</span><br>               &lt;&lt; <span class="hljs-string">&quot;buffer. Use the &#x27;bytes&#x27; type if you intend to send raw &quot;</span><br>               &lt;&lt; <span class="hljs-string">&quot;bytes. &quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>string和bytes类型在C++和Java中的区别<br>protobuf类型在C++和java中的类型对应如下：</p>
<p>在C++中，string和bytes的实现都是std::string类型。<br>在Java中string和bytes类型的实现分别是String和ByteString。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/u014630623/article/details/88992609">https://blog.csdn.net/u014630623/article/details/88992609</a></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41358574/article/details/123903840">https://blog.csdn.net/qq_41358574/article/details/123903840</a></p>
<p>ref：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014630623/article/details/88992598">https://blog.csdn.net/u014630623/article/details/88992598</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/09/17/dev/game/server/Squick%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/">← Next Squick游戏服务器框架</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/09/16/dev/game/u3d/Unity%E4%B9%8BET%E6%A1%86%E6%9E%B6/">Unity之ET框架 Prev →</a></div></div></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/Yue-plus">John Doe</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ProtoBuf"><span class="toc-number">1.</span> <span class="toc-text">ProtoBuf</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protobuffer%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">protobuffer语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E8%A7%84%E5%88%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">指定字段规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%A0%87%E8%AF%86%E5%8F%B7"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">变量标识号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.5.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.1.6.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90"><span class="toc-number">1.1.7.</span> <span class="toc-text">生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.8.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.9.</span> <span class="toc-text">常用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.10.</span> <span class="toc-text">常用的序列化方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84API"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">C数组的序列化与反序列化的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-String%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96API"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">C++ String的序列化与反序列化API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96API"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">文件描述符序列化与反序列化API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-stream-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96API"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">C++ stream 序列化和反序列化API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E5%92%8Cbytes%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">string和bytes类型的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">赣ICP备19008355号</a></nobr><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><br><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'LSe7mf1XYliLqgIrc3jlqXfT-gzGzoHsz'
 , appKey: 'Fu9giJfnidkCamaW89FUpidw' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>