<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Redis常见问题 | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":""}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Redis常见问题</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-09-28T02:09:47.000Z" id="date"> 2022-09-28</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-10-24T09:44:31.246Z" id="updated"> 2022-10-24</time></div></span><br><span>Word Count: <div class="control">1.7k</div></span><br><span>Read Time: <div class="control">5 min</div></span></div></div><hr><div id="post-content"><h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><h3 id="Redis到底是单线程的还是多线程的？"><a href="#Redis到底是单线程的还是多线程的？" class="headerlink" title="Redis到底是单线程的还是多线程的？"></a>Redis到底是单线程的还是多线程的？</h3><p>Redis 6.0版本之前的单线程指的是其网络I&#x2F;O和键值对读写是由一个线程完成的</p>
<p>Redis6.0引入的多线程指的是网络请求过程采用了多线程，而键值对读写命令仍然是单线程处理的，所以Redis依然是并发安全的。</p>
<p>也就是只有网络请求模块和数据库操作模块是单线程的，其他的持久化、集群数据同步等是由额外线程执行的。</p>
<p><img src="/images/Snipaste_2022-09-28_10-37-53.png" alt="Snipaste_2022-09-28_10-37-53"></p>
<h3 id="Redis单线程为什么还能这么快？"><a href="#Redis单线程为什么还能这么快？" class="headerlink" title="Redis单线程为什么还能这么快？"></a>Redis单线程为什么还能这么快？</h3><p>命令执行基于内存操作，一条命令在内存里操作的时间是几十纳秒</p>
<p>命令执行是单线程操作，没有线程切换的开销</p>
<p>基于IO多路复用机制提示Redis的I&#x2F;O利用率</p>
<p>高效的数据存储结构：全局hash表以及多种高效的数据结构，比如全局hash表，跳表，压缩列表，双向链表，整数数组等等。</p>
<h3 id="Redis底层数据如何用跳表来存储的？"><a href="#Redis底层数据如何用跳表来存储的？" class="headerlink" title="Redis底层数据如何用跳表来存储的？"></a>Redis底层数据如何用跳表来存储的？</h3><p>跳表：将有序链表改造为支持近似“折半查找”算法，可以进行快速的插入、删除、查找操作。</p>
<p><img src="/images/Snipaste_2022-09-28_10-36-55.png" alt="Snipaste_2022-09-28_10-36-55"></p>
<h3 id="Redis-Key过期了为什么内存没有释放？"><a href="#Redis-Key过期了为什么内存没有释放？" class="headerlink" title="Redis Key过期了为什么内存没有释放？"></a>Redis Key过期了为什么内存没有释放？</h3><p>在使用Redis是，肯定经常使用SET命令</p>
<p>SET除了可以设置key-value之外，还可以设置key的过期时间，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">set i0gan abc ex 120<br>ttl i0gan # 查看过期剩余时间<br></code></pre></td></tr></table></figure>

<p>此时如果你想修改key的值，但只是单纯的使用set命令，而没有加上过期时间的参数，那这个key的过期时间会被擦除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">set i0gan abc<br>ttl i0gan<br>(integer) -1 # 永久<br></code></pre></td></tr></table></figure>

<p>导致这个问题的原因在于：set命令如果不设置过期时间，那么redis会自动擦除这个key的过期时间。</p>
<p>如果你发现了redis的内存持续增长，而且很多key原来设置了过期时间，后来发现过期时间丢失了，很有可能是因为这个原因导致的。</p>
<p>这时你的Redis中就会存在大量不过期的key，消耗过多的内存资源。</p>
<p>所以在使用set命令时，如果开始时设置了过期时间，那么之后修改这个key时，也务必加上过期时间的参数，避免过期时间丢失的问题。</p>
<p>redis对于过期key的处理一般有惰性删除和定时删除两种策略</p>
<ol>
<li>惰性删除：当读&#x2F;写一个已经过期的key时，会触发惰性删除策略，判断key是否过期，如果过期了直接删除掉这个key</li>
<li>定时删除：由于惰性删除策略无法保证冷数据及时杯删除，redis会定期（默认每100ms）主动删除一批已过期的key，这里的一批只是部分过期key，所以可能出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放。</li>
</ol>
<h3 id="Redis-key-没有设置过期时间为什么被redis主动删除？"><a href="#Redis-key-没有设置过期时间为什么被redis主动删除？" class="headerlink" title="Redis key 没有设置过期时间为什么被redis主动删除？"></a>Redis key 没有设置过期时间为什么被redis主动删除？</h3><p>当redis已用内存超过maxmemory限定时，会触发主动清理策略</p>
<p>主动清理策略在redis4.0之前一共实现了6中淘汰策略，在4.0之后，又增加了2中策略，总共8种：</p>
<h4 id="针对设置了过期时间的key做处理"><a href="#针对设置了过期时间的key做处理" class="headerlink" title="针对设置了过期时间的key做处理"></a>针对设置了过期时间的key做处理</h4><ol>
<li>volatile-ttl:在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random: 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru:会使用LRU算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu: 会使用LFU算法筛选设置了过期时间的键值对删除。</li>
</ol>
<h4 id="针对所有的key做处理"><a href="#针对所有的key做处理" class="headerlink" title="针对所有的key做处理"></a>针对所有的key做处理</h4><ol start="5">
<li>allkeys-random: 从所有键值对中随机选择并删除数据</li>
<li>allkeys-lru: 使用LRU算法在所有数据中进行筛选删除</li>
<li>allkeys-lfu: 使用LFU算法在所有数据中进行筛选删除</li>
</ol>
<h4 id="不处理"><a href="#不处理" class="headerlink" title="不处理"></a>不处理</h4><ol start="8">
<li>noeviction: 不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ol>
<h3 id="Redis淘汰key的算法LRU与LFU区别"><a href="#Redis淘汰key的算法LRU与LFU区别" class="headerlink" title="Redis淘汰key的算法LRU与LFU区别"></a>Redis淘汰key的算法LRU与LFU区别</h3><p>LRU（Least Recently Used，最近最少使用)：淘汰很久没有被访问过的数据，以最近一次访问时间作为参考</p>
<p>LFU（Least Frequently Used，最不经常使用）：淘汰最近一段时间被访问次数最少的数据，以次数作为参考，绝大多数情况我们都可以用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点。</p>
<h3 id="删除Key的命令会阻塞Redis吗？"><a href="#删除Key的命令会阻塞Redis吗？" class="headerlink" title="删除Key的命令会阻塞Redis吗？"></a>删除Key的命令会阻塞Redis吗？</h3><p>这要得看删除的key是什么类型的，时间复杂度分别如下：</p>
<p>删除单个字符串类型的Key，时间复杂度为O(1)</p>
<p>删除单个列表、集合、有序或哈希表类型的key，时间复杂度为O(n)，n为数据结构内元素的数量。</p>
<p>删除拥有较多元素的key的话，可能会出现阻塞的。</p>
<h3 id="Redis主从、哨兵、集群架构优缺点比较"><a href="#Redis主从、哨兵、集群架构优缺点比较" class="headerlink" title="Redis主从、哨兵、集群架构优缺点比较"></a>Redis主从、哨兵、集群架构优缺点比较</h3><h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p><img src="/images/Snipaste_2022-09-28_11-55-39.png" alt="Snipaste_2022-09-28_11-55-39"></p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p><img src="/images/Snipaste_2022-09-28_12-21-31.png" alt="Snipaste_2022-09-28_12-21-31"></p>
<p>在redis3.0以前的版本要实现集群一般是借助哨兵sentinel弓弩来监控master节点的状态，如果master节点异常，则会做主从切换，将一台slave作为master,哨兵的配置略微复杂，并且性能和高可用性方面表现一般，特别是从主从切换的瞬间存在<code>访问瞬断</code>的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。</p>
<h4 id="高可用集群模式"><a href="#高可用集群模式" class="headerlink" title="高可用集群模式"></a>高可用集群模式</h4><p><img src="/images/Snipaste_2022-09-28_12-24-51.png" alt="Snipaste_2022-09-28_12-24-51"></p>
<p>redis集群是一个由多个主从节点群组的分布式服务器群，它具有复制、高可用性和分片的特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平拓展，根据官方文档称可以线性拓展到上万个节点（官方推荐不超过1000个节点）。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置也非常简单。</p>
<h3 id="Redis集群数据hash分片算法是怎么回事？"><a href="#Redis集群数据hash分片算法是怎么回事？" class="headerlink" title="Redis集群数据hash分片算法是怎么回事？"></a>Redis集群数据hash分片算法是怎么回事？</h3><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/09/28/dev/language/go/go%E4%B8%8Ec%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/">← Next Go与C的互相调用</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/09/26/dev/code/nowcoder/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树 Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%85%A5%E9%97%A8"><span class="toc-text">Redis入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-text">基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%B0%E5%BA%95%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-text">Redis到底是单线程的还是多线程的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%83%BD%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-text">Redis单线程为什么还能这么快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">Redis底层数据如何用跳表来存储的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Key%E8%BF%87%E6%9C%9F%E4%BA%86%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E6%B2%A1%E6%9C%89%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="toc-text">Redis Key过期了为什么内存没有释放？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-key-%E6%B2%A1%E6%9C%89%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%ABredis%E4%B8%BB%E5%8A%A8%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="toc-text">Redis key 没有设置过期时间为什么被redis主动删除？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E8%AE%BE%E7%BD%AE%E4%BA%86%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84key%E5%81%9A%E5%A4%84%E7%90%86"><span class="toc-text">针对设置了过期时间的key做处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E6%89%80%E6%9C%89%E7%9A%84key%E5%81%9A%E5%A4%84%E7%90%86"><span class="toc-text">针对所有的key做处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%A4%84%E7%90%86"><span class="toc-text">不处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%B7%98%E6%B1%B0key%E7%9A%84%E7%AE%97%E6%B3%95LRU%E4%B8%8ELFU%E5%8C%BA%E5%88%AB"><span class="toc-text">Redis淘汰key的算法LRU与LFU区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4Key%E7%9A%84%E5%91%BD%E4%BB%A4%E4%BC%9A%E9%98%BB%E5%A1%9ERedis%E5%90%97%EF%BC%9F"><span class="toc-text">删除Key的命令会阻塞Redis吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5%E3%80%81%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-text">Redis主从、哨兵、集群架构优缺点比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-text">主从模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">高可用集群模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AEhash%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="toc-text">Redis集群数据hash分片算法是怎么回事？</span></a></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>