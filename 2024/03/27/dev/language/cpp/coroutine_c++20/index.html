<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>C++20 Coroutine | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>C++20 Coroutine</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-03-27T12:13:00.000Z" id="date"> 2024-03-27</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-10-07T08:17:07.900Z" id="updated"> 2024-10-07</time></div></span><br><span>Word Count: <div class="control">2.9k</div></span><br><span>Read Time: <div class="control">12 min</div></span></div></div><hr><div id="post-content"><h1 id="C-20-Coroutine"><a href="#C-20-Coroutine" class="headerlink" title="C++20 Coroutine"></a>C++20 Coroutine</h1><p><strong>协程是什么？</strong></p>
<p>协程（Coroutines）是一种计算机程序组件，它允许在一个函数中暂停执行，并在稍后恢复执行。简而言之，协程是一种可以在函数执行期间暂停和恢复的控制流。</p>
<p><strong>协程函数与普通函数有什么区别？</strong></p>
<p>传统的函数在调用时开始执行，然后在返回时结束执行。而协程允许函数在执行过程中挂起，并在需要时恢复执行，而不是一次性执行完毕。</p>
<p><strong>解决什么问题？</strong></p>
<p>协程在编写异步代码时非常有用，因为它们可以使异步代码更加清晰、简洁，避免了回调地狱（Callback Hell）的问题。通过协程，可以以顺序的方式编写异步代码，而不必依赖于繁琐的回调函数或者复杂的线程同步机制。</p>
<p><strong>碎语</strong></p>
<p>协程在许多编程语言中都有支持，例如C++20引入了对协程的原生支持，Python的<code>async/await</code>语法也是基于协程的概念实现的。在异步编程中，协程已经成为一种重要的编程范式。然而才在C++20引入了协程标准，可以不用依赖于其他协程库就实现程序在执行过程中暂停和恢复，而不会阻塞整个线程。有了协程使得编写异步代码更加简洁和易读。而官方和网上的案例相对比较局限，看着也不是那么通俗易懂，大部分案例也是嵌入到其他框架一起介绍的，这篇文章就以简单的几个小例子，更好的理解c++20的协程使用方法。</p>
<h2 id="直接看母语"><a href="#直接看母语" class="headerlink" title="直接看母语"></a>直接看母语</h2><p>话不多说，我们直接先上一段封装好的小代码，先不管下面这个代码是啥，我们来研究如何使用就可以，后文再做详细的介绍。</p>
<p>下面代码命名保存为 coroutine.h，后面我们的案例中都包含该头文件。该头文件现已用在<a target="_blank" rel="noopener" href="https://github.com/pwnsky/squick">squick</a>框架中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coroutine</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span> &#123;<br>        T value_;<br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> std::suspend_always&#123;&#125;; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> std::suspend_always&#123;&#125;; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125;<br>        <span class="hljs-function">Coroutine <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Coroutine&#123; handle_type::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>) &#125;; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_void</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-keyword">template</span>&lt;std::convertible_to&lt;T&gt; From&gt;<br>        <span class="hljs-function">std::suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(From&amp;&amp; from)</span> </span>&#123;<br>            value_ = std::forward&lt;From&gt;(from);<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Coroutine</span><span class="hljs-params">(handle_type handle)</span> : coro_handle_(handle) &#123;</span> start_time_ = <span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>); &#125;<br>    ~<span class="hljs-built_in">Coroutine</span>() &#123;&#125;<br>    <span class="hljs-function">handle_type <span class="hljs-title">GetHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> coro_handle_;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">time_t</span> <span class="hljs-title">GetStartTime</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> start_time_;<br>    &#125;<br>    <span class="hljs-type">time_t</span> start_time_ = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    handle_type coro_handle_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Awaitable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;<br>        coro_handle_ = h;<br>        handler_.<span class="hljs-built_in">operator</span>()(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function">T <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    T data_;<br>    std::function&lt; <span class="hljs-type">void</span>(Awaitable&lt;T&gt;* awaitable)&gt; handler_;<br>    std::coroutine_handle&lt;&gt; coro_handle_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="例子1-创建协程"><a href="#例子1-创建协程" class="headerlink" title="例子1-创建协程"></a>例子1-创建协程</h3><p>保存为demo1.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;coroutine.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function">Coroutine&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MyCoroFunc</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;hello coroutine!\n&quot;</span>;<br>        <span class="hljs-keyword">co_return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> co = <span class="hljs-built_in">MyCoroFunc</span>(); <span class="hljs-comment">// 创建协程</span><br>        <span class="hljs-keyword">auto</span> h = co.<span class="hljs-built_in">GetHandle</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine address: &quot;</span> &lt;&lt; h.<span class="hljs-built_in">address</span>() &lt;&lt; std::endl;<br>        h.<span class="hljs-built_in">resume</span>(); <span class="hljs-comment">// 运行协程</span><br>        <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">done</span>()) &#123;<br>                h.<span class="hljs-built_in">destroy</span>(); <span class="hljs-comment">// 销毁协程</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine destroyed\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">g++ demo1.cc --std=c++20<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Coroutine address: 0x55c4d0609eb0<br>hello coroutine!<br>Coroutine destroyed<br></code></pre></td></tr></table></figure>

<p>通过该例子我们已经创建了个协程，并且去调用了MyCoroFunc函数。</p>
<h3 id="例子2-获取协程函数中的返回值"><a href="#例子2-获取协程函数中的返回值" class="headerlink" title="例子2-获取协程函数中的返回值"></a>例子2-获取协程函数中的返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;coroutine.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">Coroutine&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MyCoroFunc</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyCoroFunc: Coroutine run\n&quot;</span>;<br>        <span class="hljs-keyword">co_yield</span> <span class="hljs-number">5</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyCoroFunc: Coroutine continue \n&quot;</span>;<br>        <span class="hljs-keyword">co_return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> co = <span class="hljs-built_in">MyCoroFunc</span>(); <span class="hljs-comment">// 创建协程</span><br>        <span class="hljs-keyword">auto</span> h = co.<span class="hljs-built_in">GetHandle</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine is created, address: &quot;</span> &lt;&lt; h.<span class="hljs-built_in">address</span>() &lt;&lt; std::endl;<br>        h.<span class="hljs-built_in">resume</span>(); <span class="hljs-comment">// 运行协程, 执行到co_yield返回</span><br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyCoroFunc co_yield value: &quot;</span> &lt;&lt; h.<span class="hljs-built_in">promise</span>().value_ &lt;&lt; std::endl;<br>        h.<span class="hljs-built_in">resume</span>(); <span class="hljs-comment">// 继续运行协程</span><br><br>        <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">done</span>()) &#123;<br>                h.<span class="hljs-built_in">destroy</span>(); <span class="hljs-comment">// 销毁协程</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine destroyed\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Coroutine is created, address: 0x56507223ceb0<br>MyCoroFunc: Coroutine run<br>MyCoroFunc co_yield value: 5<br>MyCoroFunc: Coroutine continue<br>Coroutine destroyed<br></code></pre></td></tr></table></figure>



<h3 id="例子3-如何在协程函数运行过程中异步获取外界传来的值"><a href="#例子3-如何在协程函数运行过程中异步获取外界传来的值" class="headerlink" title="例子3-如何在协程函数运行过程中异步获取外界传来的值"></a>例子3-如何在协程函数运行过程中异步获取外界传来的值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;coroutine.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWork</span> &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> &#123;<br>                <span class="hljs-type">int</span> id;<br>                std::string msg;<br>        &#125;;<br>        <span class="hljs-keyword">public</span>:<br>		<span class="hljs-comment">// 我们的Awaitable回调函数，主要用于知道是哪一个协程挂起了，截获协程的handler，用于后面进行恢复协程。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyAwaitbleFuncHandler</span><span class="hljs-params">(Awaitable&lt;Data&gt; *a)</span> </span>&#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;MyAwaitableFuncHandler, bind your corotine to manager\n&quot;</span>;<br>                <span class="hljs-keyword">this</span>-&gt;awaitable_ = a;<br>        &#125;<br>		<span class="hljs-comment">// 我们自己的Awaitble函数，可以把它比作http的客户端向第三方服务器发起请求过程。</span><br>        <span class="hljs-function">Awaitable&lt;Data&gt; <span class="hljs-title">MyAwaitbleFunc</span><span class="hljs-params">()</span> </span>&#123;<br>                Awaitable&lt;Data&gt; a;<br>                a.data_.id = <span class="hljs-number">1234</span>;<br>                a.handler_ = std::<span class="hljs-built_in">bind</span>(&amp;MyWork::MyAwaitbleFuncHandler, <span class="hljs-keyword">this</span>, std::placeholders::_1);<br>                <span class="hljs-keyword">return</span> a;<br>        &#125;<br>		<span class="hljs-comment">// 协程函数</span><br>        <span class="hljs-function">Coroutine&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MyCoroFunc</span><span class="hljs-params">()</span> </span>&#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;MyCoroFunc: Coroutine run\n&quot;</span>;<br>                Data d = <span class="hljs-keyword">co_await</span> <span class="hljs-built_in">MyAwaitbleFunc</span>(); <span class="hljs-comment">// 异步执行MyAwaitbleFunc函数。</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;MyCoroFunc: MyAwaitableFunc return: &quot;</span> &lt;&lt; d.msg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-keyword">co_return</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">auto</span> co = <span class="hljs-built_in">MyCoroFunc</span>(); <span class="hljs-comment">// Create a corotine</span><br>                <span class="hljs-keyword">auto</span> h = co.<span class="hljs-built_in">GetHandle</span>();<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine is created, address: &quot;</span> &lt;&lt; h.<span class="hljs-built_in">address</span>() &lt;&lt; std::endl;<br>                h.<span class="hljs-built_in">resume</span>(); <span class="hljs-comment">// 运行协程</span><br>                <span class="hljs-comment">// 设置await的返回值</span><br>                <span class="hljs-keyword">this</span>-&gt;awaitable_-&gt;data_.msg = <span class="hljs-string">&quot;Hello awaitble&quot;</span>;<br><br>                h.<span class="hljs-built_in">resume</span>(); <span class="hljs-comment">// 继续运行协程</span><br>                <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">done</span>()) &#123;<br>                        h.<span class="hljs-built_in">destroy</span>();<br>                        std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine destroyed\n&quot;</span>;<br>                &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">private</span>:<br>        Awaitable&lt;Data&gt; *awaitable_ = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        MyWork w;<br>        w.<span class="hljs-built_in">DoWork</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Coroutine is created, address: 0x55cb276c4eb0<br>MyCoroFunc: Coroutine run<br>MyAwaitableFuncHandler, bind your corotine to manager<br>MyCoroFunc: MyAwaitableFunc return: Hello awaitble<br>Coroutine destroyed<br></code></pre></td></tr></table></figure>



<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>看完了上面例子，看不懂也没关系，我在这里做一些简单的概念。</p>
<p>C++20引入了协程（Coroutines）的支持，这是一项重要的新功能，使得异步编程变得更加容易和直观。协程提供了一种在函数内部暂停和恢复执行的机制，从而使得编写异步代码更加简洁、可读性更高。</p>
<p>以下是C++20协程的一些关键概念和特性：</p>
<ol>
<li><strong>协程关键字：</strong> C++20引入了<code>co_await</code>、<code>co_yield</code>、<code>co_return</code>等新的关键字，用于在协程内部进行挂起、恢复和返回操作。</li>
<li><strong>协程函数：</strong> 使用<code>co_return</code>可以在协程函数中返回值，并在此处暂停协程的执行。协程函数可以返回一个期待值，而不是立即返回，从而使得在异步操作完成后再继续执行。</li>
<li><strong>协程生成器（Coroutine Generator）：</strong> 通过<code>co_yield</code>关键字，可以在协程内部产生值并暂停执行。这种机制非常适合生成序列或流式数据。</li>
<li><strong>协程状态机：</strong> 编译器会将协程函数转换成状态机的形式，以便在暂停和恢复时保存和恢复执行上下文。</li>
<li><strong><code>std::coroutine_handle</code>：</strong> 这是一个轻量级的句柄，用于管理协程的生命周期和执行状态。它可以用来手动控制协程的执行，例如恢复、挂起和销毁。</li>
<li><strong>协程的异步编程：</strong> 协程可以与异步任务一起使用，例如与Future、Promise、I&#x2F;O操作等结合，从而实现高效的异步编程模式，而无需显式地使用回调函数或复杂的线程管理。</li>
<li><strong>协程的异常处理：</strong> 协程内部的异常可以通过<code>co_await</code>或<code>co_yield</code>传递给调用方进行处理，也可以通过协程的<code>promise_type</code>自定义异常处理逻辑。</li>
<li><strong>协程库：</strong> C++20标准库提供了与协程相关的头文件<code>&lt;coroutine&gt;</code>，其中包含了一些与协程相关的类和函数，例如<code>std::coroutine_traits</code>、<code>std::suspend_always</code>、<code>std::suspend_never</code>等。</li>
</ol>
<p>来看看先前例子中所写的头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coroutine</span> &#123; <span class="hljs-comment">// 该类主要用于创建协程，且确定协程采用什么机制运行，有promise_type结构体负责。</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 协程状态管理,如果类中有promise_type且里面封装有协程的内置函数，编译器会自动给根据返回了该类的函数以及内嵌的函数来综合判定该函数是不是协程函数。</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span> &#123; <span class="hljs-comment">// promise_type是一个关键的概念，它是用于控制协程行为的一种特殊的类型。</span><br>        T value_; <span class="hljs-comment">// 协程的返回值</span><br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> std::suspend_always&#123;&#125;; &#125; <span class="hljs-comment">// 创建协程时调用, 返回std::suspend_always代表创建时挂起,当然也可以让它直接运行，std::suspend_nerver</span><br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> std::suspend_always&#123;&#125;; &#125; <span class="hljs-comment">// 协程结束时调用</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125; <span class="hljs-comment">// 异常处理， 该函数来处理在协程内部抛出的异常。</span><br>        <span class="hljs-function">Coroutine <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Coroutine&#123; handle_type::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>) &#125;; &#125; <span class="hljs-comment">// 返回对象管理，该函数，用于创建协程的返回对象，通常会返回一个Coroutine对象或者std::coroutine_handle对象，以便外部代码可以操作协程。 </span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_void</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 可以允许void 返回，相当于允许 co_return 关键字</span><br>        <span class="hljs-keyword">template</span>&lt;std::convertible_to&lt;T&gt; From&gt;<br>        <span class="hljs-function">std::suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(From&amp;&amp; from)</span> </span>&#123; <span class="hljs-comment">// 可以使用 co_yield 关键字让协程挂起，外界可使用协程读取promise对象获取yield的值</span><br>            value_ = std::forward&lt;From&gt;(from);<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;; <span class="hljs-comment">// 协程的handler，可以将该handler传递给外界管理协程，里面封装了几个常用的函数，如 address(), done(), resume, promise()</span><br>    <span class="hljs-comment">// address: 获取协程的地址</span><br>    <span class="hljs-comment">// done: 该协程是否执行完毕</span><br>    <span class="hljs-comment">// resume: 恢复协程，继续运行</span><br>    <span class="hljs-comment">// promise: 获取到promise_type对象，主要用于获取 co_yield传递的值。</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Coroutine</span><span class="hljs-params">(handle_type handle)</span> : coro_handle_(handle) &#123;</span> start_time_ = <span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>); &#125; <span class="hljs-comment">// 创建协程时调用该构造函数</span><br>    ~<span class="hljs-built_in">Coroutine</span>() &#123;&#125;<br>    <span class="hljs-function">handle_type <span class="hljs-title">GetHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 获取协程handle</span><br>        <span class="hljs-keyword">return</span> coro_handle_;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">time_t</span> <span class="hljs-title">GetStartTime</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> start_time_;<br>    &#125;<br>    <span class="hljs-type">time_t</span> start_time_ = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    handle_type coro_handle_;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Awaitable</span> &#123; <span class="hljs-comment">// 该类主要用于协程函数中能让协程挂起，从外界传值到协程函数中去</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125; <span class="hljs-comment">// 再调用Awaitable函数时最先运行，基本没啥作用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123; <span class="hljs-comment">// 再协程挂起后运行，我们再里面通过运行我们的回调函数将协程的handler传递出去，方便外界自行去管理该协程。在达到一定时期时，用于恢复协程。</span><br>        coro_handle_ = h; <span class="hljs-comment">// </span><br>        handler_.<span class="hljs-built_in">operator</span>()(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 调用我们的回调函数</span><br>    &#125;<br>    <span class="hljs-function">T <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125; <span class="hljs-comment">// co_await 函数的返回值</span><br>    T data_; <span class="hljs-comment">// co_await 函数返回值</span><br>    std::function&lt; <span class="hljs-type">void</span>(Awaitable&lt;T&gt;* awaitable)&gt; handler_; <span class="hljs-comment">// 回调函数，这我自己写的可以不用，只是方便在协程挂起时，能够通过回调函数捕获到是哪一个协程挂起了。</span><br>    std::coroutine_handle&lt;&gt; coro_handle_; <span class="hljs-comment">// 协程handler</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>就先介绍到这里了，学会了以上基本没啥大问题，协程的内存管理，可以通过智能指针来管理，以上例子中都是手动释放内存的。对协程的内存管理也是一门学问，看自己的框架怎么设计喽。比如下面这几个伪代码是利用上面我介绍的例子实际运用到http服务器中的。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pwnsky/squick/blob/main/src/tutorial/t5_http/http_module.cc">https://github.com/pwnsky/squick/blob/main/src/tutorial/t5_http/http_module.cc</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Coroutine&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">HttpModule::ClientAsyncGet</span><span class="hljs-params">(std::shared_ptr&lt;HttpRequest&gt; req)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;You use await to async request another server\n&quot;</span>;<br>    <span class="hljs-keyword">auto</span> data = <span class="hljs-keyword">co_await</span> m_http_client_-&gt;<span class="hljs-built_in">CoGet</span>(<span class="hljs-string">&quot;http://www.bilibili.com&quot;</span>);<br>    m_http_server_-&gt;<span class="hljs-built_in">ResponseMsg</span>(req, data.content, WebStatus::WEB_OK);<br>    <span class="hljs-keyword">co_return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>大家有兴趣可以去看看我写的<a target="_blank" rel="noopener" href="https://github.com/pwnsky/squick">squick</a>游戏框架。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/coroutines">https://en.cppreference.com/w/cpp/language/coroutines</a></p>
<p><a target="_blank" rel="noopener" href="https://chat.openai.com/chat">https://chat.openai.com/chat</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2024/04/08/dev/tools/flamegragh/">← Next Linux进程火焰图</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2023/11/15/dev/jenkins/jenkins/">Jenkins 部署 Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-20-Coroutine"><span class="toc-text">C++20 Coroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%9C%8B%E6%AF%8D%E8%AF%AD"><span class="toc-text">直接看母语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%901-%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B"><span class="toc-text">例子1-创建协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%902-%E8%8E%B7%E5%8F%96%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">例子2-获取协程函数中的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%903-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E5%A4%96%E7%95%8C%E4%BC%A0%E6%9D%A5%E7%9A%84%E5%80%BC"><span class="toc-text">例子3-如何在协程函数运行过程中异步获取外界传来的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>