<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>反调试技术 | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>反调试技术</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-08-20T09:07:21.000Z" id="date"> 2024-08-20</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-10-07T08:17:07.917Z" id="updated"> 2024-10-07</time></div></span><br><span>Word Count: <div class="control">1.3k</div></span><br><span>Read Time: <div class="control">4 min</div></span></div></div><hr><div id="post-content"><h1 id="反调试技术"><a href="#反调试技术" class="headerlink" title="反调试技术"></a>反调试技术</h1><p>ref: <a target="_blank" rel="noopener" href="https://km.woa.com/articles/show/424765?kmref=search&amp;from_page=1&amp;no=2">https://km.woa.com/articles/show/424765?kmref=search&amp;from_page=1&amp;no=2</a></p>
<h2 id="一、基于PEB的调试器检测"><a href="#一、基于PEB的调试器检测" class="headerlink" title="一、基于PEB的调试器检测"></a>一、基于PEB的调试器检测</h2><p>备注：mov eax, 0x31;dec eax;mov eax, fs:[eax]; 这么冗余的写法主要是因为</p>
<p>mov eax,fs:[0x30]太显眼，一看到这条指令就很容易猜到是操作PEB的关键代码，甚至通过特征码暴力定位关键逻辑。所以对代码做了简单变形，防代码特征码搜索。</p>
<h3 id="A、BeingDebugged标记位检测调试器"><a href="#A、BeingDebugged标记位检测调试器" class="headerlink" title="A、BeingDebugged标记位检测调试器"></a>A、BeingDebugged标记位检测调试器</h3><p>反调函数：GetBeingDebuggedFlag()</p>
<p>反调表现：存在调试器则返回true，没有调试器则返回false;</p>
<p>绕过方式：对应标记位清零</p>
<h3 id="B、NtGlobalFlag标记位检测调试器"><a href="#B、NtGlobalFlag标记位检测调试器" class="headerlink" title="B、NtGlobalFlag标记位检测调试器"></a>B、NtGlobalFlag标记位检测调试器</h3><p>反调函数：FindDebuggerByNtGlobalFlags()</p>
<p>反调表现：存在调试器则返回true，没有调试器则返回false;</p>
<p>绕过方式：对应标记位复位</p>
<h3 id="C、Heap-Flags-标记位检测调试器"><a href="#C、Heap-Flags-标记位检测调试器" class="headerlink" title="C、Heap.Flags 标记位检测调试器"></a>C、Heap.Flags 标记位检测调试器</h3><p>反调函数：FindDebuggerByHeapFlags()</p>
<p>反调表现：存在调试器则返回true，没有调试器则返回false;</p>
<p>绕过方式：对应标记位清零</p>
<h3 id="D、HEAP-ForceFlags标记位检测调试器"><a href="#D、HEAP-ForceFlags标记位检测调试器" class="headerlink" title="D、HEAP.ForceFlags标记位检测调试器"></a>D、HEAP.ForceFlags标记位检测调试器</h3><p>反调函数：FindDebuggerByForceFlags()</p>
<p>反调表现：存在调试器则返回true，没有调试器则返回false;</p>
<p>绕过方式：对应标记位置2</p>
<h2 id="二、通过NtQueryInformationProcess函数检测调试器"><a href="#二、通过NtQueryInformationProcess函数检测调试器" class="headerlink" title="二、通过NtQueryInformationProcess函数检测调试器"></a>二、通过NtQueryInformationProcess函数检测调试器</h2><h2 id="四、通过ThreadHideFromDebuger干扰调试"><a href="#四、通过ThreadHideFromDebuger干扰调试" class="headerlink" title="四、通过ThreadHideFromDebuger干扰调试"></a>四、通过ThreadHideFromDebuger干扰调试</h2><h3 id="A、ZwSetInformationThread反调"><a href="#A、ZwSetInformationThread反调" class="headerlink" title="A、ZwSetInformationThread反调"></a>A、ZwSetInformationThread反调</h3><p>ThreadHideFromDebuger是线程的一个属性值，当线程具备ThreadHideFromDebuger特性时则该线程对“调试器”隐藏，线程触发的所有异常均不会通知调试器处理。所以如果线程设置了ThreadHideFromDebuger那么当断点触发时调试器表现为卡死。当线程启动后可以通过ZwSetInformationThread函数来设置，相关代码如下：</p>
<p>反调函数：SetThreadHideFromDebugger()</p>
<p>反调表现：调用该函数后调用线程触发的异常不会在发送到调试器，触发断点后调试器卡死;</p>
<p>绕过方法：对ZwSetInformationThread进行hook过滤，ThreadHideFromDebugger参数则直接返回。</p>
<h3 id="B、NtCreateThreadEx反调"><a href="#B、NtCreateThreadEx反调" class="headerlink" title="B、NtCreateThreadEx反调"></a>B、NtCreateThreadEx反调</h3><p>除了通过ZwSetInformationThread来设置已有线程的ThreadHideFromDebuger标记位外，还可以创建一个新的、创建开始就自动具备ThreadHideFromDebuger属性的线程。ZwCreateThreadEx函数的声明如下：</p>
<p>其中CreateFlags参数如果设置了THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER位的话则创建的新线程直接具有反调试功能。</p>
<p>绕过方法：对ZwCreateThreadEx进行hook过滤，去掉线程ThreadHideFromDebugger属性。</p>
<h3 id="C、通用ThreadHideFromDebuger保护绕过方式"><a href="#C、通用ThreadHideFromDebuger保护绕过方式" class="headerlink" title="C、通用ThreadHideFromDebuger保护绕过方式"></a>C、通用ThreadHideFromDebuger保护绕过方式</h3><p>不管是ZwSetInformationThread方式还是ZwCreateThreadEx方式的ThreadHideFromDebuger线程保护，其绕过方式基本都是通过HOOK函数调用需改函数参数或者修改系统内核代码直接修改内核执行逻辑的方式绕过。理论上通过代码校验都能够发现这类修改，甚至会触发PageGuard导致系统稳定性问题。但有大咖们发现了新的、不用修改代码即可绕过ThreadHideFromDebuger保护的方式。</p>
<p>首先我们来看看ZwSetInformationThread函数对ThreadHideFromDebuger操作的处理逻辑，代码如下：</p>
<h2 id="五、基于异常原理的反调试"><a href="#五、基于异常原理的反调试" class="headerlink" title="五、基于异常原理的反调试"></a>五、基于异常原理的反调试</h2><p>操作系统异常处理逻辑比较复杂，包括VEH\SEH\UEH\VCH(自己临时命名，不一定权威，具体涉及函数见代码)等等。利用好异常处理功能可以很好的提升程序稳定性，但很多时候也被用于反调试功能。为了便于后面反调试逻辑的理解，这里先给出一份包含4种异常处理的demo例子，便于大家更好的开发包含异常处理的程序。</p>
<p>利用异常进行反调试技术可分为2大类，一大类时利用调试器过滤处理常见调试异常的BUG来发现调试器的存在。另外还有一类则是利用操作系统在有调试器和无调试器时逻辑处理差异来发现调试器的存在。这两大类反调试思路又根据实现细节划分位不同子类型。</p>
<h3 id="A、利用异常结合断点检测调试器"><a href="#A、利用异常结合断点检测调试器" class="headerlink" title="A、利用异常结合断点检测调试器"></a>A、利用异常结合断点检测调试器</h3><p>很多时候执行特定的代码会触发特定的异常，并且这类异常一般用于调试器种，如果程序没有被调试则会被异常处理函数所捕获。由于这类异常经常用于调试器种，所以很多调试器见到这类异常就直接拦截处理了，导致程序自己注册的异常处理函数捕获不到异常。常见的这类指令主要包含：int 3h; int 2ch; int 2dh;IceBp;单步异常等；网上还有说利用0xCD03断点的方法，但由于本人没测试通过所以这里就不包含该方式。</p>
<p>对程序开发者来讲虽然各异常使用场景方面稍有差异，但大致用法都还是一致的。所以利用SEH异常结合断点能够检测调试器，利用UEH\VEH等异常也能实现类似工作。SEH使用相对更便捷，所以本章节大部分异常都采用SEH异常的方式，其它异常类似功能实现可以自己摸索。</p>
<h4 id="1-利用int-3断点检测调试器"><a href="#1-利用int-3断点检测调试器" class="headerlink" title="1) 利用int 3断点检测调试器"></a>1) 利用int 3断点检测调试器</h4><p>利用int 3断点检测调试器代码如下（VS调试器上测试可用）：</p>
<h4 id="2-利用int-2C断点检测调试器"><a href="#2-利用int-2C断点检测调试器" class="headerlink" title="2) 利用int 2C断点检测调试器"></a>2) 利用int 2C断点检测调试器</h4><p>利用int 2C断点检测调试器代码如下（VS调试器上测试可用）：</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2024/09/29/dev/db/mysql/mysql_split_db_or_table/">← Next Mysql分库分表方案</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2024/08/20/security/dll_inject/">DLL注入 Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-text">反调试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E4%BA%8EPEB%E7%9A%84%E8%B0%83%E8%AF%95%E5%99%A8%E6%A3%80%E6%B5%8B"><span class="toc-text">一、基于PEB的调试器检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A%E3%80%81BeingDebugged%E6%A0%87%E8%AE%B0%E4%BD%8D%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">A、BeingDebugged标记位检测调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E3%80%81NtGlobalFlag%E6%A0%87%E8%AE%B0%E4%BD%8D%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">B、NtGlobalFlag标记位检测调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E3%80%81Heap-Flags-%E6%A0%87%E8%AE%B0%E4%BD%8D%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">C、Heap.Flags 标记位检测调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D%E3%80%81HEAP-ForceFlags%E6%A0%87%E8%AE%B0%E4%BD%8D%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">D、HEAP.ForceFlags标记位检测调试器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%80%9A%E8%BF%87NtQueryInformationProcess%E5%87%BD%E6%95%B0%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">二、通过NtQueryInformationProcess函数检测调试器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%9A%E8%BF%87ThreadHideFromDebuger%E5%B9%B2%E6%89%B0%E8%B0%83%E8%AF%95"><span class="toc-text">四、通过ThreadHideFromDebuger干扰调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A%E3%80%81ZwSetInformationThread%E5%8F%8D%E8%B0%83"><span class="toc-text">A、ZwSetInformationThread反调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E3%80%81NtCreateThreadEx%E5%8F%8D%E8%B0%83"><span class="toc-text">B、NtCreateThreadEx反调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E3%80%81%E9%80%9A%E7%94%A8ThreadHideFromDebuger%E4%BF%9D%E6%8A%A4%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F"><span class="toc-text">C、通用ThreadHideFromDebuger保护绕过方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-text">五、基于异常原理的反调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A%E3%80%81%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E7%BB%93%E5%90%88%E6%96%AD%E7%82%B9%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">A、利用异常结合断点检测调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8int-3%E6%96%AD%E7%82%B9%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">1) 利用int 3断点检测调试器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8int-2C%E6%96%AD%E7%82%B9%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">2) 利用int 2C断点检测调试器</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>