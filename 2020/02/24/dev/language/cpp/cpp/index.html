<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>C++ Language | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>C++ Language</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2020-02-24T10:52:00.000Z" id="date"> 2020-02-24</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-10-07T08:17:07.900Z" id="updated"> 2024-10-07</time></div></span><br><span>Word Count: <div class="control">16.6k</div></span><br><span>Read Time: <div class="control">86 min</div></span></div></div><hr><div id="post-content"><h1 id="C-language"><a href="#C-language" class="headerlink" title="C++ language"></a>C++ language</h1><p>Learn：</p>
<p><a target="_blank" rel="noopener" href="https://www.programiz.com/cpp-programming/variables-literals">https://www.programiz.com/cpp-programming/variables-literals</a></p>
<h2 id="Keywords-of-C"><a href="#Keywords-of-C" class="headerlink" title="Keywords of C++"></a>Keywords of C++</h2><pre><code>alignas(c++11)	 //声明结构体或类的对齐数
alignof(c++11)	 //查看结构体或类的对齐数
and				 //等价于 &amp;&amp;
and_eq			 //等价于 &amp;&amp;=
asm				 //汇编语句
auto			 //自动类型
bitand			 //等价于  &amp;
bitor			 //等价于　|
bool			 //bool类型
break			 //跳出当前循环,或switch
case			 //结合switch使用
catch			 //捕获异常
char			 //1字节变量
short			 //2字节变量
signed			 //声明为有符号类型
unsigned		 //声明为无符号类型
char16_t(c++11)  //常使用于Unicode字符
char32_t(c++11)	 //常使用于Unicode字符
int				 //默认４字节
long			 //不比int类型小的类型
class			 //类,或者声明模板类型
compl			 //等价于 ~
concept(概念Ts)	 //专家级别使用
const			 //声明常变量
constexpr(c++11) //用作函数时,是在编译是进行函数调用的,类似与宏
const_cast		 //常变量强制转化为其他变量类型
continue		 //结合循环来使用	
decltype(c++11)  //与auto差不多,可以用于某个不确定多个参数类型的模板函数
default			 //结合switch来使用
delete			 //释放new出来的东西
new				 //开辟内存
do				 //配合 while构成循环
explicit		 //不能隐式构造
export			 //专家级别使用...
extern			 //改变某个变量的作用域,常用在不同文件中使用同一个变量
float			 //4字节的浮点类型
double			 //８字节的浮点类型
for				 //for循环
goto			 //跳转
if				 //判断
friend			 //给类中的一些函数使用,可以访问类中的私有成员变量
inline			 //内联声明, 编译器对该函数进行优化,类中函数和模板函数默认代这个参数
mutable			 //在lambda表达式中使用表示为传递进来的变量可以被赋值
namespace		 //声明命名空间　
noexcept(c++11)  //声明为不抛出异常,利于编译器的优化 
not				 //等价与 !
not_eq			 //等价于 !=
nullptr(c++11)	 //c++11以后声明空指针类型,主要解决模板函数中的参数问题
operator		 //操作运算重载
or				 //等价与 |
or_eq			 //等价于 |=
private			 //声明成员为私有的
public			 //声明成员为公共的
protected		 //声明成员为保护的
register		 //声明在寄存器里的变量
reinterpret_cast //常用在　一个类型的指针转化为另一个类型的指针
requires(概念TS) //一个概念,目前还没有编译器实现
return	 //函数的返回
static	 //声明变量为静态的
sizeof	 //获取某个变量的大小
static_assert(c++11) //静态断言, 常用
static_cast //静态转化
struct	 //结构体类型
switch	 //switch分支判断结构
template //声明模板
this	 //this指针, 常用在class和struct
thread_local(c++11)  //结合线程来使用
throw	 //抛出异常
true	 //bool类型的真
false	 //bool类型的假
try		 //异常尝试
typedef	 //改变变量名称
typeid	 //获取类型的id号
typename //声明模板类型
union	//联合体
using  //可以替换typedef的功能
virtual //虚函数
void   //空类型
volatile //直接声明为定死的常量
wchar_t //表示宽字符的
while   //循环
xor		//异或 ^
xor_eq  //　^=
</code></pre>
<p>实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-comment">//#include &lt;algorithm&gt;</span><br><span class="hljs-comment">//#include &lt;vector&gt;</span><br><span class="hljs-comment">//#include &lt;list&gt;</span><br><span class="hljs-comment">//#include &lt;stack&gt;</span><br><span class="hljs-comment">//#include &lt;future&gt;</span><br><span class="hljs-comment">//#include &lt;functional&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//alignas</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">8</span>) S &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">1</span>) U &#123;S s; &#125;; <span class="hljs-comment">//bad</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-type">float</span> f;<br>	<span class="hljs-type">char</span> c;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Empty</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">64</span>) Empty64 &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">1</span>) Double &#123; <span class="hljs-type">double</span> d; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Obj</span> &#123;<span class="hljs-type">char</span> a; <span class="hljs-type">int</span> b;&#125;;<br><span class="hljs-comment">//sizeof(Obj) == 8</span><br><span class="hljs-comment">//alignof(Obj) == 4</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">alignInfo</span><span class="hljs-params">()</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;Alignment of&quot;</span> &lt;&lt; endl<br>		&lt;&lt;<span class="hljs-string">&quot;_char			 : &quot;</span> &lt;&lt; <span class="hljs-built_in">alignof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl<br>		&lt;&lt;<span class="hljs-string">&quot;_pointer          : &quot;</span> &lt;&lt; <span class="hljs-built_in">alignof</span>(<span class="hljs-type">int</span>*) &lt;&lt; endl<br>		&lt;&lt;<span class="hljs-string">&quot;_class Foo        : &quot;</span> &lt;&lt; <span class="hljs-built_in">alignof</span>(Foo) &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//and</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAnd</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>	<span class="hljs-keyword">if</span>(a == <span class="hljs-number">3</span> &amp;&amp; b == <span class="hljs-number">4</span>) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;&amp;&amp; a = 3, b = 4&quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(a == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> b == <span class="hljs-number">4</span>) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;and a = 3, b = 4&quot;</span>;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//and_eq   &lt;=&gt;  &amp;=</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testAnd_eq</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">bool</span> a = <span class="hljs-literal">false</span>;<br>	<span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;<br>	b = b <span class="hljs-keyword">and_eq</span> a;<br>	cout &lt;&lt; b &lt;&lt; endl;<br>	<span class="hljs-type">bool</span> c = <span class="hljs-literal">true</span>;<br>	c <span class="hljs-keyword">and_eq</span> a;<br>	cout &lt;&lt; <span class="hljs-string">&quot;c: &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//not &lt;=&gt; !</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNot</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-type">bool</span> a = <span class="hljs-literal">true</span>;	<br>	<span class="hljs-type">bool</span> b = <span class="hljs-built_in">not</span>(a);<br>	cout &lt;&lt; b;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//not_eq &lt;=&gt; !=</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNot_eq</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">bool</span> a = <span class="hljs-literal">true</span>;<br>	<span class="hljs-function">a <span class="hljs-title">not_eq</span><span class="hljs-params">(a)</span></span>;<br>	cout &lt;&lt; a;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//or &lt;=&gt; |</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testOr</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>	cout &lt;&lt; a <span class="hljs-keyword">or</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//or &lt;=&gt; |=</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testOr_eq</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>	a <span class="hljs-keyword">or_eq</span> <span class="hljs-number">4</span>;<br>	cout &lt;&lt; a;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAsm</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">asm</span> (<br>	<span class="hljs-string">&quot;movq $60, %rax\n\t&quot;</span> <span class="hljs-comment">//the exit syscall number on linux</span><br>	<span class="hljs-string">&quot;movq $2,  %rdi\n\t&quot;</span> <span class="hljs-comment">//this program returns 2</span><br>	<span class="hljs-string">&quot;syscall&quot;</span><br>	);<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAuto</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;type of a: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>);<br>	cout &lt;&lt; <span class="hljs-string">&quot;type of b: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">auto</span> c = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//初始化列表</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;type of c: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(c).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br>	<span class="hljs-keyword">auto</span> my_lambda = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">3</span>; &#125;;<br>	cout &lt;&lt; <span class="hljs-string">&quot;type of my_lambda: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(my_lambda).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br>	<span class="hljs-keyword">auto</span> my_fun = get_fun;<br>	cout &lt;&lt; <span class="hljs-string">&quot;my_fun: &quot;</span> &lt;&lt; <span class="hljs-built_in">my_fun</span>(<span class="hljs-number">3</span>) &lt;&lt; endl;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;type of my_fun: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(my_fun).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showBitAndOr</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> a = <span class="hljs-number">3l</span>; <span class="hljs-comment">//long int</span><br>	<span class="hljs-keyword">auto</span> b = <span class="hljs-number">4</span>;<br>	<span class="hljs-keyword">auto</span> c = a <span class="hljs-keyword">bitand</span> b;<br>	<span class="hljs-keyword">auto</span> d = a <span class="hljs-keyword">bitor</span> b;<br>	cout &lt;&lt; <span class="hljs-string">&quot;c: &quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;d: &quot;</span> &lt;&lt; d;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testBool</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">bool</span> a = <span class="hljs-literal">true</span>;<br>	<span class="hljs-type">bool</span> b = <span class="hljs-literal">false</span>;<br>	*(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(&amp;a)) = <span class="hljs-number">-1</span>;<br>	cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>	<span class="hljs-keyword">if</span>(a == <span class="hljs-literal">true</span>) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;i&#x27;m true&quot;</span>;<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a == <span class="hljs-literal">false</span>)&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;i&#x27;m false&quot;</span>;<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;What?&quot;</span>;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testBreak</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">for</span>(;;) &#123;<br>		<span class="hljs-keyword">for</span>(;;) &#123;<br>			++a;	<br>			<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">break</span>;<br>		&#125;	<br>		<span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">100000000</span>) <span class="hljs-keyword">break</span>;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testCompl</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">-3</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-built_in">compl</span>(a); <span class="hljs-comment">// compl(a) &lt;=&gt; ~a</span><br>	cout &lt;&lt; b;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (n * <span class="hljs-built_in">fact</span>(n - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (n * <span class="hljs-built_in">factorial</span>(n - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NN</span>&#123;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; N &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testConstExpr</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">fact</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">//运行时计算</span><br>	<span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">factorial</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">//编译时计算, 类似于宏定义计算</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>	<span class="hljs-type">char</span> group[<span class="hljs-built_in">factorial</span>(<span class="hljs-number">5</span>)];<br>	NN&lt;<span class="hljs-built_in">factorial</span>(<span class="hljs-number">8</span>)&gt; nn;<br>	nn.<span class="hljs-built_in">print</span>();<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">void testThread(const int &amp;a) &#123;</span><br><span class="hljs-comment">	cout &lt;&lt; &quot;thread&quot;	</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testConst_cast</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;<br>	<span class="hljs-comment">//const int*</span><br>	<span class="hljs-type">int</span> *p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;i);<br><span class="hljs-comment">//	std::thread aa([&amp;i]()&#123; testThread(i); &#125;);</span><br>	*p = <span class="hljs-number">5</span>;<br>	cout &lt;&lt; p &lt;&lt; endl &lt;&lt; &amp;i &lt;&lt; endl;<br>	cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//decltype 与 auto 十分相近</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">x</span>(n) &#123;&#125; <span class="hljs-type">double</span> x;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testDecltype</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">const</span> A* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">auto</span> aa = a-&gt;x;<br>	<span class="hljs-keyword">decltype</span>(a-&gt;x) y; <span class="hljs-comment">// 相当于auto  aa = a-&gt;x</span><br>	<span class="hljs-keyword">decltype</span>((a-&gt;x)) z = y; <span class="hljs-comment">//相当于 auto &amp; z = y, 引用</span><br>	y = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//	z = 4;</span><br>	cout &lt;&lt; y &lt;&lt; endl &lt;&lt; z;<br>&#125;<br><span class="hljs-comment">// 写一个相加函数, 实现不确定类型相加的函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T a, U b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span> </span>&#123; <span class="hljs-comment">//decltype(a + b) 推导出返回值类型</span><br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//陷阱: auto </span><br><span class="hljs-comment">template&lt;typename T, typename U&gt;</span><br><span class="hljs-comment">auto add(Ta, Ub) &#123;&#125;</span><br><span class="hljs-comment">	return a + b;</span><br><span class="hljs-comment">	// return a + b 与 return (a + b) 可能表示的意义不同, 后者可能代表引用</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Drive</span> : Base &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testDynamic_cast</span><span class="hljs-params">()</span> </span>&#123;<br>	Base *b1 = <span class="hljs-keyword">new</span> Base;<br>	<span class="hljs-comment">//这里会调用不成功</span><br>	<span class="hljs-keyword">if</span>(Drive *d = <span class="hljs-built_in">dynamic_cast</span>&lt;Drive *&gt;(b1)) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;downcast from b1 to d successful&quot;</span> &lt;&lt; std::endl;	<br>		d-&gt;<span class="hljs-built_in">name</span>(); <span class="hljs-comment">//safe to call</span><br>	&#125;<br>	<br>	Base *b2 = <span class="hljs-keyword">new</span> Drive;<br>	<span class="hljs-comment">//这里会调用成功</span><br>	<span class="hljs-keyword">if</span>(Drive *d = <span class="hljs-built_in">dynamic_cast</span>&lt;Drive *&gt;(b2)) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;downcast from b2 to d successful&quot;</span> &lt;&lt; std::endl;	<br>		d-&gt;<span class="hljs-built_in">name</span>(); <span class="hljs-comment">//safe to call</span><br>	&#125;<br>	<span class="hljs-comment">//对于dynamic_cast转换引用,若转化失败,则会抛出异常</span><br>	<span class="hljs-comment">//dynamic_cast 在运行期进行检查 </span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	Base bb; </span><br><span class="hljs-comment">	Drive&amp; cc = dynamic_cast&lt;Drive&amp;&gt;(bb);</span><br><span class="hljs-comment">	*/</span><br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; red, green, blue &#125;;<br><span class="hljs-comment">//老的版本中,若出现 enmu Color2 &#123;red, green, blue&#125;; 就会出先重复的元素,就会报错</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testOldEnum</span><span class="hljs-params">()</span> </span>&#123;<br>	Color r = red;<br>	<span class="hljs-keyword">switch</span>(r) &#123;<br>		<span class="hljs-keyword">case</span> red:<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;red&quot;</span> &lt;&lt; std::endl;<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> green:<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;green&quot;</span> &lt;&lt; std::endl;<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> blue:<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;blue&quot;</span> &lt;&lt; std::endl;<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">default</span>:<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;what ?&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">NewColor</span> &#123;red, green, blue = green + <span class="hljs-number">12</span>&#125;;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">MyColor</span> : <span class="hljs-type">short</span> &#123;black&#125;; <span class="hljs-comment">//通过short指定元素的类型为short</span><br><br><span class="hljs-comment">//若以bool作为函数参数, 建议使用enum来代替bool参数.</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">IsGood</span> &#123;Yes, No&#125;;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">IsOk</span> &#123;Yes, No&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enumBoolTest</span><span class="hljs-params">(IsGood isGood, IsOk isOk)</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNewEnum</span><span class="hljs-params">()</span> </span>&#123;<br>	NewColor r = NewColor::blue;<br>	<span class="hljs-keyword">switch</span>(r) &#123;<br>		<span class="hljs-keyword">case</span> NewColor::blue: &#123;<br>			cout &lt;&lt; <span class="hljs-string">&quot;new blue&quot;</span> &lt;&lt; endl;						 <br>		&#125; <span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> NewColor::red: &#123;<br>			cout &lt;&lt; <span class="hljs-string">&quot;new red&quot;</span> &lt;&lt; endl;						 <br>		&#125; <span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> NewColor::green: &#123;<br>			cout &lt;&lt; <span class="hljs-string">&quot;new green&quot;</span> &lt;&lt; endl; <br>		&#125; <span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">default</span>:<br>			cout &lt;&lt; <span class="hljs-string">&quot;new what?&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-type">int</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(blue) + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(NewColor::blue);<br>	cout &lt;&lt; <span class="hljs-string">&quot;blud + NewColor::blue = &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>	<span class="hljs-built_in">enumBoolTest</span>(IsGood::Yes, IsOk::No);<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//test explicit</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AA</span> &#123;<br>	<span class="hljs-built_in">AA</span>(<span class="hljs-type">int</span>) &#123;&#125;<br>	<span class="hljs-built_in">AA</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">//AA可以默认的转化为int类型</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BB</span> &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BB</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;&#125;<br>	<span class="hljs-built_in">BB</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testExplicit</span><span class="hljs-params">()</span> </span>&#123;<br>	AA a1 = <span class="hljs-number">1</span>; <span class="hljs-comment">//等价于 AA a1 = AA(1);</span><br>	<span class="hljs-comment">//而BB就不能 BB b = 1;</span><br>	AA a2 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//等价于 AA a1 = AA(3, 5);</span><br>	BB b2 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//BB中B(int, int)没有加explicit</span><br>	<span class="hljs-type">int</span> i = a1; <span class="hljs-comment">//能通过</span><br>	<span class="hljs-comment">//而BB就不能 int i = b2;</span><br>	<span class="hljs-comment">//将BB强转.</span><br>	<span class="hljs-type">int</span> na2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a1);<br>	<span class="hljs-type">int</span> nb2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(b2); <span class="hljs-comment">//强转explicit　可以</span><br>	AA a4 = (AA)<span class="hljs-number">3</span>;<br>	BB b3 = (BB)<span class="hljs-number">4</span>; <span class="hljs-comment">//通过C语言方式强制转换, 可以</span><br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//friend</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Friend</span> &#123;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> data; <span class="hljs-comment">//private member</span><br>	<span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream &amp;out, <span class="hljs-type">const</span> Friend &amp;o);<br>	<span class="hljs-comment">//Mycla　类是Fried类的好友, 只是单向</span><br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCla</span>;  <span class="hljs-comment">//every MyClass&lt;T&gt; is a friend of Friend</span><br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span> </span>&#123;&#125; <span class="hljs-comment">//every f&lt;T&gt; if a friend of Firend</span><br>	<span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Friend</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">data</span>(x) &#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;data; &#125;<br>&#125;;<br><span class="hljs-comment">//这样可以拿这个函数当公共函数访问私有成员</span><br>std::ostream &amp;<span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream &amp;out, <span class="hljs-type">const</span> Friend &amp;f) &#123;<br>	<span class="hljs-keyword">return</span> out &lt;&lt; f.data;<br>&#125;<br><span class="hljs-comment">//若发生继承关系, MyCla不是, Friend2 的好友.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Friend2</span> : <span class="hljs-keyword">public</span> Friend &#123; &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testFriend</span><span class="hljs-params">()</span> </span>&#123;<br>		Friend a = <span class="hljs-number">44</span>;<br>	cout &lt;&lt; a;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//goto</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testGoto</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>;<br>NO:<br>	<span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">5</span>) &#123;<br>		cout &lt;&lt; i;<br>		i ++;<br>		<span class="hljs-keyword">goto</span> NO;	<br>	&#125;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//inline</span><br><span class="hljs-comment">//尽量的减少栈空间开辟和回收操作</span><br><span class="hljs-comment">//类和模板函数,默认会加上inline进行优化.</span><br><span class="hljs-comment">//但不一定快</span><br><span class="hljs-comment">//inline 也可以与 namespace一起用， inline namespace</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">plus</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inline</span> &#123;<br>	<span class="hljs-comment">//在类中的函数里,编译器会默认加上inline进行优化</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello\n&quot;</span>; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vlaue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_value; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_value;<br>&#125;;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//namespace</span><br><span class="hljs-keyword">namespace</span> XGroup &#123;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">A_</span> &#123;<br>		<span class="hljs-type">int</span> value;	<br>	&#125;;<br>&#125;<br><span class="hljs-keyword">namespace</span> YGroup &#123;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">A_</span> &#123;<br>		<span class="hljs-type">int</span> value;	<br>	&#125;;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">B_</span> &#123;<br>		<span class="hljs-type">int</span> value;	<br>	&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNmaespace</span><span class="hljs-params">()</span> </span>&#123;<br>	XGroup::A_ a;	<br>	YGroup::A_ b;	<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNamespace2</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> XGroup;<br>	A_ a;<br>	<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> YGroup;<br>	B_ b; <span class="hljs-comment">//可以不用写 YGroup::B_</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNamespace3</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">namespace</span> CGroup = XGroup;	<br>	CGroup::A_ a;<br>	<span class="hljs-keyword">using</span> YGroup::B_;<br>	B_ b;<br>&#125;<br><span class="hljs-comment">//没有名字的namespace</span><br><span class="hljs-keyword">namespace</span> &#123;<br>	<span class="hljs-function">std::string <span class="hljs-title">astring</span><span class="hljs-params">(<span class="hljs-string">&quot;long&quot;</span>)</span></span>; <span class="hljs-comment">//相当于　static std::string astirng</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNamespace4</span><span class="hljs-params">()</span> </span>&#123;<br>	cout &lt;&lt; astring; <span class="hljs-comment">//打印astring</span><br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//noexcept</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">noexCept</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">//声明确定不会抛出异常,可以减轻编译器压力,利于优化代码.</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-comment">//std::terminate(); abort(); exit(0);</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">noexCept2</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span> </span>&#123; <span class="hljs-comment">//等价于没写</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nullPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t, U u)</span> </span>&#123;<br>	<span class="hljs-built_in">t</span>(u);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testNullPointer</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//三者直接调用,结果一样</span><br>	<span class="hljs-built_in">nullPointer</span>(<span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">nullPointer</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//(void*)0</span><br>	<span class="hljs-built_in">nullPointer</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//std::nullptr_t 在c++11中有专有的类型</span><br>	<span class="hljs-comment">//利用模板函数之后, NULL 模板函数推导为int</span><br>	<span class="hljs-built_in">func</span>(nullPointer, <span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-comment">//不能调用　</span><br><span class="hljs-comment">//	func(nullPointer, NULL);</span><br><span class="hljs-comment">//	func(nullPointer, 0);</span><br>	<span class="hljs-comment">//若想调用,需要强制转换　</span><br>	<span class="hljs-built_in">func</span>(nullPointer, (<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">func</span>(nullPointer, (<span class="hljs-type">int</span>*)<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//operator</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Operator</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Operator</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">data</span>(x) &#123; &#125;<br><span class="hljs-comment">//	operator int() const &#123; return this-&gt;data; &#125;</span><br>	<span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> &lt;&lt; (Operator <span class="hljs-type">const</span>&amp; o) <span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> data + o.data;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> &amp; () <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br>	<span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> data;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testOperator</span><span class="hljs-params">()</span> </span>&#123;<br>	Operator a = <span class="hljs-number">10</span>;<br>	Operator b = <span class="hljs-number">5</span>;<br>	Operator c = a &lt;&lt; b; <span class="hljs-comment">//实际实现相加</span><br>	cout &lt;&lt; &amp;c &lt;&lt; endl; <span class="hljs-comment">//采用去地址符号实现返回里面的值</span><br>&#125;<br><span class="hljs-comment">//实例应用:</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct AClass &#123;</span><br><span class="hljs-comment">	~AClass() &#123; delete m_value&#125;</span><br><span class="hljs-comment">	AClass() : m_value(new int()) &#123;&#125;</span><br><span class="hljs-comment">	private:</span><br><span class="hljs-comment">	int *m_value;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">void test() &#123;</span><br><span class="hljs-comment">	Aclass A;</span><br><span class="hljs-comment">	Aclass B;</span><br><span class="hljs-comment">	A = B; //这种情况,里面的值m_value,会发生直接赋值,A和B直接指向同一块内存,</span><br><span class="hljs-comment">	//会发生两次析构,内存会错误.</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">&#125; */</span><br><span class="hljs-comment">//使用操作符重载 = 来避免:</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AClass</span> &#123;<br>	~<span class="hljs-built_in">AClass</span>() &#123; <span class="hljs-keyword">delete</span> m_value;&#125;<br>	<span class="hljs-built_in">AClass</span>(<span class="hljs-type">const</span> AClass&amp; rhs) : <span class="hljs-built_in">m_value</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(rhs.m_value))) &#123;&#125;<br>	AClass&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> AClass&amp; rhs) &#123;<br>		*m_value = *(rhs.m_value);<br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> *m_value;<br>&#125;;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//reinterpret_cast</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testReinterpret_cast</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//reinterpret_cast</span><br>	<span class="hljs-comment">//static_cast</span><br>	<span class="hljs-comment">//const_cast</span><br>	<span class="hljs-comment">//dynamic_cast</span><br>	<span class="hljs-comment">//c like cast　可以实现以上的大部分, 而dynamic_cast c语言这种方式不能实现的</span><br><br>	<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">// 也相当于 char* p = (char*)&amp;a;</span><br>	<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(&amp;a); <span class="hljs-comment">//转化为char*</span><br>	<span class="hljs-comment">//不能char* b = static_cast&lt;char*&gt; &amp;b;</span><br>	<span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;the system is little endian\n&quot;</span>;<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;the system is big endian\n&quot;</span>;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//sizeof, before c++11</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SizeofEmpty</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SizeofBase</span> &#123; <span class="hljs-type">int</span> a;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SizeofDerived</span> : Base&#123; <span class="hljs-type">int</span> b;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SizeofBit</span> &#123;<span class="hljs-type">unsigned</span> bit : <span class="hljs-number">1</span>;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testSizeof</span><span class="hljs-params">()</span> </span>&#123;<br>	SizeofEmpty e;<br>	SizeofDerived d;<br>	SizeofBase b;<br>	SizeofBit bit;<br>	cout &lt;&lt; <span class="hljs-string">&quot;sizeof empty: &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span> e &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;sizeof derived: &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span> d &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;sizeof base: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(b) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;sizeof bit: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(SizeofBit) &lt;&lt; endl;<br><span class="hljs-comment">//	cout &lt;&lt; &quot;szieof void&quot; &lt;&lt; sizeof(void) &lt;&lt; endl;</span><br><span class="hljs-comment">//	cout &lt;&lt; &quot;szieof int[]&quot; &lt;&lt; sizeof(int[]) &lt;&lt; endl;</span><br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//static</span><br><span class="hljs-comment">//最好要这么用</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalA = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> localStatic = <span class="hljs-number">0</span>; <span class="hljs-comment">//多线程不要这么用</span><br>	++ localStatic;<br>	cout &lt;&lt; <span class="hljs-string">&quot;globalA: &quot;</span> &lt;&lt; globalA &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;localStatic: &quot;</span> &lt;&lt; localStatic &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Static</span> &#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> s; <span class="hljs-comment">//注意: sizeof(Static) == 1, s的空间已经分配</span><br>&#125;;<br><span class="hljs-type">int</span> Static::s = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HeHe</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Static2</span> &#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> a[];<br>	<span class="hljs-type">static</span> HeHe foo;<br>	<span class="hljs-type">static</span> Static2 ss;<br>&#125;;<br><span class="hljs-comment">//对成员进行实例化</span><br><span class="hljs-type">int</span> Static2::a[<span class="hljs-number">10</span>];<br>HeHe Static2::foo;<br>Static2 Static2::ss;<br><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//static_assert c++11的一个宏, 在编译期进行检测</span><br><span class="hljs-comment">//assert 是在运行的时候进行检测</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testStaticAssert</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) == <span class="hljs-number">4</span>, <span class="hljs-string">&quot;only work for int of 32bit&quot;</span>);<br>	<span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>),<br>			<span class="hljs-string">&quot;only work for int of 32bit&quot;</span>);<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">//判断变量 a == b 采用assert</span><br>	<span class="hljs-type">int</span> b = <span class="hljs-number">5</span>;<br>	<span class="hljs-built_in">assert</span>(a != b &amp;&amp; <span class="hljs-string">&quot;error&quot;</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">static_assertFun</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">alignof</span>(T) ==<span class="hljs-number">4</span>, <span class="hljs-string">&quot;only for alignof 4&quot;</span>);<br>&#125;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//typedef , 换名称</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ulong;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comp</span> &#123;<br>	<span class="hljs-keyword">typedef</span> std::map&lt;<span class="hljs-type">int</span>, ulong&gt; Group;<br>	Group a; <span class="hljs-comment">//相当于 std::map&lt;int, ulong&gt; a;</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aa</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//std::map&lt;int, ulong&gt;::iterator iter = a.find(10)</span><br>		Group::iterator iter = a.<span class="hljs-built_in">find</span>(<span class="hljs-number">10</span>);<br>		<span class="hljs-comment">//也可以使用: auto iter = a.fine(10);</span><br>	&#125;<br>&#125;;<br><span class="hljs-comment">//---------------------------------------------------------------</span><br><span class="hljs-comment">//using </span><br><span class="hljs-comment">//可以使用与namespace,也可以替换typedef</span><br><span class="hljs-keyword">using</span> newGroup = std::map&lt;<span class="hljs-type">int</span>, ulong&gt;;<br><br><span class="hljs-comment">//using namespace std;</span><br><br><span class="hljs-comment">//---------------------------------------------------------------</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-comment">//	showAuto();</span><br><span class="hljs-comment">//	showBitAndOr();</span><br><span class="hljs-comment">//	showAsm();</span><br><span class="hljs-comment">//	testAnd_eq();</span><br><span class="hljs-comment">//	testNot();</span><br><span class="hljs-comment">//	testNot_eq();</span><br><span class="hljs-comment">//	testBool();</span><br><span class="hljs-comment">//	testBreak();</span><br><span class="hljs-comment">//	testCompl();</span><br><span class="hljs-comment">//	testConstExpr();</span><br><span class="hljs-comment">//	testConst_cast();</span><br><span class="hljs-comment">//	testDecltype();</span><br><span class="hljs-comment">//	testDynamic_cast();</span><br><span class="hljs-comment">//	testOldEnum();</span><br><span class="hljs-comment">//	testNewEnum();</span><br><span class="hljs-comment">//	testExplicit();</span><br><span class="hljs-comment">//	testFriend();</span><br><span class="hljs-comment">//	testGoto();</span><br><span class="hljs-comment">//	testNamespace4();</span><br><span class="hljs-comment">//	testOperator();</span><br><span class="hljs-comment">//	testReinterpret_cast();</span><br><span class="hljs-comment">//	testSizeof();</span><br>	<span class="hljs-built_in">testStaticAssert</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="C-析构函数中抛出异常问题"><a href="#C-析构函数中抛出异常问题" class="headerlink" title="C++析构函数中抛出异常问题"></a>C++析构函数中抛出异常问题</h3><p>注意: 不要在析构函数中抛出异常 </p>
<h3 id="析构函数调用规则"><a href="#析构函数调用规则" class="headerlink" title="析构函数调用规则"></a>析构函数调用规则</h3><ol>
<li>先调用成员析构</li>
<li>再调用派生类析构</li>
</ol>
<h3 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h3><p>分析代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">A</span>() &#123;&#125;<br>		~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A析构了..&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-comment">//析构函数绝对不要抛出异常</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">B</span>() &#123;&#125;<br>		~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B析构了.. &quot;</span> &lt;&lt; std::endl; <br>		<span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;B error&quot;</span>); &#125; <span class="hljs-comment">// 编译器默认析构函数: inline ~B() noexcept &#123;&#125;</span><br>	<span class="hljs-comment">//编译器默认析构函数实现:</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		inline ~B() noexcept &#123;</span><br><span class="hljs-comment">			try &#123;</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			&#125; catch(...) &#123;</span><br><span class="hljs-comment">				std::terminate();	</span><br><span class="hljs-comment">				//析构函数绝对不要抛出异常</span><br><span class="hljs-comment">			&#125;</span><br><span class="hljs-comment">		&#125; </span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span>:<br>		std::string m_value;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			在掉~B() 析构时候, 先调用 m_value的析构,再调用派生类 ~A();</span><br><span class="hljs-comment">		 */</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testClass_1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//测试析构</span><br>	B *b = <span class="hljs-keyword">new</span> B;<br>	<span class="hljs-keyword">delete</span> b;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilB</span> : <span class="hljs-keyword">public</span> B &#123;<br>	<span class="hljs-keyword">public</span>:<br>		~<span class="hljs-built_in">EvilB</span>() <span class="hljs-built_in">noexcept</span>(<span class="hljs-literal">false</span>) &#123; <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;error&quot;</span>); &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testEvilB</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">try</span> &#123;<br>		EvilB *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EvilB</span>();	<br>		<span class="hljs-keyword">delete</span> b;<br>		<br>	&#125; <span class="hljs-built_in">catch</span>(std::string e) &#123;<br>		<span class="hljs-comment">//没有捕获到异常,编译器已经调用std::terminate(),且程序崩溃</span><br>		<span class="hljs-comment">//因为编译器为析构函数默认加入关键字 noexcept,可以加入关键字 noexcept(false) </span><br>		<span class="hljs-comment">//问题1 : 派生类虽然能够析构,若派生类析构函数也抛出异常,则程序就挂.</span><br>		<span class="hljs-comment">//出现抛出两个异常, 则无法捕获.</span><br>		<span class="hljs-comment">//问题2 : 若声明两次EvilB对象,析构两次时,则程序就会崩溃.</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;catch your evil: &quot;</span> &lt;&lt; e &lt;&lt;  std::endl;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">testEvilB</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h3><p>建议: 在类的构造函数中抛出异常 </p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">B</span>() &#123;&#125;<br>		~<span class="hljs-built_in">B</span>() &#123; <span class="hljs-comment">/*std::cout &lt;&lt; &quot;byebye B\n&quot;;*/</span> &#125;<br>	<span class="hljs-keyword">private</span>:<br>		std::string m_value;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodB</span> : <span class="hljs-keyword">public</span> B &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">GoodB</span>() : <span class="hljs-built_in">m_v</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(<span class="hljs-number">10000000</span>)) &#123;&#125;<br>		<span class="hljs-built_in">GoodB</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* f) : <span class="hljs-built_in">m_file</span>(f, std::ios_base::in) &#123;<br>			<span class="hljs-comment">//在构造器里进行抛出异常,而不是一直判断是否有错误来避免错误.</span><br>			<span class="hljs-keyword">if</span>(!m_file.<span class="hljs-built_in">is_open</span>()) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Couldn&#x27;t open file..\n&quot;</span>);<br><br>			std::string line;	<br>			<span class="hljs-keyword">while</span>(std::<span class="hljs-built_in">getline</span>(m_file, line)) &#123;<br>				m_info.<span class="hljs-built_in">push_back</span>(line);<br>			&#125;<br>		&#125;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doIt</span><span class="hljs-params">( GoodB <span class="hljs-type">const</span>&amp;b)</span> </span>&#123;<br>			<span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">isOpen</span>()) &#123;<br>				<span class="hljs-comment">//do	</span><br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//通过析构来提示.</span><br>		~<span class="hljs-built_in">GoodB</span>() &#123; <span class="hljs-built_in">assert</span>((!<span class="hljs-built_in">isOpen</span>()) &amp;&amp; <span class="hljs-string">&quot;open file: &quot;</span>); &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">char</span> *m_v;<br>		std::fstream m_file; <span class="hljs-comment">//外部文件 </span><br>		std::vector&lt;std::string&gt; m_info;<br>		<span class="hljs-comment">//若作为状态判断,一般声明为私有函数, 通过assert来提示.</span><br>		<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> !m_info.<span class="hljs-built_in">empty</span>(); &#125;<br>&#125;;<br><span class="hljs-comment">//循环构造, 内存崩溃</span><br><span class="hljs-comment">//想实现一个 std::out_of_memory 异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(;;) &#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			++i;	<br>			<span class="hljs-keyword">if</span>(i % <span class="hljs-number">10000</span> == <span class="hljs-number">0</span>) std::cout &lt;&lt; <span class="hljs-string">&quot;count i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>			GoodB b;	<br>		&#125; <span class="hljs-built_in">catch</span>(...) &#123;<br>			<span class="hljs-keyword">return</span> ;	<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename)</span> </span>&#123;<br>	<span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//在构造时候进行抛出异常,重复抛出, 不会出现问题, 而在析构函数中抛出,程序则会崩溃</span><br>		<span class="hljs-function">GoodB <span class="hljs-title">b</span><span class="hljs-params">(filename)</span></span>;<br>		<span class="hljs-function">GoodB <span class="hljs-title">d</span><span class="hljs-params">(filename)</span></span>;<br>		b.<span class="hljs-built_in">doIt</span>(b);<br>		<span class="hljs-comment">//std::swap(b, d) //也不要抛出异常</span><br>	&#125; <span class="hljs-built_in">catch</span>(std::string msg) &#123;<br>		std::cout &lt;&lt; msg;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(argc &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">//	test();</span><br>	<span class="hljs-built_in">test2</span>(argv[<span class="hljs-number">1</span>]);<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;exit!!!\n&quot;</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="管理内存的几种方式"><a href="#管理内存的几种方式" class="headerlink" title="管理内存的几种方式"></a>管理内存的几种方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">versionOne</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">versionTwo</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br>	<span class="hljs-built_in">versionOne</span>();<br>	<span class="hljs-built_in">versionTwo</span>();<br>	<span class="hljs-built_in">versionThree</span>();<br>	<span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">versionOne</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//c语言方式开辟内存</span><br>	<span class="hljs-type">int</span> *ageC = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>	<span class="hljs-keyword">if</span>(argC) &#123;<br>		<span class="hljs-built_in">free</span>(ageC);<br>	&#125;<br>	<span class="hljs-type">char</span> *c = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>	<span class="hljs-built_in">free</span>(c);<br><br>	<span class="hljs-comment">//c++ 开辟内存方式</span><br>	<span class="hljs-type">int</span> *age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">25</span>);<br>	<span class="hljs-type">int</span> *height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">160</span>);<br>	<span class="hljs-comment">//缺陷,容易忘掉free 或 delete</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">versionTow</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//智能指针</span><br>	<span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">age</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">28</span>))</span></span>;<br>	<span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">height</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">160</span>))</span></span>;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;VersionTwo: you age is &quot;</span> &lt;&lt; *age &lt;&lt; <span class="hljs-string">&quot;, and your height is &quot;</span><br>		&lt;&lt; *height &lt;&lt; std::endl;<br>	<span class="hljs-comment">//不需要做任何事情, 内存会自动的释放掉</span><br>	<span class="hljs-comment">//基本上,不会造成内存泄露问题</span><br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="逐渐退化的虚函数"><a href="#逐渐退化的虚函数" class="headerlink" title="逐渐退化的虚函数"></a>逐渐退化的虚函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	类虚函数遇到构造和析构就退化了</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span>; <span class="hljs-comment">//类的前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125; <span class="hljs-comment">//why? virtual</span><br>		<span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> _id) : <span class="hljs-built_in">m_id</span>(_id) &#123;&#125;<br>		<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(Event <span class="hljs-type">const</span>&amp;)</span> </span>= <span class="hljs-number">0</span>;<br>		<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_id; &#125; <br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_id;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drived</span> : <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-comment">//why public?</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span> <span class="hljs-params">(Event <span class="hljs-type">const</span>&amp;)</span></span>;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>		<span class="hljs-built_in">Drived</span>(<span class="hljs-type">int</span> id);<br>		~<span class="hljs-built_in">Drived</span>();<br>	<span class="hljs-keyword">private</span>:<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Grouped</span> : <span class="hljs-keyword">public</span> Base &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(Event <span class="hljs-type">const</span>&amp;)</span></span>;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addBase</span><span class="hljs-params">(Base* b)</span></span>;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeBase</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<br>		<span class="hljs-built_in">Grouped</span>(<span class="hljs-type">int</span> id);<br>		~<span class="hljs-built_in">Grouped</span>();<br>	<span class="hljs-keyword">private</span>:<br>		std::map&lt;<span class="hljs-type">int</span>, Base *&gt; m_info;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//int a = 1;</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	Drived *info = new Drived(1);	</span><br><span class="hljs-comment">	Grouped *group = new Grouped();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	group-&gt;print();</span><br><span class="hljs-comment">	group-&gt;act(ev);</span><br><span class="hljs-comment">	group-&gt;addBase(info);</span><br><span class="hljs-comment">	group-&gt;removeBase(info-&gt;id());</span><br><span class="hljs-comment">	group-&gt;id();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	Base *baseGroup = group;</span><br><span class="hljs-comment">	baseGroup-&gt;act(ev);</span><br><span class="hljs-comment">	baseGroup-&gt;print();</span><br><span class="hljs-comment">	baseGroup-&gt;id();</span><br><span class="hljs-comment">	//removeBase()</span><br><span class="hljs-comment">	//addBase()</span><br><span class="hljs-comment">	//而基类的指针baseGroup中强制把派生类转换,而基类在虚函数中干的事,与派生类的一样</span><br><span class="hljs-comment">	//相当于派生类来实现函数,而不是基类.这就实现了指针对接口进行编程.</span><br><span class="hljs-comment">	delete group; //delete baseGroup;没有内存泄露,　与delete group等价</span><br><span class="hljs-comment">	delete info;</span><br><span class="hljs-comment">	*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">test</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="虚函数几种实现方法"><a href="#虚函数几种实现方法" class="headerlink" title="虚函数几种实现方法"></a>虚函数几种实现方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; std::endl; &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>	<span class="hljs-built_in">Base</span>() &#123;<br>		<span class="hljs-built_in">init</span>();	<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base &#123; <span class="hljs-comment">//结构体默认为public 继承, 类默认为 private</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">//加入override关键字,表示重写基类的f()虚函数</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;derived overide&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;virtual init&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125; ;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived2</span> : Derived &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function">Base* <span class="hljs-title">factoryBase</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> </span>&#123;<br>	Base* ret = <span class="hljs-literal">nullptr</span>;<br>	<span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>) &#123;<br>		ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();	<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>) &#123;<br>		ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();	<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">2</span>) &#123;<br>		ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived2</span>();	<br>	&#125;<br><br>	<span class="hljs-keyword">if</span>(ret) ret-&gt;<span class="hljs-built_in">init</span>();<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testVirtual</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//Base b;</span><br>	<span class="hljs-comment">//Derived d;</span><br>	<span class="hljs-comment">////虚函数调用通过引用</span><br>	<span class="hljs-comment">////virtual funciton call through reference</span><br>	<span class="hljs-comment">//Base&amp; br = b;  //the type of br is Base&amp;</span><br>	<span class="hljs-comment">//Base&amp; dr = d;  //the type of dr is Base&amp; as well</span><br>	<span class="hljs-comment">//br.f();</span><br>	<span class="hljs-comment">//dr.f(); //在Derived类中已经对fun() 重写.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">////虚函数调用通过指针</span><br>	<span class="hljs-comment">////virtual function call through pointer</span><br>	<span class="hljs-comment">//Base* bp = &amp;b;</span><br>	<span class="hljs-comment">//Base* dp = &amp;d;</span><br>	<span class="hljs-comment">//bp-&gt;f();</span><br>	<span class="hljs-comment">//dp-&gt;f();</span><br><br>	<span class="hljs-comment">////直接调用.</span><br>	<span class="hljs-comment">////non-virtual function call</span><br>	<span class="hljs-comment">//b.Base::f();</span><br>	<span class="hljs-comment">//d.Derived::f(); //派生类</span><br>	<span class="hljs-comment">//d.Base::f(); //基类</span><br>	<span class="hljs-comment">////若在构造函数中或者析构函数中调用虚函数, 则会调用自身类中的虚函数,而不是派生类的重写的虚函数</span><br>	<span class="hljs-comment">////虚函数特性还没体现</span><br>	Derived d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">testVirtual</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>() &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;A\n&quot;</span>;<br>	&#125;<br>	~<span class="hljs-built_in">A</span>() &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;~A\n&quot;</span>;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	A a;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>生成可执行文件ida反编译如下:</p>
<p>main</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+8h] [rbp-18h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  A::<span class="hljs-built_in">A</span>((A *)v4);<br>  A::~<span class="hljs-built_in">A</span>((A *)v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>A::A()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> __fastcall <span class="hljs-title">A::A</span><span class="hljs-params">(A *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  *(_DWORD *)<span class="hljs-keyword">this</span> = <span class="hljs-number">1</span>;<br>  *((_DWORD *)<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>) = <span class="hljs-number">2</span>;<br>  std::<span class="hljs-keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="hljs-type">char</span>&gt;&gt;(&amp;std::cout, &amp;unk_2005);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>A::~A()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> __fastcall A::~<span class="hljs-built_in">A</span>(A *<span class="hljs-keyword">this</span>)<br>&#123;<br>  std::<span class="hljs-keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="hljs-type">char</span>&gt;&gt;(&amp;std::cout, &amp;unk_2008);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>this指针即是堆栈上数据v4的地址。</p>
<h3 id="在堆区上的普通对象"><a href="#在堆区上的普通对象" class="headerlink" title="在堆区上的普通对象"></a>在堆区上的普通对象</h3><p>source</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A\n&quot;</span>;&#125;<br>	~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;~A\n&quot;</span>;&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;test\n&quot;</span>;&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	A *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>	a-&gt;<span class="hljs-built_in">test</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>生成可执行文件ida反编译如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  A *v3; <span class="hljs-comment">// rbx</span><br><br>  v3 = (A *)<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-number">8uLL</span>);<br>  A::<span class="hljs-built_in">A</span>(v3);<br>  A::<span class="hljs-built_in">test</span>(v3);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>A::A()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> __fastcall <span class="hljs-title">A::A</span><span class="hljs-params">(A *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  *(_DWORD *)<span class="hljs-keyword">this</span> = <span class="hljs-number">1</span>;<br>  *((_DWORD *)<span class="hljs-keyword">this</span> + <span class="hljs-number">1</span>) = <span class="hljs-number">2</span>;<br>  std::<span class="hljs-keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="hljs-type">char</span>&gt;&gt;(&amp;std::cout, &amp;unk_2005);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>与堆栈上的差不多， 堆栈上的对象不用管内存泄漏问题，编译器调用析构函数，开辟在堆区的对象由于没有delete a，所有没有析构函数调用和内存的释放，出现内存泄漏。</p>
<h3 id="拥有vital-function"><a href="#拥有vital-function" class="headerlink" title="拥有vital function"></a>拥有vital function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>() &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;A\n&quot;</span>;<br>	&#125;<br>	~<span class="hljs-built_in">A</span>() &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;~A\n&quot;</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vir_1</span><span class="hljs-params">()</span> </span>&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;vir_1 A\n&quot;</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vir_2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">B</span>() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;B\n&quot;</span>;&#125;	<br>	~<span class="hljs-built_in">B</span>() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;~B\n&quot;</span>;&#125;	<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vir_2</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">4</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	B a;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 生成可执行文件ida反编译如下:</p>
<p>main</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">24</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-30h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+18h] [rbp-18h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  B::<span class="hljs-built_in">B</span>((B *)v4);<br>  B::~<span class="hljs-built_in">B</span>((B *)v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>B::B()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> __fastcall <span class="hljs-title">B::B</span><span class="hljs-params">(B *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  A::<span class="hljs-built_in">A</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//先构造父类</span><br>  *(_QWORD *)<span class="hljs-keyword">this</span> = off_3D68; <span class="hljs-comment">// 3D68这个位置就是B类的虚函数表,将B类的虚函数表赋给this指针指向的第一个内存块</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    .data.rel.ro:0000000000003D68 off_3D68        dq offset _ZN1A5vir_1Ev ; DATA XREF: B::B(void)+19↑o</span><br><span class="hljs-comment">	.data.rel.ro:0000000000003D68                                         ; B::~B()+C↑o</span><br><span class="hljs-comment">	.data.rel.ro:0000000000003D68                                         ; A::vir_1(void)</span><br><span class="hljs-comment">	.data.rel.ro:0000000000003D70                 dq offset _ZN1B5vir_2Ev ; B::vir_2(void)</span><br><span class="hljs-comment">    */</span><br>  *((_DWORD *)<span class="hljs-keyword">this</span> + <span class="hljs-number">4</span>) = <span class="hljs-number">4</span>;<br>  std::<span class="hljs-keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="hljs-type">char</span>&gt;&gt;(&amp;std::cout, <span class="hljs-string">&quot;B\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>A::A()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> __fastcall <span class="hljs-title">A::A</span><span class="hljs-params">(A *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  *(_QWORD *)<span class="hljs-keyword">this</span> = &amp;off_3D88; <span class="hljs-comment">// 3D88是A类的虚函数表</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    .data.rel.ro:0000000000003D88 off_3D88        dq offset _ZN1A5vir_1Ev ; DATA XREF: A::A(void)+C↑o</span><br><span class="hljs-comment">	.data.rel.ro:0000000000003D88                                         ; A::~A()+C↑o</span><br><span class="hljs-comment">	.data.rel.ro:0000000000003D88                                         ; A::vir_1(void)</span><br><span class="hljs-comment">    */</span><br>  std::<span class="hljs-keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="hljs-type">char</span>&gt;&gt;(&amp;std::cout, &amp;unk_2005);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>B::~B() </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> __fastcall B::~<span class="hljs-built_in">B</span>(B *<span class="hljs-keyword">this</span>)<br>&#123;<br>  *(_QWORD *)<span class="hljs-keyword">this</span> = off_3D68; <span class="hljs-comment">//析构时再次赋予虚函数表</span><br>  std::<span class="hljs-keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="hljs-type">char</span>&gt;&gt;(&amp;std::cout, <span class="hljs-string">&quot;~B\n&quot;</span>);<br>  A::~<span class="hljs-built_in">A</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>A::~A()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">void</span> __fastcall A::~<span class="hljs-built_in">A</span>(A *<span class="hljs-keyword">this</span>)<br>&#123;<br>  *(_QWORD *)<span class="hljs-keyword">this</span> = &amp;off_3D88; <span class="hljs-comment">//析构时再次赋予虚函数表</span><br>  std::<span class="hljs-keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="hljs-type">char</span>&gt;&gt;(&amp;std::cout, &amp;unk_2008);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由以上看类中的内容是储存在ptr + 1之后的，第一个用于储存虚函数表的地址。</p>
<p>ref: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/qg-whz/p/4909359.html">https://www.cnblogs.com/qg-whz/p/4909359.html</a></p>
<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><h3 id="C-98-类的基本三大原则"><a href="#C-98-类的基本三大原则" class="headerlink" title="C++98 类的基本三大原则"></a>C++98 类的基本三大原则</h3><ol>
<li>类的构造</li>
<li>类的析构</li>
<li>类的复制</li>
</ol>
<p>若c++98中,不想复制的话,把构造函数设为私有变量, 并不实现构造函数<br>不然编译器会自动生成一个对应的构造函数</p>
<h3 id="C-11-类的基本五大原则"><a href="#C-11-类的基本五大原则" class="headerlink" title="C++11 类的基本五大原则"></a>C++11 类的基本五大原则</h3><p>前面三点基于c++98，增加了两个原则</p>
<ol start="4">
<li>5 可以对拷贝构造函数和operator&#x3D;进行右值引用进行重载</li>
</ol>
<p>也就是采用左值或者右值进行构造,编译器会对不同的构造函数进行构造.</p>
<p>代码例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleOfFive</span>;  <span class="hljs-comment">//前置声明class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Child</span><span class="hljs-params">(Parent *p)</span> : m_parent(p) &#123;</span>&#125;<br>	<span class="hljs-keyword">private</span>:<br>		Parent *m_parent;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-comment">//                           等同于: m_children.push_back(child)</span><br>		<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">addChild</span><span class="hljs-params">(Child* child)</span> </span>&#123;m_children.<span class="hljs-built_in">emplace_back</span>(child); &#125;<br>	<span class="hljs-keyword">private</span>:<br>		std::vector&lt;Child*&gt; m_children;<br><br>&#125;;<br><span class="hljs-comment">//若c++98中,不想复制的话,把构造函数设为私有变量, 并不实现构造函数</span><br><span class="hljs-comment">//不然编译器会自动生成一个对应的构造函数</span><br><span class="hljs-comment">//c++11 中: RuleOfThree(const RuleOfThree&amp; other) = delete;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleOfThree</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">RuleOfThree</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg) : <span class="hljs-built_in">cstring</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(arg) + <span class="hljs-number">1</span>])&#123; <span class="hljs-comment">//allocate</span><br>			std::<span class="hljs-built_in">strcpy</span>(cstring, arg); <span class="hljs-comment">//populate	</span><br>		&#125;<br>		~<span class="hljs-built_in">RuleOfThree</span>() &#123;<br>			<span class="hljs-keyword">delete</span>[] cstring;	<br>		&#125;<br>		<span class="hljs-comment">//c++ 11中,声明该构造不能用, 以防编译器自动生成一个构造函数</span><br>		<span class="hljs-built_in">RuleOfThree</span>(<span class="hljs-type">const</span> RuleOfThree&amp; other)  = <span class="hljs-keyword">delete</span>;<br>		<span class="hljs-comment">//	&#123;//copy constructor</span><br>		<span class="hljs-comment">//		cstring = new char[std::strlen(other.cstring) + 1];</span><br>		<span class="hljs-comment">//		std::strcpy(cstring, other.cstring);</span><br>		<span class="hljs-comment">//	&#125;</span><br>		RuleOfThree&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> RuleOfThree&amp; other) &#123;<br>			<span class="hljs-type">char</span> *tmp_cstring = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(other.cstring) + <span class="hljs-number">1</span>];	<br>			std::<span class="hljs-built_in">strcpy</span>(tmp_cstring, other.cstring);<br>			<span class="hljs-keyword">delete</span>[] cstring;<br>		&#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">char</span>* cstring;<br><br>&#125;;<br><span class="hljs-comment">//c++11</span><br><span class="hljs-comment">//类的５大基本原则:</span><br><span class="hljs-comment">//采用左值或者右值进行构造,编译器会对不同的构造函数进行构造.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleOfFive</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-comment">//只能针对与右值进行构造</span><br>		<span class="hljs-built_in">RuleOfFive</span>(RuleOfFive&amp;&amp; rhs) &#123;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;右值构造..&quot;</span> &lt;&lt; std::endl;<br>			std::cout &lt;&lt; rhs.m_value;<br>			m_value = rhs.m_value;<br>			rhs.m_value = <span class="hljs-literal">nullptr</span>;<br>		&#125;;<br>		<span class="hljs-built_in">RuleOfFive</span>() : <span class="hljs-built_in">m_value</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) ) &#123;&#125;<br>		<span class="hljs-comment">//采用右值或者左值进行构造</span><br>		<span class="hljs-built_in">RuleOfFive</span>(<span class="hljs-type">const</span> RuleOfFive &amp;rhs) : <span class="hljs-built_in">m_value</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(* (rhs.m_value))) &#123;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;左值或者右值构造..&quot;</span> &lt;&lt; std::endl;<br>		&#125;<br>		RuleOfFive&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> RuleOfFive &amp;rhs) &#123;<br>			<span class="hljs-keyword">delete</span> m_value; <span class="hljs-comment">//删掉以前的</span><br>			*m_value = *(rhs.m_value);<br>			<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>		&#125;<br>		<span class="hljs-comment">//对= 操作符进行右值重载</span><br>		RuleOfFive&amp; <span class="hljs-keyword">operator</span>=(RuleOfFive&amp;&amp; rhs) &#123;<br>			m_value = rhs.m_value;	<br>			rhs.m_value = <span class="hljs-literal">nullptr</span>;<br>			<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>		&#125;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>			<span class="hljs-built_in">assert</span>(m_value &amp;&amp; <span class="hljs-string">&quot;class print: &quot;</span>); <span class="hljs-comment">//不推荐使用if来判断</span><br>			std::cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; *m_value &lt;&lt; std::endl;<br>		&#125;<br>		~<span class="hljs-built_in">RuleOfFive</span>() &#123; <span class="hljs-keyword">delete</span> m_value; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> *m_value;<br>&#125;;<br><span class="hljs-comment">//左值和右值的定义:</span><br><span class="hljs-comment">//1. 能够取到地址的值称为左值,否则为右值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leftOrRight</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> b;<br>	<span class="hljs-type">int</span> c = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br>	<span class="hljs-type">int</span> d = a + c;<br>	<span class="hljs-keyword">auto</span> address = &amp;a;<br>	<span class="hljs-comment">//auto address2 = &amp;(2 + 3);</span><br>	<span class="hljs-type">int</span>&amp; e = a; <span class="hljs-comment">//左值引用</span><br>	<span class="hljs-comment">//int&amp; e2 = 3; //错误</span><br>	<span class="hljs-type">int</span>&amp;&amp; e3 = <span class="hljs-number">3</span>; <span class="hljs-comment">//右值引用.</span><br>&#125;<br><span class="hljs-comment">//c++11增加了左值和右值的概念, 所以类的从３大基本原则变为了5大基本原则</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leftAndRight</span><span class="hljs-params">()</span> </span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; a; <span class="hljs-comment">//left</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) a.<span class="hljs-built_in">push_back</span>(i);<br>	<span class="hljs-keyword">auto</span> b = a; <span class="hljs-comment">//b as left value</span><br>	<span class="hljs-keyword">auto</span> &amp;c = b; <span class="hljs-comment">//c as left value</span><br>	<span class="hljs-comment">//std::vector&lt;int&gt;&amp; c = b; //c as left value</span><br>	<span class="hljs-comment">//move函数啥也不干,就是让编译器把b转换为右值.</span><br>	<span class="hljs-keyword">auto</span> d = std::<span class="hljs-built_in">move</span>(b);<span class="hljs-comment">//std::move(b) 就为右值了</span><br>	RuleOfFive f;<br>	<span class="hljs-function">RuleOfFive <span class="hljs-title">g</span><span class="hljs-params">(f)</span></span>; <span class="hljs-comment">//左值构造</span><br>	<span class="hljs-function">RuleOfFive <span class="hljs-title">h</span> <span class="hljs-params">(std::move(f))</span></span>; <span class="hljs-comment">//右值构造, f已经毫无意义</span><br><span class="hljs-comment">//	f.print(); //m_value 已经为nullptr</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">leftAndRight</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL 是一个框架, 将数据结构和算法进一步的抽象, 包含了容器, 迭代器, 算法<br>容器: 储存数据的</p>
<p>迭代器: 容器之间统一的一个查询元素接口，可以用来遍历容器的元素</p>
<p>算法:  查找, 排序, 修改…</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>1 序列式容器 array &#x2F; vector &#x2F; deque&#x2F;list &#x2F; forward_list		 一般实现方式: 数组 ,指针 链表<br>2 关联类有序容器 set &#x2F; map &#x2F; multiset &#x2F; multimap               实现方式: 二叉树, 红黑树<br>3 关联类无序容器 unordered_map &#x2F; unordered_set &#x2F; unordered_multimap &#x2F; unordered_multiset		实现方式: hash table, 哈希表<br>4 其他容器: stack &#x2F; queue &#x2F; priority_queue &#x2F; string &#x2F; bitset (存储对或错)</p>
<p>新型: regex (正则表达式), 增强了 rand算法, thread(线程), async, furture, time</p>
<h3 id="容器内元素的条件"><a href="#容器内元素的条件" class="headerlink" title="容器内元素的条件"></a>容器内元素的条件</h3><ol>
<li>必须可以复制(copy) 或则搬移(move) (隐含的条件是在拷贝和搬移的过程中应该没有副作用) </li>
<li>c++ 的基本类型满足以上要求: bool char int int* char*, reference</li>
<li>元素必须可以被赋值操作,来作为复制或者搬移, (因为容器和算法对复写有要求)</li>
<li>元素可以被销毁</li>
</ol>
<p>针对于不同的容器还有特殊的要求</p>
<ol>
<li>对于序列式容器, 元素必须有默认的构造函数</li>
<li>对于某些操作,元素需要定义 &#x3D;&#x3D;</li>
<li>对于关联式容器, 排序默认准则的是 &lt; </li>
<li>无顺序容器,必须要提供一个hash函数</li>
</ol>
<p>stl容器里面存的是元素的值而不是引用，到底我们的容器里面应该存的东西是什么呢?</p>
<p>STL对于错误怎么处理<br>我们要记住的是STL的设计原则是: 效率优先, 安全为次<br>异常? STL自己却不怎么用</p>
<p>实例代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-comment">//多数容器共有的接口:</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">containerAllInterface</span><span class="hljs-params">(T &amp;a, T &amp;b)</span> </span>&#123;<br>	T c;<br>	<span class="hljs-function">T <span class="hljs-title">d</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">//copy</span><br>	T e = a; <span class="hljs-comment">//copy</span><br>	T ee &#123;a&#125;; <span class="hljs-comment">//copy</span><br>	T eee = &#123;a&#125;; <span class="hljs-comment">//copy</span><br>	<span class="hljs-function">T <span class="hljs-title">f</span><span class="hljs-params">(std::move(a))</span></span>; <span class="hljs-comment">//move不是转化为右值,是移动数据</span><br>	<span class="hljs-comment">//new</span><br>	<span class="hljs-keyword">auto</span> iterB = b.<span class="hljs-built_in">begin</span>();<br>	<span class="hljs-keyword">auto</span> iterE = b.<span class="hljs-built_in">end</span>();<br>	<span class="hljs-comment">//old</span><br>	<span class="hljs-keyword">typename</span> T::iterator iterF = b.<span class="hljs-built_in">begin</span>();<br><br>	<span class="hljs-function">T <span class="hljs-title">g</span><span class="hljs-params">(b.begin(), b.end())</span></span>; <span class="hljs-comment">//从开始的地方到结束的地方进行拷贝</span><br>	<span class="hljs-function">T <span class="hljs-title">g2</span><span class="hljs-params">(iterB, iterE)</span></span>; <span class="hljs-comment">//使用迭代器方式,一样</span><br><br><br>	b.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//std::forwad list 不提供size接口,绝大多数都有</span><br>	b.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">//return b.size() == 0;</span><br>	b.<span class="hljs-built_in">max_size</span>();<br>	<span class="hljs-keyword">if</span>(b == c) &#123;&#125; <span class="hljs-comment">//先比较数量, 再比较顺序</span><br>	<span class="hljs-keyword">if</span>(b != d) &#123;&#125; <span class="hljs-comment">//</span><br>	<span class="hljs-keyword">if</span>(b &lt; e) &#123;&#125;  <span class="hljs-comment">//unordered_set unordered_map .. 无顺序容器没有</span><br>	<span class="hljs-comment">// b &lt;= e	</span><br>	<span class="hljs-comment">// b &gt; e</span><br>	<span class="hljs-comment">// b &gt;= e</span><br>	<span class="hljs-comment">//赋值</span><br>	e = b;<br>	e = std::<span class="hljs-built_in">move</span>(b);<br><br>	e.<span class="hljs-built_in">swap</span>(g); <span class="hljs-comment">//交换容器所管理的资源, std::arrary 的交换为线性, O(n), 而其他是 O(1)</span><br>	<span class="hljs-comment">//所以其他容器交换很高效,除了array</span><br>	std::<span class="hljs-built_in">swap</span>(e, g); <span class="hljs-comment">//与以上一样</span><br><br>	e.<span class="hljs-built_in">cbegin</span>(); <span class="hljs-comment">//const_iterator, 返回const iterator的引用</span><br>	<span class="hljs-keyword">auto</span> ea = e.<span class="hljs-built_in">cbegin</span>();<br>	<span class="hljs-keyword">auto</span> eea = e.<span class="hljs-built_in">cbegin</span>();<br>	*eea; <span class="hljs-comment">//const &amp;, &amp;</span><br>	*ea; <span class="hljs-comment">// const &amp;</span><br>	e.<span class="hljs-built_in">cend</span>();<br>	e.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空容器的所有元素, 有一个容器没有. std::array</span><br>	<span class="hljs-comment">//就是调用所有元素的析构.</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_container</span><span class="hljs-params">()</span> </span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; a;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; b;<br>	containerAllInterface&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(a, b);<br><br>	std::list&lt;<span class="hljs-type">int</span>&gt; e;<br>	std::list&lt;<span class="hljs-type">int</span>&gt; f;<br>	containerAllInterface&lt;std::list&lt;<span class="hljs-type">int</span>&gt;&gt;(e, f);<br><br>	std::deque&lt;<span class="hljs-type">int</span>&gt; g;<br>	std::deque&lt;<span class="hljs-type">int</span>&gt; h;<br>	containerAllInterface&lt;std::deque&lt;<span class="hljs-type">int</span>&gt;&gt;(g, h);<br><br>	<span class="hljs-comment">//.......</span><br>	<span class="hljs-comment">//? array, forward_list, unordered_...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 是c++98中引入的动态数组(dynamic array)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std &#123;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator = allocator&lt;T&gt;&gt; <span class="hljs-comment">//就是用默认的alloctor了,</span><br>	<span class="hljs-keyword">class</span> vector;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特点</p>
<p>随机访问元素, 末端添加删除元素效率最高, 前端和中间删除和添加元素效率最低，存在当前容器大小和容量的关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-comment">//#include &lt;memory&gt;</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">vectorPart</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">using</span> Group = std::vector&lt;<span class="hljs-type">float</span>&gt;;<br>Group a;<br>Group b = a; <span class="hljs-comment">//拷贝构造</span><br><span class="hljs-function">Group <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">//拷贝构造</span><br><span class="hljs-function">Group <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//定义容量的大小</span><br><span class="hljs-function">Group <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1.0f</span>)</span></span>; <span class="hljs-comment">//10个初始化为1.0</span><br><span class="hljs-function">Group <span class="hljs-title">f</span><span class="hljs-params">(e.begin(), e.end())</span></span>; <span class="hljs-comment">//传入两个迭代器,中间的所有值都会被拷贝</span><br><span class="hljs-function">Group <span class="hljs-title">g</span><span class="hljs-params">(&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;)</span></span>; <span class="hljs-comment">//c++11, 把写好的元素直接填</span><br>Group h = &#123;<span class="hljs-number">1.1f</span>, <span class="hljs-number">2.1f</span>, <span class="hljs-number">3.1f</span>&#125;;<br>Group i &#123;<span class="hljs-number">1.2f</span>, <span class="hljs-number">2.2f</span>, <span class="hljs-number">3.2f</span>, <span class="hljs-number">4.2f</span>&#125;; <span class="hljs-comment">//initialize list</span><br><br>d.<span class="hljs-built_in">empty</span>();<br>d.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//当前的大小</span><br>d.<span class="hljs-built_in">max_size</span>(); <span class="hljs-comment">//max_size()相对于其他容器的要小一些</span><br>d.<span class="hljs-built_in">capacity</span>(); <span class="hljs-comment">//最多能在装入多少个元素,前提没有分配内存的情况下.</span><br>d.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//预先分配100个内存空间</span><br>d.<span class="hljs-built_in">shrink_to_fit</span>(); <span class="hljs-comment">//c++11 </span><br><br><span class="hljs-comment">//operator == != &lt; &gt; &lt;= &gt;=</span><br><br><span class="hljs-comment">//赋值</span><br>b = g;<br>b.<span class="hljs-built_in">assign</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1.0f</span>); <span class="hljs-comment">//代表重新分配元素为: &#123;1.0f, 1.0f, 1.0f&#125;</span><br>b.<span class="hljs-built_in">assign</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>b.<span class="hljs-built_in">assign</span>(&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;);<br><br><span class="hljs-comment">//交换: 交换给vector类中的指针,效率比较高</span><br>b.<span class="hljs-built_in">swap</span>(a);<br>std::<span class="hljs-built_in">swap</span>(a, b); <br><br><span class="hljs-comment">//元素访问:</span><br>b[<span class="hljs-number">0</span>];<br>b.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//越界抛出异常: std::out_of_range</span><br><span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">empty</span>()) &#123;<br>	b.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//一定要检查, 不然会出现错误, undefined</span><br>	b.<span class="hljs-built_in">back</span>();<br><br>&#125;<br>b.<span class="hljs-built_in">front</span>();<br>b.<span class="hljs-built_in">back</span>();<br><br><span class="hljs-comment">//迭代器相关:</span><br>a.<span class="hljs-built_in">begin</span>();<br>a.<span class="hljs-built_in">end</span>();<br>a.<span class="hljs-built_in">cbegin</span>();<br>a.<span class="hljs-built_in">cend</span>();<br>a.<span class="hljs-built_in">rbegin</span>();<br>a.<span class="hljs-built_in">rend</span>();<br>a.<span class="hljs-built_in">crbegin</span>();<br>a.<span class="hljs-built_in">crend</span>();<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//去除最后一个元素</span><br><span class="hljs-comment">//signal thread OK, multthread maybe wrong</span><br>a.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//maybe wrong</span><br><br><span class="hljs-comment">//删除某个特定位置的元素</span><br>b.<span class="hljs-built_in">erase</span>(b.<span class="hljs-built_in">begin</span>()); <span class="hljs-comment">//删除掉迭代器当前位置的元素, 而后面的元素会往前移动, 返回下一个元素的位置</span><br>b.<span class="hljs-built_in">erase</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//删除掉迭代器中间元素</span><br><span class="hljs-comment">//要检查迭代器是否失效</span><br><br>b.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10.0f</span>); <span class="hljs-comment">//尾部插入元素</span><br>b.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//获取尾部元素,且释放</span><br><br><span class="hljs-comment">//在某个位置插入元素</span><br><span class="hljs-comment">//在尾部插入100.0</span><br><span class="hljs-keyword">auto</span> iter = b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">100.0f</span>); <span class="hljs-comment">//返回插入元素所在的迭代器</span><br>iter = b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">-10.0f</span>); <span class="hljs-comment">//在尾部插入10个 -10.0f</span><br>b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), h.<span class="hljs-built_in">begin</span>(), h.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//在尾部插入 两个迭代器之间的元素</span><br><br>b.<span class="hljs-built_in">emplace</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10.0f</span>); <span class="hljs-comment">//c++11</span><br>b.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">10.0f</span>); <span class="hljs-comment">//c++11  &amp;&amp; move copy 右值 拷贝</span><br><br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//设置vector的大小</span><br><span class="hljs-comment">// 若改变小了,就会调用元素相应的析构</span><br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1.0f</span>); <span class="hljs-comment">//把vector的大小设置为100,若元素个数不足100,以值为:1.0来填充到100</span><br>b.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//注意: 并不会让以前所占的内存降低, 只是可以把空间腾出来</span><br>b.<span class="hljs-built_in">shrink_to_fit</span>(); <span class="hljs-comment">//c++11, 降低内存到合适的大小</span><br><br><span class="hljs-comment">//和C的接口互用</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">carr</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-built_in">strcpy</span>(&amp;carr[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;hello World\n&quot;</span>); <span class="hljs-comment">//最好用 carr.data();</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, carr.<span class="hljs-built_in">data</span>());<br><span class="hljs-comment">//错误用法:</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, carr.<span class="hljs-built_in">begin</span>());<br><br><span class="hljs-comment">//异常:</span><br><span class="hljs-comment">//1. push_back</span><br><span class="hljs-comment">//2. 元素 move / copy 没有异常的话</span><br><span class="hljs-comment">//insert</span><br><span class="hljs-comment">//emplact</span><br><span class="hljs-comment">//emplce_back</span><br><span class="hljs-comment">//push_bakc</span><br><span class="hljs-comment">//pop_back</span><br><span class="hljs-comment">//erase</span><br><span class="hljs-comment">//swap</span><br><span class="hljs-comment">//clear　都不会有异常</span><br><br><span class="hljs-comment">//特殊:</span><br><span class="hljs-comment">//标准化的失误:  不要使用,std::vector&lt;bool&gt;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span> </span>&#123;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque是c++98中引入的动态数组(dynamic array)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std &#123;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator = allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> deque;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特点</p>
<p>随机访问元素, 末端和头部添加删除元素效率高,中间删除和添加元素效率低，而vector仅仅操作尾部效率高，元素的访问和迭代比vector要慢,迭代器不能是普通的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> Group = std::deque&lt;<span class="hljs-type">float</span>&gt;;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dequePart</span><span class="hljs-params">()</span> </span>&#123;<br>Group a;<br>Group b = a;<br><span class="hljs-function">Group <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1.0f</span>)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">f</span><span class="hljs-params">(e.begin(), e.end())</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">g</span><span class="hljs-params">(&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;)</span></span>;<br>Group h = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;;<br>Group i &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;;<br><br><span class="hljs-keyword">if</span>(!a.<span class="hljs-built_in">empty</span>()) a.<span class="hljs-built_in">pop_back</span>();<br><br>d.<span class="hljs-built_in">empty</span>();<br>d.<span class="hljs-built_in">size</span>();<br>d.<span class="hljs-built_in">max_size</span>();<br><br><span class="hljs-comment">//和vector不同, deque不提供以下的函数 </span><br><span class="hljs-comment">//d.capacity();</span><br><span class="hljs-comment">//d.reserve(100);</span><br>d.<span class="hljs-built_in">shrink_to_fit</span>(); <span class="hljs-comment">//c++11</span><br><br><span class="hljs-comment">//交换</span><br>b.<span class="hljs-built_in">swap</span>(a); <br>std::<span class="hljs-built_in">swap</span>(a, b);<br><br><span class="hljs-comment">//元素访问</span><br>b[<span class="hljs-number">0</span>];<br>b.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);<br>b.<span class="hljs-built_in">front</span>();<br>b.<span class="hljs-built_in">back</span>();<br><br><span class="hljs-comment">//迭代器相关</span><br>a.<span class="hljs-built_in">begin</span>();<br>b.<span class="hljs-built_in">end</span>();<br>a.<span class="hljs-built_in">cbegin</span>();<br>a.<span class="hljs-built_in">cend</span>();<br>a.<span class="hljs-built_in">rbegin</span>();<br>a.<span class="hljs-built_in">rend</span>();<br>a.<span class="hljs-built_in">crbegin</span>();<br>a.<span class="hljs-built_in">crend</span>();<br><br><br>a.<span class="hljs-built_in">pop_back</span>();<br>a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1.0f</span>);<br>a.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1.2f</span>); <span class="hljs-comment">//vector没有</span><br>b.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">1.0f</span>);<br><br><br><span class="hljs-keyword">auto</span> iter = b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">100.0f</span>); <span class="hljs-comment">//在某个位置插入元素</span><br>b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">-10.0f</span>);<br>b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), h.<span class="hljs-built_in">begin</span>(), h.<span class="hljs-built_in">end</span>());<br>b.<span class="hljs-built_in">emplace</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10.0f</span>);<br>b.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">10.0f</span>);<br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>, <span class="hljs-number">10.0f</span>);<br>b.<span class="hljs-built_in">clear</span>();<br>b.<span class="hljs-built_in">shrink_to_fit</span>(); <span class="hljs-comment">//释放适当的内存</span><br><br><span class="hljs-comment">//异常</span><br><span class="hljs-comment">//1 push_back push_front 不会抛出异常</span><br><span class="hljs-comment">//2 move /copy 没有异常的话</span><br><span class="hljs-comment">//insert emplace emplace_back push_back emplace_front</span><br><span class="hljs-comment">//pop_back pop_front erase swap clear　不会抛出异常</span><br><br><span class="hljs-comment">//应用场景: 可以来储存网络消息的连聊天包机制,分别发包机制</span><br><span class="hljs-comment">//using Buffer = std::vector&lt;char&gt;;</span><br><span class="hljs-comment">//using BufferGroup = std::deque&lt;Buffer&gt;;</span><br><span class="hljs-comment">//BufferGroup group;</span><br><span class="hljs-comment">//Buffer buffer;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//auto ok = readFromClinet(socket, &amp;buffer);</span><br><span class="hljs-comment">//if(ok) &#123;</span><br><span class="hljs-comment">//	group.emplace_back(std::move(buffer));</span><br><span class="hljs-comment">//&#125;else &#123;</span><br><span class="hljs-comment">//	//handle error</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//while(!group.empty()) &#123;</span><br><span class="hljs-comment">//	auto ok = sendToClient(socket, group.front());</span><br><span class="hljs-comment">//	if(ok) &#123;</span><br><span class="hljs-comment">//		group.pop_front();	</span><br><span class="hljs-comment">//	&#125;else &#123;</span><br><span class="hljs-comment">//		//handle error	</span><br><span class="hljs-comment">//	&#125;</span><br><span class="hljs-comment">//&#125;</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list 是c++98中引入的双向串列(double linked list)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">namespace std &#123;<br>template&lt;typename T, typename Allocator = allocator&lt;T&gt;&gt;<br>class list;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特点</p>
<p> 不支持随机访问元素,访问头部和尾部元素快<br>任何位置插入删除元素都很快,常亮时间内完成<br>插入和删除不会造成迭代器的失效<br>对于异常支持好, 出现异常对于list而言, 要么不成功, 要么没有影响</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">listPart</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">using</span> Group = std::list&lt;<span class="hljs-type">float</span>&gt;;<br><br>Group a;<br>Group b = a;<br><span class="hljs-function">Group <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1.0f</span>)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">f</span><span class="hljs-params">(e.begin(), e.end())</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">g</span><span class="hljs-params">(&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;)</span></span>;<br>Group h = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;;<br>Group i &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;;<br><br>d.<span class="hljs-built_in">empty</span>();<br>d.<span class="hljs-built_in">size</span>();<br>d.<span class="hljs-built_in">max_size</span>();<br><span class="hljs-comment">//和vecotr不同, list不提供以下函数</span><br><span class="hljs-comment">//d.capacity();</span><br><span class="hljs-comment">//d.reserve(100);</span><br><span class="hljs-comment">//d.shrink_to_fit();</span><br><br><span class="hljs-comment">// operator == != &lt; &gt; &lt;= &gt;=</span><br><span class="hljs-comment">//赋值</span><br>b = g;<br>b.<span class="hljs-built_in">assign</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1.0f</span>);<br>b.<span class="hljs-built_in">assign</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>b.<span class="hljs-built_in">assign</span>(&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;);<br><br><span class="hljs-comment">//交换</span><br>b.<span class="hljs-built_in">swap</span>(a);<br>std::<span class="hljs-built_in">swap</span>(a, b);<br><br><span class="hljs-comment">//元素访问, 不能随机访问</span><br><span class="hljs-comment">//b[0];</span><br><span class="hljs-comment">//b.at(0);</span><br>b.<span class="hljs-built_in">front</span>();<br>b.<span class="hljs-built_in">back</span>();<br><br><span class="hljs-comment">//迭代器相关:</span><br>a.<span class="hljs-built_in">begin</span>();<br>a.<span class="hljs-built_in">end</span>();<br>a.<span class="hljs-built_in">cbegin</span>();<br>a.<span class="hljs-built_in">cend</span>();<br>a.<span class="hljs-built_in">rbegin</span>();<br>a.<span class="hljs-built_in">rend</span>();<br>a.<span class="hljs-built_in">crbegin</span>();<br>a.<span class="hljs-built_in">crend</span>();<br><br>a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">auto</span> iterBegin = a.<span class="hljs-built_in">begin</span>();<br><span class="hljs-built_in">assert</span>(a.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">10</span>);<br><span class="hljs-comment">//for(int i = 0; i &lt; 5; ++i) ++iterBegin; //改变迭代器</span><br>std::<span class="hljs-built_in">advance</span>(iterBegin, <span class="hljs-number">0</span>); <span class="hljs-comment">//改变迭代器位置2</span><br><span class="hljs-comment">//遍历元素</span><br><span class="hljs-keyword">for</span>(; iterBegin != a.<span class="hljs-built_in">end</span>(); ++iterBegin) std::cout &lt;&lt; *iterBegin &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>a.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//maybe wrong</span><br><span class="hljs-keyword">if</span>(!a.<span class="hljs-built_in">empty</span>()) a.<span class="hljs-built_in">pop_back</span>();<br><br>b.<span class="hljs-built_in">erase</span>(b.<span class="hljs-built_in">begin</span>());<br>b.<span class="hljs-built_in">erase</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br><br>b.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10.0f</span>);<br>b.<span class="hljs-built_in">pop_back</span>();<br>b.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1.2f</span>);<br>b.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">1.3f</span>);<br><br><span class="hljs-keyword">auto</span> iter = b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">100.0f</span>);<br>iter = b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">-10.0f</span>);<br><br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1.2f</span>);<br><br><span class="hljs-comment">//算法:</span><br>b.<span class="hljs-built_in">remove</span>(<span class="hljs-number">1.0f</span>); <span class="hljs-comment">//删除值为1.0f的所有值</span><br><span class="hljs-comment">//符合某个条件的值把它删除掉, 100.0f的值全部删除掉</span><br>b.<span class="hljs-built_in">remove_if</span>([](<span class="hljs-keyword">auto</span> v) &#123; <span class="hljs-keyword">return</span> v &gt; <span class="hljs-number">100.0f</span>; &#125;); <span class="hljs-comment">//v 是list中元素的值</span><br>b.<span class="hljs-built_in">reverse</span>(); <span class="hljs-comment">//反转list</span><br>b.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">//默认以 &lt; </span><br><br>b.<span class="hljs-built_in">merge</span>(g); <span class="hljs-comment">// 合并两个排好顺序的list在b中,并清空g中的元素,结果b中就也是排好序的</span><br>c.<span class="hljs-built_in">unique</span>(); <span class="hljs-comment">// 前提: 将排好序的list重复的元素去掉</span><br>c.<span class="hljs-built_in">splice</span>(c.<span class="hljs-built_in">begin</span>(), b); <span class="hljs-comment">//在某个位置插入整块的list, 把b作为一块插入c.begin().</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">listPart</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>&#x2F;&#x2F;forward_list 是c++11中引入的单项串列(singal linked list)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std &#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator = allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> forward_list;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特点</p>
<p>不支持随机元素访问, 访问头部元素速度快，”forward_list” 和自己手写的c-style signal linked list相比没有任何时间和空间上的额外开销, 任何性质如果和这个目标抵触,我们就放弃该特征.任何位置插入和删除元素都很快, 常亮时间完成。插入和删除不会造成迭代器失效，对于异常支持好, 出现异常对于forward_lit而言, 要么不成功, 要么没什么影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">forwardListPart</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">using</span> Group = std::forward_list&lt;<span class="hljs-type">float</span>&gt;;<br><br>Group a;<br>Group b = a;<br><span class="hljs-function">Group <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1.0f</span>)</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">f</span><span class="hljs-params">(e.begin(), e.end())</span></span>;<br><span class="hljs-function">Group <span class="hljs-title">g</span><span class="hljs-params">(&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;)</span></span>;<br>Group h = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;;<br>Group i &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;;<br><br>d.<span class="hljs-built_in">empty</span>();<br><span class="hljs-comment">//d.size(); //没有size() ,为了效率</span><br>d.<span class="hljs-built_in">max_size</span>();<br><span class="hljs-comment">//和vector不同, forward_list不提供以下函数:</span><br><span class="hljs-comment">//d.capacity();</span><br><span class="hljs-comment">//d.reserve(100);</span><br><span class="hljs-comment">//d.shrink_to_fit();</span><br><br><span class="hljs-comment">//operator == != &lt; &gt; &lt;= &gt;=</span><br><br><span class="hljs-comment">//赋值</span><br>b = g;<br>b.<span class="hljs-built_in">assign</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1.0f</span>);<br>b.<span class="hljs-built_in">assign</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>b.<span class="hljs-built_in">assign</span>(&#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;);<br><br><span class="hljs-comment">//交换:</span><br>b.<span class="hljs-built_in">swap</span>(a);<br>std::<span class="hljs-built_in">swap</span>(a, b);<br><br><span class="hljs-comment">//元素访问, 不能随机访问</span><br><span class="hljs-comment">//b[0];</span><br><span class="hljs-comment">//b.at(0);</span><br>b.<span class="hljs-built_in">front</span>();<br><span class="hljs-comment">//b.back(); 没有提供最后一个</span><br><br><span class="hljs-comment">//迭代器相关</span><br>a.<span class="hljs-built_in">begin</span>();<br>a.<span class="hljs-built_in">end</span>();<br>a.<span class="hljs-built_in">cbegin</span>();<br>a.<span class="hljs-built_in">cend</span>();<br>a.<span class="hljs-built_in">before_begin</span>(); <span class="hljs-comment">//返回第一个元素的前一个位置, 这个位置只是个占位符</span><br>a.<span class="hljs-built_in">cbefore_begin</span>();  <span class="hljs-comment">//const &amp;</span><br><span class="hljs-comment">//a.rbegin();</span><br><span class="hljs-comment">//a.rend();</span><br><span class="hljs-comment">//a.rcbegin();</span><br><span class="hljs-comment">//a.rcend();</span><br><br><span class="hljs-keyword">auto</span> iterBegin = a.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">//a.pop_back(); </span><br>a.<span class="hljs-built_in">empty</span>();<br><br><span class="hljs-comment">//b.erase(b.begin()); //不支持erase</span><br>b.<span class="hljs-built_in">erase_after</span>(b.<span class="hljs-built_in">begin</span>()); <span class="hljs-comment">//删除b.begin(), 的下一个元素 </span><br>b.<span class="hljs-built_in">erase_after</span>(b.<span class="hljs-built_in">before_begin</span>()); <span class="hljs-comment">//return void //正确删除第一个元素 </span><br>b.<span class="hljs-built_in">erase_after</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//return void</span><br><br><span class="hljs-comment">//b.push_back(10.0f)</span><br><span class="hljs-comment">//b.pop_back();</span><br><br>b.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1.2f</span>);<br>b.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">1.3f</span>);<br><br><span class="hljs-comment">//b.insert(b.begin(), 3.0f); 不支持insert</span><br><br><span class="hljs-keyword">auto</span> iter = b.<span class="hljs-built_in">insert_after</span>(b.<span class="hljs-built_in">before_begin</span>(), <span class="hljs-number">100.0f</span>);<br>iter = b.<span class="hljs-built_in">insert_after</span>(b.<span class="hljs-built_in">before_begin</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">-10.0f</span>);<br>b.<span class="hljs-built_in">insert_after</span>(b.<span class="hljs-built_in">before_begin</span>(), h.<span class="hljs-built_in">begin</span>(), h.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">//b.emplace(b.end(), 10.0f);</span><br><span class="hljs-comment">//b.emplace_back(10.0f);</span><br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br>b.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1.0f</span>);<br><span class="hljs-comment">//算法:</span><br>b.<span class="hljs-built_in">remove</span>(<span class="hljs-number">1.0f</span>);<br>b.<span class="hljs-built_in">remove_if</span>([](<span class="hljs-keyword">auto</span> v) &#123; <span class="hljs-keyword">return</span> v &gt; <span class="hljs-number">100.0f</span>; &#125;);<br><span class="hljs-comment">//b.reverse(); //1 2 3 4 -&gt; 4 3 2 1</span><br><span class="hljs-comment">//std::sort(a.begin(), a.end());</span><br>b.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">// &lt;</span><br>g.<span class="hljs-built_in">sort</span>();<br>b.<span class="hljs-built_in">merge</span>(g); <span class="hljs-comment">//对于排好顺序的list进行合并,且合并后也是排好顺序的</span><br>c.<span class="hljs-built_in">unique</span>(); <span class="hljs-comment">//对于排好序的进行删除重复元素</span><br>c.<span class="hljs-built_in">splice_after</span>(c.<span class="hljs-built_in">before_begin</span>(), b);<br><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-comment">//例:在索引为3的位置之前插入一个元素</span><br>	std::forward_list&lt;<span class="hljs-type">int</span>&gt; forlist = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>	<span class="hljs-keyword">auto</span> fiter = forlist.<span class="hljs-built_in">before_begin</span>();<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i, ++fiter);<br>	forlist.<span class="hljs-built_in">insert_after</span>(fiter, <span class="hljs-number">10</span>);<br>	<span class="hljs-keyword">for</span>(fiter = forlist.<span class="hljs-built_in">begin</span>(); fiter != forlist.<span class="hljs-built_in">end</span>(); ++fiter) std::cout &lt;&lt; *fiter &lt;&lt; <span class="hljs-string">&quot; &quot;</span> ;<br>	std::cout &lt;&lt; std::endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array 实际上是对c&#x2F;c++语言中的原生数组进行了封装</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std &#123;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">size_t</span> N&gt;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">array</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特点</p>
<p> 内存分配在栈(stack), 绝不会重写分配.随机访问元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">//c++ 11</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkSize</span><span class="hljs-params">(C &amp;c)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(c.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span>) &#123;<br>		c[<span class="hljs-number">3</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">//单线程OK,多线程可能出错</span><br>	&#125;<br>	c.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>) = <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">arrayPart</span><span class="hljs-params">()</span> </span>&#123;<br>	std::array&lt;<span class="hljs-type">int</span>, 100&gt; a; <span class="hljs-comment">//不进行初始化, 只管分配内存</span><br>	std::array&lt;<span class="hljs-type">int</span>, 100&gt; b = &#123;&#125;; <span class="hljs-comment">//初始化为 0 </span><br>	<span class="hljs-comment">//以上两者的区别.</span><br><br>	std::array&lt;<span class="hljs-type">int</span>, 5&gt; obj = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>	std::array&lt;<span class="hljs-type">int</span>, 5&gt; obj2 = &#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//第一个为1, 后面不0</span><br><br>	<span class="hljs-comment">//接口</span><br>	a.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//never be true if size &gt; 0</span><br>	a.<span class="hljs-built_in">size</span>();<br>	a.<span class="hljs-built_in">max_size</span>();<br><br>	<span class="hljs-comment">//operator == &lt; != &gt; &lt;= &gt;=</span><br>	<span class="hljs-keyword">auto</span> aa = a;<br>	aa.<span class="hljs-built_in">swap</span>(a); <span class="hljs-comment">//array的swap是交换每一个元素都需要做交换,因为它是在stack中储存的.不是通过堆来管理</span><br>	<span class="hljs-comment">//访问元素</span><br>	a[<span class="hljs-number">1</span>]; <span class="hljs-comment">//不进行检查,越界出错</span><br>	a.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//进行检查,越界抛出异常</span><br>	a.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//返回头部元素的引用</span><br>	a.<span class="hljs-built_in">back</span>();  <span class="hljs-comment">//返回最后元素的引用</span><br>	<span class="hljs-built_in">checkSize</span>(a);<br><br>	<span class="hljs-comment">//迭代器相关的:</span><br>	a.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//可以对begin减引操作, 但不能堆end进行此操作</span><br>	a.<span class="hljs-built_in">end</span>();<br>	a.<span class="hljs-built_in">cbegin</span>(); <span class="hljs-comment">//const　引用</span><br>	a.<span class="hljs-built_in">cend</span>();<br>	<br>	a.<span class="hljs-built_in">rbegin</span>(); <span class="hljs-comment">//从尾部遍历到头部,与以上相反</span><br>	a.<span class="hljs-built_in">rend</span>();<br><br>	a.<span class="hljs-built_in">crbegin</span>(); <span class="hljs-comment">//const 方式从尾部遍历到头部</span><br>	a.<span class="hljs-built_in">crend</span>();<br><br><br>	<span class="hljs-comment">//和C的接口互用</span><br>	std::array&lt;<span class="hljs-type">char</span>, 100&gt; carr;<br>	<span class="hljs-built_in">strcpy</span>(&amp;carr[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;carr[<span class="hljs-number">0</span>]); <span class="hljs-comment">//更好的使用 carr.data();</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, carr.<span class="hljs-built_in">data</span>());<br>	<span class="hljs-comment">//错误用法</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, carr.<span class="hljs-built_in">begin</span>());<br><br><br>	<span class="hljs-comment">//特殊的地方</span><br>	<span class="hljs-keyword">auto</span> info = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(carr); <span class="hljs-comment">//与 carr[1] 一样</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, info); <span class="hljs-comment">//</span><br>	carr.<span class="hljs-built_in">fill</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//对所有元素赋予0</span><br><br>	<span class="hljs-comment">//异常 exception</span><br>	<span class="hljs-comment">//c.at(pos)</span><br>	<span class="hljs-comment">//copy move swap, 进行操作时,可能触发异常</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">arrayPart</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>











<h2 id="C-中的补码公式与位域"><a href="#C-中的补码公式与位域" class="headerlink" title="C++中的补码公式与位域"></a>C++中的补码公式与位域</h2><h2 id="补码公式"><a href="#补码公式" class="headerlink" title="补码公式"></a>补码公式</h2><p>-x &#x3D; <del>x+1 &#x3D; ~(x-1)<br>~x &#x3D; -x-1<br>-(</del>x) &#x3D; x+1<br>~(-x) &#x3D; x-1</p>
<p>x+y &#x3D; x - <del>y-1 &#x3D; (x|y) + (x&amp;y)<br>x-y &#x3D; x + ~y+1 &#x3D; (x|</del>y) - (<del>x&amp;y)<br>x^y &#x3D; (x|y) - (x&amp;y)<br>x|y &#x3D; (x&amp; ~y) + y<br>x&amp;y &#x3D; (</del>x|y) - ~x</p>
<p>x&#x3D;&#x3D;y :  <del>(x-y|y-x)<br>x!&#x3D;y :  x-y|y-x<br>x&lt;y  :  (x-y) ^ ((x^y) &amp; ((x-y) ^x))<br>x&lt;&#x3D;y :  (x|</del>y) &amp; ((x^y) | <del>(y-x))<br>x&lt;y  :  (</del>x&amp;y) | ((<del>x|y) &amp; (x-y))   &#x2F;&#x2F;unsigned<br>x&lt;&#x3D;y :  (</del>x|y) &amp; ((x^y) | ~(y-x))   &#x2F;&#x2F;unsigned</p>
<p>实例代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator_1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator_2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator_3</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br>        <span class="hljs-built_in">operator_1</span>();<br>        <span class="hljs-built_in">operator_2</span>();<br>        <span class="hljs-built_in">operator_3</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator_1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-x = &quot;</span> &lt;&lt; -x &lt;&lt; <span class="hljs-string">&quot;   ~x+1 = &quot;</span> &lt;&lt; ~x + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~x = &quot;</span> &lt;&lt; ~x &lt;&lt; <span class="hljs-string">&quot;   -x-1 = &quot;</span> &lt;&lt; -x - <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-(~x) = &quot;</span>&lt;&lt; -(~x) &lt;&lt; <span class="hljs-string">&quot;   x+1 = &quot;</span> &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-(~x) = &quot;</span>&lt;&lt; -(~x) &lt;&lt; <span class="hljs-string">&quot;   x-1 = &quot;</span> &lt;&lt; -x <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator_2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">5</span>;<br>        cout &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x+y=&quot;</span> &lt;&lt; x+y &lt;&lt; <span class="hljs-string">&quot;   x- ~y-1= &quot;</span> &lt;&lt; x - ~y - <span class="hljs-number">1</span><br>        &lt;&lt; <span class="hljs-string">&quot;  (x|y)+(x&amp;y) = &quot;</span> &lt;&lt; (x|y) + (x&amp;y) &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x-y=&quot;</span> &lt;&lt; x-y &lt;&lt; <span class="hljs-string">&quot;   x+ ~y+1= &quot;</span> &lt;&lt; x + ~y + <span class="hljs-number">1</span><br>        &lt;&lt; <span class="hljs-string">&quot;  (x|~y) - (~x&amp;y) = &quot;</span> &lt;&lt; (x|~y) - (~x|y) &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;x^y=&quot;</span> &lt;&lt; (x^y) &lt;&lt; <span class="hljs-string">&quot; (x|y) - (x&amp;y)&quot;</span> &lt;&lt; (x|y) - (x&amp;y) &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x|y=&quot;</span> &lt;&lt; (x|y) &lt;&lt; <span class="hljs-string">&quot; (x&amp; ~y) + y = &quot;</span> &lt;&lt; (x&amp; ~y) + y &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x&amp;y=&quot;</span> &lt;&lt; (x&amp;y) &lt;&lt; <span class="hljs-string">&quot; (~x|y) - ~x = &quot;</span> &lt;&lt; (~x|y) - ~x &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator_3</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">-3</span>, y = <span class="hljs-number">-5</span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">x_t</span> = <span class="hljs-number">-1</span>, <span class="hljs-type">y_t</span> = <span class="hljs-number">-5</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x==y =&quot;</span> &lt;&lt; (x==y) &lt;&lt; <span class="hljs-string">&quot;  ~(x-y|y-x) =&quot;</span> &lt;&lt; ~(x-y|y-x) &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x!=y =&quot;</span> &lt;&lt; (x!=y) &lt;&lt; <span class="hljs-string">&quot;  x-y|y-x =&quot;</span> &lt;&lt; (x-y|y-x) &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x&lt;y =&quot;</span> &lt;&lt; (x&lt;y) &lt;&lt; <span class="hljs-string">&quot;  (x-y) ^ ((x^y) &amp; ((x-y)^x))=&quot;</span> &lt;&lt; ((x-y) ^ ((x^y) &amp; ((x-y)^x))) &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x&lt;=y =&quot;</span> &lt;&lt; (x&lt;=y) &lt;&lt; <span class="hljs-string">&quot;  (x|~y) &amp; ((x^y) |~ (y-x))=&quot;</span> &lt;&lt; ((x|~y) &amp; ((x^y) |~ (y-x))) &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;unsigned: x&lt;y =&quot;</span> &lt;&lt; (<span class="hljs-type">x_t</span>&lt;<span class="hljs-type">y_t</span>)<br>        &lt;&lt; <span class="hljs-string">&quot;  (~x&amp;y) | ((~x|y) &amp; (x-y))&quot;</span> &lt;&lt; ((~<span class="hljs-type">x_t</span>&amp;<span class="hljs-type">y_t</span>) | ((~<span class="hljs-type">x_t</span>|<span class="hljs-type">y_t</span>) &amp; (<span class="hljs-type">x_t</span>-<span class="hljs-type">y_t</span>))) &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;unsigned: x&lt;=y =&quot;</span> &lt;&lt; (<span class="hljs-type">x_t</span>&lt;=<span class="hljs-type">y_t</span>)<br>        &lt;&lt; <span class="hljs-string">&quot; (~x|y) &amp; ((x^y) | ~(y-x) =&quot;</span> &lt;&lt; ((~<span class="hljs-type">x_t</span>|<span class="hljs-type">y_t</span>) &amp; ((<span class="hljs-type">x_t</span>^<span class="hljs-type">y_t</span>) |~ (<span class="hljs-type">y_t</span>-<span class="hljs-type">x_t</span>))) &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>在结构内声明位域的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct<br>&#123;<br>  type [member_name] : width ;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>下面是有关位域中变量元素的描述：</p>
<table>
<thead>
<tr>
<th align="left">元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">type</td>
<td align="left">只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</td>
</tr>
<tr>
<td align="left">member_name</td>
<td align="left">位域的名称。</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td>
</tr>
</tbody></table>
<p>实例代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">bs</span> &#123;<br>        <span class="hljs-type">int</span> a:<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> b:<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> c:<span class="hljs-number">12</span>;<br>        <span class="hljs-type">unsigned</span> d:<span class="hljs-number">4</span><br>&#125;bs;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bit_2</span> &#123;<br>        <span class="hljs-type">unsigned</span> a:<span class="hljs-number">2</span>;<br>        <span class="hljs-type">unsigned</span> :<span class="hljs-number">2</span>;  <span class="hljs-comment">//It can&#x27;t use</span><br>        <span class="hljs-type">unsigned</span> :<span class="hljs-number">0</span>;  <span class="hljs-comment">//NULL</span><br>        <span class="hljs-type">unsigned</span> b:<span class="hljs-number">4</span>;<br>        <span class="hljs-type">unsigned</span> c:<span class="hljs-number">4</span>;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        bs bit;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(%d) \n&quot;</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> bs));<br>        bit.a = <span class="hljs-number">4</span>;<br>        bit.b = <span class="hljs-number">1</span>;<br>        bit.c = <span class="hljs-number">34235</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a: %d   b: %d  c: %d\n&quot;</span>, bit.a, bit.b, bit.c);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//基础函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">//操作符重载函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Print</span> &#123;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> <span class="hljs-type">const</span> </span>&#123;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><span class="hljs-comment">//模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">templatePrint</span><span class="hljs-params">(T1 a, T2 b, T3 c)</span> </span>&#123;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">//操作符重载 + 模板 的函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TemplatePrint</span> &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;</span><br><span class="hljs-function">		<span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(T1 a, T2 b, T3 c)</span> <span class="hljs-type">const</span> </span>&#123;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Fun&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printUseFun</span><span class="hljs-params">(Fun fun, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>	<span class="hljs-built_in">fun</span>(a, b, c);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1</span><span class="hljs-params">()</span> </span>&#123;<br>	Print printUseClass;	<br>	TemplatePrint printUseTempClass;<br><br>	<span class="hljs-built_in">printInfo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>	<span class="hljs-built_in">printUseClass</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//operator() (int a, int b, int c)</span><br><br>	<span class="hljs-built_in">templatePrint</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <br>	<span class="hljs-built_in">printUseTempClass</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>	<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>	<span class="hljs-comment">//以前inline 函数跟普通函数调用差不多</span><br>	<span class="hljs-comment">//lambda就是个inline函数, 只是把 inline 函数作为一个参数或者一个local变量来使用, </span><br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;lamda: &quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">auto</span> local = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>	&#125;;<br>	<span class="hljs-built_in">printUseFun</span>(local, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>	<span class="hljs-built_in">printUseFun</span>([](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;lamda2:&quot;</span> &lt;&lt; std::endl;	<br>		std::cout &lt;&lt; <span class="hljs-string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>	&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br><br>	<span class="hljs-type">int</span> a = <span class="hljs-number">6</span>, b = <span class="hljs-number">7</span>, c = <span class="hljs-number">8</span>;<br><br>	<span class="hljs-keyword">auto</span> local2  = [a, b, c]() &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>	&#125;;<br>	<span class="hljs-built_in">local2</span>();<br><br>	<span class="hljs-keyword">auto</span> local3 = [=]() &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;====&quot;</span> &lt;&lt; std::endl;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>	&#125;;<br>	<span class="hljs-built_in">local3</span>();<br><br>	<span class="hljs-keyword">auto</span> local4 = [=]() <span class="hljs-keyword">mutable</span> &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;====&quot;</span> &lt;&lt; std::endl;<br>		a = <span class="hljs-number">4</span>, b = <span class="hljs-number">4</span> , c = <span class="hljs-number">4</span>;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; c = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br>	&#125;;<br>	<span class="hljs-built_in">local4</span>();<br>	<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">test_1</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="C-11新型for循环-auto-类成员的初始化及左右值引用"><a href="#C-11新型for循环-auto-类成员的初始化及左右值引用" class="headerlink" title="C++11新型for循环,auto, 类成员的初始化及左右值引用"></a>C++11新型for循环,auto, 类成员的初始化及左右值引用</h2><p>C++11中新型for循环,auto, 类成员的初始化及左右值引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">autoValue</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">autoPointer</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">newVersionFor</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">newVersionConstruct</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">defaultInitValue</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">leftRefAndRightRef</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//自定义类实现新型for循环</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVector</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-keyword">using</span> GroupType = std::vector&lt;<span class="hljs-type">int</span>&gt;;<br>	<span class="hljs-keyword">public</span>:<br>		GroupType m_group;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>			m_group.<span class="hljs-built_in">push_back</span>(x);<br>		&#125;<br>&#125;;<br><br>MyVector::<span class="hljs-function">GroupType::iterator <span class="hljs-title">begin</span><span class="hljs-params">(MyVector &amp;v)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> v.m_group.<span class="hljs-built_in">begin</span>();<br>&#125;<br>MyVector::<span class="hljs-function">GroupType::iterator <span class="hljs-title">end</span><span class="hljs-params">(MyVector &amp;v)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> v.m_group.<span class="hljs-built_in">end</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testMyClass</span><span class="hljs-params">()</span> </span>&#123;<br><br>	MyVector mv;<br>	mv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>	mv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>	mv.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : mv) &#123;<br>		std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;	<br>	&#125;<br>	std::cout &lt;&lt; std::endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/*argc*/</span>, <span class="hljs-type">char</span>** <span class="hljs-comment">/*argv*/</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">testMyClass</span>();<br>	<span class="hljs-comment">//new version auto</span><br>	<span class="hljs-comment">//autoValue();</span><br>	<span class="hljs-comment">//autoPointer();</span><br><span class="hljs-comment">//	newVersionFor();</span><br>	<span class="hljs-comment">//newVersionConstruct();</span><br><span class="hljs-comment">//	defaultInitValue();</span><br>	<span class="hljs-built_in">leftRefAndRightRef</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">autoValue</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> age = <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">auto</span> name = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Yt&quot;</span>);<br>	<span class="hljs-keyword">auto</span> height = <span class="hljs-number">160.0f</span>;<br>	<span class="hljs-keyword">auto</span> wight = <span class="hljs-number">72.0</span>;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;age is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(age).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;name is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(name).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;height is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(height).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;weight is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(wight).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">autoPointer</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>	<span class="hljs-keyword">auto</span> name = <span class="hljs-string">&quot;Yt&quot;</span>;<br>	<span class="hljs-keyword">auto</span> height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>(<span class="hljs-number">160.0f</span>);<br>	<span class="hljs-keyword">auto</span> wight = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">72.0</span>);<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;age is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(age).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;name is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(name).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;height is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(height).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;weight is type &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(wight).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">newVersionFor</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> ids[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;new version&quot;</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : ids) &#123;<br>		std::cout &lt;&lt;  v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;	<br>	&#125;<br>	std::cout &lt;&lt; std::endl;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;old version&quot;</span>;<br><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(ids) / <span class="hljs-built_in">sizeof</span>(ids[<span class="hljs-number">0</span>]); ++i) &#123;<br>		std::cout &lt;&lt; ids[i] &lt;&lt;  <span class="hljs-string">&quot; &quot;</span>;	<br>	&#125;<br>	std::cout &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">//vector::</span><br>	std::vector&lt;<span class="hljs-type">int</span>&gt; group;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) group.<span class="hljs-built_in">push_back</span>(i);<br>	<span class="hljs-comment">//old version:</span><br>	<span class="hljs-comment">//老版本遍历方式 </span><br>	<span class="hljs-keyword">for</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;::size_type i = <span class="hljs-number">0</span>, size = group.<span class="hljs-built_in">size</span>(); i &lt; size; ++i) &#123;<br>		<span class="hljs-comment">//cout &lt;&lt; group[i] &lt;&lt; &quot; &quot;;	</span><br>	&#125;<br>	<span class="hljs-comment">//通过迭代器来遍历</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;iterator: &quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-comment">//-------对于迭代器自增的时候,要用前置操作符,不要用后置操作符. ++iter, 若使用后置操作符号</span><br>	<span class="hljs-comment">//多了一个步骤,就是把自增前的值先保留起来, 然后在自增.无用功</span><br>	<span class="hljs-keyword">for</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator iter = group.<span class="hljs-built_in">begin</span>(); iter != group.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>		std::cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;	<br>	&#125;<br><br>	std::cout &lt;&lt; std::endl;<br>	<span class="hljs-comment">//auto version</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;vector old version:&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : group) &#123;<br>		std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br><br>	std::cout &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;vector new version:&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v : group) &#123;<br>		v = <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v : group) &#123;<br>		std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-comment">//why explicit ?? 具体含义是什么?</span><br>		<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> : m_value(value) &#123;</span> &#125;<br><br>	<span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">newVersionConstruct</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>	A b&#123;<span class="hljs-number">3</span>&#125;;<br><br>	<span class="hljs-comment">//old</span><br>	<span class="hljs-type">int</span> avector[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; bv;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : avector) bv.<span class="hljs-built_in">push_back</span>(v);<br>	<br>	<span class="hljs-comment">//new </span><br>	std::vector&lt;<span class="hljs-type">int</span>&gt; cv = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>	<span class="hljs-function">A <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br>	<span class="hljs-function">A <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><br>	<span class="hljs-function">A <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">1.0</span>)</span></span>;<br>	<span class="hljs-comment">// A f&#123;1.0&#125; //不能做构造, 只能提高精度， 不能丢失</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">B</span>() : <span class="hljs-built_in">m_age</span>(<span class="hljs-number">18</span>), <span class="hljs-built_in">m_height</span>(<span class="hljs-number">170</span>), <span class="hljs-built_in">m_weight</span>(<span class="hljs-number">75</span>) &#123;&#125;<br>		<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> : m_age(age), m_height(<span class="hljs-number">170</span>), m_weight(<span class="hljs-number">75</span>) &#123;</span>&#125;<br>		<span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> height) : <span class="hljs-built_in">m_age</span>(age), <span class="hljs-built_in">m_height</span>(height) &#123;&#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_age; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_height; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">weight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_weight; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_age;<br>		<span class="hljs-type">int</span> m_height;<br>		<span class="hljs-type">int</span> m_weight;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewB</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">NewB</span>() &#123;&#125;<br>		<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NewB</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> : m_age &#123;</span>age&#125; &#123;&#125;<br>		<span class="hljs-built_in">NewB</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> height) : m_age&#123;age&#125;, m_height &#123;height&#125; &#123;&#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_age; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_height; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">weight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_weight; &#125;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; m_value &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m_fightValue;&#125;<br><br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_age = <span class="hljs-number">18</span>; <span class="hljs-comment">//初始化, 放置出现bug</span><br>		<span class="hljs-type">int</span> m_height = <span class="hljs-number">170</span>;<br>		<span class="hljs-type">int</span> m_weight = <span class="hljs-number">75</span>;<br>		<span class="hljs-type">int</span> m_value&#123;&#125;; <span class="hljs-comment">//代表拿int的默认值来作初始化,也就是0</span><br>		<span class="hljs-type">double</span> m_fightValue&#123;&#125;; <span class="hljs-comment">//0.0</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">defaultInitValue</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">B <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>	<span class="hljs-function">NewB <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Old a age is&quot;</span> &lt;&lt; a.<span class="hljs-built_in">age</span>() &lt;&lt; <span class="hljs-string">&quot;height &quot;</span> &lt;&lt; a.<span class="hljs-built_in">height</span>()<br>		&lt;&lt; <span class="hljs-string">&quot; wight &quot;</span> &lt;&lt; a.<span class="hljs-built_in">weight</span>() &lt;&lt; std::endl;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;New b age is&quot;</span> &lt;&lt; b.<span class="hljs-built_in">age</span>() &lt;&lt; <span class="hljs-string">&quot;height &quot;</span> &lt;&lt; b.<span class="hljs-built_in">height</span>()<br>		&lt;&lt; <span class="hljs-string">&quot; wight &quot;</span> &lt;&lt; b.<span class="hljs-built_in">weight</span>() &lt;&lt; std::endl;<br><br>	b.<span class="hljs-built_in">p</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">leftRefAndRightRef</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//什么是引用</span><br>	<span class="hljs-comment">//引用类似与指针,　不同之处在于, 指针可以为nullptr, 但引用不可以</span><br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-type">int</span> &amp;refA = a;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;constRefA = a;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot; a&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; ref of a &quot;</span> &lt;&lt; refA &lt;&lt; <span class="hljs-string">&quot; const ref a &quot;</span><br>		&lt;&lt; constRefA &lt;&lt; std::endl;<br>	<span class="hljs-comment">//this is a error</span><br>	<span class="hljs-comment">// int &amp;refB = 10;</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;constRefB = <span class="hljs-number">10</span>; <span class="hljs-comment">//不管左值还是右值,都能赋给const 引用</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;different version const ref &quot;</span> &lt;&lt; constRefB &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">//auto &amp;&amp;rrB = 20; //与下一样</span><br>	<span class="hljs-type">int</span> &amp;&amp;rrB = <span class="hljs-number">20</span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;crrB = <span class="hljs-number">20</span>;<br>	<br>	rrB = <span class="hljs-number">30</span>; <span class="hljs-comment">//可以改变右值, 其实只是改变那个值而已</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot; right ref of b &quot;</span> &lt;&lt; rrB &lt;&lt; <span class="hljs-string">&quot; const right ref b &quot;</span><br>		&lt;&lt; crrB &lt;&lt; std::endl;<br>	<span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>	<span class="hljs-type">int</span> &amp;&amp;newRRB = std::<span class="hljs-built_in">move</span>(b); <span class="hljs-comment">//强行转为右值</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;cNewRRB = std::<span class="hljs-built_in">move</span>(b);<br>	std::cout &lt;&lt; <span class="hljs-string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; right ref of be &quot;</span> &lt;&lt; newRRB &lt;&lt; <span class="hljs-string">&quot;const right ref b &quot;</span><br>		&lt;&lt; cNewRRB &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;address &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="hljs-string">&quot; ref &quot;</span> &lt;&lt; &amp;newRRB &lt;&lt; <span class="hljs-string">&quot; c ref &quot;</span> &lt;&lt; &amp;cNewRRB &lt;&lt; std::endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="C-11智能指针"><a href="#C-11智能指针" class="headerlink" title="C++11智能指针"></a>C++11智能指针</h2><p>目前c++ 的4种指针</p>
<ol>
<li><p>auto_ptr  c++98 智能指针,使用了</p>
</li>
<li><p>shared_ptr &#x2F;&#x2F;共享指针</p>
</li>
<li><p>unique_ptr &#x2F;&#x2F;只能由一个使用者使用</p>
</li>
<li><p>weaked_ptr &#x2F;&#x2F;与share_ptr搭配使用</p>
</li>
</ol>
<h3 id="shared-patr"><a href="#shared-patr" class="headerlink" title="shared_patr"></a>shared_patr</h3><p>实例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interfaceOfSharedPtr</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">interfaceOfSharedPtr</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> id) : <span class="hljs-built_in">m_id</span>(id) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;init obj &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;;<br>		~<span class="hljs-built_in">Object</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye bye &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_id; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_id = <span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-comment">//使用智能指针</span><br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br><br><span class="hljs-comment">//作为参数的obj,相当于拷贝了一次,use_count 会+ 1,但当函数结束时候,智能指针析构,use_count会恢复原来的个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ObjectPtr obj)</span> </span>&#123;<br>	<span class="hljs-comment">//-------------------------智能指针的成员函数</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;count &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot; id &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">//以引用方式,不会进行copy, use_count不变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printRef</span><span class="hljs-params">(<span class="hljs-type">const</span> ObjectPtr &amp;obj)</span> </span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;id &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interfaceOfSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>	ObjectPtr null;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; null.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">//使用智能指针来储存对象的指针</span><br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">1</span>))</span></span>;	<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj2</span><span class="hljs-params">(obj)</span></span>;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	ObjectPtr obj3 = obj;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	obj2.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//What dose means of reset ?</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	ObjectPtr obj4;<br>	obj3.<span class="hljs-built_in">swap</span>(obj4); <span class="hljs-comment">//把obj3的管理资源相互交换</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;obj4 ref count is &quot;</span> &lt;&lt; obj4.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>	std::<span class="hljs-built_in">swap</span>(obj3, obj4); <span class="hljs-comment">//采用另一种方式交换 </span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;obj4 ref count is &quot;</span> &lt;&lt; obj4.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">//把智能指针存储的指针传出来</span><br>	<span class="hljs-keyword">auto</span> p = obj.<span class="hljs-built_in">get</span>();<br>	<span class="hljs-keyword">if</span>(p) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;id is&quot;</span> &lt;&lt; p-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;	<br>	&#125;<br>	<span class="hljs-keyword">if</span>(obj) &#123; <span class="hljs-comment">//重载了 operator bool</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;p id is &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl; <span class="hljs-comment">//重载: operator -&gt;</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;ref id is &quot;</span> &lt;&lt; (*obj).<span class="hljs-built_in">id</span>() &lt;&lt; std::endl; <span class="hljs-comment">//重载了: operator *</span><br>	&#125;<br>	<br>	obj4 = <span class="hljs-literal">nullptr</span>;<br>	<span class="hljs-comment">//-----------------------------&gt;obj.use_count() == 1 可能效率比较底一点</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;only one hold ptr &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">unique</span>() &lt;&lt; std::endl; <span class="hljs-comment">//判断是否是一个人在使用</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;judge differnt: &quot;</span> &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>	<span class="hljs-built_in">printRef</span>(obj);<br>	<span class="hljs-built_in">print</span>(obj);<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleterOfObject</span><span class="hljs-params">(Object *obj)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(obj)<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;delete obj &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>()  &lt;&lt; std::endl;<br>	<span class="hljs-keyword">delete</span> obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useDeleter</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//当智能指针出了作用域后,析构函数就被调用, 哪怕中途抛出异常</span><br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">2</span>), deleterOfObject)</span></span>;<br>	ObjectPtr obj2 = obj;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>c++智能指针-shared_ptr的尴尬-诞生weak_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><br><span class="hljs-comment">//auto ptr</span><br><span class="hljs-comment">//shared_ptr</span><br><span class="hljs-comment">//unique_ptr</span><br><span class="hljs-comment">//weak_ptr</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>; <span class="hljs-comment">//采用前置声明</span><br><br><span class="hljs-keyword">using</span> ParentPtr = std::shared_ptr&lt;Parent&gt;;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Parent&gt; WeakParentPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//		ParentPtr father; //内存泄露</span><br>		WeakParentPtr father; <span class="hljs-comment">//采用弱指针,则可以释放内存,不造成内存泄露</span><br>		<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Child!!&quot;</span> &lt;&lt; std::endl; &#125;<br>		~<span class="hljs-built_in">Child</span>();<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Child&gt; WeakChildPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Parent!!&quot;</span> &lt;&lt; std::endl; &#125;<br>		ChildPtr son;<br><span class="hljs-comment">//		WeakChildPtr son;</span><br><br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;son.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;&#125;<br>		~<span class="hljs-built_in">Parent</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> id) : <span class="hljs-built_in">m_id</span>(id) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;init obj &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;;<br>		~<span class="hljs-built_in">Object</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye bye &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_id; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_id = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br>Child::~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child!&quot;</span> &lt;&lt; std::endl; &#125;<br>Parent::~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent!&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">ParentPtr <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;<br>	<span class="hljs-function">ChildPtr <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;<br><br><span class="hljs-comment">//采用这种方式,造成内存泄露</span><br>	p-&gt;son = c; <span class="hljs-comment">//智能指针拷贝, use_count + 1, c 的use_count 为 2</span><br>	p-&gt;<span class="hljs-built_in">print</span>();<br>	c-&gt;father = p; <span class="hljs-comment">//p 的 use_count 也为 2 了</span><br><br><span class="hljs-comment">//智能指针析构之后use_count  -1</span><br><span class="hljs-comment">//智能指针特性: 只有当use_count 变为0 时,才能释放掉管理的资源</span><br><span class="hljs-comment">//所以智能指针析构后,use_count 不为0,则造成了内存泄露</span><br>	<span class="hljs-comment">////////////</span><br><span class="hljs-comment">//只要打破环状的引用,则share_ptr就会很好的管理内存</span><br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//为了解决以上问题, 采用weak_ptr来解决</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedPtrWithWeakPtr</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">1</span>))</span></span>;<br>	<span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Object&gt; WeakObjectPtr;<br>	<span class="hljs-function">WeakObjectPtr <span class="hljs-title">weakObj</span><span class="hljs-params">(obj)</span></span>;<span class="hljs-comment">//弱指针依赖于share_ptr,若share_ptr是有效的,则wake_ptr也是有效的.</span><br>	<span class="hljs-function">WeakObjectPtr <span class="hljs-title">weakObj2</span><span class="hljs-params">(obj)</span></span>;<br>	<span class="hljs-comment">//而wake_ptr在进行赋值的操作运算的时候,并不影响use_count, 相当于只是作为监听者</span><br><br>	<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;obj use count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>	&#123;<br>		<span class="hljs-keyword">auto</span> p = weakObj.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//相当于返回了一个 ObjectPtr类型,</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;expired: &quot;</span> &lt;&lt; weakObj.<span class="hljs-built_in">expired</span>() &lt;&lt; std::endl; <span class="hljs-comment">//expierd() 查看监控的资源过期没有过期</span><br>		<span class="hljs-keyword">if</span>(p) &#123;<br>			std::cout &lt;&lt; p.<span class="hljs-built_in">unique</span>() &lt;&lt; std::endl; <span class="hljs-comment">//false, use_count &gt;= 2, 因为auto p = ...,进行了一次指针拷贝, </span><br>			<span class="hljs-comment">//所以use_count + 1, 而weakObj.lock()返回若是有效的话,则use_count &gt;= 1, 否则返回nullptr</span><br>			<span class="hljs-comment">//则总体的就use_count &gt;= 2</span><br>			<span class="hljs-comment">//do what you wanna do	</span><br>		&#125;<span class="hljs-keyword">else</span> &#123;<br>		<br>		<br>		&#125;<br>	&#125;<br>	obj.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//obj 放弃管理的资源</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;endl;&quot;</span>;<br>	<span class="hljs-keyword">auto</span> p2 = weakObj.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//返回空,因为,obj不管理资源了</span><br>	<br>	obj.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">//重新管理另一个资源</span><br>	&#123;<br>		<span class="hljs-keyword">auto</span> p = weakObj.<span class="hljs-built_in">lock</span>();<br>		<span class="hljs-keyword">if</span>(p) &#123;<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>		&#125;<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">//要么资源已经释放,要么obj管理的资源跟换了.</span><br>			std::cout &lt;&lt; <span class="hljs-string">&quot;changed!&quot;</span> &lt;&lt; std::endl;<br>		&#125;<br><br>	&#125;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;expired: &quot;</span> &lt;&lt; weakObj.<span class="hljs-built_in">expired</span>() &lt;&lt; std::endl; <span class="hljs-comment">//expierd() 查看监控的资源过期没有过期</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">testParentAndChild</span>();<br><span class="hljs-comment">//	sharedPtrWithWeakPtr();</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="shared-ptr储存this指针多次析构问题"><a href="#shared-ptr储存this指针多次析构问题" class="headerlink" title="shared_ptr储存this指针多次析构问题"></a>shared_ptr储存this指针多次析构问题</h3><h4 id="enable-shared-from-this解决方案"><a href="#enable-shared-from-this解决方案" class="headerlink" title="enable_shared_from_this解决方案"></a>enable_shared_from_this解决方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">		//this //调用了两次析构函数,</span><br><span class="hljs-comment">		ParentPtr p(this);</span><br><span class="hljs-comment">		//智能指针出了作用域后就delete this ,析构了</span><br><span class="hljs-comment">		//所以错了,为了解决这个问题,就需要自身的类继承于　std::enable_shared_from_this&lt;Type&gt;</span><br><span class="hljs-comment">		//将ParentPtr p(this) 换成, shared_from_this();</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;<br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Parent&gt; WeakParentPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Child&gt; &#123;<br>	<span class="hljs-keyword">public</span>:<br>		WeakParentPtr father;<br><span class="hljs-comment">//		ParentPtr father;</span><br>		~<span class="hljs-built_in">Child</span>();<br>		<span class="hljs-built_in">Child</span>();<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkRelation</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Child&gt; WeakChildPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Parent&gt; &#123;<br>	<span class="hljs-keyword">public</span>:<br>		WeakChildPtr son;<br><span class="hljs-comment">//		ChildPtr son;</span><br>		~<span class="hljs-built_in">Parent</span>();<br>		<span class="hljs-built_in">Parent</span>();<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkRelation</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleChildAndParentRef</span><span class="hljs-params">(<span class="hljs-type">const</span> Parent &amp;p, <span class="hljs-type">const</span> Child &amp;c)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(c.father.<span class="hljs-built_in">lock</span>().<span class="hljs-built_in">get</span>() == &amp;p &amp;&amp; p.son.<span class="hljs-built_in">lock</span>().<span class="hljs-built_in">get</span>() == &amp;c) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;right relation&quot;</span> &lt;&lt; std::endl;	<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;oop!!!!!!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleChildAndParent</span><span class="hljs-params">(<span class="hljs-type">const</span> ParentPtr &amp;p, <span class="hljs-type">const</span> ChildPtr &amp;c)</span> </span>&#123;<br>	<span class="hljs-built_in">assert</span>(c);<br>	<span class="hljs-built_in">assert</span>(p);<br>	<span class="hljs-keyword">if</span>(c-&gt;father.<span class="hljs-built_in">lock</span>() == p &amp;&amp; p-&gt;son.<span class="hljs-built_in">lock</span>() == c) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;right relation&quot;</span> &lt;&lt; std::endl;	<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;oop!!!!!!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br>Child::<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello child&quot;</span> &lt;&lt; std::endl; &#125;<br>Child::~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child&quot;</span> &lt;&lt; std::endl; &#125;<br>Parent::<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello parent&quot;</span> &lt;&lt; std::endl; &#125;<br>Parent::~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parent::checkRelation</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> ps = son.<span class="hljs-built_in">lock</span>();<br>	<span class="hljs-keyword">if</span>(ps) &#123;<br>		<span class="hljs-comment">//this //调用了两次析构函数,</span><br><span class="hljs-comment">//		ParentPtr p(this);</span><br>		<span class="hljs-comment">//handleChildAndParent(p, ps);	</span><br><br>		<span class="hljs-comment">//智能指针出了作用域后就delete this ,析构了</span><br>		<span class="hljs-comment">//所以错了,为了解决这个问题,就需要自身的类继承于　std::enable_shared_from_this&lt;Type&gt;</span><br>		<span class="hljs-comment">//将ParentPtr p(this) 这种错误形式换成, shared_from_this()</span><br>		<span class="hljs-built_in">handleChildAndParent</span>(<span class="hljs-built_in">shared_from_this</span>(), ps);	<br>	&#125;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;after call checkRelation&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Child::checkRelation</span><span class="hljs-params">()</span> </span>&#123;<br>	<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//若Parent 继承于 std::enable_shared_from_this&lt;Type&gt;</span><br>	<span class="hljs-comment">//则 Parent pp; 这种静态的就不推荐</span><br>	<span class="hljs-function">ParentPtr <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;<br>	<span class="hljs-function">ChildPtr <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;<br>	p-&gt;son = c;<br>	c-&gt;father = p;<br>	p-&gt;<span class="hljs-built_in">checkRelation</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interfaceOfSharedPtr</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sharedPtrWithWeakPtr</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">uniquePtr</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">testParentAndChild</span>();	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>;<br><br><span class="hljs-keyword">typedef</span> std::unique_ptr&lt;Object&gt; UniqueObjectPtr;<br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> UniqueObjectPtr&amp; obj)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">m_id</span>(x) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello Obj&quot;</span> &lt;&lt; std::endl; &#125;;<br>		~<span class="hljs-built_in">Object</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Bye Obj&quot;</span> &lt;&lt; std::endl; &#125;;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_id; &#125;<br>	<span class="hljs-keyword">private</span>:	<br>		<span class="hljs-type">int</span> m_id = <span class="hljs-number">0</span>;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(UniqueObjectPtr obj)</span> </span>&#123;<br>	std::cout &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uniquePtr</span><span class="hljs-params">()</span> </span>&#123;<br>	UniqueObjectPtr obj &#123; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">1</span>) &#125;;<br>	<span class="hljs-keyword">auto</span> p = obj.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">//operator bool</span><br>	<span class="hljs-keyword">if</span>(p) &#123;<br>		<span class="hljs-comment">//do some	</span><br>	&#125;<br>	<span class="hljs-comment">//better</span><br>	<span class="hljs-keyword">if</span>(obj) &#123;<br>				<br>	&#125;<br>	<br>	std::cout &lt;&lt; p-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*obj).<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-built_in">print</span>(obj);<br>	<br>	p = obj.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//释放所管理的指针</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;release: unique_ptr&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//直接释放资源</span><br><br>	obj.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">//reset 就是将以前所管理的指针释放掉, 管理一个新的指针</span><br>	<span class="hljs-comment">//UniqueObjectPtr (const UniqueObject&amp;) = delete //这种拷贝构造函数不存在</span><br>	<span class="hljs-comment">//UniqueObjectPtr (const UniqueObject&amp;&amp;) = default //</span><br>	<span class="hljs-built_in">transfer</span>(std::<span class="hljs-built_in">move</span>(obj)); <span class="hljs-comment">//采用这种方式传入, 则自己的资源不在管理,而交给了这个参数</span><br>	<span class="hljs-comment">//传入之后, obj 值为null</span><br><br>	<span class="hljs-built_in">assert</span>(obj == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//	std::cout &lt;&lt; obj-&gt;id() &lt;&lt; std::endl;</span><br><br>	obj.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">3</span>));<br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">sharedObj</span><span class="hljs-params">(std::move(obj))</span></span>;<br>	<span class="hljs-built_in">assert</span>(obj == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//boost库</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	c++ 智能指针来源于boost库.</span><br><span class="hljs-comment">	shared_ptr</span><br><span class="hljs-comment">	weak_ptr</span><br><span class="hljs-comment">	enable_shared_from_this</span><br><span class="hljs-comment">	scoped_ptr //与unique_ptr　很类似, 但局限性比较多, 所以c++11没有采用</span><br><span class="hljs-comment">	unique_ptr</span><br><span class="hljs-comment"> */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">uniquePtr</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="智能指针总结"><a href="#智能指针总结" class="headerlink" title="智能指针总结"></a>智能指针总结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedPtrNotice</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;<br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Parent&gt; WeakParentPtr;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Child&gt; &#123;<br>	<span class="hljs-keyword">public</span>:	<br>		WeakParentPtr father;<br>		<span class="hljs-built_in">Child</span>();<br>		~<span class="hljs-built_in">Child</span>();<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>: <br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">m_value</span>(x) &#123; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_value = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedPtrNotice</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//1 : 绝对不要自己手动的管理资源 </span><br>	<span class="hljs-comment">//int* a = new int(10);</span><br>	<span class="hljs-comment">//delete a;</span><br>	<span class="hljs-comment">//int *b = malloc(sizeof(int));</span><br>	<span class="hljs-comment">//if(b) free(b);</span><br><br>	<span class="hljs-comment">//2 :一个裸的指针不要用两个shared_ptr管理, 对于unique_ptr也如此</span><br>	<span class="hljs-comment">//auto pObj = new Object(1);	</span><br>	<span class="hljs-comment">//ObjectPtr obj(pObj);</span><br>	<span class="hljs-comment">//ObjectPtr obj2(pObj);</span><br><br>	<span class="hljs-comment">//用weak_ptr打破循环引用,parent 和 child</span><br>	<span class="hljs-comment">//当需要在类的内部接口中, 如果需要将this 作为智能指针来使用的话,</span><br>	<span class="hljs-comment">//需要用该类派生自std::enable_shared_from_this</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//使用share_ptr作为函数的接口,如果有可能有const shared_ptr&amp; 的形式</span><br>	<span class="hljs-comment">//多线程模式下使用shared_ptr需注意的事项(....)</span><br><br>	<span class="hljs-comment">//shared_ptr weak_ptr 和裸指针相比, 会大很多, 并且效率上会有影响.</span><br>	<span class="hljs-comment">//尤其是在多线程模式下</span><br><br>	<span class="hljs-comment">//shared_ptr 和 weak_ptr彼此互存,智能指针,空间上消耗资源比较大,而且时间效率上也比较低</span><br><br>	<span class="hljs-comment">//一般情况下 ObejectPtr obj(new Object(2)),　相当于进行了两次new的过程.对于时间和空间上比较消耗</span><br>	<span class="hljs-comment">//官方发现了这个问题,做了如下改正,且实现的功能一样</span><br><br>	<span class="hljs-comment">//只实现了一次new,将new Object() 和 new 自身的指针归在一起</span><br>	ObjectPtr obj5 = std::<span class="hljs-built_in">make_shared</span>&lt;Object&gt;(<span class="hljs-number">3</span>); <span class="hljs-comment">//真正推荐使用...</span><br><br><br>	<span class="hljs-comment">//enable_shared_from_this 中shared_from_this()和构造析构函数一样</span><br>	<span class="hljs-comment">//不能在构造或者析构中使用,否则会出错的.</span><br><br>	<span class="hljs-comment">//某些情况下,会出现内存不会降问题.尤其是使用weak_ptr来处理循环引用问题</span><br>	<span class="hljs-comment">//那是可能因为weak_ptr给勾住了,也要需要weak_ptr释放了,才能解决.</span><br><br>	<span class="hljs-comment">//如果有可能,优先使用类的实例,其次万不得已 2 使用std::unique_ptr</span><br>	<span class="hljs-comment">//万不得已 3 使用 std::shared_ptr</span><br>	<span class="hljs-function">Object <span class="hljs-title">obj6</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">//优先</span><br>	<span class="hljs-function">std::unique_ptr&lt;Object&gt; <span class="hljs-title">puObj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">1</span>))</span></span>; <span class="hljs-comment">//其次</span><br>	std::shared_ptr&lt;Object&gt; psObj = std::<span class="hljs-built_in">make_shared</span>&lt;Object&gt;(<span class="hljs-number">3</span>); <span class="hljs-comment">//在其次</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2020/03/08/life/2021-03-28-%E5%91%A8%E6%8A%A5/">← Next 2020-03-08 周报</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2020/02/15/env/linux/myarch/backup_and_recover/">Linux系统备份以及恢复 Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-language"><span class="toc-text">C++ language</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Keywords-of-C"><span class="toc-text">Keywords of C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98"><span class="toc-text">C++析构函数中抛出异常问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">析构函数调用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-text">问题代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95"><span class="toc-text">正确做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">管理内存的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E6%B8%90%E9%80%80%E5%8C%96%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">逐渐退化的虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">虚函数几种实现方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">对象内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1"><span class="toc-text">普通对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%A0%86%E5%8C%BA%E4%B8%8A%E7%9A%84%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1"><span class="toc-text">在堆区上的普通对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E6%9C%89vital-function"><span class="toc-text">拥有vital function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-text">基本原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-98-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">C++98 类的基本三大原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">C++11 类的基本五大原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%88%AB"><span class="toc-text">类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">容器内元素的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque"><span class="toc-text">deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-text">list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward-list"><span class="toc-text">forward_list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-text">array</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E8%A1%A5%E7%A0%81%E5%85%AC%E5%BC%8F%E4%B8%8E%E4%BD%8D%E5%9F%9F"><span class="toc-text">C++中的补码公式与位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E5%85%AC%E5%BC%8F"><span class="toc-text">补码公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="toc-text">位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda"><span class="toc-text">lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%96%B0%E5%9E%8Bfor%E5%BE%AA%E7%8E%AF-auto-%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">C++11新型for循环,auto, 类成员的初始化及左右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">C++11智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-patr"><span class="toc-text">shared_patr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E5%82%A8%E5%AD%98this%E6%8C%87%E9%92%88%E5%A4%9A%E6%AC%A1%E6%9E%90%E6%9E%84%E9%97%AE%E9%A2%98"><span class="toc-text">shared_ptr储存this指针多次析构问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enable-shared-from-this%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">enable_shared_from_this解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93"><span class="toc-text">智能指针总结</span></a></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>