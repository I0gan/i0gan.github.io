<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>C++ Smart Pointer | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":""}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>C++ Smart Pointer</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2020-02-24T11:09:00.000Z" id="date"> 2020-02-24</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-04-30T14:14:10.390Z" id="updated"> 2022-04-30</time></div></span><br><span>Word Count: <div class="control">2.8k</div></span><br><span>Read Time: <div class="control">14 min</div></span></div></div><hr><div id="post-content"><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>目前c++ 的4种指针</p>
<ol>
<li><p>auto_ptr  c++98 智能指针,使用了</p>
</li>
<li><p>shared_ptr &#x2F;&#x2F;共享指针</p>
</li>
<li><p>unique_ptr &#x2F;&#x2F;只能由一个使用者使用</p>
</li>
<li><p>weaked_ptr &#x2F;&#x2F;与share_ptr搭配使用</p>
</li>
</ol>
<h2 id="shared-patr"><a href="#shared-patr" class="headerlink" title="shared_patr"></a>shared_patr</h2><p>实例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interfaceOfSharedPtr</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">interfaceOfSharedPtr</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> id) : <span class="hljs-built_in">m_id</span>(id) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;init obj &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;;<br>		~<span class="hljs-built_in">Object</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye bye &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_id; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_id = <span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-comment">//使用智能指针</span><br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br><br><span class="hljs-comment">//作为参数的obj,相当于拷贝了一次,use_count 会+ 1,但当函数结束时候,智能指针析构,use_count会恢复原来的个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ObjectPtr obj)</span> </span>&#123;<br>	<span class="hljs-comment">//-------------------------智能指针的成员函数</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;count &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot; id &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">//以引用方式,不会进行copy, use_count不变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printRef</span><span class="hljs-params">(<span class="hljs-type">const</span> ObjectPtr &amp;obj)</span> </span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;id &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interfaceOfSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>	ObjectPtr null;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; null.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">//使用智能指针来储存对象的指针</span><br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">1</span>))</span></span>;	<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj2</span><span class="hljs-params">(obj)</span></span>;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	ObjectPtr obj3 = obj;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	obj2.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//What dose means of reset ?</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;ref count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	ObjectPtr obj4;<br>	obj3.<span class="hljs-built_in">swap</span>(obj4); <span class="hljs-comment">//把obj3的管理资源相互交换</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;obj4 ref count is &quot;</span> &lt;&lt; obj4.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>	std::<span class="hljs-built_in">swap</span>(obj3, obj4); <span class="hljs-comment">//采用另一种方式交换 </span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;obj4 ref count is &quot;</span> &lt;&lt; obj4.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>	<span class="hljs-comment">//把智能指针存储的指针传出来</span><br>	<span class="hljs-keyword">auto</span> p = obj.<span class="hljs-built_in">get</span>();<br>	<span class="hljs-keyword">if</span>(p) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;id is&quot;</span> &lt;&lt; p-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;	<br>	&#125;<br>	<span class="hljs-keyword">if</span>(obj) &#123; <span class="hljs-comment">//重载了 operator bool</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;p id is &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl; <span class="hljs-comment">//重载: operator -&gt;</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;ref id is &quot;</span> &lt;&lt; (*obj).<span class="hljs-built_in">id</span>() &lt;&lt; std::endl; <span class="hljs-comment">//重载了: operator *</span><br>	&#125;<br>	<br>	obj4 = <span class="hljs-literal">nullptr</span>;<br>	<span class="hljs-comment">//-----------------------------&gt;obj.use_count() == 1 可能效率比较底一点</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;only one hold ptr &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">unique</span>() &lt;&lt; std::endl; <span class="hljs-comment">//判断是否是一个人在使用</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;judge differnt: &quot;</span> &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>	<span class="hljs-built_in">printRef</span>(obj);<br>	<span class="hljs-built_in">print</span>(obj);<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleterOfObject</span><span class="hljs-params">(Object *obj)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(obj)<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;delete obj &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>()  &lt;&lt; std::endl;<br>	<span class="hljs-keyword">delete</span> obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useDeleter</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//当智能指针出了作用域后,析构函数就被调用, 哪怕中途抛出异常</span><br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">2</span>), deleterOfObject)</span></span>;<br>	ObjectPtr obj2 = obj;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>c++智能指针-shared_ptr的尴尬-诞生weak_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><br><span class="hljs-comment">//auto ptr</span><br><span class="hljs-comment">//shared_ptr</span><br><span class="hljs-comment">//unique_ptr</span><br><span class="hljs-comment">//weak_ptr</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>; <span class="hljs-comment">//采用前置声明</span><br><br><span class="hljs-keyword">using</span> ParentPtr = std::shared_ptr&lt;Parent&gt;;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Parent&gt; WeakParentPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//		ParentPtr father; //内存泄露</span><br>		WeakParentPtr father; <span class="hljs-comment">//采用弱指针,则可以释放内存,不造成内存泄露</span><br>		<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Child!!&quot;</span> &lt;&lt; std::endl; &#125;<br>		~<span class="hljs-built_in">Child</span>();<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Child&gt; WeakChildPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Parent!!&quot;</span> &lt;&lt; std::endl; &#125;<br>		ChildPtr son;<br><span class="hljs-comment">//		WeakChildPtr son;</span><br><br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;use_count: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;son.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;&#125;<br>		~<span class="hljs-built_in">Parent</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> id) : <span class="hljs-built_in">m_id</span>(id) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;init obj &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;;<br>		~<span class="hljs-built_in">Object</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye bye &quot;</span> &lt;&lt; m_id &lt;&lt; std::endl; &#125;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_id; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_id = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br>Child::~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child!&quot;</span> &lt;&lt; std::endl; &#125;<br>Parent::~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent!&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">ParentPtr <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;<br>	<span class="hljs-function">ChildPtr <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;<br><br><span class="hljs-comment">//采用这种方式,造成内存泄露</span><br>	p-&gt;son = c; <span class="hljs-comment">//智能指针拷贝, use_count + 1, c 的use_count 为 2</span><br>	p-&gt;<span class="hljs-built_in">print</span>();<br>	c-&gt;father = p; <span class="hljs-comment">//p 的 use_count 也为 2 了</span><br><br><span class="hljs-comment">//智能指针析构之后use_count  -1</span><br><span class="hljs-comment">//智能指针特性: 只有当use_count 变为0 时,才能释放掉管理的资源</span><br><span class="hljs-comment">//所以智能指针析构后,use_count 不为0,则造成了内存泄露</span><br>	<span class="hljs-comment">////////////</span><br><span class="hljs-comment">//只要打破环状的引用,则share_ptr就会很好的管理内存</span><br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//为了解决以上问题, 采用weak_ptr来解决</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedPtrWithWeakPtr</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">1</span>))</span></span>;<br>	<span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Object&gt; WeakObjectPtr;<br>	<span class="hljs-function">WeakObjectPtr <span class="hljs-title">weakObj</span><span class="hljs-params">(obj)</span></span>;<span class="hljs-comment">//弱指针依赖于share_ptr,若share_ptr是有效的,则wake_ptr也是有效的.</span><br>	<span class="hljs-function">WeakObjectPtr <span class="hljs-title">weakObj2</span><span class="hljs-params">(obj)</span></span>;<br>	<span class="hljs-comment">//而wake_ptr在进行赋值的操作运算的时候,并不影响use_count, 相当于只是作为监听者</span><br><br>	<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;obj use count is &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>	&#123;<br>		<span class="hljs-keyword">auto</span> p = weakObj.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//相当于返回了一个 ObjectPtr类型,</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;expired: &quot;</span> &lt;&lt; weakObj.<span class="hljs-built_in">expired</span>() &lt;&lt; std::endl; <span class="hljs-comment">//expierd() 查看监控的资源过期没有过期</span><br>		<span class="hljs-keyword">if</span>(p) &#123;<br>			std::cout &lt;&lt; p.<span class="hljs-built_in">unique</span>() &lt;&lt; std::endl; <span class="hljs-comment">//false, use_count &gt;= 2, 因为auto p = ...,进行了一次指针拷贝, </span><br>			<span class="hljs-comment">//所以use_count + 1, 而weakObj.lock()返回若是有效的话,则use_count &gt;= 1, 否则返回nullptr</span><br>			<span class="hljs-comment">//则总体的就use_count &gt;= 2</span><br>			<span class="hljs-comment">//do what you wanna do	</span><br>		&#125;<span class="hljs-keyword">else</span> &#123;<br>		<br>		<br>		&#125;<br>	&#125;<br>	obj.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//obj 放弃管理的资源</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;endl;&quot;</span>;<br>	<span class="hljs-keyword">auto</span> p2 = weakObj.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//返回空,因为,obj不管理资源了</span><br>	<br>	obj.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">//重新管理另一个资源</span><br>	&#123;<br>		<span class="hljs-keyword">auto</span> p = weakObj.<span class="hljs-built_in">lock</span>();<br>		<span class="hljs-keyword">if</span>(p) &#123;<br>			<span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>);<br>		&#125;<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">//要么资源已经释放,要么obj管理的资源跟换了.</span><br>			std::cout &lt;&lt; <span class="hljs-string">&quot;changed!&quot;</span> &lt;&lt; std::endl;<br>		&#125;<br><br>	&#125;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;expired: &quot;</span> &lt;&lt; weakObj.<span class="hljs-built_in">expired</span>() &lt;&lt; std::endl; <span class="hljs-comment">//expierd() 查看监控的资源过期没有过期</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">testParentAndChild</span>();<br><span class="hljs-comment">//	sharedPtrWithWeakPtr();</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="shared-ptr储存this指针多次析构问题"><a href="#shared-ptr储存this指针多次析构问题" class="headerlink" title="shared_ptr储存this指针多次析构问题"></a>shared_ptr储存this指针多次析构问题</h2><h3 id="enable-shared-from-this解决方案"><a href="#enable-shared-from-this解决方案" class="headerlink" title="enable_shared_from_this解决方案"></a>enable_shared_from_this解决方案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">		//this //调用了两次析构函数,</span><br><span class="hljs-comment">		ParentPtr p(this);</span><br><span class="hljs-comment">		//智能指针出了作用域后就delete this ,析构了</span><br><span class="hljs-comment">		//所以错了,为了解决这个问题,就需要自身的类继承于　std::enable_shared_from_this&lt;Type&gt;</span><br><span class="hljs-comment">		//将ParentPtr p(this) 换成, shared_from_this();</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;<br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Parent&gt; WeakParentPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Child&gt; &#123;<br>	<span class="hljs-keyword">public</span>:<br>		WeakParentPtr father;<br><span class="hljs-comment">//		ParentPtr father;</span><br>		~<span class="hljs-built_in">Child</span>();<br>		<span class="hljs-built_in">Child</span>();<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkRelation</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Child&gt; WeakChildPtr;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Parent&gt; &#123;<br>	<span class="hljs-keyword">public</span>:<br>		WeakChildPtr son;<br><span class="hljs-comment">//		ChildPtr son;</span><br>		~<span class="hljs-built_in">Parent</span>();<br>		<span class="hljs-built_in">Parent</span>();<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkRelation</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleChildAndParentRef</span><span class="hljs-params">(<span class="hljs-type">const</span> Parent &amp;p, <span class="hljs-type">const</span> Child &amp;c)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(c.father.<span class="hljs-built_in">lock</span>().<span class="hljs-built_in">get</span>() == &amp;p &amp;&amp; p.son.<span class="hljs-built_in">lock</span>().<span class="hljs-built_in">get</span>() == &amp;c) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;right relation&quot;</span> &lt;&lt; std::endl;	<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;oop!!!!!!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleChildAndParent</span><span class="hljs-params">(<span class="hljs-type">const</span> ParentPtr &amp;p, <span class="hljs-type">const</span> ChildPtr &amp;c)</span> </span>&#123;<br>	<span class="hljs-built_in">assert</span>(c);<br>	<span class="hljs-built_in">assert</span>(p);<br>	<span class="hljs-keyword">if</span>(c-&gt;father.<span class="hljs-built_in">lock</span>() == p &amp;&amp; p-&gt;son.<span class="hljs-built_in">lock</span>() == c) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;right relation&quot;</span> &lt;&lt; std::endl;	<br>	&#125;<span class="hljs-keyword">else</span> &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;oop!!!!!!&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br>Child::<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello child&quot;</span> &lt;&lt; std::endl; &#125;<br>Child::~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child&quot;</span> &lt;&lt; std::endl; &#125;<br>Parent::<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello parent&quot;</span> &lt;&lt; std::endl; &#125;<br>Parent::~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parent::checkRelation</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">auto</span> ps = son.<span class="hljs-built_in">lock</span>();<br>	<span class="hljs-keyword">if</span>(ps) &#123;<br>		<span class="hljs-comment">//this //调用了两次析构函数,</span><br><span class="hljs-comment">//		ParentPtr p(this);</span><br>		<span class="hljs-comment">//handleChildAndParent(p, ps);	</span><br><br>		<span class="hljs-comment">//智能指针出了作用域后就delete this ,析构了</span><br>		<span class="hljs-comment">//所以错了,为了解决这个问题,就需要自身的类继承于　std::enable_shared_from_this&lt;Type&gt;</span><br>		<span class="hljs-comment">//将ParentPtr p(this) 这种错误形式换成, shared_from_this()</span><br>		<span class="hljs-built_in">handleChildAndParent</span>(<span class="hljs-built_in">shared_from_this</span>(), ps);	<br>	&#125;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;after call checkRelation&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Child::checkRelation</span><span class="hljs-params">()</span> </span>&#123;<br>	<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//若Parent 继承于 std::enable_shared_from_this&lt;Type&gt;</span><br>	<span class="hljs-comment">//则 Parent pp; 这种静态的就不推荐</span><br>	<span class="hljs-function">ParentPtr <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;<br>	<span class="hljs-function">ChildPtr <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;<br>	p-&gt;son = c;<br>	c-&gt;father = p;<br>	p-&gt;<span class="hljs-built_in">checkRelation</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">interfaceOfSharedPtr</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sharedPtrWithWeakPtr</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">uniquePtr</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">testParentAndChild</span>();	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>;<br><br><span class="hljs-keyword">typedef</span> std::unique_ptr&lt;Object&gt; UniqueObjectPtr;<br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> UniqueObjectPtr&amp; obj)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">m_id</span>(x) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello Obj&quot;</span> &lt;&lt; std::endl; &#125;;<br>		~<span class="hljs-built_in">Object</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Bye Obj&quot;</span> &lt;&lt; std::endl; &#125;;<br>		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_id; &#125;<br>	<span class="hljs-keyword">private</span>:	<br>		<span class="hljs-type">int</span> m_id = <span class="hljs-number">0</span>;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(UniqueObjectPtr obj)</span> </span>&#123;<br>	std::cout &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uniquePtr</span><span class="hljs-params">()</span> </span>&#123;<br>	UniqueObjectPtr obj &#123; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">1</span>) &#125;;<br>	<span class="hljs-keyword">auto</span> p = obj.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">//operator bool</span><br>	<span class="hljs-keyword">if</span>(p) &#123;<br>		<span class="hljs-comment">//do some	</span><br>	&#125;<br>	<span class="hljs-comment">//better</span><br>	<span class="hljs-keyword">if</span>(obj) &#123;<br>				<br>	&#125;<br>	<br>	std::cout &lt;&lt; p-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; obj-&gt;<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*obj).<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-built_in">print</span>(obj);<br>	<br>	p = obj.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//释放所管理的指针</span><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;release: unique_ptr&quot;</span> &lt;&lt; std::endl;<br>	<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//直接释放资源</span><br><br>	obj.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">//reset 就是将以前所管理的指针释放掉, 管理一个新的指针</span><br>	<span class="hljs-comment">//UniqueObjectPtr (const UniqueObject&amp;) = delete //这种拷贝构造函数不存在</span><br>	<span class="hljs-comment">//UniqueObjectPtr (const UniqueObject&amp;&amp;) = default //</span><br>	<span class="hljs-built_in">transfer</span>(std::<span class="hljs-built_in">move</span>(obj)); <span class="hljs-comment">//采用这种方式传入, 则自己的资源不在管理,而交给了这个参数</span><br>	<span class="hljs-comment">//传入之后, obj 值为null</span><br><br>	<span class="hljs-built_in">assert</span>(obj == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//	std::cout &lt;&lt; obj-&gt;id() &lt;&lt; std::endl;</span><br><br>	obj.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">3</span>));<br>	<span class="hljs-function">ObjectPtr <span class="hljs-title">sharedObj</span><span class="hljs-params">(std::move(obj))</span></span>;<br>	<span class="hljs-built_in">assert</span>(obj == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//boost库</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	c++ 智能指针来源于boost库.</span><br><span class="hljs-comment">	shared_ptr</span><br><span class="hljs-comment">	weak_ptr</span><br><span class="hljs-comment">	enable_shared_from_this</span><br><span class="hljs-comment">	scoped_ptr //与unique_ptr　很类似, 但局限性比较多, 所以c++11没有采用</span><br><span class="hljs-comment">	unique_ptr</span><br><span class="hljs-comment"> */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">uniquePtr</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="智能指针总结"><a href="#智能指针总结" class="headerlink" title="智能指针总结"></a>智能指针总结</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedPtrNotice</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;<br><span class="hljs-keyword">typedef</span> std::shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">typedef</span> std::weak_ptr&lt;Parent&gt; WeakParentPtr;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Child&gt; &#123;<br>	<span class="hljs-keyword">public</span>:	<br>		WeakParentPtr father;<br>		<span class="hljs-built_in">Child</span>();<br>		~<span class="hljs-built_in">Child</span>();<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>	<span class="hljs-keyword">public</span>: <br>		<span class="hljs-built_in">Object</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">m_value</span>(x) &#123; &#125;<br>	<span class="hljs-keyword">private</span>:<br>		<span class="hljs-type">int</span> m_value = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">using</span> ObjectPtr = std::shared_ptr&lt;Object&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharedPtrNotice</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//1 : 绝对不要自己手动的管理资源 </span><br>	<span class="hljs-comment">//int* a = new int(10);</span><br>	<span class="hljs-comment">//delete a;</span><br>	<span class="hljs-comment">//int *b = malloc(sizeof(int));</span><br>	<span class="hljs-comment">//if(b) free(b);</span><br><br>	<span class="hljs-comment">//2 :一个裸的指针不要用两个shared_ptr管理, 对于unique_ptr也如此</span><br>	<span class="hljs-comment">//auto pObj = new Object(1);	</span><br>	<span class="hljs-comment">//ObjectPtr obj(pObj);</span><br>	<span class="hljs-comment">//ObjectPtr obj2(pObj);</span><br><br>	<span class="hljs-comment">//用weak_ptr打破循环引用,parent 和 child</span><br>	<span class="hljs-comment">//当需要在类的内部接口中, 如果需要将this 作为智能指针来使用的话,</span><br>	<span class="hljs-comment">//需要用该类派生自std::enable_shared_from_this</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//使用share_ptr作为函数的接口,如果有可能有const shared_ptr&amp; 的形式</span><br>	<span class="hljs-comment">//多线程模式下使用shared_ptr需注意的事项(....)</span><br><br>	<span class="hljs-comment">//shared_ptr weak_ptr 和裸指针相比, 会大很多, 并且效率上会有影响.</span><br>	<span class="hljs-comment">//尤其是在多线程模式下</span><br><br>	<span class="hljs-comment">//shared_ptr 和 weak_ptr彼此互存,智能指针,空间上消耗资源比较大,而且时间效率上也比较低</span><br><br>	<span class="hljs-comment">//一般情况下 ObejectPtr obj(new Object(2)),　相当于进行了两次new的过程.对于时间和空间上比较消耗</span><br>	<span class="hljs-comment">//官方发现了这个问题,做了如下改正,且实现的功能一样</span><br><br>	<span class="hljs-comment">//只实现了一次new,将new Object() 和 new 自身的指针归在一起</span><br>	ObjectPtr obj5 = std::<span class="hljs-built_in">make_shared</span>&lt;Object&gt;(<span class="hljs-number">3</span>); <span class="hljs-comment">//真正推荐使用...</span><br><br><br>	<span class="hljs-comment">//enable_shared_from_this 中shared_from_this()和构造析构函数一样</span><br>	<span class="hljs-comment">//不能在构造或者析构中使用,否则会出错的.</span><br><br>	<span class="hljs-comment">//某些情况下,会出现内存不会降问题.尤其是使用weak_ptr来处理循环引用问题</span><br>	<span class="hljs-comment">//那是可能因为weak_ptr给勾住了,也要需要weak_ptr释放了,才能解决.</span><br><br>	<span class="hljs-comment">//如果有可能,优先使用类的实例,其次万不得已 2 使用std::unique_ptr</span><br>	<span class="hljs-comment">//万不得已 3 使用 std::shared_ptr</span><br>	<span class="hljs-function">Object <span class="hljs-title">obj6</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">//优先</span><br>	<span class="hljs-function">std::unique_ptr&lt;Object&gt; <span class="hljs-title">puObj</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Object(<span class="hljs-number">1</span>))</span></span>; <span class="hljs-comment">//其次</span><br>	std::shared_ptr&lt;Object&gt; psObj = std::<span class="hljs-built_in">make_shared</span>&lt;Object&gt;(<span class="hljs-number">3</span>); <span class="hljs-comment">//在其次</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2020/03/08/others/weekly-report/2021-03-28-%E5%91%A8%E6%8A%A5/">← Next 2020-03-08 周报</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2020/02/24/dev/language/c++/c++-class/">C++ Class Prev →</a></div></div></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-patr"><span class="toc-text">shared_patr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr"><span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr%E5%82%A8%E5%AD%98this%E6%8C%87%E9%92%88%E5%A4%9A%E6%AC%A1%E6%9E%90%E6%9E%84%E9%97%AE%E9%A2%98"><span class="toc-text">shared_ptr储存this指针多次析构问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#enable-shared-from-this%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">enable_shared_from_this解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr"><span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93"><span class="toc-text">智能指针总结</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>