<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Go逃逸分析 | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Go逃逸分析</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2020-10-25T10:38:56.000Z" id="date"> 2020-10-25</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-10-24T09:48:31.489Z" id="updated"> 2022-10-24</time></div></span><br><span>Word Count: <div class="control">1.6k</div></span><br><span>Read Time: <div class="control">8 min</div></span></div></div><hr><div id="post-content"><h1 id="Golang-逃逸学习"><a href="#Golang-逃逸学习" class="headerlink" title="Golang 逃逸学习"></a>Golang 逃逸学习</h1><p>golang的内存管理比较安全，不可直接操作内存，且在编译期间会进行数组越界检查，在运行的时候直接报错。</p>
<p>这篇文章就记录一下golang逃逸的一些相关原理吧。</p>
<h2 id="golang逃逸分析wiki"><a href="#golang逃逸分析wiki" class="headerlink" title="golang逃逸分析wiki"></a>golang逃逸分析wiki</h2><p>In compiler optimization, escape analysis is a method for determining the dynamic scope of pointers - where in the program a pointer can be accessed. It is related to pointer analysis and shape analysis.</p>
<p>When a variable (or an object) is allocated in a subroutine, a pointer to the variable can escape to other threads of execution, or to calling subroutines. If an implementation uses tail call optimization (usually required for functional languages), objects may also be seen as escaping to called subroutines. If a language supports first-class continuations (as do Scheme and Standard ML of New Jersey), portions of the call stack may also escape.</p>
<p>If a subroutine allocates an object and returns a pointer to it, the object can be accessed from undetermined places in the program — the pointer has “escaped”. Pointers can also escape if they are stored in global variables or other data structures that, in turn, escape the current procedure.</p>
<p>Escape analysis determines all the places where a pointer can be stored and whether the lifetime of the pointer can be proven to be restricted only to the current procedure and&#x2F;or thread</p>
<h2 id="逃逸分析优势"><a href="#逃逸分析优势" class="headerlink" title="逃逸分析优势"></a>逃逸分析优势</h2><p>1 最大的好处应该是减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</p>
<p>2 因为逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好</p>
<p>3 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>
<h2 id="go与c-x2F-c-编译的程序区别"><a href="#go与c-x2F-c-编译的程序区别" class="headerlink" title="go与c&#x2F;c++编译的程序区别"></a>go与c&#x2F;c++编译的程序区别</h2><p>c&#x2F;c++编译的程序，堆栈空间给的比较少，一般做大型项目的时候，数据量大了就把数据放在堆里储存，而go呢，内存机制有自己本身管理，采用堆栈迁移的方式把堆栈迁移到所开辟出来空间比较大的地方，所以golang 在运行完大多数对象都可以放在堆栈中。下面来跟踪一下golang程序的运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hack</span><span class="hljs-params">()</span></span> &#123;<br>    fake_flag := []<span class="hljs-type">int64</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>	<span class="hljs-keyword">var</span> p []<span class="hljs-type">int64</span><br>	p = fake_flag<br>	p[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    flag := []<span class="hljs-type">int64</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> flag &#123;<br>        flag[i] = v + <span class="hljs-number">1</span><br>    &#125;<br>    hack()<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上编译为elf文件后是gdb进行调试</p>
<p>main_mian的地址为0x45DA40</p>
<p>程序刚开始运行时的堆栈就为操作系统所给的堆栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> RSP  0x7fffffffdf30 ◂— 0x1 <br> RIP  0x45b9e0 (_rt0_amd64_linux) ◂— jmp   0x458580<br><br>下断点到main_main函数<br><br> RBP  0xc00003e7d0 ◂— 0x0 <br> RSP  0xc00003e780 —▸ 0x42fb29 (runtime.main+521) ◂— mov   eax, dword ptr [rip + 0xcbbf5] <br> RIP  0x45da40 (main.main) ◂— mov   rcx, qword ptr fs:[0xfffffffffffffff8]<br></code></pre></td></tr></table></figure>





<p>可以看到以上,rsp与rbp已经不再是0x7f开头的地址了而是进行了堆栈迁移</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs text">pwndbg&gt; vmmap <br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>          0x400000           0x45e000 r-xp    5e000 0      /home/logan/share/bytectf/leak/leak<br>          0x45e000           0x4c8000 r--p    6a000 5e000  /home/logan/share/bytectf/leak/leak<br>          0x4c8000           0x4cc000 rw-p     4000 c8000  /home/logan/share/bytectf/leak/leak<br>          0x4cc000           0x4fe000 rw-p    32000 0      [heap]<br>      0xc000000000       0xc004000000 rw-p  4000000 0      <br>    0x7fffd1328000     0x7fffd3699000 rw-p  2371000 0      <br>    0x7fffd3699000     0x7fffe3819000 ---p 10180000 0      <br>    0x7fffe3819000     0x7fffe381a000 rw-p     1000 0      <br>    0x7fffe381a000     0x7ffff56c9000 ---p 11eaf000 0      <br>    0x7ffff56c9000     0x7ffff56ca000 rw-p     1000 0      <br>    0x7ffff56ca000     0x7ffff7a9f000 ---p  23d5000 0      <br>    0x7ffff7a9f000     0x7ffff7aa0000 rw-p     1000 0      <br>    0x7ffff7aa0000     0x7ffff7f19000 ---p   479000 0      <br>    0x7ffff7f19000     0x7ffff7f1a000 rw-p     1000 0      <br>    0x7ffff7f1a000     0x7ffff7f99000 ---p    7f000 0      <br>    0x7ffff7f99000     0x7ffff7ff9000 rw-p    60000 0      <br>    0x7ffff7ff9000     0x7ffff7ffd000 r--p     4000 0      [vvar]<br>    0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]<br>    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]<br>0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]<br></code></pre></td></tr></table></figure>

<p>可以发现新的堆栈空间大小为0x4000000, 而操作系统所给的为0x21000, 所以golang的变量大部分都会优先储存在堆栈上，因为堆栈空间比较大，且内存管理比较简单。</p>
<h2 id="go的逃逸分析"><a href="#go的逃逸分析" class="headerlink" title="go的逃逸分析"></a>go的逃逸分析</h2><p>go在动态编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。</p>
<h3 id="开启逃逸分析日志"><a href="#开启逃逸分析日志" class="headerlink" title="开启逃逸分析日志"></a>开启逃逸分析日志</h3><p>在编译的时候参数加上<code>-gcflags &#39;-m&#39;</code>,为了不产生inline函数，一般都会加上<code>-l</code></p>
<p>也就是 <code>-gcflags &#39;-m -l&#39;</code></p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        s := <span class="hljs-string">&quot;Hello World&quot;</span><br>        fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>逃逸分析</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">┌[logan☮arch]-(~/share/bytectf/leak)<br>└&gt; go run -gcflags &#x27;-m -l&#x27; 1.go<br># command-line-arguments<br>./1.go:6:13: ... argument does not escape<br>./1.go:6:13: s escapes to heap<br>Hello World<br></code></pre></td></tr></table></figure>



<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x S<br>    y := &amp;x<br>    _ = *identity(y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">identity</span><span class="hljs-params">(z *S)</span></span> *S &#123;<br>    <span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">┌[logan☮arch]-(~/share/bytectf/leak)<br>└&gt; go run -gcflags &#x27;-m -l&#x27; 2.go<br># command-line-arguments<br>./2.go:11:15: leaking param: z to result ~r1 level=0<br></code></pre></td></tr></table></figure>

<p>x没有被引用，没有发生逃逸</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x S<br>    _ = *ref(x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ref</span><span class="hljs-params">(z S)</span></span> *S &#123;<br>    <span class="hljs-keyword">return</span> &amp;z<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">┌[logan☮arch]-(~/share/bytectf/leak)<br>└&gt; go run -gcflags &#x27;-m -l&#x27; 3.go             <br># command-line-arguments<br>./3.go:10:10: moved to heap: z<br></code></pre></td></tr></table></figure>

<p>go进行值传递，而在调用ref后进行引用，避免内存错误，则会将z放在heap上。</p>
<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123; <br>    M *<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> <br>    refStruct(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">refStruct</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> (z S) &#123;<br>    z.M = &amp;y<br>    <span class="hljs-keyword">return</span> z <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">┌[logan☮arch]-(~/share/bytectf/leak)<br>└&gt; go run -gcflags &#x27;-m -l&#x27; 4.go<br># command-line-arguments<br>./4.go:12:16: moved to heap: y<br></code></pre></td></tr></table></figure>

<p>对y进行了值引用，则使y放在heap上</p>
<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5"></a>Example 5</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123; <br>    M *<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> <br>    refStruct(&amp;i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">refStruct</span><span class="hljs-params">(y *<span class="hljs-type">int</span>)</span></span> (z S) &#123;<br>    z.M = y<br>    <span class="hljs-keyword">return</span> z <br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">┌[logan☮arch]-(~/share/bytectf/leak)<br>└&gt; go run -gcflags &#x27;-m -l&#x27; 5.go<br># command-line-arguments<br>./5.go:12:16: leaking param: y to result z level=0<br></code></pre></td></tr></table></figure>

<p>对原先堆栈里的数据进行引用，没有发生逃逸</p>
<h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example 6"></a>Example 6</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123; <br>    M *<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    <span class="hljs-keyword">var</span> x S<br>    <span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br>    ref(&amp;i, &amp;x) <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ref</span><span class="hljs-params">(y *<span class="hljs-type">int</span>, z *S)</span></span> &#123; <br>    z.M = y<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">┌[logan☮arch]-(~/share/bytectf/leak)<br>└&gt; go run -gcflags &#x27;-m -l&#x27; 6.go<br># command-line-arguments<br>./6.go:13:10: leaking param: y<br>./6.go:13:18: z does not escape<br>./6.go:9:9: moved to heap: i<br></code></pre></td></tr></table></figure>

<p>z没有逃逸，有两个指针指向i变量，而i逃逸了，go的逃逸分析不知道z和i的关系，逃逸分析不知道参数y是z的一个成员，所以只能把i分配给堆管理</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是golang编译器通过分析代码会在编译时觉得哪些变量该分配在stack中，哪些变量该分配在heap中。</p>
<p>ref: <a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/For-learning-Go-Tutorial/src-chapter13-01.0.md">https://www.bookstack.cn/read/For-learning-Go-Tutorial/src-chapter13-01.0.md</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2020/10/29/security/ctf/pwn/new-heap-exploit/">← Next HEAP-2020-姿势学习</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2020/10/25/life/weekly/2020-10-25-%E5%91%A8%E6%8A%A5/">2020-10-25 周报 Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Golang-%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0"><span class="toc-text">Golang 逃逸学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90wiki"><span class="toc-text">golang逃逸分析wiki</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BC%98%E5%8A%BF"><span class="toc-text">逃逸分析优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E4%B8%8Ec-x2F-c-%E7%BC%96%E8%AF%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB"><span class="toc-text">go与c&#x2F;c++编译的程序区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">go的逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97"><span class="toc-text">开启逃逸分析日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-1"><span class="toc-text">Example 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-2"><span class="toc-text">Example 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-3"><span class="toc-text">Example 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-4"><span class="toc-text">Example 4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-5"><span class="toc-text">Example 5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-6"><span class="toc-text">Example 6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>