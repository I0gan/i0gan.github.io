<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>go语言面向对象 | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(/img/bg.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>go语言面向对象</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-03-30T01:41:26.000Z" id="date"> 2021-03-30</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-10-24T09:48:42.089Z" id="updated"> 2022-10-24</time></div></span><br><span>Word Count: <div class="control">2k</div></span><br><span>Read Time: <div class="control">8 min</div></span></div></div><hr><div id="post-content"><h1 id="Golang的面向对象"><a href="#Golang的面向对象" class="headerlink" title="Golang的面向对象"></a>Golang的面向对象</h1><p>如你所知，封装、继承、多态和抽象是面向对象编程的4个基本特征，本文描述Golang语言是如何实现这些特征的。</p>
<p>1 Golang的面向对象类型<br>Golang实现面向对象的两个关键类型是struct和interface，其中struct类似C++的普通类类型，interface则对应抽象类类型。与C++采用public&#x2F;protected&#x2F;private指示成员和方法的可见性不同，Golang采用大小写标识可见性，即大写字母开头的成员&#x2F;方法对外可见，小写开头的则属于类的私有成员，外部不可以直接访问。此外，Golang与C++在类类型的定义上还有一个重要区别，那就是Golang在struct内只需要声明类的成员变量，而不需要在类定义体内声明或定义所有的方法，方法定义都在struct之外完成。好了，我们开始正文。</p>
<p>2 Golang的面向对象实现<br>2.1 封装<br>学生有姓名、年龄和专业等属性，于是我们定义一个Student类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">type Student struct &#123;<br>	name  string<br>	age   int<br>	major string<br>&#125;<br></code></pre></td></tr></table></figure>

<p>学生可以跟大家打招呼：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func (s Student) SayHi() &#123;<br>	fmt.Printf(&quot;Hi, I am %s aged %d, and my major is %s\n&quot;, s.name, s.age, s.major)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在函数定义的func关键字后面加上我们定义的Student类型变量定义，这个函数就成为了Student的方法。类图表示如下：</p>
<p>值得注意的是，在Golang内，除slice、map、channel和显示的指针类型属于引用类型外，其它类型都属于值类型，前者作为函数入参传递时，函数对参数的修改会影响调用对象，而后者作为入参时，函数体内会生成调用对象的拷贝，函数对入参的修改不会影响调用对象。因此，如果我们要给Student类定义一个“构造函数”，我们希望的是这个函数的入参可以被赋值到Student的成员内，则该“构造函数”应该使用指针类型对象定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func (s *Student) Init(name string, age int, major string) &#123;<br>	s.name = name<br>	s.age = age<br>	s.major = major<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">s := Student&#123;&#125;<br>s.Init(&quot;pirlo&quot;, 21, &quot;cs&quot;)<br>s.SayHi()<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ go run test_encapsulate.go <br>Hi, I am pirlo aged 21, and my major is cs.<br></code></pre></td></tr></table></figure>

<p>我们定义的学生类型，属性都是私有的，方法都是公有的，还记得么，私有或公有都是通过属性或方法的首字母大小写决定的。那我们现在来试一下公有属性和私有方法吧。<br>比如，我想让专业（major）这个属性成为公有属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">type Student struct &#123;<br>	name  string<br>	age   int<br>	Major string<br>&#125;<br><br>func main() &#123;<br>	s := Student&#123;&#125;<br>	s.Init(&quot;pirlo&quot;, 21, &quot;cs&quot;)<br>	s.SayHi()<br>	s.Major = &quot;finance&quot;<br>	s.SayHi()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先调用构造函数设置专业为cs，再通过显示赋值的方式修改专业为finance：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ go run test_encapsulate.go <br>Hi, I am pirlo aged 21, and my major is cs.<br>Hi, I am pirlo aged 21, and my major is finance.<br></code></pre></td></tr></table></figure>

<p>但是如果我们试图修改私有属性：</p>
<p>s.age &#x3D; 22<br>编译器会告诉你：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ go run test_encapsulate.go <br></code></pre></td></tr></table></figure>

<h1 id="command-line-arguments"><a href="#command-line-arguments" class="headerlink" title="command-line-arguments"></a>command-line-arguments</h1><p>.&#x2F;test_encapsulate.go:15: s.age undefined (cannot refer to unexported field or method age)</p>
<p>括号的注释说明了不能引用未导出&#x2F;未公开的属性或方法。</p>
<p>小结一下，Golang通过struct定义类的属性，通过在func定义时传入类对象的方式定义类的方法，其中属性和方法的公有&#x2F;私有属性是通过首字母的大小写决定的。</p>
<p>2.2 继承<br>与C++、Java等完整支持面向对象的语言不同，Golang没有显式的继承，而是通过组合实现继承。<br>我们先定义一个基类Person，提供姓名和年龄两个属性，以及SayHi一个方法（Init类似于构造函数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">type Person struct &#123;<br>	name string<br>	age  int<br>&#125;<br><br>func (p *Person) Init(name string, age int) &#123;<br>	p.name = name<br>	p.age = age<br>&#125;<br><br>func (p Person) SayHi() &#123;<br>	fmt.Printf(&quot;Hi, I am %s, %d years old.\n&quot;, p.name, p.age)<br>&#125;<br><br>然后，我们通过组合的方式继承这个基类，实现Employee子类：<br><br>type Employee struct &#123;<br>	Person<br>	company string<br>&#125;<br><br>func (e *Employee) Init(name string, age int, company string) &#123;<br>	e.Person.Init(name, age)<br>	e.company = company<br>&#125;<br><br>func (e Employee) Work() &#123;<br>	fmt.Printf(&quot;I&#x27;m working %s.\n&quot;, e.company)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Employee组合了Person这个成员，除此之外它还拥有自己的成员company，即所属公司，雇员除了是一个Person之外，还需要工作，因此我们定义了Work这个方法。好了，我们再测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func main() &#123;<br>	p := oo.Person&#123;&#125;<br>	p.Init(&quot;pirlo&quot;, 21)<br>	p.SayHi()<br>	e := oo.Employee&#123;&#125;<br>	e.Init(&quot;kaka&quot;, 22, &quot;milan&quot;)<br>	e.SayHi()<br>	e.Work()<br>&#125;<br></code></pre></td></tr></table></figure>



<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ go run test_inherit.go <br>Hi, I am pirlo, 21 years old.<br>Hi, I am kaka, 22 years old.<br>I&#x27;m working in milan.<br></code></pre></td></tr></table></figure>

<p>雇员kaka可以像pirlo一样说话，与此同时，他还可以在milan工作，类图表示如下：</p>
<p>小结一下，Golang没有完整实现继承，而是通过组合的方式实现。组合类（子类）可以直接调用被组合类（基类）的公有方法，访问基类的公有属性，子类也可以定义自己的属性，以及实现自己特有的方法。Golang的设计哲学之一就是简洁，通过大小写区分成员&#x2F;方法的公有&#x2F;私有属性，通过组合的方式实现继承，都是简洁哲学的体现。</p>
<p>2.3 抽象<br>抽象的反义词是具体，在面向对象编程中，抽象的意思是将共同的属性和方法抽象出来形成一个不可以被实例化的类型，在Java里面，这是通过abstract和interface实现的，其中前者可以包含属性，后者则是纯粹的方法集合；C++通过在类内定义纯虚函数使得该类成为一个抽象类。<br>Golang的interface类型定义的也是一个抽象的基类，它是一组方法的集合，任何完整实现这些方法的类型都被称为该接口的实现。由于抽象与多态是相辅相成的，或者说抽象的目的就是为了实现多态，我们将在下一节给出实例说明Golang的抽象和多态的实现。</p>
<p>2.4 多态<br>基类指针可以指向任意派生类的对象，并在运行时绑定最终调用的方法的过程被称为多态。多态是运行时特性，而继承则是编译时特征，也就是说，继承关系在编译时就已经确定了，而多态则可以实现运行时的动态绑定。<br>小狗和小鸟都是动物，它们都会移动，也都会叫唤。我们把它们共同的方法提炼出来定义一个抽象的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">type Animal interface &#123;<br>	Move()<br>	Shout()<br>&#125;<br><br>虽然小狗和小鸟都会移动，但小狗是用四条腿爬行，小鸟是用翅膀飞行，虽然它们都会叫唤，但是叫唤的方式也不一样：<br><br>type Dog struct &#123;<br>&#125;<br><br>func (dog Dog) Move() &#123;<br>	fmt.Println(&quot;A dog moves with its legs.&quot;)<br>&#125;<br><br>func (dog Dog) Shout() &#123;<br>	fmt.Println(&quot;wang wang wang.&quot;)<br>&#125;<br><br>type Bird struct &#123;<br>&#125;<br><br>func (bird Bird) Move() &#123;<br>	fmt.Println(&quot;A bird flys with its wings.&quot;)<br>&#125;<br><br>func (bird Bird) Shout() &#123;<br>	fmt.Println(&quot;A bird shouts.&quot;)<br>&#125;<br></code></pre></td></tr></table></figure>



<p>那么，运行时的多态是怎么实现的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">func main() &#123;<br>	var animal oo.Animal<br>	animal = oo.Dog&#123;&#125;<br>	animal.Move()<br>	animal.Shout()<br><br>	animal = oo.Bird&#123;&#125;<br>	animal.Move()<br>	animal.Shout()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如前文所述，基类指针可以指向任意派生类的对象，并在运行时动态绑定最终使用的方法。这里指针是广义上的概念，在C++中是真实的指针，在Java和Golang里面，则可以是一个接口类型的对象。在上面的代码中，我们定义了一个Animal类型的对象，并分别指向Dog和Bird类型的具体对象，并调用Move和Shout方法，它们的运行效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ go run test_polymorphism.go <br>A dog moves with its legs.<br>wang wang wang.<br>A bird flys with its wings.<br>A bird shouts.<br></code></pre></td></tr></table></figure>





<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2021/03/30/dev/language/go/go/">← Next Go语言基础</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2021/03/28/life/love/angry/">我的好朋友 Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="/images/header.jpg" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Golang%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">Golang的面向对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#command-line-arguments"><span class="toc-text">command-line-arguments</span></a></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>